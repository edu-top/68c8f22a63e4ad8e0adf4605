1. Создать базовый объект `Vehicle` с методами `start()` и `stop()`, которые выводят в консоль сообщения о запуске и остановке транспортного средства. Затем с помощью прототипного наследования создать следующие объекты:

   - **`Car`**, который наследует от `Vehicle` и добавляет метод `honk()`, выводящий в консоль звук автомобиля.

   - **`Bicycle`**, который наследует от `Vehicle` и добавляет метод `ringBell()`, выводящий звонок велосипеда.

   Дополнительно расширить прототип объекта `Car`, чтобы добавить метод `openTrunk()`, который выводит сообщение об открытии багажника. Проверить, что у объектов `Car` и `Bicycle` доступны общие методы из `Vehicle` и их уникальные методы, включая расширенный метод у `Car`.

2. Создать функцию-конструктор `Book`, которая принимает параметры `title`, `author` и `year`. Внутри конструктора сохранять эти параметры как свойства объекта. Добавить метод `getSummary()` в прототип конструктора, который возвращает строку с кратким описанием книги, например: `"«Title» написана Author в Year году."` Создать два объекта книг с помощью `new Book(...)` и вывести в консоль их описания с помощью `getSummary()`. Добавить статическое свойство `Book.libraryName`, которое будет общим для всех книг и хранит название библиотеки. Добавить статический метод `Book.changeLibraryName(newName)`, чтобы менять название библиотеки.

    Создать класс `Library`, который будет управлять коллекцией книг. Каждая книга — это объект с полями `title` (название), `author` (автор), `year` (год издания) и `isAvailable` (доступность книги для выдачи).

    Требования к классу `Library`:

    - создать метод `addBook(book)`, который добавляет книгу в библиотеку;

    - создать метод `removeBook(title)`, который удаляет книгу по названию;

    - создать метод `findBooksByAuthor(author)`, который возвращает массив книг данного автора;

    - создать метод `lendBook(title)`, который меняет статус `isAvailable` книги на `false`, если книга есть и доступна;

    - создать метод `returnBook(title)`, который возвращает книгу в библиотеку (ставит `isAvailable` в `true`);

    - создать метод `getAvailableBooks()`, который возвращает список доступных книг.

    Реализовать базовые операции ООП: инкапсуляцию, конструктор, методы класса.

3. Создать систему для модели колледжа со следующими классами:

    - **Человек** (`Person`) — абстрактный базовый класс с полями `name`, `age` и методом `getDetails()`, который возвращает строку с основной информацией.

    - **Студент** (`Student`) наследует `Person`, добавляет поле `studentId` и список пар (`classes`), которые он посещает. Переопределяет метод `getDetails()`, добавляя информацию о студенте.

    - **Преподаватель** (`Teacher`) наследует `Person`, содержит поле `subjects` — массив предметов, которые он ведет, и метод `assignGrade(student, class, grade)`, который ставит студенту оценку за пару. Переопределяет `getDetails()`.

    - **Урок** (`Lesson`) — класс с полями `subject`, `teacher` (объект `Teacher`), списком студентов (`students`) и объектом оценок (`grades`), где хранятся оценки студентов по их `studentId`.

    Требования к функционалу:
    - инкапсулировать поля, где это логично (например, оценки и списки студентов в парах не должны быть напрямую доступны);

    - метод `assignGrade` должен менять оценки внутри соответствующей пары;

    - студент может получать средний балл по всем парам.

    - использовать полиморфизм в методе `getDetails`: для каждого типа человека выводить разный набор данных.

4. Создать объект-прототип `employeeProto` со следующими методами:

    - `getDetails()` — возвращает строку с именем (`name`) и должностью (`position`) сотрудника, например: "Иван — программист".

    - `changePosition(newPosition)` — меняет у сотрудника должность на `newPosition`.

    Создать нескольких сотрудников с помощью `Object.create(employeeProto)`, задавая им уникальные свойства `name` (имя), `position` (должность). Добавить еще уникальное свойство, например, `salary`. Написать функцию, которая принимает массив таких сотрудников и выводит их детали, вызывая метод `getDetails()`. Проверить, что методы `getDetails` и `changePosition` лежат в прототипе, а не в самих объектах (например, с помощью `hasOwnProperty`). Создать прототип `managerProto`, который наследует от `employeeProto` и добавляет метод `assignTask(employee, task)`, который назначает задачу `task` другому сотруднику (объекту), выводя сообщение, например: "Менеджер Иван назначил задачу 'Подготовить отчет' сотруднику Петр".

5. Реализовать конструктор `Employee(name, position, salary)`, создающий сотрудника и связывающий его с `employeeProto`. Реализовать конструктор `Manager(name, position, salary, department)`, наследующий от `Employee`, связывающий объекты с `managerProto`, добавляющий поле `department`. Создать несколько сотрудников и менеджера, продемонстрировав назначение задач менеджером сотрудникам и вызов методов.     Реализовать класс `Worker` с полями: `name`, `surname`, `rate` (ставка за день), `days` (отработанные дни). Методы `getSalary()` — возвращает зарплату: `rate * days`, `getFullName()` — возвращает полное имя в формате "Фамилия Имя". Реализовать класс `Boss`, наследующий от `Worker`, с дополнительным свойством `workers`, определяющим количество работников. Переопределить метод `getSalary()`, чтобы возвращал `rate * days * workers`. Создать объекты классов `Worker` и `Boss`, вывести все поля и результаты выполнения методов.





4. Создайть объект `employeeProto` с методами:

- `getDetails()`, который возвращает строку с именем и должностью сотрудника;

- `changePosition(newPosition)`, который меняет должность сотрудника.

С помощью `Object.create(employeeProto)` создать несколько сотрудников, задавая им свойства `name` и `position`. Требования:

- добавить уникальные для каждого сотрудника свойства, например `salary`;

- напишсать функцию, которая принимает массив таких сотрудников и выводит их детали;

- продемонстрировать, что методы `getDetails` и `changePosition` лежат в прототипе, а не в самих объектах.

Создать прототип `managerProto`, который наследует от `employeeProto` и добавляет метод:

- `assignTask(employee, task)` — назначить задачу другому сотруднику (объекту).



Реализовать конструктор `Employee(name, position, salary)`, который создает сотрудников и связывает их с прототипом `employeeProto`. Реализовать конструктор `Manager(name, position, salary, department)`, который наследует от конструктора `Employee`, связывается с `managerProto` и добавляет поле `department`. Создать нескольких сотрудников и менеджера, назначить менеджеру задачи для сотрудников. Проверить, что методы прототипов доступны объектам нужного типа, и продемонстрировать вызовы всех методов.


Реализуйте класс Worker (Работник), который будет иметь следующие свойства: name (имя), surname (фамилия), rate (ставка за день работы), days (количество отработанных дней). Также класс должен иметь метод getSalary(), который будет выводить зарплату работника. Зарплата - это произведение (умножение) ставки rate на количество отработанных дней days. И метод getFullName() - имя и фамиля работника.

const worker = new Worker('Иван', 'Иванов', 10, 31);

console.log(worker.name); //выведет 'Иван'
console.log(worker.surname); //выведет 'Иванов'
console.log(worker.getFullName); //выведет 'Иванов Иван'
console.log(worker.rate); //выведет 10
console.log(worker.days); //выведет 31
console.log(worker.getSalary()); //выведет 310 - то есть 10*31

Напишите новый класс Boss, этот класс наследуется от класса Worker и прошлого задания. Появляется новые свойство: workers - количество работников. И зарплата считается по другому: произведение (умножение) ставки rate на количество отработанных дней и на количество работников.

const boss = new Boss('Иван', 'Иванов', 10, 31, 10);
console.log(boss.name); //выведет 'Иван'
console.log(boss.surname); //выведет 'Иванов'
console.log(boss.getFullName); //выведет 'Иванов Иван'
console.log(boss.rate); //выведет 10
console.log(boss.days); //выведет 31
console.log(boss.workers); //выведет 10
console.log(boss.getSalary()); //выведет 3100 - то есть 10*31*10
