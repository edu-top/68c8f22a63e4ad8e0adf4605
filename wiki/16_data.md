# Работа с данными

- [Работа с JSON](#работа-с-json)
  - [Сериализация в JSON и десериализация](#сериализация-в-json-и-десериализация)
- [Работа с XML](#работа-с-xml)
  - [Преобразование из строки в XML](#преобразование-из-строки-в-xml)
  - [Сериализация xml-документа в строку](#сериализация-xml-документа-в-строку)
- [Куки](#куки)
  - [Установка параметров куки](#установка-параметров-куки)
    - [Параметр expires](#параметр-expires)
    - [Путь и домен](#путь-и-домен)
    - [Параметр secure](#параметр-secure)
  - [Получение куки](#получение-куки)
  - [Ограничения куки](#ограничения-куки)
- [Web Storage](#web-storage)
  - [Сохранение данных](#сохранение-данных)
  - [Получение данных](#получение-данных)
  - [Удаление](#удаление)
- [Источники информации](#источники-информации)

## Работа с JSON
*[JSON]: JavaScript Object Notation

<dfn title="JSON">JSON</dfn> (JavaScript Object Notation) представляет легковесный формат хранения данных. JSON описывает структуру и организацию данных JavaScript. Простота JSON привела к тому, что в настоящий момент он является наиболее популярным форматом передачи данных в среде web, вытеснив другой некогда популярный формат xml.

Объекты JSON очень похожи на объекты JavaScript, тем более что JSON является подмножеством JavaScript. В то же время важно их различать: JavaScript является языком программирования, а JSON является форматом данных.

JSON поддерживает три типа данных: примитивные значения, объекты и массивы. Примитивные значения представляют стандартные строки, числа, значение `null`, логические значения `true` и `false`.[^11.1]

Объекты представляют набор простейших данных, других объектов и массивов. Например, типичный объект JSON:
```json
{
    "name": "Tom",
    "married": true,
    "age": 30
}
```

В javascript этому объекту соответствовал бы следующий:
```js
const user = {
    name: "Tom",
    married: true,
    age: 30
}
```

Несмотря на общее сходство, в то же время есть и различия: в JSON названия свойств заключаются в двойные кавычки, как обычные строки. Кроме того, объекты JSON не могут хранить функции, переменные, как объекты javascript.

Объекты могут быть сложными:
```json
{
    "name": "Tom",
    "married": true,
    "age": 30,
    "company": {
        "name": "Microsoft",
        "address": "USA, Redmond"
    }
}
```

Массивы в JSON похожи на массивы javascript и также могут хранить простейшие данные или объекты:
```json
["Tom", true, 30]
```

Массив объектов:
```json
[{
    "name": "Tom",
    "married": true,
    "age": 30
},{
    "name": "Alice",
    "married": false,
    "age": 23
}]
```

### Сериализация в JSON и десериализация
Для работы с форматом JSON в языке JavaScript предназначен **`JSON`**. Он позволяет преобразовать объект JavaScript в формат json и наоборот.

Для сериализации объекта javascript в json применяется функция **`JSON.stringify()`**:
```js
// объект javascript
const user = {
    name: "Tom",
    married: false,
    age: 39
};
// объект json
const serializedUser = JSON.stringify(user);
console.log(serializedUser); // {"name":"Tom","married":false,"age":39}
```

Для обратной операции — десериализации или парсинга json-объекта в javascript применяется метод **`JSON.parse()`**:
```js
const user = {
    name: "Tom",
    married: false,
    age: 39
};
// сериализация
const serializedUser = JSON.stringify(user);
// десериализация
const tomUser = JSON.parse(serializedUser);
console.log(tomUser.name); // Tom
```

## Работа с XML
Одним из популярных форматов описания данных является формат XML. И язык JavaScript предоставляет инструментарий для работы с XML.[^11.2]

### Преобразование из строки в XML
Для создания XML-объектов на основе строки, которая содержит данные в формате XML, применяется объект **`DOMParser`**. Его методу **`parseFormString()`** можно передать соответствующую строку в качестве первого аргумента и тип MIME (обычно `text/xml`) в качестве второго аргумента. Если переданная строка содержит корректный код XML, то метод возвратит объект типа **`Document`**, который будет содержать разобранный XML. А чтобы выбрать конкретные данные из полученного документа XML, можно применять стандартные методы выбора элементов DOM, например, **`querySelector()`**.

Например, рассмотрим следующую программу:
```js
const xmlString = `<?xml version="1.0" encoding="UTF-8" ?>
    <users>
        <user name="Tom" age="39">
            <company>
                <title>Microsoft</title>
            </company>
        </user>
        <user name="Bob" age="43">
            <company>
                <title>Google</title>
            </company>
        </user>
    </users>`;

const domParser = new DOMParser();
const xmlDOM = domParser.parseFromString(xmlString, "text/xml");
// обратимся к первому элементу user
const firstUser = xmlDOM.querySelector("user");
console.log(firstUser.getAttribute("name"));                    // Tom
console.log(firstUser.getAttribute("age"));                     // 39
console.log(firstUser.querySelector("title").textContent);      // Microsoft
```

Здесь xml-документ задан строкой xmlString. Но пока это именно строка, а не xml-документ. И для парсинга строки в xml-документ создаем объект **`DOMParser`** и выполняем его метод `parseFormString()`, в который передается наша строка:
```js
const domParser = new DOMParser();
const xmlDOM = domParser.parseFromString(xmlString, "text/xml");
```

Получив xml-документ, выбираем первый элемент user с помощью метода `querySelector`
```js
const firstUser = xmlDOM.querySelector("user");
```

Далее мы можем обращаться к содержимому элемента user - к его вложенным элементам и атриубтам
```js
console.log(firstUser.getAttribute("name"));                    // Tom
console.log(firstUser.getAttribute("age"));                     // 39
console.log(firstUser.querySelector("title").textContent);      // Microsoft
```

### Сериализация xml-документа в строку
Для обратного преобразования — из xml-документа в строку — применяется объект **`XMLSerializer`**. Этот объект предоставляет метод **`serializeToString()`**, который получает объект XML и возвращает объект XML в форме строки. Например:
```js
const xmlString = `<?xml version="1.0" encoding="UTF-8" ?>
    <users>
        <user name="Tom" age="39">
            <company>
                <title>Microsoft</title>
            </company>
        </user>
        <user name="Bob" age="43">
            <company>
                <title>Google</title>
            </company>
        </user>
    </users>`;

// преобразуем строку в XML
const domParser = new DOMParser();
const xmlDOM = domParser.parseFromString(xmlString, "text/xml");
// преобразуем обратно из XML в строку
const xmlSerializer = new XMLSerializer();
const xmlString2 = xmlSerializer.serializeToString(xmlDOM);
console.log(xmlString2);
```

В итоге мы получим обратно изначальную строку `xmlString`.

Поскольку документ html по сути также является документом xml, то мы можем сериализовать в строку и html-страницу или ее часть. Например, преобразуем в строку текущую веб-страницу:
```js
const xmlSerializer = new XMLSerializer();
const htmlString = xmlSerializer.serializeToString(document);
console.log(htmlString);
```

## Куки
Одну из возможностей сохранения данных в браузере представляет использование куки. Так, каждый раз, когда мы обращаемся к веб-странице в интернете, то веб-сервер вместо с этой страницей присылает связаные с этой страницей куки (при их наличии). И браузер хранит эти данные некоторое время. При последующих обращениях к той же странице или сайту в зависимости от настроек куки обратно посылаются из браузера на сервер.

Для работы с куками в языке JavaScript в объекте **`document`** предназначено свойство **`cookie`**.

Для установки куки достаточно свойству `document.cookie` присвоить строку с куками:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Example</title>
</head>
<body>
    <script>
        document.cookie = "login=tom32;";
        console.log(document.cookie);
    </script>
</body>
</html>
```

В данном случае устанавливается куки, которая называется "login" и которая имеет значение "tom32". Затем получаем куки и выводим их на консоль.

Но стоит отметить, что работа с куками может различаться в зависимости от того, какой браузер используется, и как запускается веб-страница: как локальный файл или как файл на веб-сервере. Например, если мы запустим веб-страницу как локальный файл, то есть просто бросим выше определенную веб-страницу в браузер Mozilla FireFox или Safari, то браузер установит куки и выведет их на консоль. Браузеры поддерживают просмотр установленных кук (как и других сохраненных данных). Например, если брать Mozilla FireFox, то в инструментах разработчика есть вкладки "Хранилище" (в русскоязычной локализации), и там можно посмотреть куки:

![Установка куки в JavaScript в Mozilla FireFox](../img/cookie1.png)

Однако в других браузерах, например, в Google Chrome или Opera на установку куки в веб-страницах, которые представляют локальные файлы, действуют ограничения. Соответственно, если мы бросим выше определенную страницу в Google Chrome, то консоль нам ничего не отобразит. Потому что Google Chrome по умолчанию поддерживает установку кук только в веб-страницах, которые загружаются с веб-сервера и принадлежат некоторому домену в сети. Что в принципе неудивительно. Ведь куки предназначены прежде всего для пересылки данных по протоколу http от клиента серверу и обратно.

Поэтому в дальнейшем для работы с куками мы располагать html-страницы на веб-сервере. В данном случае воспользуемся самым простым вариантом — Node.js, так как эта технология двольно проста, доступна для всех основных операционных систем и также также позволяет использовать javascript для создания приложений. Но естественно перед созданием приложения необходимо [установить Node.js](https://metanit.com/web/nodejs/1.1.php). В данном случае не потребуется никаких знаний node.js, весь используемый код подробно описывается. Но опять же вместо node.js это может быть любая другая технология сервера — php, asp.net, python и т.д. либо какой-то определенный веб-сервер типа Apache или IIS.

Итак, создадим в файловой системе папку для файлов веб-сервера. Например, пусть это будет папка *C:\app*. Далее в этой папке определим файл сервера. Пусть он будет называться *server.js* и будет иметь следующий код:
```js
const http = require("http");
const fs = require("fs");

http.createServer(function(_, response){

    fs.readFile("index.html", (_, data) => response.end(data));

}).listen(3000, ()=>console.log("Сервер запущен по адресу http://localhost:3000"));
```

Это самый примитивный сервер, который достаточен для нашей задачи. Вкратце пробежимся по коду. Сначала подключаются пакеты с функциональностью, которую мы собираемся использовать:
```js
const http = require("http");   // для обработки входящих запросов
const fs = require("fs");       // для чтения с жесткого диска файла index.html
```

Для создания сервера применяется функция **`http.createServer()`**. В эту функцию передается функция-обработчик, которая вызывается каждый раз, когда к серверу приходит запрос. Эта функция имеет два параметра: `request` (содержит данные запроса) и `response` (управляет отправкой ответа). Первый параметр не используется, поэтому вместо него указан прочерк `_`.

В функции-обработчике отправляем файл *index.html*, который мы дальше определим:
```js
fs.readFile("index.html", (error, data) => response.end(data));
```

Для считывания файлов применяется встроенная функция **`fs.readFile()`**. Первый параметр функции — адрес файла (в данном случае предполагается, что файл *index.html* находится в одной папке с файлом сервера *server.js*). Второй параметр — функция, которая вызывается после считывания файла и получет его содержимое через свой второй параметр `data`. Затем считанное содежимое также может быть отпавлено с помощью функции `response.end(data)`.

В конце с помощью функции **`listen()`** запускаем веб-сервер на 3000 порту. То есть сервер будет запускаться по адресу http://localhost:3000/

И также в той же папке определим файл *index.html* со следующим кодом:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Example</title>
</head>
<body>
    <script>
        document.cookie = "login=tom32;";
        console.log(document.cookie);
    </script>
</body>
</html>
```

[^12.1]

Здесь, как уже было рассмотрено выше, устанавливается куки `login`. Затем куки выводятся на консоль.

Теперь в консоли перейдем к папке сервера с помощью команды **`cd`** и запустим сервер с помощью команды **`node server.js`**
```
C:\app>node server.js
Сервер запущен по адресу http://localhost:3000
```

После запуска сервера мы можем перейти в браузере по адресу http://localhost:3000, нам отобразится страница *index.html*. С помощью инструментов браузера мы сможем посмотреть установленные куки. Так, в Google Chrome это вкладка **Application**, а в левой части пункт **Storage** -> **Cookies**:

![Установка куки и их просмотр в JavaScript](../img/cookie.png)

### Установка параметров куки
Строка куки принимает до шести различных параметров:

- Имя и значение куки

    Имя не чувствительно к регистру, что означает, что, например, `login` и `Login` относятся к одному и тому же файлу cookie. В качестве значений разрешены только строки (а не, скажем, числа). Имя и значение — единственные обязательные компоненты. Указывать остальную информацию необязательно (если она не указана, используются значения по умолчанию).

- Срок окончания действия (параметр **`expires`**)

    Дата истечения срока действия, до которой файл cookie действителен. По истечении указанной здесь даты срок действия файла cookie истекает, файл cookie удаляется и больше не отправляется на сервер. Если при создании файла cookie не указана дата истечения срока действия, он удаляется по умолчанию при завершении сеанса браузера.

- Путь (параметр **`path`**) и домен (параметр **`domain`**)

    Используются для разграничения куки. Например, файл cookie с доменом `www.localhost.com` отправляется только с запросами к этому домену. Файл cookie с доменом `www.localhost.com` и путем `/home` отправляется только с запросами на `www.localhost.com/home`, но не на `www.localhost.com/about`.

- Параметр **`secure`**

    Флаг безопасности, который можно использовать, чтобы дополнительно указать, следует ли отправлять файлы cookie только при соединениях, использующих протокол Secure Sockets Layer (SSL), например, чтобы разрешить отправку по https. Если этот параметр установлен, куки могут быть посланы по адресу https://www.localhost.com, а при запросах по адресу посланы по адресу http://www.localhost.com такие куки НЕ посылаются.

Выше использовались только два параметра: имя куки и значение:
```js
document.cookie = "login=tom32;";
```

То есть в данном случае куки имеет имя `login` и значение `tom32`.

#### Параметр expires
Но подобная куки имеет очень ограниченный срок жизни: если явным образом не установить срок действия, то кука будет удалена с закрытием браузера. Подобная ситуация, возможно, идеальна для тех случаев, когда необходимо удалять всю информацию после завершения работы с веб-приложением и закрытия браузера. Однако данное поведение не всегда подходит.

И в этом случае нам надо установить параметр **`expires`**, то есть срок действия куков:
```js
document.cookie = "login=tom32;expires=Sun, 31 Dec 2023 23:59:00 GMT;";
```

То есть срок действия куки `login` истекает в понедельник 31 декабря 2023 года в 23:59. Формат параметра `expires` очень важен. Однако его можно сгенерировать программно. Для этого мы можем использовать метод **`toUTCString()`** объекта `Date`:
```js
const expire = new Date();
expire.setHours(expire.getHours() + 4);
document.cookie = "login=tom32;expires=" + expire.toUTCString() + ";";
```

В данном случае срок действия куки будет составлять 4 часа.

#### Путь и домен
Если вдруг нам надо установить куки для какого-то определенного пути на сайте, то мы можем использовать параметр **`path`**. Например, мы хотим установить куки только для пути http://localhost:3000/home:
```js
document.cookie = "login=tom32;expires=Sun, 31 Dec 2023 23:59:00 GMT;path=/home;";
```

В этом случае для других путей на сайте, например, http://localhost:3000/about, эти куки будут недоступны. Однако стоит отметить, что эта кука будет установлена, если мы обращаемся по пути http://localhost:3000/home.

Если на нашем сайте есть несколько доменов, и мы хотим установить куки непосредственно для определенного домена, тогда можно использовать параметр **`domain`**. Например, у нас на сайте есть поддомен *blog.mysite.com*:
```js
document.cookie = "login=tom32;expires=Sun, 31 Dec 2023 23:59:00 GMT;path=/;domain=blog.mysite.com;";
```

Параметр `path=/` указывает, что куки будут доступны для всех директорий и путей поддомена *blog.mysite.com*.

#### Параметр secure
Последний параметр — **`secure`** задает использование SSL (SecureSockets Layer) и подходит для сайтов, использующих протокол https. Если значение этого параметра равно `true`, то куки будут использоваться только при установке защищенного соединения ssl. По умолчанию данный параметр равен `false`.

```js
document.cookie = "login=tom32;expires=Sun, 31 Dec 2023 23:59:00 GMT;path=/;secure=true;";
```

### Получение куки
Для простейшего извлечения куки из браузера достаточно обратиться к свойству **`document.cookie`**:
```js
const expire = new Date();
expire.setHours(expire.getHours() + 4);

document.cookie = "language=JavaScript;expires="+expire.toUTCString()+";";
document.cookie = "company=Localhost;expires="+expire.toUTCString()+";";
document.cookie = "login=tom32;";

console.log(document.cookie);
```

Здесь были установлены три куки, и консоль браузера выведет нам все эти куки:
```
language=JavaScript; company=Localhost; login=tom32
```

Извлеченные куки не включают параметры `expires`, `path`, `domain` и `secure`. Кроме того, сами куки разделяются точкой с запятой, поэтому нужно еще провести некоторые преобразования, чтобы получить их имя и значение:
```js
const cookies = document.cookie.split(";");
for(cookie of cookies){

    const parts = cookie.split("=");
    console.log("Имя куки:", parts[0]);
    console.log("Значение:", parts[1],"\n\n");
}
```

### Ограничения куки
Все файлы cookie для соответствующего домена и соответствующего пути отправляются с каждым запросом, что влияет на объем пересылаемых данных. Кроме того, файлы cookie, отправляемые по протоколу HTTP (а не по безопасному протоколу HTTPS), передаются в незашифрованном виде, что представляет угрозу безопасности в зависимости от типа передаваемой информации. Еще одним ограничением файлов cookie является разрешенный размер памяти в 4 КБ.

## Web Storage

Для хранения данных в HTML5 применяется специальный API — **Web Storage API**, который обеспечивает доступ к внутреннему хранилищу браузера (web storage). Данное хранилище состоит из двух компонентов: **session storage** и **local storage**.

<dfn title="Session storage">Session storage</dfn> представляет временное хранилище информации, которая удаляется после закрытия вкладки браузера.

<dfn title="Local storage">Local storage</dfn> представляет хранилище для данных на постоянной основе. Данные из local storage автоматически не удаляются и не имеют срока действия. Эти данные не передаются на сервер в запросе HTTP. Кроме того, объем local storage составляет в Chrome и Firefox 5 Mб для домена.

Все данные в web storage представляют набор пар ключ-значение. То есть каждый объект имеет уникальное имя-ключ и определенное значение.[^12.2]

Для работы с local storage в javascript используется объект **`localStorage`**, а для работы с session storage — объект **`sessionStorage`**. Оба этих объектов с точки зрения API похожи и предоставляют аналогичные свойства и методы:

- **`length`**: содержит количество элементов в хранилище

- **`clear()`**: удаляет все элементы из хранилища

- **`getItem(key)`**: возвращает определенный элемент, который имеет ключ `key`

- **`key(index)`**: возвращает ключ элемента, который имеет индекс `index`

- **`removeItem(key)`**: удаляет элемент с ключом `key`

- **`setItem(key, value)`**: устанавливает для элемента с ключом `key` значение `value`. Если элемент с ключом `key` уже есть в хранилище, то его значение перезаписывается. Если элемента нет, то он добавляется.

### Сохранение данных
Для сохранения данных в хранилище применяется метод `setItem(key, value)`, в который передается ключ и значение элемента. Стоит учитывать, что в качестве значения сохраняются только строки. Например:
```js
localStorage.setItem("email", "tom32@gmail.com");
sessionStorage.setItem("username", "Tom Smith");
```

В данном случае в `localStorage` сохраняется элемент с ключом "email" и значением "tom32@gmail.com", а в `sessionStorage` сохраняется элемент с ключом "username" и значением "Tom Smith".

В некоторых браузерах с помощью специальных инструментов мы можем увидеть сохраненные объекты в local storage и session storage. Например, в Google Chrome мы можем открыть инструменты разработчика и перейти на вкладку **Application**. И затем в левой части выбрать пункт **Storage**->**Local storage** или **Session storage**:

![Local Storage и Session storage в JavaScript](../img/localstorage.png)

Если сохраняемое значение предстваляет не строку, а какой-то другой тип, то это значение преобразуется в строку с помощью метода `toString()`. Например:
```js
localStorage.setItem("age", 39);
```

Здесь значение представляет число, которое перед сохранением преобразуется в строку.

Трудности могут возникнуть с сохранением сложных объектов:
```js
const user ={
    name: "Tom",
    age: 23,
    isMarried: false
};

localStorage.setItem("user", user); //user = [object Object]
```

Здесь мы пытаемся сохранить объект user. Однако при преобразовании в строку мы получим `[object Object]`.

В этом случае для сохранения можно сериализовать объект в формат JSON:
```js
const user ={
    name: "Tom",
    age: 23,
    isMarried: false
};

localStorage.setItem("user", JSON.stringify(user));
```

### Получение данных
Для получения сохраненных данных надо вызвать метод **`getItem()`**, в который передается ключ объекта:
```js
// сохраняем в local storage
localStorage.setItem("email", "tom32@gmail.com");
// получаем обратно из local storage
const login = localStorage.getItem("login"); //tom32@gmail.com
```

Если были сохранены нестроковые данные, то может потребоваться их преобразование из строк в исходный тип.:
```js
localStorage.setItem("age", 23);
// преобразуем в число
let age = parseInt(localStorage.getItem("age"));
age += 1;
console.log(age); // 24
```

Если в данном случае не преобразовать значение к числу с помощью `parseInt()`, то `age` будет действовать как строка.

Если объект представляет объект, который ранее перед сохранением был преобразован в json, то при обратном получении его можно распарсить с помощью метода **`JSON.parse()`**:
```js
const tom ={
    name: "Tom",
    age: 23,
    isMarried: false
};

localStorage.setItem("user", JSON.stringify(tom));

// преобразуем в объект
const user = JSON.parse(localStorage.getItem("user"));
console.log(user.name);  // Tom
console.log(user.age);  // 23
console.log(user.isMarried); // false
```

### Удаление
Чтобы удалить объект, применяется метод **`removeItem()`**, который принимает ключ удаляемого объекта:
```js
localStorage.removeItem("email");
```

И для полного удаления всех объектов из `localStorage` можно использовать метод **`clear()`**:
```js
localStorage.clear();
```

IndexedDB
FileAPI

## Источники информации

[^11.1]: [Работа с JSON](https://metanit.com/web/javascript/11.1.php)
[^11.2]: [Работа с XML](https://metanit.com/web/javascript/11.2.php)
[^12.1]: [Хранение данных](https://metanit.com/web/javascript/12.1.php)
[^12.2]: [Web Storage](https://metanit.com/web/javascript/12.2.php)
