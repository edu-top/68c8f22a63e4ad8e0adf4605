## Объектно-ориентированное программирование

- [Объектно-ориентированное программирование](#объектно-ориентированное-программирование)
  - [Особенности ООП в JavaScript](#особенности-ооп-в-javascript)
  - [Функции-конструкторы объектов](#функции-конструкторы-объектов)
    - [Оператор instanceof](#оператор-instanceof)
  - [Расширение объектов. Прототипы](#расширение-объектов-прототипы)
    - [Прототип функций-конструкторов](#прототип-функций-конструкторов)
    - [Конструктор и прототип](#конструктор-и-прототип)
    - [Определение свойств прототипа](#определение-свойств-прототипа)
  - [Функция Object.create. Конфигурация свойств объектов](#функция-objectcreate-конфигурация-свойств-объектов)
  - [Наследование прототипов](#наследование-прототипов)
    - [Вызов методов базового прототипа](#вызов-методов-базового-прототипа)
    - [Проверка наследования прототипов и Object.isPrototypeOf()](#проверка-наследования-прототипов-и-objectisprototypeof)
  - [Классы](#классы)
    - [Определение класса](#определение-класса)
    - [Создание объектов](#создание-объектов)
    - [Поля и свойства класса](#поля-и-свойства-класса)
    - [Поведение класса и его методы](#поведение-класса-и-его-методы)
    - [Обращение к полям и методам внутри класса. Слово this](#обращение-к-полям-и-методам-внутри-класса-слово-this)
    - [Определение конструктора](#определение-конструктора)
    - [Выражения классов](#выражения-классов)
    - [Получение прототипа](#получение-прототипа)
  - [Приватные поля и методы](#приватные-поля-и-методы)
    - [Приватные поля](#приватные-поля)
    - [Приватные методы](#приватные-методы)
  - [Статические поля и методы](#статические-поля-и-методы)
    - [Статические поля](#статические-поля)
    - [Статические методы](#статические-методы)
    - [Приватные статические поля и методы](#приватные-статические-поля-и-методы)
  - [Свойства и методы доступа](#свойства-и-методы-доступа)
    - [Свойства, доступные только для чтения](#свойства-доступные-только-для-чтения)
    - [Свойства только для установки](#свойства-только-для-установки)
    - [Свойства без обращения к полям](#свойства-без-обращения-к-полям)
  - [Наследование](#наследование)
    - [Наследование класса с конструктором](#наследование-класса-с-конструктором)
    - [Определение конструктора в классе-наследнике и ключевое слово super.](#определение-конструктора-в-классе-наследнике-и-ключевое-слово-super)
    - [Переопределение методов базового класса.](#переопределение-методов-базового-класса)
    - [Наследование и приватные поля и методы](#наследование-и-приватные-поля-и-методы)
    - [Проверка принадлежности объекта классу](#проверка-принадлежности-объекта-классу)
  - [Источники информации](#источники-информации)

### Особенности ООП в JavaScript
Объектно-ориентированное программирование на сегодняшний день является одной из господствующих парадигм в разработке приложений, и в JavaScript мы также можем использовать все преимущества ООП. В то же время применительно к JavaScript объектно-ориентированное программирование имеет некоторые особенности. JavaScript реализует объектно-ориентированное программирование с помощью прототипного наследования и конструкторов, что отличает его от классического ООП на основе классов.

**Особенности ООП в JavaScript**

- Конструкторы создают объекты с определёнными свойствами и методами.

- Прототипы обеспечивают механизм наследования через цепочку прототипов.

- Наследование позволяет передавать свойства и поведение от одного объекта другому.

- Инкапсуляция скрывает внутренние детали реализации объекта.

- Деструктуризация, хотя и не является классической концепцией ООП, часто используется для удобной работы с объектами.

Такой вид объектно-ориентированного программирования (ООП) в JavaScript называется прототипно-ориентированным программированием или прототипным ООП. В отличие от классического класс-ориентированного ООП, где наследование происходит через классы, в JavaScript наследование реализовано через объекты-прототипы. Каждый объект может иметь ссылку на свой прототип, от которого он наследует свойства и методы. Это даёт большую гибкость и динамичность, позволяя создавать объекты без необходимости определять заранее классы. При этом современные версии JavaScript добавили «синтаксический сахар» в виде классов для удобства разработчиков, но под капотом остается прототипное наследование.

В JavaScript основные принципы ООП используются для организации кода: **абстракция** скрывает сложность, показывая только необходимые детали; **инкапсуляция** объединяет данные и методы объекта, скрывая внутреннюю реализацию от внешнего доступа; **наследование** позволяет создавать новые классы на основе существующих, повторно используя код; а **полиморфизм** позволяет объектам разных классов реагировать на один и тот же вызов по-своему. 

Абстракция в JavaScript — это принцип, при котором класс или объект предоставляют только ту информацию и методы, которые нужны для решения конкретной задачи, скрывая внутренние детали реализации. Обычно это достигается с помощью классов, модулей, замыканий и приватных полей (через символы или новые синтаксические конструкции). Абстракция позволяет разработчику фокусироваться на важном, упрощая взаимодействие с объектом через его публичный интерфейс.

Полиморфизм — способность объектов разных классов реагировать на один и тот же вызов (например, метод) по-разному, в данном случае поддерживается через переопределение методов: подклассы (или объекты с разными прототипами) могут иметь методы с одинаковыми именами, но с разной реализацией. Благодаря этому один и тот же вызов метода может вести себя по-разному в зависимости от типа объекта, на котором он вызван. Это динамическое поведение позволяет писать гибкий и расширяемый код.

Наследование — механизм, позволяющий создать новый класс (дочерний) на основе существующего (родительского), перенимая его свойства и методы, в JavaScript реализовано через прототипы, то есть объекты наследуют поведение от других объектов. Каждый объект содержит скрытую ссылку на свой прототип — другой объект, от которого он наследует свойства и методы. Если свойство или метод не найден в самом объекте, поиск осуществляется по цепочке прототипов вверх, пока не встретится нужное свойство или не будет достигнут конец цепочки (прототип равен `null`). Это называется прототипным наследованием.

Преимущества такого наследования:

- **Гибкость**: Можно динамически изменять прототипы объектов во время выполнения.

- **Экономия памяти**: Свойства и методы наследуются по ссылке, не копируются.

- **Простота**: Нет необходимости создавать сложные иерархии классов.

Недостатки:

- **Сложность отладки**, так как сложно отследить, откуда именно объект унаследовал свойство.

- JavaScript не поддерживает множественное наследование.

- Возможны ошибки при изменении прототипа во время работы программы.

Инкапсуляция — объединение данных (свойств) и методов (функций), которые работают с этими данными, в одном блоке (классе) и защита внутренних данных от прямого доступа извне, в JS присутствует частично, благодаря приватным полям и замыканиям, хотя полностью ограничить доступ к полям сложнее, чем в некоторых классических языках. Идея в том, чтобы скрыть внутренние детали объекта и предоставить доступ только к определённым методам и свойствам. Реализация инкапсуляции в JavaScript:

- Через замыкания — переменные внутри функции-конструктора не доступны извне, только через специально объявленные методы.

- С введением ES6 появились приватные поля и методы, обозначаемые префиксом #, которые не доступны снаружи объекта.

- Символы (Symbols) также используются для частичного сокрытия данных.

Полная инкапсуляция, как в языках со строгой типизацией и классами (например, Java или C#), в JavaScript сложнее, так как язык изначально проектировался более открытым и динамичным. Таким образом, для инкапсуляции в JavaScript применяются замыкания, приватные поля и соглашения о приватности, обеспечивая возможность скрыть детали реализации, но не столь строго, как в классических ООП языках.

Благодаря гибкости JavaScript, ООП может использоваться как с классами (синтаксический сахар ES6+), так и с прототипами напрямую. Таким образом, JavaScript реализует основные признаки ООП (абстракцию, полиморфизм, наследование, инкапсуляцию), но в контексте прототипно-ориентированного программирования с некоторыми отличиями по сравнению с классическим ООП.

### Функции-конструкторы объектов
Кроме создания новых объектов JavaScript предоставляет нам возможность создавать новые типы объектов с помощью специальных функций — **конструкторов**. Конструктор позволяет определить новый тип объекта. Определение типа может состоять из функции конструктора, методов и свойств.

Для начала определим конструктор:
```js
function Person(pName, pAge) {
    this.name = pName;
    this.age = pAge;
    this.print = function(){
        console.log("Name: ", this.name);
        console.log("Age: ", this.age);
    };
}
```

Конструктор — это обычная функция за тем исключением, что в ней мы можем установить свойства и методы. Для установки свойств и методов используется ключевое слово **`this`**:
```js
this.name = pName;
```

В данном случае устанавливаются два свойства `name` и `age` и один метод `print`.

Как правило, названия конструкторы в отличие от названий обычных функций начинаются с большой буквы.[^4.5]

После этого в программе мы можем определить объект типа `Person` и использовать его свойства и методы:
```js
// определение конструктора объектов типа Person
function Person(pName, pAge) {
    this.name = pName;
    this.age = pAge;
    this.print = function(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    };
}
// определение объекта типа Person
const tom = new Person("Tom", 39);
// обращение к свойству объекта
console.log(tom.name); // Том
// обращение к методу объекта
tom.print();    // Name: Tom  Age: 39
```

Чтобы вызвать конструктор, то есть создать объект типа `Person`, надо использовать ключевое слово **`new`**:
```js
const tom = new Person("Tom", 39);
```

Далее через имя объекта можно обращаться к его свойствам и методам, которые определены внутри функции конструктора:
```js
// обращение к свойству объекта
console.log(tom.name); // Том
// обращение к методу объекта
tom.print();
```

Стоит отметить, что, конечно, мы могли бы определить объект стандартным образом:
```js
const tom = {
    name: "Tom",
    age: 39,
    print: function(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    }
}
```

Однако использование функций-конструкторов позволяет упростить многократное создание однотипных объектов, которые имеют одинаковый набор свойств и методов. То есть фактически мы определяем новый тип объектов. Например:
```js
function Person(pName, pAge) {
    this.name = pName;
    this.age = pAge;
    this.print = function(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    };
}
const tom = new Person("Tom", 39);
const bob = new Person("Bob", 43);
const sam = new Person("Sam", 28);

tom.print();    // Name: Tom  Age: 39
bob.print();    // Name: Bob  Age: 43
sam.print();    // Name: Sam  Age: 28
```

Объекты подобных типов можно также передавать в функции или возвращать из функций, они могут выступать в качестве свойств других объектов, могут храниться в массивах и т.д. Например:
```js
function Person(pName, pAge) {
    this.name = pName;
    this.age = pAge;
    this.print = function(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    };
}
function printPersonName(person){
    console.log(person.name);
}
// массив из трех объектов Person
const people = [new Person("Tom", 39), new Person("Bob", 43), new Person("Sam", 28)];

for(person of people){
    printPersonName(person);
}
```

#### Оператор instanceof
Оператор **`instanceof`** позволяет проверить, с помощью какого конструктора создан объект. Если объект создан с помощью определенного конструктора, то оператор возвращает `true`:
```js
// определение конструктора объектов типа Person
function Person(pName, pAge) {
    this.name = pName;
    this.age = pAge;
    this.print = function(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    };
}
// определение конструктора объектов типа Employee
function Employee(eName, eCompany) {
    this.name = eName;
    this.company = eCompany;
    this.print = function(){
        console.log(`Name: ${this.name}  Company: ${this.company}`);
    };
}
const tom = new Person("Tom", 39);
const bob = new Employee("Bob", "Google");

console.log(tom instanceof Person);       // true - tom является объектом типа Person
console.log(bob instanceof Employee);   // true - bob является объектом типа Employee
console.log(tom instanceof Employee);   // false - tom НЕ является объектом типа Employee
```

### Расширение объектов. Прототипы
JavaScript — это язык, основанный на прототипах, поэтому он не знает никаких классов — по крайней мере, реальных. Вместо этого все в JavaScript основано на объектах. Почти каждый объект в JavaScript основан на прототипе. Исключения — тип `Object` (основа всех объектов) или объекты, прототип которых явно установлен в `null` — не имеют прототипа. Каждый объект также может служить шаблоном, то есть прототипом другого объекта. В этом случае новый объект наследует свойства и методы прототипа.

Прототип объекта хранится в свойстве **`__proto__`**, которое реализованно как псевдоним внутреннего свойства `[[Prototype]]`. Кроме того получить прототип объекта можно с помощью метода **`getPrototypeOf()`**. Например:
```js
const tom = {name: "Tom", age: 39};

// получаем прототип
console.log(tom.__proto__);                 // Object
console.log(Object.getPrototypeOf(tom));    // Object
```

В обоих случаях мы получим один и тот же результат в виде определения типа `Object`:
```
Object
    constructor: ƒ Object()
    hasOwnProperty: ƒ hasOwnProperty()
    isPrototypeOf: f isPrototypeOf()
    propertyIsEnumerable: f propertyIsEnumerable()
    toLocaleString: f toLocaleString()
    toString: f toString()
    valueOf: f valueOf()
    __defineGetter__: f __defineGetter__()
    __defineSetter__: f __defineSetter__()
    __lookupGetter__: f __lookupGetter__()
    __lookupSetter__: f __lookupSetter__()
    __proto__: null
    get __proto__: f __proto__()
    set __proto__: f __proto__()
```

#### Прототип функций-конструкторов
В прошлой теме были рассмотрены функции-конструкторы, который позволяют определить тип объекта и создать объект этого типа. Каждая такая функция-конструктор определяет свой **прототип**, который служит основой для создаваемых объектов. Этот прототип также можно получить с помощью свойства **`prototype`**. Например:
```js
function Person(name, age) {
    this.name = name;
    this.age = age;
    this.print = function(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    };
}

const tom = new Person("Tom", 39);

// получаем прототип
console.log(Person.prototype);
console.log(tom.__proto__);
console.log(Object.getPrototypeOf(tom));
```

Здесь получаем прототип функции-конструктора `Person`. Все три использованных способа получения прототипа аналогичны, и при выводе на консоль во всех трех случаях мы увидим что-то наподобие:
```
{constructor: ƒ}
constructor : ƒ Person(name, age)
[[Prototype]] : Object
```

#### Конструктор и прототип
Важно отличать конструктор и прототип. Прототип — это по сути план объекта, который может состоять из различных частей — методов и переменных, а собственно конструктор — только часть прототипа. Например, возьме выше определенную функцию `Person`:
```js
function Person(name, age) {
    this.name = name;
    this.age = age;
    this.print = function(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    };
}
console.log(Person.prototype);
```

Консольный вывод:
```
{constructor: ƒ}
	constructor: ƒ Person(name, age)
	[[Prototype]]: Object
```

Схематично мы можем представить прототип следующим образом:

![Прототипы функций-конструкторов в JavaScript](../img/4.2.png)

Фактически прототип функции-конструктора `Person` состоит только из конструктора (в который неявно также входят унаследованные от типа `Object` методы типа `toString()`). мы можем получить этот конструктор, использовав свойство **`constructor`**:
```js
console.log(Person.prototype.constructor);
```

Консоль должна вывести что-то наподобие:
```
ƒ Person(name, age) {
	this.name = name;
	this.age = age;
	this.print = function(){
		console.log(`Name: ${this.name}  Age: ${this.age}`);
	};
```

Поскольку свойство `constructor` — это часть прототипа, то к нему обратиться можно и через имя объекта:
```js
const tom = new Person("Tom", 39);
console.log(tom.constructor);
```

Теперь уберем метод `print()` из конструктора и определим его как часть прототипа:
```js
function Person (name, age) {
    this.name = name;
    this.age = age;
}
// функция print определена как часть прототипа
Person.prototype.print = function(){
    console.log(`Name: ${this.name}  Age: ${this.age}`);
};

console.log(Person.prototype);
```

Консольный вывод браузера:
```
{print: ƒ, constructor: ƒ}
	print: ƒ ()
	constructor: ƒ Person(name, age)
	[[Prototype]]: Object
```

Теперь прототип состоит из функции print и конструктора:

![Схема прототипов функций-конструкторов в JavaScript](../img/4.3.png)

При этом вне зависимости от того, как мы определяем методы и свойства - внутри конструктора или как часть прототипа, мы их равным образом можем использовать для объектов данного типа:
```js
function Person(name, age) {
    this.name = name;
    this.age = age;
    this.print = function(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    };
}

const tom = new Person("Tom", 39);
const bob = new Person("Bob", 43);

// измененияем прототип
Person.prototype.sayHello = function(){
    console.log(this.name, "says: Hello");
};
tom.print();    // Name: Tom  Age: 39
tom.sayHello(); // Tom says: Hello
bob.print();    // Name: Bob  Age: 43
bob.sayHello(); // Bob says: Hello
```

Причем мы можем определить одни и те же свойства и методы как внутри конструктора, так и как часть прототипа:
```js
// конструктор пользователя
function Person (name, age) {
    this.name = name;
    this.age = age;
    this.print = function(){
        console.log(`[Конструктор] Name: ${this.name}  Age: ${this.age}`);
    };
}
Person.prototype.print = function(){
    console.log(`[Прототип] Name: ${this.name}  Age: ${this.age}`);
};

const tom = new Person("Tom", 39);
const bob = new Person("Bob", 43);
tom.print();    // [Конструктор] Name: Tom  Age: 39
bob.print();    // [Конструктор] Name: Bob  Age: 43
```

В этом случае методы, определенные внутри конструктора, будут скрывать одноименные методы прототипа.

#### Определение свойств прототипа
Подобным образом можно добавлять и свойства. Например, добавим свойство `company`, которое представляет компанию:
```js
const tom = new Person("Tom", 39);
const bob = new Person("Bob", 43);

// добавляем в прототип свойство company
Person.prototype.company = "SuperCorp";
console.log(tom.company);   // SuperCorp
console.log(bob.company);   // SuperCorp
```

Но важно заметить, что значение свойства company будет одно и то же для всех объектов, это разделяемое статическое свойство. В отличие, скажем, от свойства `this.name`, которое хранит значение для определенного объекта.

В то же время мы можем определить в объекте свойство, которое будет назваться также, как и свойство прототипа. В этом случае собственное свойство объекта будет иметь приоритет перед свойством прототипа:
```js
const tom = new Person("Tom", 39);
const bob = new Person("Bob", 43);

Person.prototype.company = "SuperCorp";
bob.company = "MegaCorp";   // определяем свойство с тем же именем на уровне одного объекта
console.log(bob.company);   // MegaCorp - берет свойство из объекта bob
console.log(tom.company);   // SuperCorp - берет свойство из прототипа Person
```

И при обращении к свойству `company` javascript сначала ищет это свойство среди свойств объекта, и если оно не было найдено, тогда обращается к свойствам прототипа. То же самое касается и методов.[^4.6]

### Функция Object.create. Конфигурация свойств объектов
Еще один способ создания объекта предоставляет функция **`Object.create`**, которая принимает два параметра. Первый параметр — прототип, на основе которого будет создаваться объект, а второй параметр — определение свойств и методов объекта:
```js
const tom = Object.create(прототип, {  свойства и методы });
```

Например:
```js
const tom = Object.create(Object.prototype, {
    name: {
        value: "Tom"
    },
    age: {
        value: 39
    },
    print: {
        value: function() { console.log(`Name: ${this.name}  Age: ${this.age}`);
    }
}});

console.log(tom.name);  // Tom
console.log(tom.age);   // 39
tom.print();            // Name: Tom  Age: 39
```

Здесь в качестве прототипа в функцию `Object.create()` передается прототип `Object` — `Object.prototype`. Второй параметр функции — определение свойств вида:
```js
имя_свойства/метода: {
    value: значение_свойства/метода
}
```

Имени свойства/метода сопоставляется объект, в котором есть свойство **`value`** — это свойство собственно и хранит значение свойства/метода. Например, свойство `age` равно 39:
```js
age: {
    value: 39
}
```

Для метода значением выступает определение функции.

После создания объекта мы можем обращаться к его свойствам и методам, как и в общем случае:
```js
console.log(tom.age);   // 39
```

Подобный способ создания объектов может показаться чересчур громоздким и избыточным. Тем не менее он позволяет чуть детальнее настроить конфигурацию свойств. Так, кроме поля **`value`** при конфигурации свойства мы можем задать дополнительные поля:

- **`writeable`**: хранит логическое значение, которое указывает, доступно ли это свойство для записи, то есть можно ли ему присвоить новое значение. По умолчанию этот атрибут имеет значение `false`.

- **`enumerable`**: хранит логическое значение, которое указывает, является ли соответствующее свойство перечислимым, то есть включается ли это свойство при переборе свойств соответствующего объекта (например, с использованием цикла `for...in`). По умолчанию имеет значение `false`.

- **`configurable`**: хранит логическое значение, которое указывает, можно ли изменить сам атрибут для соответствующего свойства, то есть можно ли впоследствии настроить свойство с помощью атрибутов. Значение по умолчанию для этого атрибута также равно `false`.

- **`set`**: определяет, какая функция вызывается при изменении значения свойства.

- **`get`**: определяет, какая функция вызывается при чтении значения свойства.

Применим некоторые из этих атрибутов:
```js
const tom = Object.create(Object.prototype, {
    name: {
        value: "Tom",
        enumerable: true,       // доступно для перебора
        writable: false     // НЕ доступно для записи
    },
    age: {
        value: 39,
        enumerable: true,       // доступно для перебора
        writable: true      // доступно для записи
    },
    print: {
        value: function() { console.log(`Name: ${this.name}  Age: ${this.age}`);},
        enumerable: false,      // не доступно для перебора
        writable: false,        // НЕ доступно для записи
    }
});

console.log(tom.name);  // Tom
tom.name = "Tomas";
console.log(tom.name);  // Tom - свойство name не доступно для изменения

console.log(tom.age);   // 39
tom.age = 22;
console.log(tom.age);   // 22 - свойство age доступно для изменения

tom.print();            // Name: Tom  Age: 22

// перебор объекта
for(prop in tom){
    console.log(prop);
}
// Консольный вывод:
// name
// age
```

В примере выше функция `Object.create` использует много кода для создания объекта. Но что, если у нас есть куча свойств и методов, но некоторая конфигурация (например, сделать свойство доступно только для чтения) нужна только для одного свойства? В этом случае мы можем создать объект стандартным образом, а все дополнительные свойства, которые требуют конфигурации, определить с помощью функции **`Object.defineProperty`**:
```js
const tom = {
    age:39,
    print: function() { console.log(`Name: ${this.name}  Age: ${this.age}`);}
};
Object.defineProperty(tom, "name", {
        value: "Tom",
        writable: false     // НЕ доступно для записи
});

console.log(tom.name);  // Tom
tom.name = "Tomas";
console.log(tom.name);  // Tom - свойство name не доступно для изменения

tom.print();            // Name: Tom  Age: 22
```

Функция **`Object.defineProperty()`** принимает три параметра. Первый параметр — объект, для которого определяется свойство. Второй параметр — название свойства. Третий параметр — конфигурационный объект. То есть в данном случае доопределяем для объекта tom свойство name, которое будет достпуно только для чтения.[^4.19]

Если надо подобным образом доопределить несколько свойств, то применяется функция **`Object.defineProperties`**, которая принимает объект и набор конфигурационных настроек для добавляемых свойств:
```js
const tom = { age:39 };
//  доопределяем свойства для объекта tom
Object.defineProperties(tom, {
    name: {                 // определяем свойство name
        value: "Tom",
        writable: false     // НЕ доступно для записи
    },
    print: {        // определяем метод print
        value: function() { console.log(`Name: ${this.name}  Age: ${this.age}`);},
        writable: false,        // НЕ доступно для записи
    }
});

tom.name = "Tomas"; // свойство name не доступно для изменения
tom.print = function(){console.log("Hello Word");}  // метод print не доступен для изменения

tom.print();            // Name: Tom  Age: 39
```

Стоит отметить, что подобным образом мы можем не только добавлять новые свойства, но и переопределять конфигурацию уже существующих свойств. Например:
```js
const tom = {name: "Tom"};
// для свойства name запрещаем изменение
Object.defineProperty(tom, "name", { writable: false});
tom.name = "Tomas";
console.log(tom.name);  // Tom - значение свойства не изменилось
```

### Наследование прототипов
JavaScript поддерживает наследование, что позволяет нам при создании новых типов объектов при необходимости унаследовать их функционал от уже существующих. Однако нужно понимать, что наследование в JavaScript отличается от наследования в других распространенных и популярных языках типа Java, C++, C# и ряде других. В JavaScript наследование — это **наследование объектов** (а не наследование классов или типов), которое еще называют **наследование прототипов** или **прототипное наследование**.

Для создания объекта на основе некоторого прототипа применяется функция **`Object.create()`**, в которую передается наследуемый прототип:
```js
const person = {
    name: "",
    age: 0,
    print: function(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    }
};

const employee = Object.create(person);  // employee использует прототип объекта person

// получаем прототип
console.log(employee.__proto__);     // {name: "", age: 0, print: ƒ}

employee.name = "Tom";
employee.age = 39;
employee.print();    // Name: Tom  Age: 39
```

В данном случае объект `employee` создан на основе прототипа объекта `person`, по сути объект `employee` **наследует** прототип объекта `person`. Благодаря такому наследованию объект `employee` обладает всеми теми же свойствами и методами, которые определены в объекте `person`.

В дополнение объекты могут определять свои свойства и методы. Например:
```js
const person = {
    name: "",
    age: 0,
    print: function(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    }
};

const employee = Object.create(person);  // employee использует прототип объекта person

employee.name = "Tom";
employee.age = 39;
employee.company = "Google";  // новое свойство
// новый метод
employee.work = function(){
    console.log(`${this.name} works in ${this.company}`);
}
employee.print();    // Name: Tom  Age: 39
employee.work();    // Tom works in Google
```

В данном случае объект `employee` дополнительно определяет свойство `company` и метод `work`.

При необходимости можно переопределить унаследованные методы:
```js
const person = {
    name: "",
    age: 0,
    print: function(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    }
};
const employee = Object.create(person);

employee.name = "Tom";
employee.age = 39;
employee.company = "Google";
// переопределяем метод print
employee.print = function(){
    console.log(`Name: ${this.name}  Age: ${this.age} Company: ${this.company}`);
}
employee.print();    // Name: Tom  Age: 39  Company: Google
```

Здесь переопределяем функцию `print`, чтобы она также выводила компанию работника. Можно пойти дальше и увеличить цепочку наследования:
```js
const person = {
    name: "",
    age: 0,
    print: function(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    }
};
// объект employee наследует прототип объекта person
const employee = Object.create(person);
employee.company = "";

// объект manager наследует прототип объекта employee
const manager = Object.create(employee);
// переопределяем метод print
manager.print = function(){
    console.log(`Name: ${this.name}  Age: ${this.age}\nManager in ${this.company}`);
}
manager.name = "Bob";
manager.age = 43;
manager.company = "Microsoft";
manager.print();    // Name: Bob  Age: 43
                    // Manager in Microsoft
```

Таким образом, получаем цепочку прототипов — `person`-`employee`-`manager`: `employee` наследует прототип от `person`, `manager` наследует прототип от `employee`.

#### Вызов методов базового прототипа
Иногда может быть необходимо вызвать методы, которые определены в прототипе. Это может быть полезно для сокращения кода, уменьшения дублирования, особенно когда код переопределенного метода повторяет логику метода из прототипа. Получив прототип объекта, мы можем вызвать у него методы с помощью функции **`call()`**:
```js
const person = {
    name: "",
    age: 0,
    print: function(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    }
};
// объект employee наследует прототип объекта person
const employee = Object.create(person);
employee.name = "Tom";
employee.age = 39;
employee.company = "Google";
// переопределяем метод print
employee.print = function(){
    this.__proto__.print.call(this);    // вызываем версию метода из person
    // Object.getPrototypeOf(this).print.call(this);  // альтернативный вариант
    console.log(`Company: ${this.company}`);
}

employee.print();   // Name: Tom  Age: 39
                    // Company: Google
```

В данном случае в переопределенном методе `print` у типа `employee` вызываем через прототип версию метода `print` из `person`.

#### Проверка наследования прототипов и Object.isPrototypeOf()
С помощью метода **`Object.isPrototypeOf()`** можно проверить, является ли объект прототипом другого объекта:
```js
const person = {
    name: "",
    print: ()=>console.log("Name:", this.name)
};
const user = {
    name: "",
    print: ()=>console.log("Name:", this.name)
};

// объект employee наследует прототип объекта person
const employee = Object.create(person);

console.log(person.isPrototypeOf(employee));    // true
console.log(user.isPrototypeOf(employee));      // false
```

Здесь объект `employee` наследует прототип от `person`. Соответственно вызов `person.isPrototypeOf(employee)` возвратит `true`. А объект `user` не является прототипом для `employee` даже несмотря на то, что у него тот же набор методов и свойств.[^4.21]

### Классы
С внедрением стандарта ES2015 (ES6) в JavaScript появился новый способ определения объектов — с помощью классов. Класс представляет описание объекта, его состояния и поведения, а объект является конкретным воплощением или экземпляром класса. По сути синтаксис классов является альтернативной конструкцией, которая, как и функции-конструкторы, позволяет определить новый тип объектов.

Но стоит отметить, что несмотря на поддержку классов, JavaScript все же не является классическим объектно-ориентированным языком программирования как Java или C#. Классы JavaScript по сути представляют то, что называют "синтаксический сахар" над функциями-конструкторами — более удобные конструкции для создания объектов. И в реальности в JavaScript объекты по прежнему создаются не на основе классов, а на основе объектов или прототипов.

#### Определение класса
Для определения класса используется ключевое слово **`class`**:
```js
class Person{ }
```

После слова `class` идет название класса (в данном случае класс называется `Person`), и затем в фигурных скобках определяется тело класса.

Это наиболее расспространенный способ определения класса. Но есть и другие способы. Так, также можно определить анонимный класс и присвоить его переменной или константе:
```js
const Person = class{}
```

В принципе мы можем создать и неанонимный класс и присвоить его переменной или константе:
```js
const User = class Person{}
```

#### Создание объектов
Класс — это общее представление некоторых сущностей или объектов. Конкретным воплощением этого представления, класса является объект. И после определения класса мы можем создать объекты класса с помощью конструктора:
```js
class Person{}

const tom = new Person();
const bob = new Person();
```

Для создания объекта с помощью конструктора сначала ставится ключевое слово **`new`**. Затем собственно идет вызов конструктора — по сути вызов функции по имени класса. По умолчанию классы имеют один конструктор без параметров. Поэтому в данном случае при вызове конструктора в него не передается никаких аргументов.

Стоит отметить, что в отличие от функций, чтобы использовать класс, его надо сначала определить. Например, в следующем коде мы получим ошибку, так как пытаемся использовать класс до его определения:
```js
const tom = new Person();   // ! Ошибка - Uncaught ReferenceError: Cannot access 'Person' before initialization

class Person{}
```

Если определение класса присвоено переменной или константе, то мы можем использовать имя этой переменной/константы для создания объектов класса:
```js
const User = class Person{}
const tom = new User();
console.log(tom);
```

Выше в коде несмотря на то, что мы используем вызов `new User()`, в реальности создаваемый объект будет представлять класс `Person`.

Пример создания объекта анонимного класса:
```js
const Person = class{}
const tom = new Person();
console.log(tom);
```

#### Поля и свойства класса
Для хранения данных или состояния объекта в классе используются поля и свойства.

Итак, выше был определен класс `Person`, который представлял человека. У человека есть отличительных признаков, например, имя и возраст. Определим в классе `Person` поля для хранения этих данных:
```js
class Person{
    name;
    age;
}
const tom = new Person();
tom.name = "Tom";
tom.age = 37;
console.log(tom.name);  // Tom
console.log(tom.age);   // 37
```

Определение поля фактически просто представляет его название:
```js
name;
age;
```

Так, здесь определено поле `name` для хранения имени человека, и поле `age` для хранения возраста человека.

После создания объекта класса мы можем обратиться к этим полям. Для этого после имени объекта через точку указывается имя поля:
```js
tom.name = "Tom";       // установим значение поля
console.log(tom.name);  // получим значение свойства
```

В примере выше поля класса также можно назвать **свойствами**. По сути свойства представляют доступные извне или публичные поля класса. Дальше мы подробно разберем, когда поля бывают непубличные, то есть недоступными извне. Но пока стоит понимать, что свойства и публичные поля — это одно и то же. И в примере выше поля `name` и `age` также можно назвать свойствами.

При необходимости мы можем присвоить полям некоторые начальные значения:
```js
class Person{
    name = "Unknown";
    age= 18;
}
const tom = new Person();
console.log(tom.name);  // Unknown
tom.name = "Tom";
console.log(tom.name);  // Tom
```

#### Поведение класса и его методы
Кроме хранения данных, которые определяют состояние объекта, класс может иметь методы, которые определяют поведение объекта — действия, которые выполняет объект. Например, определим в классе `Person` пару методов:
```js
class Person{
    name;
    age;
    move(place){
        console.log(`Go to ${place}`);
    }
    eat(){
        console.log("Eat apples");
    }
}
const tom = new Person();
tom.move("Hospital");   // Go to Hospital
tom.move("Cinema");     // Go to Cinema
tom.eat();              // Eat apples
```

Здесь определен метод `move()`, который представляет условное передвижение человека. В качестве параметра метод принимает место, к которому идет человек. Второй метод — `eat()` — представляет условный процесс питания.

#### Обращение к полям и методам внутри класса. Слово this
Что если мы хотим в методах класса обратиться к полям класса или к другим его методам? В этом случае перед именем поля/свойства или метода указывается ключевое слово **`this`**, которое в данном случае указывает на текущий объект.

Например, определим метод, который выводит информацию об объекте:
```js
class Person{
    name;
    age;
    print(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    }
}
const tom = new Person();
tom.name = "Tom";
tom.age = 37;
tom.print();    // Name: Tom  Age: 37

const bob = new Person();
bob.name = "Bob";
bob.age = 41;
bob.print();    // Name: Bob  Age: 41
```

#### Определение конструктора
Для создания объекта класса используется конструктор:
```js
const bob = new Person();
```

Вызов конструктора по умолчанию, который есть в классах, фактически представляет вызов метода, который имеет то же название, что и класс, и возвращает объект этого класса.

Но также мы можем определить в классах свои конструкторы:
```js
class Person{
    name;
    age;
    constructor(){
        console.log("Вызов конструктора");
    }
    print(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    }
}
const tom = new Person();   // Вызов конструктора
const bob = new Person();   // Вызов конструктора
```

Конструктор определяется с помощью метода с именем **`constructor`**. По сути это обычный метод, который может принимать параметры. В данном случае конструктор просто выводит на консоль некоторое сообщение. Соответственно при выполнении строки
```js
const tom = new Person();
```

Мы увидим в консоли браузера соответствующее сообщение.

Как правило, цель конструктора — инициализация объекта некоторыми начальными данными:
```js
class Person{
    name;
    age;
    constructor(pName, pAge){
        this.name = pName;
        this.age = pAge;
    }
    print(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    }
}
const tom = new Person("Tom", 37);
tom.print();    // Name: Tom  Age: 37
const bob = new Person("Bob", 41);
bob.print()     // Name: Bob  Age: 41
```

Здесь конструктор принимает два параметра и передает их значения полям класса. Соответственно при создании объекта мы можем передать в конструктор соответствующие значения для этих параметров:
```js
const tom = new Person("Tom", 37);
```

Стоит отметить, что в примере выше определения полей класса избыточно. Обращение в конструкторе к полям через `this` фактически будет аналогично их определению, и в данном случае мы можем убрать определение полей:
```js
class Person{

    constructor(pName, pAge){
        this.name = pName;
        this.age = pAge;
    }
    print(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    }
}
const tom = new Person("Tom", 37);
tom.print();    // Name: Tom  Age: 37
const bob = new Person("Bob", 41);
bob.print()     // Name: Bob  Age: 41
```

#### Выражения классов
JavaScript также позволяет определять классы через выражения классов (class expression). Класс присваивается переменной/константе, через которую далее можно ссылаться на этот класс:
```js
const Person = class {
    constructor(pName, pAge){
        this.name = pName;
        this.age = pAge;
    }
    print(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    }
}
const tom = new Person("Tom", 38);
tom.print();
```

#### Получение прототипа
Как и функция-конструктор, класс имеет прототип, который можно получить стандартными способами:
```js
class Person{

    constructor(pName, pAge){
        this.name = pName;
        this.age = pAge;
    }
    print(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    }
}
const tom = new Person("Tom", 37);
// получаем прототип
console.log(Person.prototype);      // через свойство prototype класса
console.log(tom.__proto__);         // через свойство __proto__ объекта
console.log(Object.getPrototypeOf(tom));  // через функцию Object.getPrototypeOf и объект
console.log(tom.constructor);             // получение функции-конструктора (определения типа) объекта
```

### Приватные поля и методы
В прошлых темах мы использовали класс, свойства и методы которого были досупны извне, и соответственно мы могли к им обратиться в любом месте программы. Например:
```js
class Person{

    constructor(name, age){
        this.name = name;
        this.age = age;
    }
    print(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    }
}
const tom = new Person("Tom", 37);
tom.name = "Sam";
tom.age = -45;
tom.print();    // Name: Sam  Age: -45
```

С одной стороны, это замечательно, что мы можем использовать функциональность класса в своей программе, обращаться к его свойствам, методам. Но это может быть источником потенциальных проблем. Как видно в примере выше, мы можем изменить имя человека. Но что, если мы не хотим, чтобы в программе можно было менять начальное имя? Также мы можем изменить возраст человека, но изменить его на любое число, которое может предствлять некорректный возраст (например, отрицательный).

Иногда необходимо, чтобы к данным или действиям извне класса нельзя было обратиться, и чтобы к ним можно было обращаться только внутри этого же класса. Или иными словами, сделать свойства и методы класса приватными — доступными только для этого класса. И язык JavaScript предоставляет для этого необходимый инструментарий. Для этого название полей и методов должно начинаться с символа решетки **`#`**.

#### Приватные поля
Названия приватных полей предваряется символом **`#`**:
```js
class Person{
    #name;
    #age;
    constructor(name, age){
        this.#name = name;
        this.#age = age;
    }
    print(){
        console.log(`Name: ${this.#name}  Age: ${this.#age}`);
    }
}
const tom = new Person("Tom", 37);
// tom.#name = "Sam";   // ! Ошибка - нельзя обратиться к приватному полю
// tom.#age = -45;      // ! Ошибка - нельзя обратиться к приватному полю
tom.print();    // Name: Tom  Age: 37
```

В примере выше определены приватные поля `#name` и `#age`. Установить и получить их значение можно только внури класса `Person`. Вне его они не доступны. Поэтому при попытке обратиться к ним через имя объекта, мы получим ошибку:
```js
tom.#name = "Sam";  // ! Ошибка - нельзя обратиться к приватному полю
tom.#age = -45;     // ! Ошибка - нельзя обратиться к приватному полю
```

Если потребуется как-то к ним все-таки обратиться, то мы можем определить для этого методы. Например, выше метод `print()` получает их значения и выводит на консоль. Подобным образом можно определить и методы для установки значения:
```js
class Person{
    #name;
    #age= 1;
    constructor(name, age){
        this.#name = name;
        this.setAge(age);
    }
    setAge(age){
        if (age > 0 && age < 110) this.#age = age;
    }
    print(){
        console.log(`Name: ${this.#name}  Age: ${this.#age}`);
    }
}
const tom = new Person("Tom", 37);
tom.print();    // Name: Tom  Age: 37
tom.setAge(22);
tom.print();    // Name: Tom  Age: 22
tom.setAge(-1234);
tom.print();    // Name: Tom  Age: 22
```

В данном случае метод `setAge` проверяет корректность переданного значения, и если оно корректно, переустанавливает возраст.

#### Приватные методы
Названия приватных методов также предваряются символом **`#`**:
```js
class Person{
    #name = "undefined";
    #age = 1;
    constructor(name, age){
        this.#name = this.#checkName(name);
        this.setAge(age);
    }
    #checkName(name){
        if(name!=="admin") return name;
    }
    setAge(age){
        if (age > 0 && age < 110) this.#age = age;
    }
    print(){
        console.log(`Name: ${this.#name}  Age: ${this.#age}`);
    }
}
const tom = new Person("Tom", 37);
tom.print();    // Name: Tom  Age: 37
const bob = new Person("admin", 41);
bob.print();    // Name: Undefined  Age 41
//let personName = bob.#checkName("admin"); // ! Ошибка - нельзя обратится к приватному методу
```

В примере выше определен приватный метод `#checkName()`, который выполняет условную проверку имени — если оно не равно "admin", то возвращает переданное значение. (К примеру, мы не хотим, чтобы имя пользователя было "admin"). И также вне класса мы не можем обратиться к этому методу:
```js
let personName = bob.#checkName("admin");   // ! Ошибка
```

Как правило, подобные приватные методы используются для выполнения каких-то вспомогательных действий, как, например, валидация в примере выше, и которые нет смысла делать доступными извне.[^4.16]

### Статические поля и методы
Кроме обычных полей и методов класс может определять статические поля и методы. В отличие от обычных полей/свойств и методов они относятся ко всему классу, а не к отдельному объекту.

#### Статические поля
Статические поля хранят состояния класса в целом, а не отдельного объекта. Перед названием статического поля ставится ключевое слово `static`. Например:
```js
class Person{
    static retirementAge = 65;
    constructor(name, age){
        this.name = name;
        this.age = age;
    }
    print(){
        console.log(`Имя: ${this.name}  Возраст: ${this.age}`);
    }
}

console.log(Person.retirementAge); // 65
Person.retirementAge = 62;
console.log(Person.retirementAge); // 62
```

Здесь в классе Person определено статическое поле `retirementAge`, которое хранит условный возраст выхода на пенсию:
```js
static retirementAge = 65;
```

Это поле относится ко всему классу `Person` в целом и описывает состояние всего класса в целом. Ведь, как правило, есть некий общий возраст выхода на пенсию, принтый для всех (не берем в расчет отдельные случаи для отдельных профессий). И поэтому для обращения к статическому полю применяется имя класса, а не имя какого-либо объекта. Используя имя класса, мы можем получить или установить его значение:
```js
Person.retirementAge = 62;
console.log(Person.retirementAge); // 62
```

При этом мы НЕ можем в нестатических методах и конструкторе класса обращаться к этим полям через `this`, наподобие следующего:
```js
print(){
        console.log(`Имя: ${this.name}  Возраст: ${this.age}`);
        console.log(`Пенсионный возраст: ${this.retirementAge}`);   // к статическому полю нельзя обратиться через this
}
```

Если мы все таки хотим обратиться к статическим полям и методам внутри нестатических методов и конструкторе класса, то опять же, как и в общем случае, необходимо использовать имя класса:
```js
print(){
    console.log(`Имя: ${this.name}  Возраст: ${this.age}`);
    console.log(`Пенсионный возраст: ${Person.retirementAge}`);
}
```

#### Статические методы
Статические методы, как и статические поля, определяются для всего класса в целом, а не для отдельного объекта. Для их определения перед названием метода ставится оператор **`static`**. Например:
```js
class Person{
    constructor(name, age){
        this.name = name;
        this.age = age;
    }
    print(){
        console.log(`Имя: ${this.name}  Возраст: ${this.age}`);
    }
    static printClassInfo(){
        console.log("Класс Person представляет человека");
    }
}
Person.printClassInfo();    // Класс Person представляет человека
```

Здесь определен статический метод `printClassInfo()`, который для простоты просто выводит некоторое сообщение. В отличие от обычных нестатических методов, которые определяют поведение объекта, статические методы определяют поведение для всего класса. Поэтому для их вызова применяется имя класса, а не имя объекта:
```js
Person.printClassInfo();
```

Поскольку статический метод относится классу в целом, а не к объекту, то мы НЕ можем обращаться в нем к нестатическим полям/свойствам и методам объекта, наподобие следующего:
```js
class Person{
    constructor(name, age){
        this.name = name;
        this.age = age;
    }
    print(){
        console.log(`Имя: ${this.name}  Возраст: ${this.age}`);
    }
    static printAge(){  console.log(this.age); }    // для статического метода this.age не существует
}
Person.printAge();  // undefined
```

Если необходимо в статическом методе обратиться к свойствам объекта, то мы можем опеределить в методе параметр, через который в метод будет передаваться объект:
```js
class Person{
    constructor(name, age){
        this.name = name;
        this.age = age;
    }
    static print(person){
        console.log(`Имя: ${person.name}  Возраст: ${person.age}`);
    }
}
const tom = new Person("Tom", 37);
const bob = new Person("Bob", 41);
Person.print(tom);  // Tom 37
Person.print(bob);  // Bob 41
```

Однако мы можем использовать в статических методах слово **`this`** для обращения к статическим полям и другим статическим методам:
```js
class Person{
    static retirementAge = 65;
    constructor(name, age){
        this.name = name;
        this.age = age;
    }
    print(){ 
        console.log(`Имя: ${this.name}  Возраст: ${this.age}`);
    }
    static calculateRestAges(person){
        if(this.retirementAge > person.age){
            const restAges = this.retirementAge - person.age;
            console.log(`До пенсии осталось ${restAges} лет`);
        }
        else console.log("Вы уже на пенсии");
    }
}
const tom = new Person("Tom", 37);
Person.calculateRestAges(tom);      // До пенсии осталось 28 лет
const bob = new Person("Bob", 71);
Person.calculateRestAges(bob);      // Вы уже на пенсии
```

Здесь определен статический метод `calculateRestAges()`, который расчитывает, сколько определенному человеку осталось до пенсии. И для вычисления он обращается к статическому полю `retirementAge`:
```js
const restAges = this.retirementAge - person.age;
```

#### Приватные статические поля и методы
Как и обычные поля и методы статические поля и методы могут быть приватными. Такие поля и методы доступны только из других статических методов класса:
```js
class Person{
    static #retirementAge = 65;
    constructor(name, age){
        this.name = name;
        this.age = age;
    }
    print(){
        console.log(`Имя: ${this.name}  Возраст: ${this.age}`);
    }
    static calculateRestAges(person){
        if(this.#retirementAge > person.age){
            const restAges = this.#retirementAge - person.age;
            console.log(`До пенсии осталось ${restAges} лет`);
        }
        else console.log("Вы уже на пенсии");
    }
}
// console.log(Person.#retirementAge);  // ! Ошибка: поле retirementAge -приватное
const tom = new Person("Tom", 37);
Person.calculateRestAges(tom);      // До пенсии осталось 28 лет
const bob = new Person("Bob", 71);
Person.calculateRestAges(bob);      // Вы уже на пенсии
```

В отличие от предыдущего примера теперь статическое поле `retirementAge` приватное. И теперь к нему можно обратиться только внутри статических методов класса.[^4.17]

### Свойства и методы доступа
Для опосредования доступа к свойствам класса в последних стандартах JavaScript была добавлена поддержка методов доступа — **`get`** и **`set`**. Сначала рассмотрим проблему, с которой мы можем столкнуться:
```js
class Person{
    constructor(name, age){
        this.name = name;
        this.age = age;
    }
}
const tom = new Person("Tom", 37);
console.log(tom.age);   // 37
tom.age = -15;
console.log(tom.age);   // -15
```

Класс Person определяет два свойства — `name` (имя) и `age` (возраст человека), значения которых мы можем получить или установить. Но что если мы передадим некорректные значения? Так, в примере выше свойству age передается отрицательное число, но возраст не может быть отрицательным.

Чтобы выйти из этой ситуации, мы можем определить приватное поле `age`, к которому можно было бы обратиться только из текущего класса. А для получения или установки его значения создать специальные методы:
```js
class Person{
    #ageValue = 1;
    constructor(name, age){
        this.name = name;
        this.setAge(age);
    }
    getAge(){
        return this.#ageValue;
    }
    setAge(value){ if(value>0 && value < 110) this.#ageValue = value; }
}
const tom = new Person("Tom", 37);
console.log(tom.getAge());  // 37
tom.setAge(-15);
console.log(tom.getAge());  // 37
```

Теперь возраст хранится в приватном поле `ageValue`. При его установке в методе `setAge()` проверяется переданное значение. И установка происходит, если только передано корректное значение. А метод `getAge()` возвращает значение этой переменной.

Но есть и другое решение — применение методов доступа **`get`** и **`set`**.

```js
// определение приватного поля
#field;
set field(value){
    this.#field= value;
}
get field(){
    return this.#field;
}
```

Оба метода — `get` и `set` имеют одинаковые названия. Как правило, они опосредуют доступ к некоторому приватному полю. Метод **`set`** предназначен для установки. Он принимает в качестве параметра новое значение. Далее в методе `set` мы можем выполнить ряд действий при установке.

Метод **`get`** предназначен для получения значения. Здесь мы можем определить какую-нибудь логику при возвращении значения.

Так, перепишем предыдущий пример с использованием **`get`** и **`set`**:
```js
class Person{
    #ageValue = 1;
    constructor(name, age){
        this.name = name;
        this.age = age;
    }
    set age(value){
        console.log(`Передано ${value}`);
        if(value>0 && value < 110) this.#ageValue = value;
    }
    get age(){
        return this.#ageValue;
    }
}
const tom = new Person("Tom", 37);
console.log(tom.age);
tom.age = -15;
console.log(tom.age);
```

Стоит отметить, что работа с методами доступа производится также, как с обычными свойствами. Так, для получения значения и вывода на консоль применяется вызов:
```js
console.log(tom.age);
```

а не
```js
console.log(tom.age());
```

То есть при обращении `tom.age` фактически будет срабатывать метод **`get`**, который возвратит значение поля `ageValue`.

А при вызове
```js
tom.age = -15;
```

будет срабатывать метод **`set`**, который получит передаваемое ему значение (здесь число -15) через единственный параметр. И далее в самом методе `set` мы можем решить, надо ли устанавливать это значение.

#### Свойства, доступные только для чтения
Выше применялись оба метода `get` и `set`, соответственно значение поля можно было и получить, и установить. Однако в реальност мы можем использовать только один из них. Например, мы можем оставить только метод **`get`** и тем самым сделать свойство доступным **только для чтения**.

Например, в изменим пример выше и сделаем свойство name доступным только для чтения:
```js
class Person{
    #age = 1;
    #name;
    constructor(name, age){
        this.#name = name;
        this.age = age;
    }
    //set name(value){ this.#name = value; }
    get name(){ return this.#name; }
    set age(value){ if(value>0 && value < 110) this.#age = value; }
    get age(){ return this.#age; }
}
const tom = new Person("Tom", 37);
console.log(tom.name);  // Tom
tom.name = "Bob";       // Это ничего не даст
console.log(tom.name);  // Tom   - значение не изменилось
```

В данном случае вместо общедоступного свойства `name` определена приватное поле `#name`. Его можно установить только из внутри класса, что мы и делаем в конструкторе класса. Однако извне его можно только прочитать с помощью метода `get`. Поэтому попытка установки свойства
```js
tom.name = "Bob";
```

ни к чему не приведет

#### Свойства только для установки
Также мы можем сделать свойство доступным только для записи, оставив только метод **`set`**. Например, добавим новое свойство `id`, которое будет доступно только для записи:
```js
class Person{
    #id;
    constructor(name, age, id){
        this.name = name;
        this.age = age;
        this.id = id;
    }
    set id(value){ this.#id = value;}
    print(){
        console.log(`id: ${this.#id}   name: ${this.name}   age: ${this.age}`);
    }
}
const tom = new Person("Tom", 37, 1);
tom.print();            // id: 1   name: Tom   age: 37
tom.id = 55;            // устанавливаем значение свойства id
tom.print();            // id: 55   name: Tom   age: 37
console.log(tom.id);    // undefined - значение свойства id нельзя получить
```

Здесь определено свойство `id`, которое устанавливает значение приватного поля `#id`. Но поскольку метода `get` для этого свойства не определено, то при попытке получить значение свойства `id`, мы получим `undefined`:
```js
console.log(tom.id);    // undefined - значение свойства id нельзя получить
```

#### Свойства без обращения к полям
Стоит отметить, что методы `get` и `set` необязательно должны обращаться к приватным или неприватным полям. Это могут быть и вычисляемые свойства. Например:
```js
class Person{
    constructor(firstName, lastName){
        this.firstName = firstName;
        this.lastName = lastName;
    }
    get fullName(){ return `${this.firstName} ${this.lastName}` }
}
const tom = new Person("Tom", "Smith");
console.log(tom.fullName);  // Tom Smith
```

В данном случае свойство для чтения `fullName` возращает фактически объединение двух свойств — `firstName` и `lastName`.

Подобным образом можно определить и свойство для записи:
```js
class Person{
    constructor(firstName, lastName){
        this.firstName = firstName;
        this.lastName = lastName;
    }
    get fullName(){ return `${this.firstName} ${this.lastName}` }
    set fullName(value){
        [this.firstName, this.lastName] = value.split(" ");
    }
}
const tom = new Person("Tom", "Smith");
console.log(tom.fullName);  // Tom Smith
tom.fullName = "Tomas Jefferson";
console.log(tom.lastName);  // Jefferson
```

В данном случае метод `set` свойства `fullName` в качестве параметра получает некоторую строку и с помощью ее метода `split` разбивает по пробелу и получает массив подстрок, которые были разделены пробелом. То есть, теоретически мы рассчитываем, что будет передано что-то наподобие "Tom Smith", а после разделения по пробелу свойство `firstName` получит значение "Tom", а свойтсво `lastName` — значение "Smith". Стоит отметить, что для простоты и целй демонстрации здесь мы не рассматриваем исключительные ситуации, когда передается пустая строка или строка, которая не делится по пробелу на две части и т.д.

В итоге при получении нового значения
```js
tom.fullName = "Tomas Jefferson";
```

Метод `set` разобьет его по пробелу, и первый элемент массива будет передан свойству `firstName`, а второй — свойству `lastName`.[^4.14.]

### Наследование
Одни классы могут наследоваться от других. Наследование позволяет сократить объем кода в классах-наследниках. Например, возьмем следующие классы:
```js
class Person{
    name;
    age;
    print(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    }
}
class Employee{
    name;
    age;
    company;
    print(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    }
    work(){
        console.log(`${this.name} works in ${this.company}`);
    }
}

const tom = new Person();
tom.name = "Tom";
tom.age= 34;
const bob = new Employee();
bob.name = "Bob";
bob.age = 36; 
bob.company = "Google";
tom.print();    // Name: Tom  Age: 34
bob.print();    // Name: Bob  Age: 36
bob.work();     // Bob works in Google
```

Здесь определены два класса — `Person`, который представляет человека, и `Employee`, который представляет работника предприятия. Оба класса прекрасно работают, мы можем создавать их объекты, но мы также видим, что класс `Employee` повторяет функционал класса `Person`, так как работник также является человеком, для которого также можно определить свойства `name` и `age` и метод `print`.

Наследование позволяет одним классам автоматически получить функцонал других классов и тем самым сократить объем кода. Для наследования одного класса от другого применяется ключевое слово **`extends`**:
```js
class Base{}
class Derived extends Base{}
```

После названия класса-наследника ставится ключевое слово **`extends`**, после которого идет имя класса, от которого мы хотим унаследовать функционал.

Так, изменим классы `Person` и `Employee`, применив наследование:
```js
class Person{
    name;
    age;
    print(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    }
}
class Employee extends Person{
    company;
    work(){
        console.log(`${this.name} works in ${this.company}`);
    }
}

const tom = new Person();
tom.name = "Tom";
tom.age= 34;
const bob = new Employee();
bob.name = "Bob";
bob.age = 36;
bob.company = "Google";
tom.print();    // Name: Tom  Age: 34
bob.print();    // Name: Bob  Age: 36
bob.work();     // Bob works in Google
```

Теперь класс `Employee` наследуется от класса `Person`. В этом отношении класс `Person` еще называется базовым или родительским классом, а `Employee` — производным классом или классом-наследником. Поскольку класс `Employee` наследует функционал от `Person`, то нам нет необходимости заново определять в нем свойства `name`, `age` и метод `print`. В итоге код класса `Employee` получился короче, а результат программы тот же.

#### Наследование класса с конструктором
Вместе со всем функционалом производный класс наследует и конструктор базового класса. Например, определим в базовом классе `Person` конструктор:
```js
class Person{
    constructor(name, age){
        this.name = name;
        this.age = age;
    }
    print(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    }
}
class Employee extends Person{
    company;
    work(){
        console.log(`${this.name} works in ${this.company}`);
    }
}

const tom = new Person("Tom", 34);
tom.print();    // Name: Tom  Age: 34

const sam = new Employee("Sam", 25);    // унаследованный конструктор
sam.print();    // Name: Sam  Age: 25
```

В данном случае класс `Person` определяет конструктор с двумя параметрами. В этом случае класс `Employee` наследует его и использует для создания объекта `Employee`.

#### Определение конструктора в классе-наследнике и ключевое слово super.
Производный класс также может определить свой конструктор. Если производный класс определяет конструктор, то в нем **должен быть** вызван конструктор базового класса. Для обращения производном классе к функциональности базового класса, в том числе для обращения к конструктору базового класса, применяется ключевое слово **`super`**
```js
class Person{
    constructor(name, age){
        this.name = name;
        this.age = age;
    }
    print(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    }
}
class Employee extends Person{

    constructor(name, age, company){
        super(name, age);
        this.company = company;
    }
    work(){
        console.log(`${this.name} works in ${this.company}`);
    }
}

const tom = new Person("Tom", 34);
tom.print();    // Name: Tom  Age: 34

const sam = new Employee("Sam", 25, "Google");
sam.print();    // Name: Sam  Age: 25
sam.work();     // Sam works in Google
```

Класс `Employee` определяет свой конструктор с тремя параметрами, первой строкой в котором идет обращение к конструктору базового класса `Person`:
```js
super(name, age);
```

Поскольку конструктор класса `Person` имеет два параметра, соответственно в него передаются два значения. При этом конструктор базового класса должен вызываться до обращения к свойствам текущего объекта через `this`.

#### Переопределение методов базового класса.
Производный класс, как и в случае с конструктором, может переопределять методы базового класса. Так, в примере выше метод `print()` класса `Person` выводит имя и возраст человека. Но что, если мы хотим, чтобы для работника метод `print()` выводил также и компанию? В этом случае мы можем определить в классе `Employee` свой метод `print()`:
```js
class Person{
    constructor(name, age){
        this.name = name;
        this.age = age;
    }
    print(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    }
}
class Employee extends Person{

    constructor(name, age, company){
        super(name, age);
        this.company = company;
    }
    print(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
        console.log(`Company: ${this.company}`);
    }
}
const sam = new Employee("Sam", 25, "Google");
sam.print();    // Name: Sam  Age: 25
                // Company: Google
```

Однако в коде выше мы видим, что первая строка метода `print()` в классе `Employee` по сути повторяет код метода `print()` из класса `Person`. В данном случае это всего одна строка, но в другой ситуации повторяемый код мог бы больше. И чтобы не повторяться, мы опять же можем просто обратиться к реализации метода `print()` родительского класса `Person` через **`super`**:
```js
class Person{
    constructor(name, age){
        this.name = name;
        this.age = age;
    }
    print(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    }
}
class Employee extends Person{
  
    constructor(name, age, company){
        super(name, age);
        this.company = company;
    }
    print(){
        super.print();
        console.log(`Company: ${this.company}`);
    }
}
const sam = new Employee("Sam", 25, "Google");
sam.print();    // Name: Sam  Age: 25
                // Company: Google
```

То есть в данном случае вызов
```js
super.print();
```

представляет вызов реализации метода из базового класса. Таким образом, с помощью `this` и `super` мы можем разграничить обращение к функциональности текущего класса или его базового класса.

#### Наследование и приватные поля и методы
При наследовании стоит учитывать, что производный класс может обращаться к любой функциональности базового класса, кроме приватных полей и методов. Например:
```js
class Person{
    #name;
    constructor(name, age){
        this.#name = name;
        this.age = age;
    }
    print(){
        console.log(`Name: ${this.#name}  Age: ${this.age}`);
    }
}
class Employee extends Person{

    constructor(name, age, company){
        super(name, age);
        this.company = company;
    }
    print(){
        super.print();
        console.log(`Company: ${this.company}`);
    }
    work(){
        console.log(`${this.#name} works in ${this.company}`);  // ! Ошибка - поле #name недоступно из Employee
    }
}
```

В данном случае поле `#name` в классе `Person` определено как приватное, поэтому достуно только внутри этого класса. Поытка обратиться к этому полю в классе-наследнике `Employee` приведет к ошибке вне зависимости будет идти обращение через `this.#name` или `super.#name`. При необходимости в базовом классе можно определить геттеры и сеттеры, которые обращаются к приватным полям. А в классе-наследники через эти геттеры и сеттеры обращаться к приватным полям базового класса.

#### Проверка принадлежности объекта классу
Тот факт, что класс-наследник унаследован от некоторого базового класса говорит о том, что объект класса-наследника также является объектом базового класса. Объектом какого класса является объект, можно проверить с помощью оператора **`instanceof`**:
```js
class Person{
    constructor(name, age){
        this.name = name;
        this.age = age;
    }
    print(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    }
}
class Employee extends Person{

    constructor(name, age, company){
        super(name, age);
        this.company = company;
    }
    print(){
        super.print();
        console.log(`Works in ${this.company}`);
    }
}
class Manager extends Person{

    constructor(name, age, company){
        super(name, age);
        this.company = company;
    }
    print(){
        super.print();
        console.log(`Manager in ${this.company}`);
    }
}
const sam = new Employee("Sam", 25, "Google");
console.log(sam instanceof Person); // true
console.log(sam instanceof Employee); // true
console.log(sam instanceof Manager); // false
```

Здесь константа sam представляет объект класса `Employee`, который унаследован от `Person`, соответственно выражения `sam instanceof Person` и `sam instanceof Employee` возвратят `true`. А вот объектом класса `Manager` константа `sam` не является, поэтому выражение `sam instanceof Manager` возвратит `false`.[^4.15]

### Источники информации
[^4.5]: [Функции-конструкторы объектов](https://metanit.com/web/javascript/4.5.php)
[^4.6]: [Расширение объектов. Прототипы](https://metanit.com/web/javascript/4.6.php)
[^4.19]: [Функция Object.create. Конфигурация свойств объектов](https://metanit.com/web/javascript/4.19.php)
[^4.21]: [Наследование прототипов](https://metanit.com/web/javascript/4.21.php)
[^4.12]: [ООП. Классы](https://metanit.com/web/javascript/4.12.php)
[^4.16]: [Приватные поля и методы](https://metanit.com/web/javascript/4.16.php)
[^4.14.]: [Свойства и методы доступа](https://metanit.com/web/javascript/4.14.php)
[^4.17]: [Статические поля и методы](https://metanit.com/web/javascript/4.17.php)
[^4.15]: [Наследование](https://metanit.com/web/javascript/4.15.php)
