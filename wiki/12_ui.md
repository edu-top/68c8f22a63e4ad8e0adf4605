<link href="../styles.css" rel="stylesheet" />

## Интерфейсные события

- [Интерфейсные события](#интерфейсные-события)
  - [События мыши](#события-мыши)
    - [Типы событий мыши](#типы-событий-мыши)
    - [Порядок событий](#порядок-событий)
    - [MouseEvent](#mouseevent)
    - [Кнопки мыши](#кнопки-мыши)
    - [Модификаторы: shift, alt, ctrl и meta](#модификаторы-shift-alt-ctrl-и-meta)
    - [Координаты: clientX/Y, pageX/Y](#координаты-clientxy-pagexy)
    - [Отключаем выделение](#отключаем-выделение)
    - [Итого](#итого)
    - [Задачи](#задачи)
  - [Движение мыши: mouseover/out, mouseenter/leave](#движение-мыши-mouseoverout-mouseenterleave)
    - [События mouseover/mouseout, relatedTarget](#события-mouseovermouseout-relatedtarget)
    - [Пропуск элементов](#пропуск-элементов)
    - [Событие mouseout при переходе на потомка](#событие-mouseout-при-переходе-на-потомка)
    - [События mouseenter и mouseleave](#события-mouseenter-и-mouseleave)
    - [Делегирование событий](#делегирование-событий)
    - [Итого](#итого-1)
    - [Заключение](#заключение)
    - [Задачи](#задачи-1)
      - [Улучшенная подсказка](#улучшенная-подсказка)
      - ["Умная" подсказка](#умная-подсказка)
  - [Перетаскивание элементов](#перетаскивание-элементов)
    - [Drag'n'Drop с событиями мыши](#dragndrop-с-событиями-мыши)
      - [Алгоритм Drag’n’Drop](#алгоритм-dragndrop)
      - [Правильное позиционирование](#правильное-позиционирование)
      - [Цели переноса (droppable)](#цели-переноса-droppable)
      - [Итого](#итого-2)
    - [Задачи](#задачи-2)
      - [Слайдер](#слайдер)
      - [Расставить супергероев по полю](#расставить-супергероев-по-полю)
    - [Drag-and-Drop API](#drag-and-drop-api)
      - [Перетаскивание элементов с помощью Drag-and-Drop API](#перетаскивание-элементов-с-помощью-drag-and-drop-api)
      - [Установка и послучение перетаскиваемых данных с помощью DataTransfer](#установка-и-послучение-перетаскиваемых-данных-с-помощью-datatransfer)
    - [Заключение](#заключение-1)
  - [События клавиатуры](#события-клавиатуры)
    - [События keydown, keyup, keypress](#события-keydown-keyup-keypress)
    - [Объект клавиатурного события](#объект-клавиатурного-события)
    - [Свойства event.code и event.key](#свойства-eventcode-и-eventkey)
    - [Автоповтор](#автоповтор)
    - [Действия по умолчанию](#действия-по-умолчанию)
    - [«Дела минувших дней»](#дела-минувших-дней)
    - [Обработка клавиатурных событий](#обработка-клавиатурных-событий)
    - [Используйте события по назначению](#используйте-события-по-назначению)
    - [Итого](#итого-3)
    - [Задачи](#задачи-3)
      - [Отследить одновременное нажатие](#отследить-одновременное-нажатие)
  - [События указателя](#события-указателя)
    - [Краткая история](#краткая-история)
    - [Типы событий указателя](#типы-событий-указателя)
    - [Свойства событий указателя](#свойства-событий-указателя)
    - [Мульти-тач](#мульти-тач)
    - [Событие: pointercancel](#событие-pointercancel)
    - [Захват указателя](#захват-указателя)
    - [События при захвате указателя](#события-при-захвате-указателя)
    - [Итого](#итого-4)
  - [Прокрутка](#прокрутка)
    - [Предотвращение прокрутки](#предотвращение-прокрутки)
    - [Задачи](#задачи-4)
      - [Бесконечная страница](#бесконечная-страница)
      - [Кнопка вверх/вниз](#кнопка-вверхвниз)
      - [Загрузка видимых изображений](#загрузка-видимых-изображений)
  - [Глоссарий](#глоссарий)
  - [Практическая работа. Создание выделяемого списка](#практическая-работа-создание-выделяемого-списка)
    - [Задание](#задание)
  - [Практическая работа. Создание кастомных слайдеров](#практическая-работа-создание-кастомных-слайдеров)
    - [Задание](#задание-1)
  - [Практическая работа. Создание списка задач и управление его элементами](#практическая-работа-создание-списка-задач-и-управление-его-элементами)
    - [Задание](#задание-2)
  - [Практическая работа. Отслеживание одновременного нажатия](#практическая-работа-отслеживание-одновременного-нажатия)
    - [Задание](#задание-3)
  - [Практическая работа. Создание слайдеров](#практическая-работа-создание-слайдеров)
    - [Задание](#задание-4)
  - [Практическая работа. Реализация альтернативных механизмов замены изображения пользователя](#практическая-работа-реализация-альтернативных-механизмов-замены-изображения-пользователя)
    - [Задание](#задание-5)
  - [Практическая работа. Имитация сенсорных событий](#практическая-работа-имитация-сенсорных-событий)
    - [Задание](#задание-6)
  - [Практическая работа. Реализация бесконечной ленты](#практическая-работа-реализация-бесконечной-ленты)
    - [Задание](#задание-7)
  - [Практическая работа. Реализация загрузки изображений по требованию](#практическая-работа-реализация-загрузки-изображений-по-требованию)
    - [Задание](#задание-8)
  - [Источники информации](#источники-информации)

### События мыши
В этой секции более детально будут рассмотрены события мыши и их свойства. События мыши представляют собой одну из наиболее часто используемых групп событий.

Сразу заметим: эти события бывают не только из-за мыши, но и эмулируются на других устройствах, в частности, на мобильных, для совместимости.

#### Типы событий мыши

- `mousedown`: возникает при нахождении указателя мыши на элементе, когда кнопка мыши находится в нажатом состоянии.

- `mouseup`: возникает при нахождении указателя мыши на элементе во время отпускания кнопки мыши.

- `click`: возникает при нажатии указателем мыши на элемент. Вызывается при `mousedown` , а затем `mouseup` над одним и тем же элементом, если использовалась левая кнопка мыши.

- `dblclick`: возникает при двойном нажатии указателем мыши на элемент.

- `contextmenu`: вызывается при попытке открытия контекстного меню, как правило, нажатием правой кнопки мыши. Но, заметим, это не совсем событие мыши, оно может вызываться и специальной клавишей клавиатуры.

- `mousemove`: возникает при прохождении указателя мыши над элементом. Каждое движение мыши над элементом генерирует это событие.

- `mouseover`: возникает при вхождении указателя мыши в границы элемента.

- `mouseout`: возникает, когда указатель мыши выходит за пределы элемента.

- `mouseenter`: возникает при вхождении указателя мыши в границы элемента.

- `mouseleave`: возникает, когда указатель мыши выходит за пределы элемента.

Отдельно стоит сказать про разницу между последними четырьмя событиями. `mouseenter` и `mouseleave` срабатывают только тогда, когда пересекается внешний край соответствующего элемента. А события `mouseover` и `mouseout` также срабатывают, когда другой элемент находится внутри соответствующего элемента и курсор мыши перемещается во внутренний элемент (т.е. уходит от внешнего элемента) или покидает внутренний элемент (то есть перемещается на внешний элемент).

Например, обработаем события `mouseover` и `mouseout`:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
    <style>
    #blueRect{
        width:100px;
        height:100px;
        background-color:blue;
    }
    </style>
</head>
<body>
<div id="blueRect"></div>

<script>
function setColor(e){
    if(e.type==="mouseover")
        e.target.style.backgroundColor = "red";
    else if(e.type==="mouseout")
        e.target.style.backgroundColor = "blue";
}
const blueRect = document.getElementById("blueRect");
blueRect.addEventListener("mouseover", setColor);
blueRect.addEventListener("mouseout", setColor);
</script>
</body>
</html>
```

Теперь при наведении указателя мыши на блок `blueRect` он будет окрашиваться в красный цвет, а при уходе указателя мыши — блок будет обратно окрашиваться в синий цвет.

#### Порядок событий
Как вы можете видеть из приведённого выше списка, действие пользователя может вызвать несколько событий.

Например, клик мышью вначале вызывает `mousedown`, когда кнопка нажата, затем `mouseup` и `click`, когда она отпущена.

В случае, когда одно действие инициирует несколько событий, порядок их выполнения фиксирован. То есть обработчики событий вызываются в следующем порядке: `mousedown` → `mouseup` → `click`.

Ниже показана запись событий мыши, зафиксированных регистратором (скриптом).

![Mouse events](../img/mouse-events-logger.png)

В окне теста ниже все события мыши записываются, и если задержка между ними более 1 секунды, то они разделяются горизонтальной чертой. Зафиксирован следующий порядок вызов событий: левый клик, правый клик, клик средней кнопкой (колесом) и двойной клик левой кнопкой мыши.

Кроме того, мы можем видеть свойство `button`, которое позволяет нам определять кнопку мыши; это объясняется ниже.[^mouse-events-basics]

Аналогично работают и другие последовательности в DOM-событиях:

- **Двойной клик**: `mousedown` → `mouseup` → `click` → `mousedown` → `mouseup` → `click` → `dblclick`

- **Фокус на элемент**: `focusin` (на контейнере) → `focus` (на элементе) → `focus` (на связанных элементах, если `bubbling`)

- **Потеря фокуса**: `blur` → `focusout`

- **Ввод клавиши**: `keydown` → (опционально `keypress`) → `keyup`

- **Перетаскивание** (drag): `dragstart` → `dragenter`/`dragleave`/`dragover` → `drop` → `dragend`

Важные нюансы:
- Порядок строго фиксирован браузерами (стандарт WHATWG DOM Events).

- `click` не срабатывает, если между `mousedown` и `mouseup` мышь вышла за пределы элемента.

- События могут прерываться (`preventDefault()` или `stopPropagation()` в одном обработчике влияет на следующие).

- Для сенсорных устройств добавляются `touchstart` → `touchend` → `click` (с задержкой ~300 мс).

Это помогает предсказуемо обрабатывать взаимодействия в JavaScript.

#### MouseEvent
Объект `Event` является общим для всех событий. Однако для разных типов событий существуют также свои объекты событий, которые добавляют ряд своих свойств. Так, для работы с событиями указателя мыши определен объект **`MouseEvent`**, который добавляет следующие свойства:[^9.5]

- **`altKey`**: возвращает `true`, если была нажата клавиша `Alt` во время генерации события

- **`button`**: содержит номер нажатой кнопки мыши

- **`buttons`**: содержит номер, который представляет нажатую кнопку мыши. 1 обозначает левую кнопку мыши, 2 — правую кнопку мыши, 4 — колесо мыши или среднюю кнопку мыши, 8 — четвертую кнопку мыши, а 16 — пятую кнопку мыши. Если при срабатывании события было нажато несколько кнопок, это свойство содержит сумму соответствующих чисел.

- **`clientX`**: определяет координату Х окна браузера, на которой находился указатель мыши во время генерации события

- **`clientY`**: определяет координату Y окна браузера, на которой находился указатель мыши во время генерации события

- **`ctrlKey`**: возвращает `true`, если была нажата клавиша <kbd>Ctrl</kbd> во время генерации события

- **`movementX`**: содержит координату Х относительно предыдущей координаты X при последнем событии перемещения мыши

- **`movementY`**: содержит координату Y относительно предыдущей координаты Y при последнем событии перемещения мыши

- **`metaKey`**: возвращает `true`, если была нажата во время генерации события метаклавиша клавиатуры (<kbd>Alt</kbd>, <kbd>Ctrl</kbd>, <kbd>Shift</kbd>)

- **`region`**: содержит идентификатор области или элемента, которая относится к событию

- **`relatedTarget`**: определяет вторичный источник возникновения события

- **`screenX`**: определяет координату Х относительно верхнего левого угла экрана монитора, на которой находился указатель мыши во время генерации события

- **`screenY`**: определяет координату Y относительно верхнего левого угла экрана монитора, на которой находился указатель мыши во время генерации события

- **`shiftKey`**: возвращает `true`, если была нажата клавиша <kbd>Shift</kbd> во время генерации события

Определим координаты клика:
```js
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <style>
    #blueRect{
        width:100px;
        height:100px;
        background-color:blue;
    }
    </style>
</head>
<body>
<div id="blueRect"></div>

<script>
function handleClick(e){
    console.log("screenX: " + e.screenX);
    console.log("screenY: " + e.screenY);
    console.log("clientX: " + e.clientX);
    console.log("clientY: " + e.clientY);
}
const blueRect = document.getElementById("blueRect");
blueRect.addEventListener("click", handleClick);
</script>
</body>
</html>
```

#### Кнопки мыши
*[MMB]: Middle Mouse Button

События, связанные с кликом, всегда имеют свойство `button`, которое позволяет получить конкретную кнопку мыши.

Обычно мы не используем его для событий `click` и `contextmenu`, потому что первое происходит только при щелчке левой кнопкой мыши, а второе – только при щелчке правой кнопкой мыши.

С другой стороны, обработчикам `mousedown` и `mouseup` может потребоваться `event.button`, потому что эти события срабатывают на любую кнопку, таким образом `button` позволяет различать «нажатие правой кнопки» и «нажатие левой кнопки».

Возможными значениями `event.button` являются:

| Состояние кнопки                 | `event.button` |
| -------------------------------- | ------------ |
| Левая кнопка (основная)          | 0            |
| Средняя кнопка (вспомогательная) | 1            |
| Правая кнопка (вторичная)        | 2            |
| Кнопка X1 (назад)                | 3            |
| Кнопка X2 (вперёд)               | 4            |

Большинство мышек имеют только левую и правую кнопку, поэтому возможные значения это 0 или 2. Сенсорные устройства также генерируют аналогичные события, когда кто-то нажимает на них.

Также есть свойство `event.buttons`, в котором все нажатые в данный момент кнопки представлены в виде целого числа, по одному биту на кнопку. На практике это свойство используется очень редко, вы можете найти подробную информацию по адресу [MDN](https://developer.mozilla.org/ru/docs/Web/api/MouseEvent/buttons), если вам это когда-нибудь понадобится.

!!! warning "Устаревшее свойство `event.which`"

    В старом коде вы можете встретить `event.which` свойство – это старый нестандартный способ получения кнопки с возможными значениями:

    - `event.which == 1` – левая кнопка,
    - `event.which == 2` – средняя кнопка,
    - `event.which == 3` – правая кнопка.

    На данный момент `event.which` устарел, нам не следует его использовать.

Средняя кнопка (*middle mouse button*, MMB) сейчас используется редко в повседневных сценариях. Основная причина — эргономика и привычки пользователей. Большинство мышей имеют колесо прокрутки, которое выполняет роль средней кнопки (нажатие на колесо), но оно часто тугое, неудобное для удержания в зажатом состоянии и требует напряжения пальцев или кисти.

#### Модификаторы: shift, alt, ctrl и meta
Все события мыши включают в себя информацию о нажатых клавишах-модификаторах.

Свойства события:

- `shiftKey`: <kbd>Shift</kbd>
- `altKey`: <kbd>Alt</kbd> (или <kbd>Opt</kbd> для Mac)
- `ctrlKey`: <kbd>Ctrl</kbd>
- `metaKey`: <knf>Cmd</knf> для Mac

Они равны `true`, если во время события была нажата соответствующая клавиша.

Например, кнопка внизу работает только при комбинации <kbd>Alt</kbd>+<kbd>Shift</kbd>+клик:
```html
<button id="button">Нажми Alt+Shift+Click на мне!</button>

<script>
  button.onclick = function(event) {
    if (event.altKey && event.shiftKey) {
      alert('Ура!');
    }
  };
</script>
```

![Alt+Shit+click](../img/alt-shift-click.png)

!!! warning "Внимание: обычно на Mac используется клавиша `Cmd` вместо `Ctrl`"
    В Windows и Linux клавишами-модификаторами являются <kbd>Alt</kbd>, <kbd>⇧ Shift</kbd> и <kbd>Ctrl</kbd>. На Mac есть ещё одна: <kbd>Cmd</kbd>, которой соответствует свойство `metaKey`.

    В большинстве приложений, когда в Windows/Linux используется <kbd>Ctrl</kbd>, на Mac используется <knf>Cmd</knf>.

    То есть, когда пользователь Windows нажимает <kbd>Ctrl</kbd>+<kbd>Enter</kbd> и <kbd>Ctrl</kbd>+<kbd>A</kbd>, пользователь Mac нажимает <kbd>Cmd</kbd>+<kbd>⏎ Enter</kbd> или <kbd>Cmd</kbd>+<kbd>A</kbd>, и так далее.

    Поэтому, если мы хотим поддерживать такие комбинации, как <kbd>Ctrl</kbd>+клик, то для Mac имеет смысл использовать <kbd>Cmd</kbd>+клик. Это удобней для пользователей Mac.

    Даже если мы и хотели бы заставить людей на Mac использовать именно <kbd>Ctrl</kbd>+клик, это довольно сложно. Проблема в том, что левый клик в сочетании с <kbd>Ctrl</kbd> интерпретируется как правый клик на MacOS и генерирует событие `contextmenu`, а не `click` как на Windows/Linux.

    Поэтому, если мы хотим, чтобы пользователям всех операционных систем было удобно, то вместе с `ctrlKey` нам нужно проверять `metaKey`.

    Для JS-кода это означает, что мы должны проверить `if (event.ctrlKey || event.metaKey)`.

!!! warning "Не забывайте про мобильные устройства"
    Комбинации клавиш хороши в качестве дополнения к рабочему процессу. Так что, если посетитель использует клавиатуру – они работают.

    Но если на их устройстве его нет – тогда должен быть способ жить без клавиш-модификаторов.

#### Координаты: clientX/Y, pageX/Y
Все события мыши имеют координаты двух видов:

1. Относительно окна: `clientX` и `clientY`.
2. Относительно документа: `pageX` и `pageY`.

Мы уже рассмотрели разницу между ними в главе "Координаты" раздела, посвященного DOM.

Если вкратце, то относительные координаты документа `clientX`/`Y` отсчитываются от левого верхнего угла **текущего окна** и не меняются при прокрутке страницы, в то время как `pageX`/`Y` отсчитываются от левого верхнего угла **документа**. Когда страница прокручивается, они меняются.

Например, если у нас есть окно размером 500x500, и курсор мыши находится в левом верхнем углу, то значения `clientX` и `clientY` равны `0`, независимо от того, как прокручивается страница.

А если мышь находится в центре окна, то значения `clientX` и `clientY` равны `250` независимо от того, в каком месте документа она находится и до какого места документ прокручен. В этом они похожи на `position:fixed`.

Наведите курсор мыши на поле ввода, чтобы увидеть `clientX`/`clientY` (пример находится в `iframe`, поэтому координаты определяются относительно этого `iframe`):
```html
<input onmousemove="this.value=event.clientX+':'+event.clientY" value="Наведи на меня мышь">
```

Координаты относительно документа `pageX`, `pageY` отсчитываются не от окна, а от левого верхнего угла документа. Подробнее о координатах можно узнать в главе "Координаты" раздела, посвященного DOM.

#### Отключаем выделение
Двойной клик мыши имеет побочный эффект, который может быть неудобен в некоторых интерфейсах: он выделяет текст.

Например, двойной клик на текст ниже выделяет его в дополнение к нашему обработчику:
```html
<span ondblclick="alert('dblclick')">Сделайте двойной клик на мне</span>
```

![Double click](../img/dbl-click_1.png)

Если зажать левую кнопку мыши и, не отпуская кнопку, провести мышью, то также будет выделение, которое в интерфейсах может быть некстати.

Есть несколько способов запретить выделение, о которых можно прочитать в главе "Диапазоны и выделение".

В данном случае самым разумным будет отменить действие браузера по умолчанию при событии `mousedown`, это отменит оба этих выделения:
```html
До...
<b ondblclick="alert('Клик!')" onmousedown="return false">
  Сделайте двойной клик на мне
</b>
...После
```

![Double click](../img/dbl-click_2.png)

Теперь выделенный жирным элемент не выделяется при двойном клике, а также на нём нельзя начать выделение, зажав кнопку мыши.

Стоит отметить, что текст внутри него по-прежнему можно выделить, если начать выделение не на самом тексте, а до него или после. Обычно это нормально воспринимается пользователями.

!!! info "Предотвращение копирования"
    Если мы хотим отключить выделение для защиты содержимого страницы от копирования, то мы можем использовать другое событие: `oncopy`.

    ```html
    <div oncopy="alert('Копирование запрещено!');return false">
      Уважаемый пользователь,
      Копирование информации запрещено для вас.
      Если вы знаете JS или HTML, вы можете найти всю нужную вам информацию в исходном коде страницы.
    </div>
    ```

    ![Prevent copy](../img/prevent-copy.png)

    Если вы попытаетесь скопировать текст в `<div>`, у вас это не получится, потому что срабатывание события `oncopy` по умолчанию запрещено.

    Конечно, пользователь имеет доступ к HTML-коду страницы и может взять текст оттуда, но это не так удобно и не все знают, как это сделать.

#### Итого
События мыши имеют следующие свойства:

- Кнопка: `button`.

- Клавиши-модификаторы (`true` если нажаты): `altKey`, `ctrlKey`, `shiftKey` и `metaKey` (Mac).

    - Если вы планируете обработать <kbd>Ctrl</kbd>, то не забудьте, что пользователи Mac обычно используют <kbd>Cmd</kbd>, поэтому лучше проверить `if (e.metaKey || e.ctrlKey)`.

- Координаты относительно окна: `clientX`/`clientY`.

- Координаты относительно документа: `pageX`/`pageY`.

Действие по умолчанию события `mousedown` – начало выделения, если в интерфейсе оно скорее мешает, его можно отменить.

В следующей главе мы поговорим о событиях, которые возникают при передвижении мыши, и об отслеживании смены элементов под указателем.

#### Задачи
Создайте список, в котором элементы могут быть выделены, как в файловых менеджерах.

- При клике на элемент списка выделяется только этот элемент (добавляется класс `.selected`), отменяется выделение остальных элементов.
- Если клик сделан вместе с <kbd>Ctrl</kbd> (<kbd>Cmd</kbd> для Mac), то выделение переключается на элементе, но остальные элементы при этом не изменяются.

Демо:

![Selectable list](../img/selectable-list.png)

P.S. В этом задании все элементы списка содержат только текст. Без вложенных тегов.

P.P.S. Предотвратите стандартное для браузера выделение текста при кликах.

<details>
<summary>Решение</summary>

[Код решения](../src/11_events/selectable-list.html)

</details>

### Движение мыши: mouseover/out, mouseenter/leave
В этой главе мы более подробно рассмотрим события, возникающие при движении указателя мыши над элементами страницы.[^mousemove-mouseover-mouseout-mouseenter-mouseleave]

#### События mouseover/mouseout, relatedTarget
Событие `mouseover` происходит в момент, когда курсор оказывается над элементом, а событие `mouseout` – в момент, когда курсор уходит с элемента.

![Mouseover/mousout](../svg/mouseover-mouseout.svg)

Эти события являются особенными, потому что у них имеется свойство `relatedTarget`. Оно «дополняет» `target`. Когда мышь переходит с одного элемента на другой, то один из них будет `target`, а другой `relatedTarget`.

Для события `mouseover`:

- `event.target` – это элемент, *на который* курсор перешёл.
- `event.relatedTarget` – это элемент, *с которого* курсор ушёл (`relatedTarget` → `target`).

Для события `mouseout` наоборот:

- `event.target` – это элемент, *с которого* курсор ушёл.
- `event.relatedTarget` – это элемент, *на который* курсор перешёл (`target` → `relatedTarget`).

В примере ниже каждое лицо и его черты – отдельные элементы. При движении указателя по этим элементам в текстовом поле отображаются происходящие события.

Каждое из них содержит информацию о `target` и `relatedTarget`:

[Тестовый стенд](../test/test_01/)

!!! warning "Свойство `relatedTarget` может быть `null`"
    Свойство `relatedTarget` может быть `null`.

    Это нормально и означает, что указатель мыши перешёл не с другого элемента, а из-за пределов окна браузера. Или же, наоборот, ушёл за пределы окна.

    Следует держать в уме такую возможность при использовании `event.relatedTarget` в своём коде. Если, например, написать `event.relatedTarget.tagName`, то при отсутствии `event.relatedTarget` будет ошибка.

#### Пропуск элементов
Событие `mousemove` происходит при движении мыши. Однако, это не означает, что указанное событие генерируется при прохождении каждого пикселя.

Браузер периодически проверяет позицию курсора и, заметив изменения, генерирует события `mousemove`.

Это означает, что если пользователь двигает мышкой очень быстро, то некоторые DOM-элементы могут быть пропущены:

![Mouseover mouseout over elems](../svg/mouseover-mouseout-over-elems.svg)

Если курсор мыши передвинуть очень быстро с элемента `#FROM` на элемент `#TO`, как это показано выше, то лежащие между ними элементы `<div>` (или некоторые из них) могут быть пропущены. Событие `mouseout` может запуститься на элементе `#FROM` и затем сразу же сгенерируется `mouseover` на элементе `#TO`.

Это хорошо с точки зрения производительности, потому что если промежуточных элементов много, вряд ли мы действительно хотим обрабатывать вход и выход для каждого.

С другой стороны, мы должны иметь в виду, что указатель мыши не «посещает» все элементы на своём пути. Он может и «прыгать».

В частности, возможно, что указатель запрыгнет в середину страницы из-за пределов окна браузера. В этом случае значение `relatedTarget` будет `null`, так как курсор пришёл «из ниоткуда»:

![Mouseover mouseout from outside](../svg/mouseover-mouseout-from-outside.svg)

Вы можете проверить это «вживую» на тестовом стенде ниже.

В его HTML есть два элемента, `<div id="child">` вложен в `<div id="parent">`. Если быстро провести мышью над ними, то событие может возникнуть только на внутреннем элементе или только на внешнем, а может вообще не сгенерироваться никаких событий.

Также попробуйте поставить курсор на внутренний элемент, а затем очень быстро сделайте движение мышкой вниз через внешний элемент. Если у вас получится достаточно быстро, то на родительском элементе не будет сгенерировано никаких событий. То есть, мышь пройдёт через внешний элемент, не замечая его.

[Тестовый стенд](../test/test_02/)

!!! info "Если был `mouseover`, то будет и `mouseout`"
    Несмотря на то, что при быстрых переходах промежуточные элементы могут игнорироваться, в одном мы можем быть уверены: **элемент может быть пропущен только целиком**.

    Если указатель «официально» зашёл на элемент, то есть было событие `mouseover`, то при выходе с него обязательно будет `mouseout`.

#### Событие mouseout при переходе на потомка
Важная особенность события `mouseout` – оно генерируется в том числе, когда указатель переходит с элемента на его потомка.

То есть, визуально указатель всё ещё на элементе, но мы получим `mouseout`!

![Mouseover to child](../svg/mouseover-to-child.svg)

Это выглядит странно, но легко объясняется.

**По логике браузера, курсор мыши может быть только над одним элементом в любой момент времени – над самым глубоко вложенным и верхним по z-index.**

Таким образом, если курсор переходит на другой элемент (пусть даже дочерний), то он покидает предыдущий.

Обратите внимание на важную деталь.

Событие `mouseover`, происходящее на потомке, всплывает. Поэтому если на родительском элементе есть такой обработчик, то оно его вызовет.

![Mouseover bubble nested](../svg/mouseover-bubble-nested.svg)

Наглядно увидеть это можно в примере ниже: `<div id="child">` находится внутри `<div id="parent">`. На родителе определены обработчики событий `mouseover`/`out`, которые выводят информацию о них в текстовое поле.

При переходе мышью с внешнего элемента на внутренний, вы увидите сразу два события: `mouseout [target: parent]` (ушли с родителя) и `mouseover [target: child]` (перешли на потомка, событие всплыло).

[Тестовый стенд](../test/test_03/)

При переходе с родителя элемента на потомка на родителе сработают два обработчика: и `mouseout` и `mouseover`:
```js
parent.onmouseout = function(event) {
  /* event.target: внешний элемент */
};
parent.onmouseover = function(event) {
  /* event.target: внутренний элемент (всплыло) */
};
```

Если код внутри обработчиков не смотрит на `target`, то он подумает, что мышь ушла с элемента `parent` и вернулась на него обратно. Но это не так! Мышь никуда не уходила, она просто перешла на потомка.

Если при уходе с элемента что-то происходит, например, запускается анимация, то такая интерпретация происходящего может давать нежелательные побочные эффекты.

Чтобы этого избежать, можно смотреть на `relatedTarget` и, если мышь всё ещё внутри элемента, то игнорировать такие события.

Или же можно использовать другие события: `mouseenter` и `mouseleave`, которые мы сейчас изучим, с ними такая проблема не возникает.

#### События mouseenter и mouseleave
События `mouseenter`/`mouseleave` похожи на `mouseover`/`mouseout`. Они тоже генерируются, когда курсор мыши переходит на элемент или покидает его.

Но есть и пара важных отличий:

1. Переходы внутри элемента, на его потомки и с них, не считаются.
2. События `mouseenter`/`mouseleave` не всплывают.

События `mouseenter`/`mouseleave` предельно просты и понятны.

Когда указатель появляется над элементом – генерируется `mouseenter`, причём не имеет значения, где именно указатель: на самом элементе или на его потомке.

Событие `mouseleave` происходит, когда курсор покидает элемент.

Вот тот же пример, что и выше, но на этот раз на верхнем элементе стоят обработчики `mouseenter`/`mouseleave` вместо `mouseover`/`mouseout`.

Как можно увидеть, генерируются только события, связанные с движением курсора относительно верхнего `<div>`. Ничего не произойдёт при переходе на внутренний `<div>` и обратно. Переходы на потомки игнорируются.

[Тестовый стенд](../test/test_04/)

#### Делегирование событий
События `mouseenter`/`leave` просты и легки в использовании. Но они не всплывают. Таким образом, мы не можем их делегировать.

Представьте ситуацию, когда мы хотим обрабатывать события, сгенерированные при движении курсора по ячейкам таблицы. И в таблице сотни ячеек.

Очевидное решение – определить обработчик на родительском элементе `<table>` и там обрабатывать возникающие события. Но, так как `mouseenter`/`leave` не всплывают, то если событие происходит на ячейке `<td>`, то только обработчик на `<td>` может поймать его.

Обработчики событий `mouseenter`/`leave` на `<table>` срабатывают, если курсор оказывается над таблицей в целом или же уходит с неё. Невозможно получить какую-либо информацию о переходах между ячейками внутри таблицы.

Что ж, не проблема – будем использовать `mouseover`/`mouseout`.

Начнём с простых обработчиков, которые выделяют текущий элемент под указателем мыши:
```js
// выделим элемент под мышью
table.onmouseover = function(event) {
  let target = event.target;
  target.style.background = 'pink';
};

table.onmouseout = function(event) {
  let target = event.target;
  target.style.background = '';
};
```

Вот они в действии. При переходе между элементами этой таблицы, текущий будет подсвечен:

[Тестовый стенд](../test/test_05/)

![Bagua square](../img/bagua-square_1.png)

В нашем случае мы хотим обрабатывать переходы именно между ячейками `<td>`: вход на ячейку и выход с неё. Прочие переходы, в частности, внутри ячейки `<td>` или вообще вне любых ячеек, нас не интересуют, хорошо бы их отфильтровать.

Можно достичь этого так:

- Запоминать текущую ячейку `<td>` в переменную, которую назовём `currentElem`.
- На `mouseover` – игнорировать событие, если мы всё ещё внутри той же самой ячейки `<td>`.
- На `mouseout` – игнорировать событие, если это не уход с текущей ячейки `<td>`.

Вот пример кода, учитывающего все ситуации:
```js
// ячейка <td> под курсором в данный момент (если есть)
let currentElem = null;

table.onmouseover = function(event) {
  // перед тем, как войти на следующий элемент, курсор всегда покидает предыдущий
  // если currentElem есть, то мы ещё не ушли с предыдущего <td>,
  // это переход внутри - игнорируем такое событие
  if (currentElem) return;

  let target = event.target.closest('td');

  // переход не на <td> - игнорировать
  if (!target) return;

  // переход на <td>, но вне нашей таблицы (возможно при вложенных таблицах)
  // игнорировать
  if (!table.contains(target)) return;

  // ура, мы зашли на новый <td>
  currentElem = target;
  target.style.background = 'pink';
};


table.onmouseout = function(event) {
  // если мы вне <td>, то игнорируем уход мыши
  // это какой-то переход внутри таблицы, но вне <td>,
  // например с <tr> на другой <tr>
  if (!currentElem) return;

  // мы покидаем элемент – но куда? Возможно, на потомка?
  let relatedTarget = event.relatedTarget;

  while (relatedTarget) {
    // поднимаемся по дереву элементов и проверяем – внутри ли мы currentElem или нет
    // если да, то это переход внутри элемента – игнорируем
    if (relatedTarget == currentElem) return;

    relatedTarget = relatedTarget.parentNode;
  }

  // мы действительно покинули элемент
  currentElem.style.background = '';
  currentElem = null;
};
```

Полный пример со всеми деталями:

[Тестовый стенд](../test/test_06/)

Можно попробовать подвигать курсор между ячейками и внутри них. Быстро или медленно – без разницы. В отличие от предыдущего примера выделяется только сама ячейка `<td>`.

#### Итого
Мы рассмотрели события `mouseover`, `mouseout`, `mousemove`, `mouseenter` и `mouseleave`.

Особенности, на которые стоит обратить внимание:

- При быстром движении мыши события не будут возникать на промежуточных элементах.
- События `mouseover`/`out` и `mouseenter`/`leave` имеют дополнительное свойство: `relatedTarget`. Оно дополняет свойство `target` и содержит ссылку на элемент, с которого/на который мы переходим.

События `mouseover`/`out` возникают, даже когда происходит переход с родительского элемента на потомка. С точки зрения браузера, курсор мыши может быть только над одним элементом в любой момент времени – над самым глубоко вложенным.

События `mouseenter`/`leave` в этом отличаются. Они генерируются, когда курсор переходит на элемент в целом или уходит с него. Также они не всплывают.

#### Заключение
События мыши — это фундаментальные механизмы в веб-разработке, позволяющие отслеживать взаимодействие пользователя с элементами страницы через устройство ввода. Они обеспечивают отзывчивость интерфейсов, реагируя на клики, перемещения и другие действия.

События мыши включают `mousedown` и `mouseup` для фиксации нажатия и отпускания кнопок, `click` для одиночного клика, `dblclick` для двойного, а также `mousemove` для отслеживания движения указателя мыши.

Дополнительно используются `mouseover`/`mouseout` и `mouseenter`/`mouseleave` для обнаружения входа и выхода указателя над элементом, с учетом вложенности.

Свойства события, такие как `clientX`/`clientY`, `button` и флаги клавиш (`shiftKey`, `ctrlKey`), предоставляют координаты и контекст.

#### Задачи

##### Улучшенная подсказка

Напишите JavaScript код, который показывает подсказку над элементом с атрибутом `data-tooltip`. Значение атрибута должно становиться текстом подсказки.

Это похоже на задачу [Поведение "подсказка"](./11_events.md#поведение-подсказка), но здесь элементы с подсказками могут быть вложены друг в друга. Показываться должна подсказка на самом глубоко вложенном элементе.

Только одна подсказка может быть показана в любой момент времени.

Например:
```html
<div data-tooltip="Здесь - домашний интерьер" id="house">
  <div data-tooltip="Здесь - крыша" id="roof"></div>
  ...
  <a href="https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%B8_%D0%BF%D0%BE%D1%80%D0%BE%D1%81%D1%91%D0%BD%D0%BA%D0%B0" data-tooltip="Читать далее…">Наведи курсор на меня</a>
</div>
```

Результат в iframe:

![Improved tooltip](../img/improved-tooltip_1.png)

![Improved tooltip](../img/improved-tooltip_2.png)

<details>
<summary>Решение</summary>

![Код решения](../src/12_ui/improved-tooltip.html)

</details>

##### "Умная" подсказка

Напишите функцию, которая показывает подсказку над элементом только в случае, когда пользователь передвигает мышь *на него*, но не *через него*.

Другими словами, если пользователь подвинул курсор на элементе и остановился – показывать подсказку. А если он просто быстро провёл курсором по элементу, то не надо ничего показывать. Кому понравится лишнее мелькание?

Технически, мы можем измерять скорость прохода курсора мыши над элементом, и если она низкая, то можно посчитать, что пользователь остановил курсор над элементом, и показать ему подсказку. А если скорость высокая, то тогда не показывать.

Создайте для этого универсальный объект `new HoverIntent(options)`.

Его настройки `options`:

- `elem` – отслеживаемый элемент.
- `over` – функция, вызываемая, при заходе на элемент, считаем что заход – это когда курсор медленно двигается или остановился над элементом.
- `out` – функция, вызываемая при уходе курсора с элемента (если был заход).

Пример использования такого объекта для показа подсказки:
```js
// пример подсказки
let tooltip = document.createElement('div');
tooltip.className = "tooltip";
tooltip.innerHTML = "Tooltip";

// объект будет отслеживать движение мыши и вызывать функции over/out
new HoverIntent({
  elem,
  over() {
    tooltip.style.left = elem.getBoundingClientRect().left + 'px';
    tooltip.style.top = elem.getBoundingClientRect().bottom + 5 + 'px';
    document.body.append(tooltip);
  },
  out() {
    tooltip.remove();
  }
});
```

Если двигать курсор над «часами» быстро, то ничего не произойдёт, а если вы замедлите движение курсора над элементом или остановите его, то будет показана подсказка.

Обратите внимание: подсказка не должна пропадать (мигать), когда курсор переходит между дочерними элементами часов.

<details>
<summary>Решение</summary>

Алгоритм выглядит просто:

1. Назначаем обработчики `onmouseover`/`out` на элементе. Также можно было бы использовать `onmouseenter`/`leave`, но они менее универсальны и не сработают с делегированием.
2. Когда курсор переходит на элемент, начинаем измерять скорость его движения, используя `mousemove`.
3. Если скорость низкая, то вызываем `over`.
4. Когда мы выходим из элемента, если запускали `over`, вызываем `out`.

Но как измерить скорость?

Первая идея может быть такой: запускать нашу функцию каждые `100ms` и находить разницу между прежними и текущими координатами курсора. Если она мала, то значит и скорость низкая.

К сожалению, в JavaScript нет возможности получать текущие координаты мыши. Не существует функции типа `получитьТекущиеКоординатыМыши()`.

Единственный путь – это слушать события мыши, например `mousemove`, и координаты брать из объекта события.

Так что поставим обработчик на `mousemove`, чтобы отслеживать координаты и запоминать их. И будем сравнивать результаты каждые `100ms`.

P.S. Обратите внимание: тесты для решения этой задачи используют `dispatchEvent`, чтобы проверить, что подсказка работает корректно.

![Код решения](../src/12_ui/clever-tooltip)

</details>

### Перетаскивание элементов
Drag’n’Drop – отличный способ улучшить интерфейс. Захват элемента мышкой и его перенос визуально упростят что угодно: от копирования и перемещения документов (как в файловых менеджерах) до оформления заказа («положить в корзину»).

В современном стандарте HTML5 есть [раздел о Drag and Drop](https://html.spec.whatwg.org/multipage/interaction.html#dnd) – и там есть специальные события именно для Drag’n’Drop переноса, такие как `dragstart`, `dragend` и так далее.

Они интересны тем, что позволяют легко решать простые задачи. Например, можно перетащить файл в браузер, так что JS получит доступ к его содержимому.

Но у них есть и ограничения. Например, нельзя организовать перенос «только по горизонтали» или «только по вертикали». Также нельзя ограничить перенос внутри заданной зоны. Есть и другие интерфейсные задачи, которые такими встроенными событиями не реализуемы. Кроме того, мобильные устройства плохо их поддерживают.[^mouse-drag-and-drop]

Поэтому сначала рассмотрим вариант реализации Drag’n’Drop при помощи событий мыши.

#### Drag'n'Drop с событиями мыши

##### Алгоритм Drag’n’Drop
Базовый алгоритм Drag’n’Drop выглядит так:

1. При `mousedown` – готовим элемент к перемещению, если необходимо (например, создаём его копию).
2. Затем при `mousemove` передвигаем элемент на новые координаты путём смены `left`/`top` и `position:absolute`.
3. При `mouseup` – остановить перенос элемента и произвести все действия, связанные с окончанием Drag’n’Drop.

Это и есть основа Drag’n’Drop. Позже мы сможем расширить этот алгоритм, например, подсветив элементы при наведении на них мыши.

В следующем примере эти шаги реализованы для переноса мяча:
```js
ball.onmousedown = function(event) { // (1) отследить нажатие

  // (2) подготовить к перемещению:
  // разместить поверх остального содержимого и в абсолютных координатах
  ball.style.position = 'absolute';
  ball.style.zIndex = 1000;
  // переместим в body, чтобы мяч был точно не внутри position:relative
  document.body.append(ball);
  // и установим абсолютно спозиционированный мяч под курсор

  moveAt(event.pageX, event.pageY);

  // передвинуть мяч под координаты курсора
  // и сдвинуть на половину ширины/высоты для центрирования
  function moveAt(pageX, pageY) {
    ball.style.left = pageX - ball.offsetWidth / 2 + 'px';
    ball.style.top = pageY - ball.offsetHeight / 2 + 'px';
  }

  function onMouseMove(event) {
    moveAt(event.pageX, event.pageY);
  }

  // (3) перемещать по экрану
  document.addEventListener('mousemove', onMouseMove);

  // (4) положить мяч, удалить более ненужные обработчики событий
  ball.onmouseup = function() {
    document.removeEventListener('mousemove', onMouseMove);
    ball.onmouseup = null;
  };

};
```

Если запустить этот код, то мы заметим нечто странное. При начале переноса мяч «раздваивается» и переносится не сам мяч, а его «клон».

Это можно увидеть в действии:

![Drag ball](../img/ball-phantom.png)

Попробуйте перенести мяч мышкой и вы увидите описанное поведение.

Всё потому, что браузер имеет свой собственный Drag’n’Drop, который автоматически запускается и вступает в конфликт с нашим. Это происходит именно для картинок и некоторых других элементов.

Его нужно отключить:
```js
ball.ondragstart = function() {
  return false;
};
```

Теперь всё будет в порядке.

В действии:

![Drag ball](../img/drag-ball.png)

Ещё одна деталь – событие `mousemove` отслеживается на `document`, а не на `ball`. С первого взгляда кажется, что мышь всегда над мячом и обработчик `mousemove` можно повесить на сам мяч, а не на документ.

Но, как мы помним, событие `mousemove` возникает хоть и часто, но не для каждого пикселя. Поэтому из-за быстрого движения указатель может спрыгнуть с мяча и оказаться где-нибудь в середине документа (или даже за пределами окна).

Вот почему мы должны отслеживать `mousemove` на всём `document`, чтобы поймать его.

##### Правильное позиционирование
В примерах выше мяч позиционируется так, что его центр оказывается под указателем мыши:
```js
ball.style.left = pageX - ball.offsetWidth / 2 + 'px';
ball.style.top = pageY - ball.offsetHeight / 2 + 'px';
```

Неплохо, но есть побочные эффекты. Мы, для начала переноса, можем нажать мышью на любом месте мяча. Если мячик «взят» за самый край – то в начале переноса он резко «прыгает», центрируясь под указателем мыши.

Было бы лучше, если бы изначальный сдвиг курсора относительно элемента сохранялся.

Где захватили, за ту «часть элемента» и переносим:

![Ball shift](../svg/ball_shift.svg)

Обновим наш алгоритм:

1. Когда пользователь нажимает на мячик (`mousedown`), запомним расстояние от курсора до левого верхнего угла шара в переменных `shiftX`/`shiftY`. Далее будем удерживать это расстояние при перетаскивании.

    Чтобы получить этот сдвиг, мы можем вычесть координаты:
    ```js
    // onmousedown
    let shiftX = event.clientX - ball.getBoundingClientRect().left;
    let shiftY = event.clientY - ball.getBoundingClientRect().top;
    ```

2. Далее при переносе мяча мы позиционируем его с тем же сдвигом относительно указателя мыши, вот так:

    ```js
    // onmousemove
    // ball has position:absoute
    ball.style.left = event.pageX - shiftX + 'px';
    ball.style.top = event.pageY - shiftY + 'px';
    ```

Итоговый код с правильным позиционированием:
```js
ball.onmousedown = function(event) {

  let shiftX = event.clientX - ball.getBoundingClientRect().left;
  let shiftY = event.clientY - ball.getBoundingClientRect().top;

  ball.style.position = 'absolute';
  ball.style.zIndex = 1000;
  document.body.append(ball);

  moveAt(event.pageX, event.pageY);

  // переносит мяч на координаты (pageX, pageY),
  // дополнительно учитывая изначальный сдвиг относительно указателя мыши
  function moveAt(pageX, pageY) {
    ball.style.left = pageX - shiftX + 'px';
    ball.style.top = pageY - shiftY + 'px';
  }

  function onMouseMove(event) {
    moveAt(event.pageX, event.pageY);
  }

  // передвигаем мяч при событии mousemove
  document.addEventListener('mousemove', onMouseMove);

  // отпустить мяч, удалить ненужные обработчики
  ball.onmouseup = function() {
    document.removeEventListener('mousemove', onMouseMove);
    ball.onmouseup = null;
  };

};

ball.ondragstart = function() {
  return false;
};
```

В действии (внутри ифрейма):

![Drag ball](../img/drag-ball.png)

Различие особенно заметно, если захватить мяч за правый нижний угол. В предыдущем примере мячик «прыгнет» серединой под курсор, в этом – будет плавно переноситься с текущей позиции.

##### Цели переноса (droppable)
В предыдущих примерах мяч можно было бросить просто где угодно в пределах окна. В реальности мы обычно берём один элемент и перетаскиваем в другой. Например, «файл» в «папку» или что-то ещё.

Абстрактно говоря, мы берём перетаскиваемый (*draggable*) элемент и помещаем его в другой элемент — «цель переноса» (*droppable*).

Нам нужно знать:

- куда пользователь положил элемент в конце переноса, чтобы обработать его окончание
- и, желательно, над какой потенциальной целью (элемент, куда можно положить, например, изображение папки) он находится в процессе переноса, чтобы подсветить её.

Решение довольно интересное и немного хитрое, давайте рассмотрим его.

Какой может быть первая мысль? Возможно, установить обработчики событий `mouseover`/`mouseup` на элемент – потенциальную цель переноса?

Но это не работает.

Проблема в том, что при перемещении перетаскиваемый элемент всегда находится поверх других элементов. А события мыши срабатывают только на верхнем элементе, но не на нижнем.

Например, у нас есть два элемента `<div>`: красный поверх синего (полностью перекрывает). Не получится поймать событие на синем, потому что красный сверху:
```html
<style>
  div {
    width: 50px;
    height: 50px;
    position: absolute;
    top: 0;
  }
</style>
<div style="background:blue" onmouseover="alert('никогда не сработает')"></div>
<div style="background:red" onmouseover="alert('над красным!')"></div>
```

![Red square](../img/red-square.png)

То же самое с перетаскиваемым элементом. Мяч всегда находится поверх других элементов, поэтому события срабатывают на нём. Какие бы обработчики мы ни ставили на нижние элементы, они не будут выполнены.

Вот почему первоначальная идея поставить обработчики на потенциальные цели переноса нереализуема. Обработчики не сработают.

Так что же делать?

Существует метод `document.elementFromPoint(clientX, clientY)`. Он возвращает наиболее глубоко вложенный элемент по заданным координатам окна (или `null`, если указанные координаты находятся за пределами окна).

Мы можем использовать его, чтобы из любого обработчика событий мыши выяснить, над какой мы потенциальной целью переноса, вот так:
```js
// внутри обработчика события мыши
ball.hidden = true; // (*) прячем переносимый элемент

let elemBelow = document.elementFromPoint(event.clientX, event.clientY);
// elemBelow - элемент под мячом (возможная цель переноса)

ball.hidden = false;
```

Стоит отметить, что нам нужно спрятать мяч перед вызовом функции `(*)`. В противном случае по этим координатам мы будем получать мяч, ведь это и есть элемент непосредственно под указателем: `elemBelow=ball`. Так что мы прячем его и тут же показываем обратно.

Мы можем использовать этот код для проверки того, над каким элементом мы «летим», в любое время. И обработать окончание переноса, когда оно случится.

Расширенный код `onMouseMove` с поиском потенциальных целей переноса:
```js
// потенциальная цель переноса, над которой мы пролетаем прямо сейчас
let currentDroppable = null;

function onMouseMove(event) {
  moveAt(event.pageX, event.pageY);

  ball.hidden = true;
  let elemBelow = document.elementFromPoint(event.clientX, event.clientY);
  ball.hidden = false;

  // событие mousemove может произойти и когда указатель за пределами окна
  // (мяч перетащили за пределы экрана)

  // если clientX/clientY за пределами окна, elementFromPoint вернёт null
  if (!elemBelow) return;

  // потенциальные цели переноса помечены классом droppable (может быть и другая логика)
  let droppableBelow = elemBelow.closest('.droppable');

  if (currentDroppable != droppableBelow) {
    // мы либо залетаем на цель, либо улетаем из неё
    // внимание: оба значения могут быть null
    //   currentDroppable=null,
    //     если мы были не над droppable до этого события (например, над пустым пространством)
    //   droppableBelow=null,
    //     если мы не над droppable именно сейчас, во время этого события

    if (currentDroppable) {
      // логика обработки процесса "вылета" из droppable (удаляем подсветку)
      leaveDroppable(currentDroppable);
    }
    currentDroppable = droppableBelow;
    if (currentDroppable) {
      // логика обработки процесса, когда мы "влетаем" в элемент droppable
      enterDroppable(currentDroppable);
    }
  }
}
```

В приведённом ниже примере, когда мяч перетаскивается через футбольные ворота, ворота подсвечиваются.

![Ball goal](../img/ball-goal_1.png)
![Ball goal](../img/ball-goal_2.png)

[Исходный код](../samples/12_ui/ball-goal/index.html)

Теперь в течение всего процесса в переменной `currentDroppable` мы храним текущую потенциальную цель переноса, над которой мы сейчас, можем её подсветить или сделать что-то ещё.

##### Итого
Мы рассмотрели основной алгоритм Drag’n’Drop.

Ключевые идеи:

1. Поток событий: `ball.mousedown` → `document.mousemove` → `ball.mouseup` (не забудьте отменить браузерный `ondragstart`).
2. В начале перетаскивания: запоминаем начальное смещение указателя относительно элемента: `shiftX`/`shiftY` – и сохраняем его при перетаскивании.
3. Выявляем потенциальные цели переноса под указателем с помощью `document.elementFromPoint`.

На этой основе можно сделать многое.

- На `mouseup` – по-разному завершать перенос: изменять данные, перемещать элементы.
- Можно подсвечивать элементы, пока мышь «пролетает» над ними.
- Можно ограничить перетаскивание определённой областью или направлением.
- Можно использовать делегирование событий для `mousedown`/`up`. Один обработчик событий на большой зоне, который проверяет `event.target`, может управлять Drag’n’Drop для сотен элементов.
- И так далее.

Существуют фреймворки, которые строят архитектуру поверх этого алгоритма, создавая такие классы, как `DragZone`, `Droppable`, `Draggable`. Большинство из них делают вещи, аналогичные описанным выше. Вы можете и сами создать вашу собственную реализацию переноса, как видите, это достаточно просто, возможно, проще, чем адаптация чего-то готового.

#### Задачи

##### Слайдер

Создайте слайдер:

![Slider](../img/slider.png)

Захватите мышкой синий бегунок и двигайте его.

Важные детали:

- Слайдер должен нормально работать при резком движении мыши влево или вправо за пределы полосы. При этом бегунок должен останавливаться чётко в нужном конце полосы.
- При нажатом бегунке мышь может выходить за пределы полосы слайдера, но слайдер пусть всё равно работает (это удобно для пользователя).

<details>
<summary>Решение</summary>

Как можно видеть из HTML/CSS, слайдер – это `<div>`, подкрашенный фоном/градиентом, внутри которого находится другой `<div>`, оформленный как бегунок, с `position:relative`.

Используем для его координат `position:relative`, т.е. координаты ставятся не абсолютные, а относительно родителя, так как это удобнее.

И дальше реализуем Drag’n’Drop только по горизонтали, с ограничением по ширине.

[Код решения](../src/12_ui/slider/index.html)

</details>

##### Расставить супергероев по полю

В этой задаче вы можете проверить своё понимание сразу нескольких аспектов Drag’n’Drop и DOM.

Сделайте так, чтобы элементы с классом `draggable` можно было переносить мышкой. Как мяч в этой главе.

Требования к реализации:

- Используйте делегирование событий для отслеживания начала перетаскивания: только один обработчик событий mousedown на документе.
- Если элементы подносят к верхней/нижней границе окна – оно должно прокручиваться вверх/вниз, чтобы позволить дальнейшее перетаскивание.
- Горизонтальная прокрутка отсутствует (чуть-чуть упрощает задачу, её просто добавить).
- Элемент при переносе, даже при резких движениях мышкой, не должен даже частично попасть вне окна.

Демо доступно по [ссылке](https://learn.javascript.ru/task/drag-heroes/solution/).

<details>
<summary>Решение</summary>

Чтобы перетащить элемент, мы можем использовать `position:fixed`, это делает управление координатами проще. В конце следует переключиться обратно на `position:absolute`, чтобы положить элемент в документ.

Когда координаты находятся в верхней/нижней части окна, мы используем его `window.scrollTo` для прокрутки.

Детали решения расписаны в комментариях в исходном коде.

[Код решения](../src/12_ui/superheroes/index.html)

</details>

#### Drag-and-Drop API
**Drag-and-Drop API** позволяет переносить различные элементы мышью на определенную позицию на веб-странице. При перемещении элементов у нас есть <dfn title="источник перемещения">источник перемещения</dfn> — элемент, который перемещаем мышью, и <dfn title="цель перемещения">цель перемещения</dfn> — целевая область на веб-странице (другой элемент), на которую надо переместить источник перемещения.[^25.1]

##### Перетаскивание элементов с помощью Drag-and-Drop API

Чтобы определить элемент на веб-странице, который можно перемещать (источник перетаскивания), нужно для этого элемент определить атрибут **`draggable`** со значением **`true`**. Теоретически в качестве перетаскиваемого элемента может выступать любой элемент веб-страницы. Например:
```html
<div style="width:50px;height:50px; background-color: red;" draggable="true"></div>
```

По умолчанию элементы не являются перетаскиваемыми (кроме изображений, ссылок и выделенного текста).

В качестве цели перетаскивания может служить произвольный элемент веб-страницы.

После того, как элемент определен как перемещаемый, надо также определить действия, выполняемые при перемещении элемента. Во время операции перетаскивания запускается ряд различных событий:

- **`dragstart`**: генерируется, когда начинается перетаскивание элемента

- **`drag`**: генерируется постоянно по мере того, как элемент перетаскивается

- **`dragend`**: генерируется, когда перетаскивание элемента завершено

- **`dragenter`**: генерируется, когда элемент входит в границы целевой области

- **`dragover`**: генерируется постоянно (несколько раз в секунду) по мере того, как элемент перетаскивается над целевой областью

- **`dragleave`**: генерируется, когда элемент покидает целевую область

- **`drop`**: генерируется, когда перетаскиваемый элемент отпускается на целевой области

Обработчики всех выше перечисленных событий перемещения в качестве параметра получают объект типа **`DragEvent`**. Этот тип наследует свойства от `MouseEvent` и соответственно типа `Event`.

Обработчик события **`dragstart`** определяется для перетаскиваемого элемента, а обработчики остальных событий определяются для области, на которую надо переместить элемент. Например:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
    <style>
      #source { width:50px; height:50px; background-color: red; display: inline-block;}
      #target {width: 200px; height: 150px; overflow: hidden; border: #ccc 1px dashed;}
    div{margin:5px;}
    </style>
</head>
<body>
  <div id="source" draggable="true"></div>
  <div id="target"></div>
  <script>
    const source = document.getElementById("source");
    source.addEventListener("dragstart", () => console.log("Drag operation started"));

    const target = document.getElementById("target");
    target.addEventListener("dragover", (event) => {
        event.preventDefault();
        console.log("Dragover operation");
    });
    target.addEventListener("drop", () => console.log("Drag operation finished"));
  </script>
</body>
</html>
```

[Исходный код](../samples/12_ui/dnd/index1.html)

В данном случае перемещаемый элемент имеет идентификатор `source`, и для него регистрируется обработчик события "dragstart". Оно будет возникать, когда мы захватим элемент указателем мыши и начнем перемещать.

Область, на которую перемещаем элемент, представляет другой элемент с идентификатором `target`. Для демонстрации для него регистрируем обработчики событий "dragover" и "drop". Событие "dragover" будет возникать, когда элемент `item` будет перемещаться поверх элемента `target`. Чтобы предупредить генерацию события по умолчанию для "drop" во время перемещения, в обработчике этого события вызывается метод `event.preventDefault()`. Когда мы отпустим элемент `item` на элемент `target`, будет сгенерировано событие "drop".

![Drag&Drop API в JavaScript](../img/dragdrop3_cp.png)

!!! info "preventDefault() в обработчике `dragover` целевого элемента"

    `preventDefault()` в обработчике `dragover` необходим, чтобы разрешить сброс (`drop`) на целевой элемент, блокируя браузерное действие по умолчанию — запрет на сброс в большинство элементов.

    Механизм браузера по умолчанию
    1. Перетаскиваем элемент над `target`
    2. Браузер видит: "Это НЕ текстовая область/ссылка"
    3. `dragover` → по умолчанию `drop` запрещён → событие `drop` НЕ генерируется
    4. Отпускаем мышку → ничего не происходит

    Что блокирует `preventDefault()`
    ```js
    target.addEventListener("dragover", (e) => {
        e.preventDefault(); // Блокирует "запрет drop"
        // Теперь target ведёт себя как textarea
    });
    ```

    Таким образом, `preventDefault()` не создаёт `drop`, а разрешает браузеру его генерировать, переопределяя политику по умолчанию "запрещать `drop` везде кроме `input`/`textarea`".

Однако в выше приведенном примере в реальности перетаскиваемый элемент пока никуда не перемещается. Потому что нам надо установить перемещаемые данные и при завершении перемещения получить их. Например:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
    <style>
    #source { width:50px; height:50px; background-color: red; display: inline-block;}
    #target {width: 200px; height: 150px; overflow: hidden; border: #ccc 1px dashed;}
    div{margin:5px;}
    </style>
</head>
<body>
  <div id="source" draggable="true"></div>
  <div id="target"></div>
  <script>
    let dragged = null; // перемещенные данные
    // источник перемещения
    const source = document.getElementById("source")
    // в обработчике устанавливаем ссылку на перетаскиваемый элемент
    source.addEventListener("dragstart", (e) => dragged = e.target);

    // целевая область перемещения
    const target = document.getElementById("target");
    // предупреждаем запрет сброса по умолчанию
    target.addEventListener("dragover", (e) => e.preventDefault());
    // копируем перетаскиваемый элемент и помещаем его копию на целевую область
    target.addEventListener("drop", (e) => e.target.appendChild(dragged.cloneNode()));
  </script>
</body>
</html>
```

[Исходный код](../samples/12_ui/dnd/index2.html)

Здесь при начале перетаскивания мы сохраняем перемещаемый объект в переменную `dragged`
```js
source.addEventListener("dragstart", (e) => dragged = e.target);
```

При окончании перетаскивания помещаем копию элемента `source` на элемент `target`
```js
target.addEventListener("drop", (e) => e.target.appendChild(dragged.cloneNode()));
```

Таким образом, при перетаскивании на область `target` будут добавляться копии элемента `source`:

![Drag-and-Drop API в JavaScript](../img/dragdrop1-1.png)
![Drag-and-Drop API в JavaScript](../img/dragdrop1-2.png)

В качестве альтернативы мы можем выполнить полное перемещение перетаскиваемого элемента:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
    <style>
    #source { width:50px; height:50px; background-color: red; display: inline-block;}
    #target {width: 200px; height: 150px; overflow: hidden; border: #ccc 1px dashed;}
    div{margin:5px;}
    </style>
</head>
<body>
  <div id="target"></div>
  <div id="source" draggable="true"></div>
  <script>
    let dragged = null; // перемещенные данные
    // источник перемещения
    const source = document.getElementById("source")
    // в обработчике устанавливаем ссылку на перетаскиваемый элемент
    source.addEventListener("dragstart", (e) => dragged = e.target);

    // целевая область перемещения
    const target = document.getElementById("target");
    // предупреждаем событие drop
    target.addEventListener("dragover", (e) => e.preventDefault());
    // полностью перемещаем перетаскиваемый элемент на целевую область
    target.addEventListener("drop", (e) => {
        dragged.parentNode.removeChild(dragged);
        e.target.appendChild(dragged);
    });
  </script>
</body>
</html>
```

[Исходный код](../samples/12_ui/dnd/index3.html)

Здесь в обработчике "drop" сначала удаляем перетаскиваемый элемент из родительского контейнера (в данном случае элемента `body`), а затем добавляем его на целевую область:
```js
target.addEventListener("drop", (e) => {
    dragged.parentNode.removeChild(dragged);
    e.target.appendChild(dragged);
});
```

![Перемещение элементов с помощью Drag-and-Drop API в JavaScript](../img/dragdrop2-1.png)
![Перемещение элементов с помощью Drag-and-Drop API в JavaScript](../img/dragdrop2-2.png)

##### Установка и послучение перетаскиваемых данных с помощью DataTransfer
*[IE]: Internet Explorer
*[VB]: Visual Basic
*[OLE]: Object Linking & Embedding

При перетаскивании элементов в обработчик событий перетаскивания передается объект типа **`DragEvent`**. Этот тип наследует свойства от `MouseEvent` и соответственно типа `Event`, но в дополнение к ним также определяет свойство **`dataTransfer`**. Это свойство представляет перетаскиваемые данные в виде объекта **`DataTransfer`**.[^25.2]

Тип `DataTransfer` определяет ряд свойств, которые позволяют получить информацию о получаемых данных или настроить их перетаскивание:

- **`dropEffect`**: получает или устанавливает тип операции перетаскивания. Может принимать значения:

  - `copy`: создается **копия** перетаскиваемых данных, и эта копия помещается на новую позицию

  - `move`: данные полностью перемещаются на новую позицию

  - `link`: создается ссылка на источник данных

  - `none`: данные не перетаскиваются

- **`effectAllowed`**: устанавливает возможные типы операций. Может принимать следующие значения

  - `none`: элемент не перетаскивается

  - `copy`: элемент может копироваться на новую позицию

  - `copyLink`: допустимо копирование элемента или создание ссылки на него

  - `copyMove`: допустимо копирование или перемещение элемента

  - `link`: допустимо создание ссылки на перетаскиваемый элемент

  - `linkMove`: допустимо перемещение элемента или создание ссылки на него

  - `move`: допустимо перемещение элемента на новую позицию

  - `all`: все операции допустимы

  - `uninitialized`: значение по умолчанию, если это свойство не установлено. Эквивалентно `all`

- **`files`**: содержит список всех локальных файлов, доступных для передачи данных. Если операция перетаскивания не предполагает перетаскивание файлов, это свойство представляет собой пустой список.

- **`items`**: предоставляет объект `DataTransferItemList`, который представляет собой список всех данных перетаскивания.

- **`types`**: массив строк, задающих форматы, заданные в событии перетаскивания.

Свойства **`dropEffect`** и **`effectAllowed`** визуально управляют курсором и ограничивают операции. `dropEffect` и `effectAllowed` — это по сути "родитель" и "ребенок" в контроле Drag & Drop операций.

| Свойство      | Где устанавливается  | Роль                                        | Пример                                       |
| ------------- | -------------------- | ------------------------------------------- | -------------------------------------------- |
| **`effectAllowed`** | `dragstart` (источник)  | Разрешает операции для всего перетаскивания<br>✅ Курсор<br>✅ Визуальная обратная связь<br>❌ Логика перемещения | `copyMove` — можно копировать ИЛИ перемещать |
| **`dropEffect`**    | `dragover` (цель)      | Выбирает конкретную операцию + курсор<br>	✅ Ограничения операций<br>✅ Курсор<br>❌ Какой код выполнится      | `copy` — сделаю копию, покажу курсор        |

*Последовательность работы*:
```js
// 1. ИСТОЧНИК говорит: "Разрешаю copy/move"
source.addEventListener("dragstart", (e) => {
  e.dataTransfer.effectAllowed = 'copyMove';  // ОГРАНИЧЕНИЕ
});

// 2. ЦЕЛЬ говорит: "Из разрешённого выберу copy"
target.addEventListener("dragover", (e) => {
  e.preventDefault();
  e.dataTransfer.dropEffect = 'copy';        // КУРСОР + ВЫБОР
});
```

*Правила взаимодействия*:
```
effectAllowed = 'copyMove'
└── dropEffect может быть: 'copy' или 'move' ✅
    └── НЕ может быть: 'link' ❌ (запрещено источником)
```

Если конфликт:
- `effectAllowed: 'copy'`
- `dropEffect:    'move'`

**Результат**: `'none'` (запрещено) + курсор ❌

*Практический пример*:
```js
source.addEventListener("dragstart", (e) => {
  e.dataTransfer.effectAllowed = 'move';     // Только перемещение!
  e.dataTransfer.setData('text', source.id);
});

target.addEventListener("dragover", (e) => {
  e.preventDefault();
  // Попытка копирования запрещена источником
  e.dataTransfer.dropEffect = 'copy';        // Будет проигнорировано!
  console.log(e.dataTransfer.dropEffect);    // 'none'
});
```

Здесь уместна следующая аналогия: `effectAllowed` — меню ресторана, `dropEffect` — ваш заказ. Заказывают только из меню!

!!! warning "Миф об автоматическом перемещении"

    Свойства `dropEffect` и `effectAllowed` управляют только визуальными эффектами (курсор, индикация). DOM-перемещение при этом выполняется вручную.

    Подлинное автоматическое перемещение элементов было возможно при использовании     технологии OLE DragDrop из Windows 90-х, работавшее в браузере Internet Explorer 5 (IE5). OLE (Object Linking & Embedding) — технология Microsoft 1990-х для поддержки событий перетаскивания между Word, Excel, IE. Тогда достаточно было написать одну строку на языке Visual Basic 6 (VB6). HTML5 переписал под веб-стандарты, убрав автоматику ради универсальности.

[Исходный код](../samples/12_ui/dnd/index4.html)

Для управления данными при перетаскивании тип `DataTransfer` определяет следующие методы:

- **`clearData()`**: удаляет данные, связанные с объектом `DataTransfer`.

- **`getData(format)`**: извлекает данные объекта `DataTransfer`. В качестве параметра передается формат данных. Возвращаются данные указанного формата. Если данные указанного формата не установлены, возвращает пустую строку.

- **`setData(format, data)`**: устанавливает для объекта `DataTransfer` данные `data`, которые относятся к формату `format`. Если в `DataTransfer` уже есть данные указанного формата, то новые данные заменяют те, которые имелись ранее.

- **`setDragImage(imgElement, xOffset, yOffset)`**: устанавливает изображение, применяемое при перетаскивании. Первый параметр — `imgElement` представляет элемент `<img>`, используемый в качестве источника изображения. А параметры `xOffset`, `yOffset` задают соответственно смещения внутри изображения по оси x и y.

Последний метод полезен для установки собственного фантомного изображения. Фантом в данном случае — это визуальная копия перетаскиваемого элемента, которую браузер автоматически создаёт и показывает под курсором во время drag-сессии. Это полупрозрачная "тень" перетаскиваемого элемента, следующая за мышью/пальцем.

**Алгоритм работы**:
1. `dragstart` → Браузер клонирует элемент
2. Клон получает стили: `opacity` ~0.5-0.7, приоритетный `z-index`
3. Фантом следует за курсором с небольшим смещением (`offset`)
4. `dragend` → Фантом исчезает

Метод `setDragImage()` позволяет установить полный контроль над фантомом:
```js
function dragStart(e) {
  const dt = e.dataTransfer;

  // 1️⃣ Прозрачный фантом (скрыть)
  const invisible = document.createElement('canvas');
  invisible.width = invisible.height = 0.1;
  dt.setDragImage(invisible, 0, 0);

  // 2️⃣ Кастомная иконка
  const icon = document.createElement('img');
  icon.src = 'drag-icon.png';
  icon.style.width = '32px';
  document.body.appendChild(icon);
  dt.setDragImage(icon, 16, 16);

  // 3️⃣ Canvas-арт
  const canvas = document.createElement('canvas');
  canvas.width = canvas.height = 48;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = '#3b82f6';
  ctx.fillRect(8, 8, 32, 32);
  dt.setDragImage(canvas, 24, 24);
}
```

**Браузерные ограничения**:
- Вызывать `setDragImage` можно ТОЛЬКО в `dragstart`
- Элемент должен быть в DOM (в качестве альтернативы можно создать временный)
- IE11 не поддерживает (нужен полифилл)
- Firefox игнорирует размеры менее `1px`
- Стили фантома нельзя менять с помощью CSS

*Отладка фантома*:
```js
element.addEventListener('dragstart', (e) => {
  console.log('Фантом создан:', e.dataTransfer);
  // Проверяем поддержку
  if (e.dataTransfer.setDragImage) {
    console.log('✅ setDragImage доступен');
  }
});
```

Управление фантомом полезно, например, в задаче сортировки карточек, когда удобнее показывать масштабированные (слегка уменьшенные) клоны сортируемых элементов.

В свою очередь, методы `setData()`/`getData()` позволяют нам легко установить и получить нужные данные при перетаскивании элементов. Например:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
    <style>
    #target {width: 200px;height: 150px; border: #ccc 1px dashed;}
    #target.dragover {border-color:#000;}
    .item {width:50px;height:50px; display: inline-block; margin:5px;}
    </style>
</head>
<body>
<div class="item" style="background-color: red;" draggable="true"></div>
<div class="item" style="background-color: blue;" draggable="true"></div>
<div id="target"></div>
<script>
const items = document.getElementsByClassName("item");
// устанавливаем обработчик перетаскивания элемента
for (item of items) {
    item.addEventListener("dragstart", (e) => {
        // в качестве перетаскиваемых данных устанавливаем html-код элемента
        e.dataTransfer.setData("text/html", e.target.outerHTML);
    });
}
const target = document.getElementById("target");
target.addEventListener("dragover", (e) => e.preventDefault());
// при заходе и выходе из целевой области меняем класс
target.addEventListener("dragenter", (e) => e.target.classList.add("dragover"));
target.addEventListener("dragleave", (e) => e.target.classList.remove("dragover"));
// при отпускании элемента добавляем его на целевую область
target.addEventListener("drop", (e) => {
    e.srcElement.innerHTML += e.dataTransfer.getData("text/html");
    e.target.classList.remove("dragover");
});
</script>
</body>
</html>
```

Перетаскиваемые элементы здесь определены с классом `item` — это синий и красный квадраты. Перетаскивание осуществляется на элемент `<div id="target">`.

Сначала регистрируется обработчик события **`dragstart`** для всех перемещаемых элементов `item`. В этом обработчике через параметр и его свойство `dataTransfer` можно получить объект **`DataTransfer`**:
```js
const items = document.getElementsByClassName("item");
// устанавливаем обработчик перетаскивания элемента
for (item of items) {
    item.addEventListener("dragstart", (e) => {
        // в качестве перетаскиваемых данных устанавливаем html-код элемента
        e.dataTransfer.setData("text/html", e.target.outerHTML);
    });
}
```

Объект **`DataTransfer`** представляет данные, которые перетаскиваются. Эти данные можно определить с помощью метода **`setData()`**:
```js
e.dataTransfer.setData("text/html", event.target.outerHTML);
```

Здесь `e.target` представляет перемещаемый элемент (у которого установлен атрибут `draggable`). А `e.target.outerHTML` представляет html-код этого элемента. То есть таким образом мы будем перемещать html-код, а перемещаемое содержимое будет иметь тип "text/html"

На целевой области перетаскивания (в элементе `target`) эти данные затем можно получить с помощью метода `getData()`. В примере выше это делается в обработчике события **`drop`**, когда пользователь отпустил перетаскиваемый элемент на целевую область:
```js
target.addEventListener("drop", (e) => {
    e.srcElement.innerHTML += e.dataTransfer.getData("text/html");
    e.target.classList.remove("dragover");
});
```

В данном случае мы берем перетаскиваемые данные (html-код элемента) и добавляем их в элемент `target`.

Кроме того, для визуального эффекта, когда перетаскиваемый элемент пересекает границу целевой области, переключаем класс `loading`:
```js
target.addEventListener("dragenter", (e) => e.target.classList.add("dragover"));
target.addEventListener("dragleave", (e) => e.target.classList.remove("dragover"));
```

Таким образом, мы сможем перемещать элементы `item` на элемент `target`:

![Перетаскивание элементов веб-страницы с помощью Drag-and-Drop API в JavaScript](../img/dragdrop4_cp.png)

#### Заключение
Перетаскивание объектов является отличным способом улучшить пользовательский интерфейс. Оно интуитивно понятно и дает визуальную обратную связь через нативные курсоры и "призрак" элемента. Перетаскивание упрощает задачи вроде загрузки файлов, сортировки карточек и работает на мобильных устройствах с минимумом кода.

Перетаскивание реализуется двумя способами: нативным Drag'n'Drop API (`dragstart`, `dragover`, `drop`) или событиями мыши (`mousedown`, `mousemove`, `mouseup`). Drag'n'Drop API проще для стандартных задач — браузер рисует курсоры и "призрак" элемента, но ограничивает контроль (нельзя задать зоны/направления). События мыши дают полный контроль над анимацией и ограничениями, но требуют больше кода.

### События клавиатуры
Ещё одним распространенным типом событий являются события клавиатуры.[^9.6]

Прежде чем перейти к клавиатуре, обратите внимание, что на современных устройствах есть и другие способы «ввести что-то». Например, распознавание речи (это особенно актуально на мобильных устройствах) или Копировать/Вставить с помощью мыши.

Поэтому, если мы хотим корректно отслеживать ввод в поле `<input>`, то одних клавиатурных событий недостаточно. Существует специальное событие `input`, чтобы отслеживать любые изменения в поле `<input>`. И оно справляется с такой задачей намного лучше. Такого типа события будут рассмотрены позже в отдельном разделе, посвященном формам и элементам управления.

События клавиатуры же должны использоваться, если мы хотим обрабатывать взаимодействие пользователя именно с клавиатурой (в том числе виртуальной). К примеру, если нам нужно реагировать на стрелочные клавиши <kbd>↑&nbsp;Up</kbd> и <kbd>↓&thinsp;Down</kbd> или горячие клавиши (включая комбинации клавиш).[^keyboard-events]

Для того, чтобы лучше понять, как работают события клавиатуры, можно использовать тестовый стенд ниже.

Для исследования клавиатурных событий сфокусируйтесь на нужном поле (с надписью "Клавишу нажимать тут") и нажмите какую-нибудь клавишу.

[Тестовый стенд](../test/keyboard-evt/index.html)

#### События keydown, keyup, keypress
Основные клавиатурные события:

- `keydown`: возникает при нажатии клавиши клавиатуры и длится, пока нажата клавиша;

- `keyup`: возникает при отпускании клавиши клавиатуры;

- `keypress`: возникает при нажатии клавиши клавиатуры, но после события `keydown` и до события `keyup`. Надо учитывать, что данное событие генерируется только для тех клавиш, которые формируют вывод в виде символов, например, при печати символов. Нажатия на остальные клавиши, например, на <kbd>Alt</kbd>, не учитываются.

Порядок срабатывания при однократном нажатии клавиши:

`keydown` → `keypress` → `keydown`

Порядок срабатывания при удержании клавиши:

`keydown` (1-й раз) → `keypress` (1-й раз) → `keydown` (повтор) → `keypress` (повтор) → ... → `keyup`

#### Объект клавиатурного события
Для работы с событиями клавиатуры определен объект **`KeyboardEvent`**, который добавляет к свойствам объекта `Event` ряд специфичных для клавиатуры свойств:

- **`altKey`**: возвращает `true`, если была нажата клавиша <kbd>Alt</kbd> во время генерации события.

- **`key`**: возвращает символ нажатой клавиши, например, при нажатии на клавишу <kbd>T</kbd> это свойство будет содержать `"T"`. А если нажата клавиша <kbd>Я</kbd>, то это свойство будет содержать `"Я"`.

- **`code`**: возвращает строковое представление нажатой клавиши физической клавиатуры QWERTY, например, при нажатии на клавишу <kbd>T</kbd> это свойство будет содержать `"KeyT"`, а при нажатии на клавишу <kbd>;</kbd> (точка запятой), то свойство возвратит `"Semicolon"`.

  При использовании этого свойства следует учитывать ряд моментов. Прежде всего используется клавиатура QWERTY. То есть мы переключим раскладку, к примеру, на русскоязычную и нажмем на клавишу <kbd>Я</kbd>, то значением будет `"KeyZ"` — на клавиатуре QWERTY клавиша <kbd>Z</kbd> представляет ту же клавишу, что и на русскоязычной раскладке <kbd>Я</kbd>.

  Другой момент — учитывается именно физическая клавитура. Если нажата клавиша на виртуальной клавиатуре, то возвращаемое значение будет устанавливаться браузером исходя из того, какой клавише на физической клавиатуре соответствовало нажатие.

- **`ctrlKey`**: возвращает `true`, если во время генерации события была нажата клавиша <kbd>Ctrl</kbd>.

- **`metaKey`**: возвращает `true`, если во время генерации события была нажата  метаклавиша клавиатуры. <dfn title="метаклавиша">Метаклавиша</dfn> (*metakey*) — это клавиша-модификатор, которая не печатает символ сама по себе, а служит для модифицирования поведения других клавиш во время ввода или горячих клавиш. К числу таких клавиш относят <kbd>Alt</kbd>, <kbd>Ctrl</kbd>, <kbd>⇧ Shift</kbd>.

- **`shiftKey`**: возвращает `true`, если во время генерации события была нажата клавиша <kbd>⇧ Shift</kbd>.

#### Свойства event.code и event.key
Свойство `key` объекта события позволяет получить символ, а свойство `code` – «физический код клавиши».

К примеру, одну и ту же клавишу <kbd>Z</kbd> можно нажать с клавишей <kbd>⇧ Shift</kbd> и без неё. В результате получится два разных символа: `z` в нижнем регистре и `Z` в верхнем регистре.

Свойство `event.key` – это непосредственно символ, и он может различаться. Но `event.code` всегда будет тот же:

| Клавиша | `event.key`           | `event.code` |
| ------- | ------------------- | ---------- |
| <kbd>Z</kbd>       | `z` (нижний регистр)  | `KeyZ`       |
| <kbd>⇧ Shift</kbd> + <kbd>Z</kbd> | `Z` (верхний регистр) | `KeyZ`       |

Если пользователь работает с разными языками, то при переключении на другой язык символ изменится с "Z" на совершенно другой. Получившееся станет новым значением `event.key`, тогда как `event.code` останется тем же: "KeyZ".

!!! info "«KeyZ» и другие клавишные коды"
    У каждой клавиши есть код, который зависит от её расположения на клавиатуре. Подробно о клавишных кодах можно прочитать в [спецификации о кодах событий UI](https://www.w3.org/TR/uievents-code/).

    Например:

    - Буквенные клавиши имеют коды по типу "Key<буква>": "KeyA", "KeyB" и т.д.
    - Коды числовых клавиш строятся по принципу: "Digit<число>": "Digit0", "Digit1" и т.д.
    - Код специальных клавиш – это их имя: "Enter", "Backspace", "Tab" и т.д.

    Существует несколько широко распространённых раскладок клавиатуры, и в спецификации приведены клавишные коды к каждой из них.

    Можно их прочитать в [разделе спецификации, посвящённом буквенно-цифровым клавишам](https://www.w3.org/TR/uievents-code/#key-alphanumeric-section) или просто нажмите нужную клавишу на [тестовом стенде](../test/keyboard-evt/index.html) и посмотрите.

!!! warning "Регистр важен: "KeyZ", а не "keyZ""
    Выглядит очевидно, но многие всё равно ошибаются.

    Пожалуйста, избегайте опечаток: правильно `KeyZ`, а не `keyZ`. Условие `event.code=="keyZ"` работать не будет: первая буква в слове "Key" должна быть заглавная.

А что, если клавиша не буквенно-цифровая? Например, <kbd>⇧ Shift</kbd> или <kbd>F1</kbd>, или какая-либо другая специальная клавиша? В таких случаях значение свойства `event.key` примерно тоже, что и у `event.code`:

| Клавиша   | `event.key` | `event.code`               |
| --------- | --------- | ------------------------ |
| <kbd>F1</kbd>        | `F1`        | `F1`                       |
| <kbd>⌫ Backspace</kbd> | `Backspace` | `Backspace`                |
| <kbd>⇧ Shift</kbd>     | `Shift`     | `ShiftRight` или `ShiftLeft` |

Обратите внимание, что `event.code` точно указывает, какая именно клавиша нажата. Так, большинство клавиатур имеют по две клавиши `Shift`: слева и справа. `event.code` уточняет, какая именно из них была нажата, в то время как `event.key` сообщает о «смысле» клавиши: что вообще было нажато (`Shift`).

Допустим, мы хотим обработать горячую клавишу <kbd>Ctrl</kbd> + <kbd>Z</kbd> (или <kbd>Cmd</kbd> + <kbd>Z</kbd> для Mac). Большинство текстовых редакторов к этой комбинации подключают действие «Отменить». Мы можем поставить обработчик событий на `keydown` и проверять, какая клавиша была нажата.

Здесь возникает дилемма: в нашем обработчике стоит проверять значение `event.key` или `event.code`?

С одной стороны, значение `event.key` – это символ, он изменяется в зависимости от языка, и если у пользователя установлено в ОС несколько языков, и он переключается между ними, нажатие на одну и ту же клавишу будет давать разные символы. Так что имеет смысл проверять `event.code`, ведь его значение всегда одно и тоже.

Вот пример кода:
```js
document.addEventListener('keydown', function(event) {
  if (event.code == 'KeyZ' && (event.ctrlKey || event.metaKey)) {
    alert('Отменить!')
  }
});
```

С другой стороны, с `event.code` тоже есть проблемы. На разных раскладках к одной и той же клавише могут быть привязаны разные символы.

Например, вот схема стандартной (US) раскладки («QWERTY») и под ней немецкой («QWERTZ») раскладки (из Википедии):

![US layout](../svg/us-layout.svg)

![German layout](../svg/german-layout.svg)

Для одной и той же клавиши в американской раскладке значение `event.code` равно «Z», в то время как в немецкой «Y».

Буквально, для пользователей с немецкой раскладкой `event.code` при нажатии на <kbd>Y</kbd> будет равен `KeyZ`.

Если мы будем проверять в нашем коде `event.code == 'KeyZ'`, то для людей с немецкой раскладкой такая проверка сработает, когда они нажимают `Y`.

Звучит очень странно, но это и в самом деле так. В [спецификации](https://www.w3.org/TR/uievents-code/#table-key-code-alphanumeric-writing-system) прямо упоминается такое поведение.

Так что `event.code` может содержать неправильный символ при неожиданной раскладке. Одни и те же буквы на разных раскладках могут сопоставляться с разными физическими клавишами, что приводит к разным кодам. К счастью, это происходит не со всеми кодами, а с несколькими, например `KeyA`, `KeyQ`, `KeyZ` (как мы уже видели), и не происходит со специальными клавишами, такими как <kbd>⇧ Shift</kbd>. Вы можете найти полный список проблемных кодов в [спецификации](https://www.w3.org/TR/uievents-code/#table-key-code-alphanumeric-writing-system).

Чтобы отслеживать символы, зависящие от раскладки, `event.key` надёжнее.

С другой стороны, преимущество `event.code` заключается в том, что его значение всегда остаётся неизменным, будучи привязанным к физическому местоположению клавиши, даже если пользователь меняет язык. Так что горячие клавиши, использующие это свойство, будут работать даже в случае переключения языка.

Хотим поддерживать клавиши, меняющиеся при раскладке? Тогда `event.key` – верный выбор.

Или мы хотим, чтобы горячая клавиша срабатывала даже после переключения на другой язык? Тогда `event.code` может быть лучше.

#### Автоповтор
При долгом нажатии клавиши возникает автоповтор: `keydown` срабатывает снова и снова, и когда клавишу отпускают, то отрабатывает `keyup`. Так что ситуация, когда много `keydown` и один `keyup`, абсолютно нормальна.

Для событий, вызванных автоповтором, у объекта события свойство `event.repeat` равно `true`.

При долгом нажатии клавиши возникает автоповтор с двумя фазами:
```
⌨️ Долгое нажатие клавиши 'A'
            ↓
┌───────────────────────┐
│ keydown (repeat=false)│  ← Задержка ~500мс
└───────────────────────┘
            ↓
┌───────────────────────┐
│ keydown (repeat=true) │  ← Повтор каждые ~30-50мс
│ keydown (repeat=true) │  ← Многократно!
│ keydown (repeat=true) │
│    ... много раз      │
└───────────────────────┘
            ↓
┌───────────────────────┐
│         keyup         │  ← Только ОДИН раз!
└───────────────────────┘
```

Правильная обработка движения:
```js
let isMoving = false;

document.addEventListener('keydown', (e) => {
  if (e.repeat) return;   // Игнорируем повторы

  if (e.key === 'ArrowRight') {
    isMoving = true;
    moveRight();          // Начало движения
  }
});

document.addEventListener('keyup', (e) => {
  if (e.key === 'ArrowRight') {
    isMoving = false;     // Остановка
  }
});
```

Неправильная обработка (без repeat):
```js
// Плохо: счётчик будет расти без остановки!
document.addEventListener('keydown', (e) => {
  if (e.key === 'ArrowRight') {
    counter++; // +1 каждые 30мс!
  }
});
```

Параметры автоповтора (зависят от ОС):
- Задержка до повтора: 400-1000мс

- Скорость повтора: 30-100мс между событиями

- Настраивается в настройках ОС (Windows: Панель управления → Клавиатура)

Советы по использованию:
- `event.repeat === true` — игнорируйте для одиночных действий

- `event.repeat === false` — обрабатывайте как первое нажатие

- Всегда проверяйте `keyup` для завершения действий

- Для игр используйте `requestAnimationFrame()` вместо автоповтора

#### Действия по умолчанию
Действия по умолчанию весьма разнообразны, много чего можно инициировать нажатием на клавиатуре.

Для примера:

- появление символа (самое очевидное);
- удаление символа (клавиша <kbd>Delete</kbd>);
- прокрутка страницы (клавиша <kbd>PageDown</kbd>);
- открытие диалогового окна браузера «Сохранить» (<kbd>Ctrl</kbd> + <kbd>S</kbd>);
- …и так далее.

Предотвращение стандартного действия с помощью `event.preventDefault()` работает практически во всех сценариях, кроме тех, которые происходят на уровне операционной системы. Например, комбинация <kbd>Alt</kbd> + <kbd>F4</kbd> инициирует закрытие браузера в Windows, что бы мы ни делали в JavaScript.

Для примера, `<input>` ниже ожидает телефонный номер, так что ничего кроме чисел, `+`, `()` или `-` принято не будет:
```html
<script>
function checkPhoneKey(key) {
  return (key >= '0' && key <= '9') || key == '+' || key == '(' || key == ')' || key == '-';
}
</script>
<input onkeydown="return checkPhoneKey(event.key)" placeholder="Введите телефон" type="tel">
```

![Enter phone number](../img/enter-phone-number.png)

Заметьте, что специальные клавиши, такие как <kbd>⌫ Backspace</kbd>, <kbd>← Left</kbd>, <kbd>→ Right</kbd>, <kbd>Ctrl</kbd> + <kbd>V</kbd>, в этом поле для ввода не работают. Это побочный эффект чересчур жёсткого фильтра `checkPhoneKey`.

Добавим ему немного больше свободы:
```html
<script>
function checkPhoneKey(key) {
  return (key >= '0' && key <= '9') || key == '+' || key == '(' || key == ')' || key == '-' ||
    key == 'ArrowLeft' || key == 'ArrowRight' || key == 'Delete' || key == 'Backspace';
}
</script>
<input onkeydown="return checkPhoneKey(event.key)" placeholder="Введите телефон" type="tel">
```

![Enter phone number](../img/enter-phone-number.png)

Теперь стрелочки и удаление прекрасно работают.

…Впрочем, мы всё равно можем ввести в `<input>` что угодно с помощью правого клика мыши и пункта «Вставить» контекстного меню. Так что такой фильтр не обладает 100% надёжностью. Мы можем просто оставить всё как есть, потому что в большинстве случаев это работает. Альтернатива – отслеживать событие `input`, оно генерируется после любых изменений в поле `<input>`, и мы можем проверять новое значение и подчёркивать/изменять его, если оно не подходит.

#### «Дела минувших дней»
В прошлом существовало также событие `keypress`, а также свойства `keyCode`, `charCode`, `which` у объекта события.

Но количество браузерных несовместимостей при работе с ними было столь велико, что у разработчиков спецификации не было другого выхода, кроме как объявить их устаревшими и создать новые, современные события (которые и описываются выше). Старый код ещё работает, так как браузеры продолжают поддерживать и `keypress`, и `keyCode` с `charCode`, и `which`, но более нет никакой необходимости в их использовании.

*Устаревшие события*

| Событие  | Проблемы                            | Статус          |
| -------- | ----------------------------------- | --------------- |
| `keypress` | Только символы, разная работа в IE  | Deprecated      |
| `keyCode`  | Разные коды в разных браузерах      | Не использовать |
| `charCode` | Только для `keypress`, нестабильно    | Не использовать |
| `which`    | Псевдо-стандарт jQuery, разные коды | Не использовать |

❌  *Старый код (проблемный)*
```js
document.addEventListener('keypress', function(e) {
  var code = e.keyCode || e.charCode || e.which;
  if (code === 13) { // Enter?
    console.log('Enter!');
  }
});
```

Проблемы: Не работает одинаково в Firefox/Chrome/IE, пропускает Shift/Ctrl.

✅ *Новый код (стандартный)*:
```js
document.addEventListener('keydown', function(e) {
  if (e.key === 'Enter') {
    console.log('Enter!');
  }
});
```

Преимущества: Работает везде, читаемо, поддерживает все клавиши.

#### Обработка клавиатурных событий
Например, мы можем с помощью клавиш клавиатуры перемещать элемент на веб-странице:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
    <style>
    #blueRect{
        width:100px;
        height:100px;
        background-color:blue;
    }
    </style>
</head>
<body>
<div id="blueRect"></div>

<script>
const blueRect = document.getElementById("blueRect");
// получаем стиль для blueRect
const blueRectStyle = window.getComputedStyle(blueRect);
// устанавливаем обработчик нажатия клавиши
window.addEventListener("keydown", moveRect);

function moveRect(e){
    const left = parseInt(blueRectStyle.marginLeft); //смещение от левого края
    const top = parseInt(blueRectStyle.marginTop);  // смещения от левой границы

    switch(e.key){

        case "ArrowLeft":  // если нажата клавиша влево
            if(left>0)
                blueRect.style.marginLeft = left - 10 + "px";
            break;
        case "ArrowUp":   // если нажата клавиша вверх
            if(top>0)
                blueRect.style.marginTop = top - 10 + "px";
            break;
        case "ArrowRight":   // если нажата клавиша вправо
            if(left < document.documentElement.clientWidth - 100)
                blueRect.style.marginLeft = left + 10 + "px";
            break;
        case "ArrowDown":   // если нажата клавиша вниз
            if(top < document.documentElement.clientHeight - 100)
                blueRect.style.marginTop = top + 10 + "px";
            break;
    }
}
</script>
</body>
</html>
```

В данном случае обрабатывается событие `keydown`, в обработчке которого управляем стилевыми свойствами элемента `blueRect`. Так как при прикреплении обработчика стиль элемента может быть не установлен, то явным образом вычисляем его с помощью метода `window.getComputedStyle()`:
```js
const blueRectStyle = window.getComputedStyle(blueRect);
```
В обработчике события из этого стиля выбираем значения свойств `marginLeft` и `marginTop`.

```js
const left = parseInt(blueRectStyle.marginLeft); //смещение от левого края
const top = parseInt(blueRectStyle.marginTop);  // смещения от левой границы
```

Затем м помощью свойства `e.key` получаем нажатую клавишу. Список кодов клавиш клавиатуры можно посмотреть на странице https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values.

Здесь нам интересуют четыре клавиши: вверх, вниз, влево, вправо. Им соответственно будут соответствовать названия "ArrowUp", "ArrowDown", "ArrowLeft" и "ArrowRight". Если одна из них нажата, производим действия: увеличение или уменьшение отступа элемента от верхней или левой границы. Ну и чтобы элемент не выходил за границы окна, проверяем предельные значения с помощью `document.documentElement.clientWidth` (ширина корневого элемента) и `document.documentElement.clientHeight` (высота корневого элемента).

Стоит отметить, что этот код не очень оптимален, поскольку для проверки значений нам приходится вычислять положение `blueRect` по горизонтали и вертикали. Плюс необходимо вычислять при каждом вызове обработчика проверяем правый (`document.documentElement.clientWidth - 100`) и нижний край (`document.documentElement.clientHeight - 100;`) области документа, чтобы `blueRect` не вышел за предел видимого пространства. В этом случае мы можем добавить дополнительные абстракции в виде текущих координат `blueRect` и положения правой и нижней границ видимой области. Так, изменим код JavaScript следующим образом:
```js
const blueRect = document.getElementById("blueRect");
const position = [20, 20];  // позиция blueRect

// перемещаем blueRect на позицию в position
function setPosition() {
    blueRect.style.marginLeft = position[0] + "px";
    blueRect.style.marginTop = position[1] + "px";
}

function init(){
    const rightLimit = document.documentElement.clientWidth - 100;  // правый край
    const bottomLimit = document.documentElement.clientHeight - 100;    // нижний край

    setPosition();  // устанавливаем начальную позицию для blueRect

    function moveRect(e){
        switch(e.key){

        case "ArrowLeft":  // если нажата клавиша влево
            if(position[0] > 0)
                position[0] = position[0] - 10;
            break;
        case "ArrowUp":   // если нажата клавиша вверх
            if(position[1] > 0)
                position[1] = position[1] - 10;
            break;
        case "ArrowRight":   // если нажата клавиша вправо
            if(position[0] < rightLimit)
                position[0] = position[0] + 10;
            break;
        case "ArrowDown":   // если нажата клавиша вниз
            if(position[1] < bottomLimit)
                position[1] = position[1] + 10;
            break;
        }
        setPosition();
    }
    window.addEventListener("keydown", moveRect);
}
//  при загрузке страницы выполняем функцию init
window.addEventListener("load", init);
```

Теперь координаты `blueRect` хранятся в массиве `position`, где первое значение — это отступ слева, а второе значение — отступ сверху. Чтобы по этим координатам установить реальную позицию `blueRect` на странице определена функция `setPosition`.

```js
const position = [20, 20];  // позиция blueRect

// перемещаем blueRect на позицию в position
function setPosition() {
    blueRect.style.marginLeft = position[0] + "px";
    blueRect.style.marginTop = position[1] + "px";
}
```

Прикрепляем к событию загрузки окна — **`load`** обработчик — функцию `init`:
```js
window.addEventListener("load", init);
```

В функции `init` определяем правый и нижний край для перемещения `blueRect`, а также устанавливаем его начальную позицию:
```js
const rightLimit = document.documentElement.clientWidth - 100;  // правый край
const bottomLimit = document.documentElement.clientHeight - 100;    // нижний край
setPosition();  // устанавливаем начальную позицию для blueRect
```

Далее определяем обработчик `moveRect`, в котором изменяем значения в массиве `position`:
```js
function moveRect(e){
    switch(e.key){

    case "ArrowLeft":  // если нажата клавиша влево
        if(position[0] > 0)
            position[0] = position[0] - 10;
        break;
    //............
    }
    setPosition();
}
```

И после всех изменений переустанавливаем позицию с помощью функции `setPosition`.

В конце прикрепляем обработчик к нажатию клавиши клавиатуры:
```js
window.addEventListener("keydown", moveRect);
```

#### Используйте события по назначению

В прошлом события клавиатуры иногда использовались для отслеживания ввода данных пользователем в полях формы. Это ненадёжно, потому как ввод данных не обязательно может осуществляться с помощью клавиатуры.

❌ *Неправильно: клавиатура для отслеживания ввода*
```js
// НЕ ДЕЛАЙТЕ ТАК!
input.addEventListener('keydown', (e) => {
  if (e.key.length === 1) {
    value += e.key; // Пропустит Ctrl+V!
  }
});
```

Существуют события `input` и `change` специально для обработки ввода. Они срабатывают в результате любого ввода, включая Копировать/Вставить мышью и распознавание речи.

✅ *Правильно: input для любых изменений*
```js
input.addEventListener('input', (e) => {
  value = e.target.value; // Ловит всё: печать, вставка, речь
});
```

Сравнение событий ввода

| Событие | Когда срабатывает                           | Повторяется? | Подходит для          |
| ------- | ------------------------------------------- | ------------ | --------------------- |
| `input`   | Любой ввод: печать, вставка, удаление, речь | ✅ Да         | Отслеживание значения |
| `change`  | Потеря фокуса И изменение значения          | ❌ Нет        | Валидация формы       |
| `keydown` | Только нажатие клавиши                      | ✅ Повтор     | Горячие клавиши       |

События клавиатуры же должны использоваться только по назначению – для клавиатуры. Например, чтобы реагировать на горячие или специальные клавиши.[^keyboard-events]

**Практические сценарии**

1. Автодополнение/поиск (реальное время)

    ```js
    input.addEventListener('input', debounce((e) => {
      search(e.target.value); // Срабатывает при Ctrl+V!
    }, 300));
    ```

2. Валидация формы (при потере фокуса)

    ```js
    input.addEventListener('change', (e) => {
      validate(e.target); // Только при blur + изменение
    });
    ```

3. Горячие клавиши (только клавиатура)

    ```js
    document.addEventListener('keydown', (e) => {
      if (e.ctrlKey && e.key === 's') {
        e.preventDefault();
        saveDocument();
      }
    });
    ```

*Когда какое событие использовать*

| Задача              | Событие | Почему            |
| ------------------- | ------- | ----------------- |
| Отслеживание текста | `input`   | Ловит всё         |
| Валидация при потере фокуса  | `change`  | Стандарт форм     |
| <kbd>Ctrl</kbd>+<kbd>S</kbd>, <kbd>F1</kbd>, <kbd>Escape</kbd>  | `keydown` | Только клавиатура |
| Игра (WASD/стрелки) | `keydown` | Повторы, коды     |
| Подсчёт символов    | `input`   | Реальное значение |

Пример ниже демонстрирует продвинутый комбинированный подход к обработке событий:
```js
const input = document.querySelector('input');

// 1. Отслеживаем значение (всё)
input.addEventListener('input', (e) => {
  updateCounter(e.target.value.length);
});

// 2. Только Enter для отправки
input.addEventListener('keydown', (e) => {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault();
    sendMessage();
  }
});

// 3. Валидация при blur
input.addEventListener('change', validate);
```


Исключения: когда клавиатура всё же нужна для ввода

1. **Маски ввода** (телефон, дата) → Нужен контроль каждой клавиши

2. **Игровой ввод** (WASD в реальном времени)

3. **Предотвращение вставки** (только цифры)

   ```javascript
   input.addEventListener('keydown', (e) => {
     if (!/[0-9]/.test(e.key) && e.key.length === 1) {
       e.preventDefault();
     }
   });
   ```

Правило: 95% случаев — `input`. Клавиатура — только для специальных клавиш.

#### Итого
Нажатие клавиши всегда генерирует клавиатурное событие, будь то буквенно-цифровая клавиша или специальная типа <kbd>⇧ Shift</kbd> или <kbd>Ctrl</kbd> и т.д. Единственным исключением является клавиша <kbd>Fn</kbd>, которая присутствует на клавиатуре некоторых ноутбуков. События на клавиатуре для неё нет, потому что она обычно работает на уровне более низком, чем даже ОС.

События клавиатуры:

- `keydown` – при нажатии на клавишу (если клавиша остаётся нажатой, происходит автоповтор),
- `keyup` – при отпускании клавиши.

Главные свойства для работы с клавиатурными событиями:

- `code` – «код клавиши» ("KeyA", "ArrowLeft" и так далее), особый код, привязанный к физическому расположению клавиши на клавиатуре;
- `key` – символ ("A", "a" и так далее), для не буквенно-цифровых групп клавиш (таких как `Esc`) обычно имеет то же значение, что и `code`.

Клавиатурные события в современном JavaScript сводятся к использованию `keydown`/`keyup` со свойствами `event.key` (название клавиши), `event.code` (физическое положение), `event.repeat` (автоповтор после ~500мс) и модификаторами (`ctrlKey`, `shiftKey`). Очередность: `keydown` → `keyup`, автоповтор только в `keydown` с `repeat=true`. Забудьте устаревшие `keypress`/`keyCode`/`charCode`. Используйте только для горячих клавиш и игр, для отслеживания текста — `input`/`change` (ловят <kbd>Ctrl</kbd>+<kbd>V</kbd>, речь, drag&drop). Всегда проверяйте `e.preventDefault()` для браузерных сочетаний и `!e.repeat` для одиночных действий.

#### Задачи

##### Отследить одновременное нажатие

Создайте функцию `runOnKeys(func, code1, code2, ... code_n)`, которая запускает `func` при одновременном нажатии клавиш с кодами `code1`, `code2`, …, `code_n`.

Например, код ниже выведет `alert` при одновременном нажатии клавиш "Q" и "W" (в любом регистре, в любой раскладке)
```js
runOnKeys(
  () => alert("Привет!"),
  "KeyQ",
  "KeyW"
);
```

<details>
<summary>Решение</summary>

Необходимо использовать два обработчика событий: `document.onkeydown` и `document.onkeyup`.

Создадим множество `pressed = new Set()`, в которое будем записывать клавиши, нажатые в данный момент.

В первом обработчике будем добавлять в него значения, а во втором удалять. Каждый раз, как отрабатывает `keydown`, будем проверять – все ли нужные клавиши нажаты, и, если да – выводить сообщение.

[Код решения](../src/12_ui/keypress.html)

</details>

### События указателя
<dfn title="события указателя">События указателя</dfn> (*pointer events*) – это современный способ обработки ввода с помощью различных указывающих устройств, таких как мышь, перо/стилус, сенсорный экран и так далее.[^pointer-events]

#### Краткая история
Сделаем небольшой обзор, чтобы стала понятной общая картиа и место событий указателя среди других типов событий.

- Давным-давно, в прошлом, существовали только события мыши

  Затем получили широкое распространение сенсорные устройства, в частности телефоны и планшеты. Чтобы скрипты корректно работали, они генерировали (и до сих пор генерируют) события мыши. Например, касание сенсорного экрана генерирует событие `mousedown`. Таким образом, сенсорные устройства позволяли работать с существующими веб-страницами.

  Но сенсорные устройства во многих аспектах мощнее, чем мышь. Например, они позволяют касаться экрана сразу в нескольких местах («мульти-тач»). Однако, события мыши не имеют необходимых свойств для обработки таких прикосновений.

- Поэтому появились события касания (*touch events*), такие как `touchstart`, `touchend`, `touchmove`, которые имеют специфичные для касаний свойства (мы не будем здесь рассматривать их подробно, потому что события указателя ещё лучше).

  Но и этих событий оказалось недостаточно, так как существует много других устройств, таких как перо, у которых есть свои особенности. Кроме того, универсальный код, который отслеживал бы и события касаний и события мыши, неудобно писать.

- Для решения этих задач был внедрён стандарт Pointer Events («События Указателя»). Он предоставляет единый набор событий для всех типов указывающих устройств.

К настоящему времени спецификация [Pointer Events Level 2](https://www.w3.org/TR/pointerevents2/) поддерживается всеми основными браузерами, а [Pointer Events Level 3](https://w3c.github.io/pointerevents/) находится в разработке и почти полностью совместима с Pointer Events Level 2.

Если вы не разрабатываете под старые браузеры, такие как Internet Explorer 10, Safari 12, или более ранние версии, больше нет необходимости использовать события мыши или касаний – можно переходить сразу на события указателя.

При этом ваш код будет корректно работать и с сенсорными устройствами и с мышью. Впрочем, у событий указателя есть важные особенности, которые нужно знать, чтобы их правильно использовать, без лишних сюрпризов. Они будут особо отмечены далее.

#### Типы событий указателя
Схема именований событий указателя похожа на события мыши:

| Событие указателя    | Аналогичное событие мыши   |
| -------------------- | -------------------------- |
| `pointerdown`        | `mousedown`                |
| `pointerup`          | `mouseup`                  |
| `pointermove`        | `mousemove`                |
| `pointerover`        | `mouseover`                |
| `pointerout`         | `mouseout`                 |
| `pointerenter`       | `mouseenter`               |
| `pointerleave`       | `mouseleave`               |
| `pointercancel`      | -                          |
| `gotpointercapture`  | -                          |
| `lostpointercapture` | -                          |

Как мы видим, для каждого `mouse<`*`события`*`>` есть соответствующее `pointer<`*`событие`*`>`, которое играет аналогичную роль. Также есть 3 дополнительных события указателя, у которых нет соответствующего аналога `mouse...`, они будут разобраны далее.

!!! info "Замена `mouse<`*`событий`*`>` на `pointer<`*`события`*`>` в коде"
    Мы можем заменить события `mouse...` на аналогичные `pointer...` в коде и быть уверенными, что с мышью по-прежнему всё будет работать нормально.

    При этом поддержка сенсорных устройств «волшебным» образом улучшится. Хотя, возможно, кое-где понадобится добавить `touch-action: none` в CSS. Подробнее мы разберём это ниже, в секции про `pointercancel`.


Простая миграция:
```js
// Было
element.addEventListener('mousedown', onMouseDown);
element.addEventListener('mousemove', onMouseMove);

// Стало
element.addEventListener('pointerdown', onMouseDown);
element.addEventListener('pointermove', onMouseMove);
```

Магическое улучшение:
- ✅ Мышь — работает как раньше
- ✅ Сенсор (один палец) — работает как мышь
- ✅ Сенсор (мультитач) — `pointerId` различает пальцы
- ✅ Перо/стилус — работает идеально

#### Свойства событий указателя
События указателя содержат те же свойства, что и события мыши, например `clientX`/`Y`, `target` и т.п., и несколько дополнительных:

- `pointerId` – уникальный идентификатор указателя, вызвавшего событие.

  Идентификатор генерируется браузером. Это свойство позволяет обрабатывать несколько указателей, например сенсорный экран со стилусом и мульти-тач (увидим примеры ниже).

- `pointerType` – тип указывающего устройства. Должен быть строкой с одним из значений: «mouse», «pen» или «touch».

  Мы можем использовать это свойство, чтобы определять разное поведение для разных типов указателей.

- `isPrimary` – равно `true` для основного указателя (первый палец в мульти-тач).

Некоторые устройства измеряют область контакта и степень надавливания, например пальца на сенсорном экране, для этого есть дополнительные свойства:

- `width` – ширина области соприкосновения указателя (например, пальца) с устройством. Если не поддерживается, например мышью, то всегда равно `1`.
- `height` – высота области соприкосновения указателя с устройством. Если не поддерживается, например мышью, то всегда равно `1`.
- `pressure` – степень давления указателя в диапазоне от 0 до 1. Для устройств, которые не поддерживают давление, принимает значение `0.5` (нажато) либо `0`.
- `tangentialPressure` – нормализованное тангенциальное давление.
- `tiltX`, `tiltY`, `twist` – специфичные для пера свойства, описывающие положение пера относительно сенсорной поверхности.

Эти свойства большинством устройств не поддерживаются, поэтому редко используются. При необходимости, подробности о них можно найти в [спецификации](https://w3c.github.io/pointerevents/#pointerevent-interface).

#### Мульти-тач
Одной из функций, которую абсолютно не поддерживают события мыши, является мульти-тач: возможность касаться сразу нескольких мест на телефоне или планшете или выполнять специальные жесты.

События указателя позволяют обрабатывать мульти-тач с помощью свойств `pointerId` и `isPrimary`.

Вот что происходит, когда пользователь касается сенсорного экрана в одном месте, а затем в другом:

1. При касании первым пальцем:
   - происходит событие `pointerdown` со свойством `isPrimary=true` и некоторым `pointerId`.
2. При касании вторым и последующими пальцами (при остающемся первом):
   - происходит событие `pointerdown` со свойством `isPrimary=false` и уникальным `pointerId` для каждого касания.

Обратите внимание: `pointerId` присваивается не на всё устройство, а для каждого касающегося пальца. Если коснуться экрана 5 пальцами одновременно, получим 5 событий `pointerdown`, каждое со своими координатами и индивидуальным `pointerId`.

События, связанные с первым пальцем, всегда содержат свойство `isPrimary=true`.

Мы можем отслеживать несколько касающихся экрана пальцев, используя их `pointerId`. Когда пользователь перемещает, а затем убирает палец, получаем события `pointermove` и `pointerup` с тем же `pointerId`, что и при событии `pointerdown`.

Вот небольшое демо, выводящее события `pointerdown` и `pointerup`:

[Тестовый стенд](../test/multi-touch/index.html)

Обратите внимание: чтобы увидеть разницу в `pointerId`/`isPrimary`, вам нужно использовать устройство с сенсорным экраном, такое как телефон или планшет. Для устройств без поддержки мульти-тач, таких как мышь, всегда будет один и тот же `pointerId` со свойством `isPrimary=true`, для всех событий указателя.

#### Событие: pointercancel
Событие `pointercancel` происходит, когда текущее действие с указателем по какой-то причине прерывается, и события указателя больше не генерируются.

К таким причинам можно отнести:

- указывающее устройство было физически выключено;
- изменилась ориентация устройства (перевернули планшет);
- браузер решил сам обработать действие, считая его жестом мыши, масштабированием и т.п.

Мы продемонстрируем `pointercancel` на практическом примере, чтобы увидеть, как это влияет на нас.

Допустим, мы реализуем перетаскивание («drag-and-drop») для нашего мяча, как в начале статьи [Drag'n'Drop с событиями мыши](#dragndrop-с-событиями-мыши).

Вот последовательность действий пользователя и соответствующие события:

1. Пользователь нажимает на изображении, чтобы начать перетаскивание
   - происходит событие `pointerdown`
2. Затем он перемещает указатель, двигая изображение
   - происходит событие `pointermove` (возможно, несколько раз)
3. И тут происходит сюрприз! Браузер имеет встроенную поддержку «Drag’n’Drop» для изображений, которая запускает и перехватывает процесс перетаскивания, генерируя при этом событие `pointercancel`.
   - Теперь браузер сам обрабатывает перетаскивание изображения. У пользователя есть возможность перетащить изображение мяча даже за пределы браузера, в свою почтовую программу или файловый менеджер.
   - Событий `pointermove` для нас больше не генерируется.

Таким образом, браузер «перехватывает» действие: в начале переноса drag-and-drop запускается событие `pointercancel`, и после этого события `pointermove` больше не генерируются.

Вот демо drag’n’drop с записью событий указателя (только `up`/`down`, `move` и `cancel`) в `textarea`:

![Drag the ball demo](../img/drag-the-ball-1.png)

[Тестовый стенд](../test/drag-the-ball/index1.html)

Мы бы хотели реализовать перетаскивание самостоятельно, поэтому давайте скажем браузеру не перехватывать его.

**Предотвращайте действие браузера по умолчанию, чтобы избежать `pointercancel`.**

Нужно сделать две вещи:

1. Предотвратить запуск встроенного drag’n’drop
   - Мы можем сделать это, задав `ball.ondragstart = () => false`, как описано в статье [Drag'n'Drop с событиями мыши](#dragndrop-с-событиями-мыши).
   - Это работает для событий мыши.
2. Для устройств с сенсорным экраном существуют другие действия браузера, связанные с касаниями, кроме drag’n’drop. Чтобы с ними не возникало проблем:
   - Мы можем предотвратить их, добавив в CSS свойство `#ball { touch-action: none }`.
   - Затем наш код начнёт корректно работать на устройствах с сенсорным экраном

После того, как мы это сделаем, события будут работать как и ожидается, браузер не будет перехватывать процесс и не будет вызывать событие `pointercancel`.

В данном демо произведены нужные действия:

![Drag the ball demo](../img/drag-the-ball-2.png)

[Тестовый стенд](../test/drag-the-ball/index2.html)

Как вы можете видеть, событие `pointercancel` больше не срабатывает.

Теперь мы можем добавить код для перемещения мяча и наш drag’n’drop будет работать и для мыши и для устройств с сенсорным экраном.

#### Захват указателя
Захват указателя – особая возможность событий указателя.

Общая идея очень проста, но поначалу может показаться странной, так как для других событий ничего подобного просто нет.

Основной метод:

- `elem.setPointerCapture(`*`pointerId`*`)` – привязывает события с данным `pointerId` к `elem`. После такого вызова все события указателя с таким `pointerId` будут иметь `elem` в качестве целевого элемента (как будто произошли над `elem`), вне зависимости от того, где в документе они произошли.

Другими словами, `elem.setPointerCapture(pointerId)` меняет `target` всех дальнейших событий с данным `pointerId` на `elem`.

Эта привязка отменяется:

- автоматически, при возникновении события `pointerup` или `pointercancel`,
- автоматически, если `elem` удаляется из документа,
- при вызове `elem.releasePointerCapture(pointerId)`.

**Захват указателя используется для упрощения операций с переносом (drag’n’drop) элементов.**

В качестве примера давайте вспомним реализацию слайдера из статьи [Drag'n'Drop с событиями мыши](#dragndrop-с-событиями-мыши).

Мы делаем элемент для слайдера – полоску с «ползунком» (`thumb`) внутри:
```html
<div class="slider">
  <div class="thumb"></div>
</div>
```

![Slider](../img/slider-elem.png)

[Исходный код](../test/slider-touch/index1.html)

Затем он работает так:

1. Пользователь сначала нажимает на ползунок `thumb` – срабатывает `pointerdown`.
2. Затем двигает его указателем – срабатывает `pointermove`, и наш код перемещает элемент `thumb`.
   - …Причём, по мере движения, указатель может покидать ползунок – перемещаться выше или ниже. При этом ползунок должен передвигаться строго по горизонтали, на одной линии с указателем.

В решении, основанном на событиях мыши, для отслеживания всех движений указателя, включая те, которые происходят выше/ниже элемента `thumb`, мы должны были назначить обработчик события mousemove на весь документ `document`.

Однако это не самое правильное решение. Одна из проблем – это то, что движения указателя по документу могут вызвать сторонние эффекты, заставить работать другие обработчики (например, `mouseover`), не имеющие отношения к слайдеру.

Именно здесь вступает в игру `setPointerCapture`:

- Мы можем вызывать `thumb.setPointerCapture(event.pointerId)` в обработчике `pointerdown`,
- Тогда дальнейшие события указателя до `pointerup`/`cancel` будут привязаны к `thumb`.
- Затем, когда произойдёт `pointerup` (передвижение завершено), привязка будет автоматически удалена, нам об этом не нужно беспокоиться.

Так что, даже если пользователь будет двигать указателем по всему документу, обработчики событий будут вызваны на `thumb`. Причём все свойства объекта события, такие как `clientX`/`clientY`, будут корректны – захват указателя влияет только на `target`/`currentTarget`.

Вот основной код:
```js
thumb.onpointerdown = function(event) {
  // перенацелить все события указателя (до pointerup) на thumb
  thumb.setPointerCapture(event.pointerId);
  // начать отслеживание перемещения указателя
  thumb.onpointermove = function(event) {
    // перемещение слайдера: отслеживание thumb, т.к все события указателя перенацелены на него
    let newLeft = event.clientX - slider.getBoundingClientRect().left;
    thumb.style.left = newLeft + 'px';
  };
  // если сработало событие pointerup, завершить отслеживание перемещения указателя
  thumb.onpointerup = function(event) {
    thumb.onpointermove = null;
    thumb.onpointerup = null;
    // ...при необходимости также обработайте "конец перемещения"
  };
};
// примечание: нет необходимости вызывать thumb.releasePointerCapture,
// это происходит автоматически при pointerup
```

![Slider full demo](../img/slider-full-demo.png)

[Исходный код](../test/slider-touch/index2.html)

В демонстрационном примере также имеется дополнительный элемент с обработчиком `onmouseover`, показывающий текущую дату.

Обратите внимание: пока вы перетаскиваете ползунок, вы можете навести курсор на этот элемент, и его обработчик *не сработает*.

Таким образом, благодаря `setPointerCapture` перетаскивание теперь не имеет побочных эффектов.

Таким образом, мы имеем два бонуса:

1. Код становится чище, поскольку нам больше не нужно добавлять/удалять обработчики для всего документа. Удаление привязки происходит автоматически.
2. Если в документе есть какие-то другие обработчики `pointermove`, то они не будут нечаянно вызваны, пока пользователь находится в процессе перетаскивания слайдера.

#### События при захвате указателя
Существует два связанных с захватом события:

- `gotpointercapture` срабатывает, когда элемент использует `setPointerCapture` для включения захвата.
- `lostpointercapture` срабатывает при освобождении от захвата: явно с помощью `releasePointerCapture` или автоматически, когда происходит событие `pointerup`/`pointercancel`.

#### Итого
События указателя позволяют одновременно обрабатывать действия с помощью мыши, касания и пера, в едином фрагменте кода.

События указателя расширяют события мыши. Мы можем заменить `mouse` на `pointer` в названиях событий и код продолжит работать для мыши, при этом получив лучшую поддержку других типов устройств.

При обработке переносов и сложных касаний, которые браузер может попытаться обработать сам, не забывайте отменять действие браузера и ставить `touch-action: none` в CSS для элементов, с которыми мы взаимодействуем.

Дополнительные возможности событий указателя:

- Поддержка мультитач с помощью `pointerId` и `isPrimary`.
- Особые свойства для определённых устройств, такие как `pressure`, `width`/`height` и другие.
- Захват указателя: мы можем перенаправить все события указателя на определённый элемент до наступления события `pointerup`/`pointercancel`.

На данный момент события указателя поддерживаются в основных браузерах, поэтому мы можем безопасно переходить на них, особенно если нет необходимости в поддержке IE10 и Safari 12. И даже для этих браузеров есть полифилы, которые добавляют эту поддержку.[^pointer-events]

### Прокрутка
Событие прокрутки `scroll` позволяет реагировать на прокрутку страницы или элемента. Есть много хороших вещей, которые при этом можно сделать.

Например:

- Показать/скрыть дополнительные элементы управления или информацию, основываясь на том, в какой части документа находится пользователь.
- Подгрузить данные, когда пользователь прокручивает страницу вниз до конца.
Вот небольшая функция для отображения текущей прокрутки:

Вот небольшая функция для отображения текущей прокрутки:
```js
window.addEventListener('scroll', function() {
  document.getElementById('showScroll').innerHTML = pageYOffset + 'px';
});
```

В действии:

Текущая прокрутка = 181.81817626953125px

Событие `scroll` работает как на `window`, так и на других элементах, на которых включена прокрутка.[^onscroll]

#### Предотвращение прокрутки
Как можно сделать что-то непрокручиваемым?

Нельзя предотвратить прокрутку, используя `event.preventDefault()` в обработчике `onscroll`, потому что он срабатывает после того, как прокрутка уже произошла.

Но можно предотвратить прокрутку, используя `event.preventDefault()` на событии, которое вызывает прокрутку, например, на событии `keydown` для клавиш <kbd>pageUp</kbd> и <kbd>pageDown</kbd>.

Если поставить на них обработчики, в которых вызвать `event.preventDefault()`, то прокрутка не начнётся.

Способов инициировать прокрутку много, поэтому более надёжный способ – использовать CSS, свойство `overflow`.

Вот несколько задач, которые вы можете решить или просмотреть, чтобы увидеть применение `onscroll`.

#### Задачи

##### Бесконечная страница

Создайте бесконечную страницу. Когда посетитель прокручивает её до конца, она автоматически добавляет текущие время и дату в текст (чтобы посетитель мог прокрутить ещё).

Как тут:

![Endless page](../img/endless-page.png)

Пожалуйста, обратите внимание на две важные особенности прокрутки:

1. **Прокрутка «эластична»**. Можно прокрутить немного дальше начала или конца документа на некоторых браузерах/устройствах (после появляется пустое место, а затем документ автоматически «отскакивает» к нормальному состоянию).
2. **Прокрутка неточна**. Если прокрутить страницу до конца, можно оказаться в 0-50px от реальной нижней границы документа.

Таким образом, «прокрутка до конца» должна означать, что посетитель находится на расстоянии не более 100px от конца документа.

P.S. В реальной жизни мы можем захотеть показать «больше сообщений» или «больше товаров».

<details>
<summary>Решение</summary>

Основа решения – функция, которая добавляет больше дат на страницу (или загружает больше материала в реальной жизни), пока мы находимся в конце этой страницы.

Мы можем вызвать её сразу же и добавить как обработчик для `window.onscroll`.

Самый важный вопрос: «Как обнаружить, что страница прокручена к самому низу?»

Давайте используем координаты относительно окна.

Документ представлен тегом `<html>` (и содержится в нём же), который доступен как `document.documentElement`.

Так что мы можем получить его координаты относительно окна как `document.documentElement.getBoundingClientRect()`, свойство `bottom` будет координатой нижней границы документа относительно окна.

Например, если высота всего HTML-документа `2000px`, тогда:
```js
// когда мы находимся вверху страницы
// координата top относительно окна равна 0
document.documentElement.getBoundingClientRect().top = 0

// координата bottom относительно окна равна 2000
// документ длинный, вероятно, далеко за пределами нижней части окна
document.documentElement.getBoundingClientRect().bottom = 2000
```

Если прокрутить `500px` вниз, тогда:
```js
// верх документа находится выше окна на 500px
document.documentElement.getBoundingClientRect().top = -500
// низ документа на 500px ближе
document.documentElement.getBoundingClientRect().bottom = 1500
```

Когда мы прокручиваем до конца, предполагая, что высота окна `600px`:
```js
// верх документа находится выше окна на 1400px
document.documentElement.getBoundingClientRect().top = -1400
// низ документа находится ниже окна на 600px
document.documentElement.getBoundingClientRect().bottom = 600
```

Пожалуйста, обратите внимание, что `bottom` не может быть `0`, потому что низ документа никогда не достигнет верха окна. Нижним пределом координаты `bottom` является высота окна (выше мы предположили, что это `600`), больше прокручивать вверх нельзя.

Получить высоту окна можно как `document.documentElement.clientHeight`.

Для нашей задачи мы хотим знать, когда нижняя граница документа находится не более чем в `100px` от неё (т.е. `600`-`700px`, если высота `600`).

Итак, вот функция:
```js
function populate() {
  while(true) {
    // нижняя граница документа
    let windowRelativeBottom = document.documentElement.getBoundingClientRect().bottom;

    // если пользователь не прокрутил достаточно далеко (>100px до конца страницы) — прерываем цикл
    if (windowRelativeBottom > document.documentElement.clientHeight + 100) {
        break;
    }

    // добавим больше данных
    document.body.insertAdjacentHTML("beforeend", `<p>Date: ${new Date()}</p>`);
  }
}
```

[Код решения](../src/12_ui/endless-page.html)

</details>

##### Кнопка вверх/вниз

Создайте кнопку «наверх», чтобы помочь с прокруткой страницы.

Она должна работать следующим образом:

- Пока страница не прокручена вниз хотя бы на высоту окна – кнопка невидима.
- Когда страница прокручена вниз больше, чем на высоту окна – появляется стрелка «наверх» в левом верхнем углу. Если страница прокручивается назад, стрелка исчезает.
- Когда нажимается стрелка, страница прокручивается вверх.

Как тут (слева-сверху, прокрутите):

![Scroll to top](../img/scroll-to-top.png)

<details>
<summary>Решение</summary>

[Код решения](../src/12_ui/scroll-to-top.html)

</details>

##### Загрузка видимых изображений

Допустим, у нас есть клиент с низкой скоростью соединения, и мы хотим сэкономить его трафик.

Для этого мы решили не показывать изображения сразу, а заменять их на «макеты», как тут:
```html
<img src="placeholder.svg" width="128" height="128" data-src="real.jpg">
```

То есть, изначально, все изображения – *placeholder.svg*. Когда страница прокручивается до того положения, где пользователь может увидеть изображение – мы меняем `src` на значение из `data-src`, и таким образом изображение загружается.

Вот пример:

![Image load on demand](../img/image-load-on-demand.png)

Прокрутите его, чтобы увидеть загрузку изображений «по требованию».

Требования:

- При загрузке страницы те изображения, которые уже видимы, должны загружаться сразу же, не ожидая прокрутки.
- Некоторые изображения могут быть обычными, без `data-src`. Код не должен касаться их.
- Если изображение один раз загрузилось, оно не должно больше перезагружаться при прокрутке.

P.S. Если можете, реализуйте более продвинутое решение, которое будет загружать изображения на одну страницу ниже/после текущей позиции.

P.P.S. Достаточно обрабатывать вертикальную прокрутку, горизонтальную не требуется.

<details>
<summary>Решение</summary>

Обработчик `onscroll` должен проверить, какие изображения видимы, и показать их.

Мы также можем запустить его при загрузке страницы, чтобы сразу обнаружить видимые изображения и загрузить их.

Код должен выполниться, когда документ загружен, чтобы у него был доступ к его содержимому.

Можно разместить его перед закрывающим тегом `</body>`:
```js
// ...содержимое страницы выше...

function isVisible(elem) {

  let coords = elem.getBoundingClientRect();

  let windowHeight = document.documentElement.clientHeight;

  // верхний край элемента виден?
  let topVisible = coords.top > 0 && coords.top < windowHeight;

  // нижний край элемента виден?
  let bottomVisible = coords.bottom < windowHeight && coords.bottom > 0;

  return topVisible || bottomVisible;
}
```

Функция `showVisible()` использует проверку на видимость, реализованную в `isVisible()` для загрузки видимых картинок:
```js
function showVisible() {
  for (let img of document.querySelectorAll('img')) {
    let realSrc = img.dataset.src;
    if (!realSrc) continue;

    if (isVisible(img)) {
      img.src = realSrc;
      img.dataset.src = '';
    }
  }
}

showVisible();
window.onscroll = showVisible;
```

P.S. В решении этой задачи есть также вариант `isVisible`, который предварительно загружает изображения, находящиеся в пределах одной страницы выше/ниже от текущей прокрутки документа.

[Код решения](../src/12_ui/picture-on-demand/index.html)

</details>

### Глоссарий

Источник перемещения
: элемент, перемещаемый мышью

Метаклавиша (*metakey*)
: клавиша-модификатор, которая не печатает символ сама по себе, а служит для модифицирования поведения других клавиш во время ввода или горячих клавиш. К числу таких клавиш относят <kbd>Alt</kbd>, <kbd>Ctrl</kbd>, <kbd>⇧ Shift</kbd>.

Цель перемещения
: целевая область на веб-странице (другой элемент), на которую передвигается источник перемещения.

### Практическая работа. Создание выделяемого списка

#### Задание

Создать список, в котором элементы могут быть выделены, как в файловых менеджерах.

- При клике на элемент списка выделяется только этот элемент (добавляется класс `.selected`), отменяется выделение остальных элементов.
- Если клик сделан вместе с <kbd>Ctrl</kbd> (<kbd>Cmd</kbd> для Mac), то выделение переключается на элементе, но остальные элементы при этом не изменяются.
- В этом задании все элементы списка содержат только текст. Без вложенных тегов.
- Предотвратить стандартное для браузера выделение текста при кликах.

Примерный внешний вид:

![Selectable list](../img/selectible-list.png)

Решение представить в виде файлов исходного кода.

<details>
<summary>Решение</summary>

[Код решения](../src/11_events/selectable-list.html)

</details>


### Практическая работа. Создание кастомных слайдеров

#### Задание

Реализовать различные варианты виджета на базе перетаскивания с помощью событий мыши и использования кастомных событий.

1. **Базовый слайдер**

    Создать базовый вариант виджета "слайдер":

    ![Slider](../img/slider-widget_1.png)

    - Элементы слайдера (полоса и бегунок) сделаны на базе `div`

    - Бегунок можно передвигать при захвате мышью

    - Слайдер должен нормально работать при резком движении мыши влево или вправо за пределы полосы. При этом бегунок должен останавливаться чётко в нужном конце полосы.

    - При нажатом бегунке мышь может выходить за пределы полосы слайдера, но слайдер пусть всё равно работает (это удобно для пользователя).

    - Для реализации задачи использовать перетаскивание с помощью событий мыши.

    <details>
    <summary>Решение</summary>

    Как можно видеть из HTML/CSS, слайдер – это `<div>`, подкрашенный фоном/градиентом, внутри которого находится другой `<div>`, оформленный как бегунок, с `position:relative`.

    Используем для его координат `position:relative`, т.е. координаты ставятся не абсолютные, а относительно родителя, так как это удобнее.

    И дальше реализуем Drag’n’Drop только по горизонтали, с ограничением по ширине.

    [Код решения](../src/12_ui/slider/index.html)

    </details>

2. **Улучшенный слайдер**

    ![Slider](../img/slider-widget_2.png)

   - Сделать бегунок фокусируемым и передвигаемым с помощью клавиатуры (стрелками вправо и влево).

   - Бегунок должен получать фокус и при клике мышкой.

   - Обеспечить перемещение бегунка при клике по полосе в то место, куда был совершен клик.

   - Обеспечить возможность доступа из внешнего кода текущих значений бегунка у элемента виджета.

   - Реализовать генерацию кастомного события (например, `slide`) при перетаскивании бегунка. В объект события записывать данные о текущем относительном положении бегунка (в долях ширины полосы — должно быть число от `0` до `1`).

3. **Настраиваемый слайдер**

    ![Slider](../img/slider-widget_3.png)

   - Добавить визуальные метки начала и конца диапазона (шкалу). Значения границ диапазона должны быть доступными для определения через атрибуты веб-компонента.

   - Обеспечить возможность добавления промежуточных меток на шкале с настраиваемым шагом.

   - Реализовать функционал дискретного перемещения бегунка с определенным шагом.

   - Предоставить возможность вертикальной ориентации слайдера через атрибут.

Предоставить работу в виде файлов исходного кода.

### Практическая работа. Создание списка задач и управление его элементами

#### Задание

Создать простой список задач (to-do list) в виде вертикально расположенных карточек. Помимо добавления реализовать удаление карточек с помощью смещения элемента в сторону (по типу свайпа, используемого для аналогичного функционала на мобильных устройствах).

- Осуществлять удаление только по достижении некоторой величины смещения элемента (*критического порога* — например, в 50% относительно ширины сдвигаемого элемента) во избежание ошибочного удаления.
- По отпускании в том случае, если смещение элемента превышает критический порог, выполнять удаление элемента и перераспределение оставшихся карточек с тем, чтобы они заняли освободившееся место.
- Если смещение элемента по отпускании не достигает критического порога, возвращать элемент на место.
- Обеспечить строго горизонтальное перемещение элемента (игнорировать вертикальный компонент перетаскивания).
- Реализовать удаление записи только при смещении в левую сторону.

Результат представить в виде файлов исходного кода.

### Практическая работа. Отслеживание одновременного нажатия

#### Задание

Создать функцию `runOnKeys(func, code1, code2, ... code_n)`, которая запускает `func` при одновременном нажатии клавиш с кодами `code1`, `code2`, …, `code_n`.

Например, код ниже выведет `alert` при одновременном нажатии клавиш "Q" и "W" (в любом регистре, в любой раскладке)
```js
runOnKeys(
  () => alert("Привет!"),
  "KeyQ",
  "KeyW"
);
```

Предоставить работу в виде файлов исходного кода.

<details>
<summary>Решение</summary>

Необходимо использовать два обработчика событий: `document.onkeydown` и `document.onkeyup`.

Создадим множество `pressed = new Set()`, в которое будем записывать клавиши, нажатые в данный момент.

В первом обработчике будем добавлять в него значения, а во втором удалять. Каждый раз, как отрабатывает `keydown`, будем проверять – все ли нужные клавиши нажаты, и, если да – выводить сообщение.

[Код решения](../src/12_ui/keypress.html)

</details>

### Практическая работа. Создание слайдеров

#### Задание

Реализовать различные варианты виджета на базе перетаскивания с помощью событий мыши.

1. **Базовый слайдер**

    Создать базовый вариант виджета "слайдер":

    ![Slider](../img/slider-widget_1.png)

    ![Slider](../img/slider.png)

    - Элементы слайдера (полоса и бегунок) сделаны на базе `div`

    - Бегунок можно передвигать при захвате мышью

    - Слайдер должен нормально работать при резком движении мыши влево или вправо за пределы полосы. При этом бегунок должен останавливаться чётко в нужном конце полосы.

    - При нажатом бегунке мышь может выходить за пределы полосы слайдера, но слайдер пусть всё равно работает (это удобно для пользователя).

    - Для реализации задачи использовать перетаскивание с помощью событий мыши.

    <details>
    <summary>Решение</summary>

    Как можно видеть из HTML/CSS, слайдер – это `<div>`, подкрашенный фоном/градиентом, внутри которого находится другой `<div>`, оформленный как бегунок, с `position:relative`.

    Используем для его координат `position:relative`, т.е. координаты ставятся не абсолютные, а относительно родителя, так как это удобнее.

    И дальше реализуем Drag’n’Drop только по горизонтали, с ограничением по ширине.

    [Код решения](../src/12_ui/slider/index.html)

    </details>

2. **Улучшенный слайдер**

    ![Slider](../img/slider-widget_2.png)

   - Сделать бегунок фокусируемым и передвигаемым с помощью клавиатуры (стрелками вправо и влево).

   - Бегунок должен получать фокус и при клике мышкой.

   - Обеспечить перемещение бегунка при клике по полосе в то место, куда был совершен клик.

   - Обеспечить возможность доступа из внешнего кода текущих значений бегунка у элемента виджета.

   - Реализовать генерацию кастомного события (например, `slide`) при перетаскивании бегунка. В объект события записывать данные о текущем относительном положении бегунка (в долях ширины полосы — должно быть число от `0` до `1`).

3. **Настраиваемый слайдер**

    ![Slider](../img/slider-widget_3.png)

   - Добавить визуальные метки начала и конца диапазона (шкалу). Значения границ диапазона должны быть доступными для определения через атрибуты веб-компонента.

   - Обеспечить возможность добавления промежуточных меток на шкале с настраиваемым шагом.

   - Реализовать функционал дискретного перемещения бегунка с определенным шагом.

   - Предоставить возможность вертикальной ориентации слайдера через атрибут.

4. **Сложный слайдер**

    ![Slider](../img/slider-input.png)

    Реализовать еще один компонент на базе комбинации уже разработанного слайдера с полем ввода.

     - Поле ввода отображает точное текущее абсолютное (если пользователем заданы границы диапазона) или относительное (если таковое не задано) значение

     - Поле должно обеспечивать возможность ввода определенного значения, не выходящего за границы диапазона слайдера. При вводе значения бегунок слайдера должен перемещаться в соответствующее положение.

     - Поле ввода расположить справа от слайдера.

5. **Диапазонный слайдер**

    ![Slider](../img/slider-widget_5.png)

    Реализовать еще один компонент на базе разработанных, позволяющий задавать определенный диапазон.

    - Компонент должен содержать два бегунка на слайдере и два поля ввода, расположенные слева и справа от слайдера.

    - Часть полосы, соответствующая указанному диапазону, должна иметь цветовое выделение.

Оформить разработанный функционал в виде веб-компонента, который может быть встроен на любую веб-страницу. Предоставить работу в виде исходного файла компонента.

### Практическая работа. Реализация альтернативных механизмов замены изображения пользователя

#### Задание
Реализовать добавление и замену изображения профиля пользователя на странице пользовательских установок с помощью перетаскивания пользовательского файла изображения.

- Использовать Drag & drop API для перетаскивания файла на зону приема с визуальной обратной связью.
- Реализовать альтернативный способ загрузки изображения (например, клик на области приема файла)
- Обеспечить предпросмотр изображения в реальном времени.
- Гарантировать валидацию типов и размера файлов для приема только изображений, не превышающих 5 МБ.
- Сохранение изображения осуществлять в `localStorage`.

Результат представить в виде файлов исходного кода.

### Практическая работа. Имитация сенсорных событий

#### Задание
Реализовать удаление карточки (например, учетной записи пользователя) с помощью смещения элемента в сторону (по типу свайпа, используемого для аналогичного функционала на мобильных устройствах).

- Осуществлять удаление только по достижении некоторой величины смещения элемента (*критического порога* — например, в 50% относительно ширины сдвигаемого элемента) во избежание ошибочного удаления.
- По отпускании в том случае, если смещение элемента превышает критический порог, выполнять удаление элемента и перераспределение оставшихся карточек с тем, чтобы они заняли освободившееся место.
- Если смещение элемента по отпускании не достигает критического порога, возвращать элемент на место.
- Обеспечить строго горизонтальное перемещение элемента (игнорировать вертикальный компонент перетаскивания).
- Реализовать удаление записи только при смещении в левую сторону.

Результат представить в виде файлов исходного кода.

### Практическая работа. Реализация бесконечной ленты

#### Задание
Реализовать механизм бесконечной ленты по типу новостной ленты социальных сетей. Дополнить разработанный механизм кнопкой перехода вверх.

1. **Бесконечная страница**

    Создать бесконечную страницу. Когда посетитель прокручивает её до конца, она автоматически добавляет некоторый текстовый фрагмент (сообщения, новости, карточки товаров и т.п.), обязательно содержащий текущие время и дату (чтобы посетитель мог прокрутить ещё).

    Требования к прокрутке:

    1. **Прокрутка «эластична»**. Можно прокрутить немного дальше начала или конца документа на некоторых браузерах/устройствах (после появляется пустое место, а затем документ автоматически «отскакивает» к нормальному состоянию).
    2. **Прокрутка неточна**. Если прокрутить страницу до конца, можно оказаться в 0-50px от реальной нижней границы документа.

    Таким образом, «прокрутка до конца» должна означать, что посетитель находится на расстоянии не более 100px от конца документа.

    <details>
    <summary>Решение</summary>

    Основа решения – функция, которая добавляет больше дат на страницу (или загружает больше материала в реальной жизни), пока мы находимся в конце этой страницы.

    Мы можем вызвать её сразу же и добавить как обработчик для `window.onscroll`.

    Самый важный вопрос: «Как обнаружить, что страница прокручена к самому низу?»

    Давайте используем координаты относительно окна.

    Документ представлен тегом `<html>` (и содержится в нём же), который доступен как `document.documentElement`.

    Так что мы можем получить его координаты относительно окна как `document.documentElement.getBoundingClientRect()`, свойство `bottom` будет координатой нижней границы документа относительно окна.

    Например, если высота всего HTML-документа `2000px`, тогда:
    ```js
    // когда мы находимся вверху страницы
    // координата top относительно окна равна 0
    document.documentElement.getBoundingClientRect().top = 0

    // координата bottom относительно окна равна 2000
    // документ длинный, вероятно, далеко за пределами нижней части окна
    document.documentElement.getBoundingClientRect().bottom = 2000
    ```

    Если прокрутить `500px` вниз, тогда:
    ```js
    // верх документа находится выше окна на 500px
    document.documentElement.getBoundingClientRect().top = -500
    // низ документа на 500px ближе
    document.documentElement.getBoundingClientRect().bottom = 1500
    ```

    Когда мы прокручиваем до конца, предполагая, что высота окна `600px`:
    ```js
    // верх документа находится выше окна на 1400px
    document.documentElement.getBoundingClientRect().top = -1400
    // низ документа находится ниже окна на 600px
    document.documentElement.getBoundingClientRect().bottom = 600
    ```

    Пожалуйста, обратите внимание, что `bottom` не может быть `0`, потому что низ документа никогда не достигнет верха окна. Нижним пределом координаты `bottom` является высота окна (выше мы предположили, что это `600`), больше прокручивать вверх нельзя.

    Получить высоту окна можно как `document.documentElement.clientHeight`.

    Для нашей задачи мы хотим знать, когда нижняя граница документа находится не более чем в `100px` от неё (т.е. `600`-`700px`, если высота `600`).

    Итак, вот функция:
    ```js
    function populate() {
      while(true) {
        // нижняя граница документа
        let windowRelativeBottom = document.documentElement.getBoundingClientRect().bottom;

        // если пользователь не прокрутил достаточно далеко (>100px до конца страницы) — прерываем цикл
        if (windowRelativeBottom > document.documentElement.clientHeight + 100) {
            break;
        }

        // добавим больше данных
        document.body.insertAdjacentHTML("beforeend", `<p>Date: ${new Date()}</p>`);
      }
    }
    ```

    [Код решения](../src/12_ui/endless-page.html)

    </details>

2. **Кнопка вверх/вниз**

    Создать кнопку «наверх», чтобы помочь с прокруткой страницы.

    Она должна работать следующим образом:

    - Пока страница не прокручена вниз хотя бы на высоту окна – кнопка невидима.
    - Когда страница прокручена вниз больше, чем на высоту окна – появляется стрелка «наверх» в левом верхнем углу. Если страница прокручивается назад, стрелка исчезает.
    - Когда нажимается стрелка, страница прокручивается вверх.

Решение предоставить в виде файлов исходного кода.

### Практическая работа. Реализация загрузки изображений по требованию

#### Задание

Допустим, имеется клиент с низкой скоростью соединения, и необходимо сэкономить его трафик. Для этого принято решение показывать изображения сразу, а заменять их на «макеты», например:

![Placeholder](../svg/placeholder.svg)

То есть изначально все изображения заменяются плейсхолдерами. Когда страница прокручивается до того положения, где пользователь может увидеть изображение, `src` меняется на значение из `data-src`, и таким образом изображение загружается.

1. **Базовое решение**

    Требования:

    - При загрузке страницы те изображения, которые уже видимы, должны загружаться сразу же, не ожидая прокрутки.
    - Некоторые изображения могут быть обычными, без `data-src`. Код не должен касаться их.
    - Если изображение один раз загрузилось, оно не должно больше перезагружаться при прокрутке.
    - Достаточно обрабатывать вертикальную прокрутку, горизонтальную не требуется.

2. **Продвинутое решение**

   - Изображения загружаются немного заранее — на одну страницу ниже/после текущей позиции.

Решение предоставить в виде файлов исходного кода.

<details>
<summary>Решение</summary>

Обработчик `onscroll` должен проверить, какие изображения видимы, и показать их.

Мы также можем запустить его при загрузке страницы, чтобы сразу обнаружить видимые изображения и загрузить их.

Код должен выполниться, когда документ загружен, чтобы у него был доступ к его содержимому.

Можно разместить его перед закрывающим тегом `</body>`:
```js
// ...содержимое страницы выше...

function isVisible(elem) {

  let coords = elem.getBoundingClientRect();

  let windowHeight = document.documentElement.clientHeight;

  // верхний край элемента виден?
  let topVisible = coords.top > 0 && coords.top < windowHeight;

  // нижний край элемента виден?
  let bottomVisible = coords.bottom < windowHeight && coords.bottom > 0;

  return topVisible || bottomVisible;
}
```

Функция `showVisible()` использует проверку на видимость, реализованную в `isVisible()` для загрузки видимых картинок:
```js
function showVisible() {
  for (let img of document.querySelectorAll('img')) {
    let realSrc = img.dataset.src;
    if (!realSrc) continue;

    if (isVisible(img)) {
      img.src = realSrc;
      img.dataset.src = '';
    }
  }
}

showVisible();
window.onscroll = showVisible;
```

P.S. В решении этой задачи есть также вариант `isVisible`, который предварительно загружает изображения, находящиеся в пределах одной страницы выше/ниже от текущей прокрутки документа.

[Код решения](../src/12_ui/picture-on-demand/index.html)

</details>


### Источники информации
[^9.5]: [События мыши](https://metanit.com/web/javascript/9.5.php)
[^9.6]: [События клавиатуры](https://metanit.com/web/javascript/9.6.php)
[^mouse-events-basics]: [Основы событий мыши](https://learn.javascript.ru/mouse-events-basics)
[^mousemove-mouseover-mouseout-mouseenter-mouseleave]: [Движение мыши: mouseover/out, mouseenter/leave](https://learn.javascript.ru/mousemove-mouseover-mouseout-mouseenter-mouseleave)
[^25.1]: [Перетаскивание элементов с помощью Drag-and-Drop API](https://metanit.com/web/javascript/25.1.php)
[^25.2]: [Установка и послучение перетаскиваемых данных с помощью DataTransfer](https://metanit.com/web/javascript/25.2.php)
[^mouse-drag-and-drop]: [Drag'n'Drop с событиями мыши](https://learn.javascript.ru/mouse-drag-and-drop)
[^keyboard-events]: [Клавиатура: keydown и keyup](https://learn.javascript.ru/keyboard-events)
[^pointer-events]: [События указателя](https://learn.javascript.ru/pointer-events)
[^onscroll]: [Прокрутка](https://learn.javascript.ru/onscroll)
