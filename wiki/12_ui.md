## Интерфейсные события

- [Интерфейсные события](#интерфейсные-события)
  - [События мыши](#события-мыши)
    - [Типы событий мыши](#типы-событий-мыши)
    - [Порядок событий](#порядок-событий)
    - [MouseEvent](#mouseevent)
    - [Кнопки мыши](#кнопки-мыши)
    - [Модификаторы: shift, alt, ctrl и meta](#модификаторы-shift-alt-ctrl-и-meta)
    - [Координаты: clientX/Y, pageX/Y](#координаты-clientxy-pagexy)
    - [Отключаем выделение](#отключаем-выделение)
    - [Итого](#итого)
    - [Задачи](#задачи)
  - [Движение мыши: mouseover/out, mouseenter/leave](#движение-мыши-mouseoverout-mouseenterleave)
    - [События mouseover/mouseout, relatedTarget](#события-mouseovermouseout-relatedtarget)
    - [Пропуск элементов](#пропуск-элементов)
    - [Событие mouseout при переходе на потомка](#событие-mouseout-при-переходе-на-потомка)
    - [События mouseenter и mouseleave](#события-mouseenter-и-mouseleave)
    - [Делегирование событий](#делегирование-событий)
    - [Итого](#итого-1)
    - [Задачи](#задачи-1)
      - [Улучшенная подсказка](#улучшенная-подсказка)
      - ["Умная" подсказка](#умная-подсказка)
  - [Перетаскивание элементов](#перетаскивание-элементов)
    - [Drag'n'Drop с событиями мыши](#dragndrop-с-событиями-мыши)
  - [События клавиатуры](#события-клавиатуры)
  - [Глоссарий](#глоссарий)

### События мыши
В этой секции более детально будут рассмотрены события мыши и их свойства. События мыши представляют собой одну из наиболее часто используемых групп событий.

Сразу заметим: эти события бывают не только из-за мыши, но и эмулируются на других устройствах, в частности, на мобильных, для совместимости.

#### Типы событий мыши

- `mousedown`: возникает при нахождении указателя мыши на элементе, когда кнопка мыши находится в нажатом состоянии

- `mouseup`: возникает при нахождении указателя мыши на элементе во время отпускания кнопки мыши

- `click`: возникает при нажатии указателем мыши на элемент. Вызывается при `mousedown` , а затем `mouseup` над одним и тем же элементом, если использовалась левая кнопка мыши.

- `dblclick`: возникает при двойном нажатии указателем мыши на элемент

- `contextmenu`: вызывается при попытке открытия контекстного меню, как правило, нажатием правой кнопки мыши. Но, заметим, это не совсем событие мыши, оно может вызываться и специальной клавишей клавиатуры.

- `mousemove`: возникает при прохождении указателя мыши над элементом. Каждое движение мыши над элементом генерирует это событие.

- `mouseover`: возникает при вхождении указателя мыши в границы элемента

- `mouseout`: возникает, когда указатель мыши выходит за пределы элемента

- `mouseenter`: возникает при вхождении указателя мыши в границы элемента

- `mouseleave`: возникает, когда указатель мыши выходит за пределы элемента

Отдельно стоит сказать про разницу между последними четырьмя событиями. `mouseenter` и `mouseleave` срабатывают только тогда, когда пересекается внешний край соответствующего элемента. А события `mouseover` и `mouseout` также срабатывают, когда другой элемент находится внутри соответствующего элемента и курсор мыши перемещается во внутренний элемент (т.е. уходит от внешнего элемента) или покидает внутренний элемент (то есть перемещается на внешний элемент).

Например, обработаем события `mouseover` и `mouseout`:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>METANIT.COM</title>
    <style>
    #blueRect{
        width:100px;
        height:100px;
        background-color:blue;
    }
    </style>
</head>
<body>
<div id="blueRect"></div>

<script>
function setColor(e){
    if(e.type==="mouseover")
        e.target.style.backgroundColor = "red";
    else if(e.type==="mouseout")
        e.target.style.backgroundColor = "blue";
}
const blueRect = document.getElementById("blueRect");
blueRect.addEventListener("mouseover", setColor);
blueRect.addEventListener("mouseout", setColor);
</script>
</body>
</html>
```

Теперь при наведении указателя мыши на блок `blueRect` он будет окрашиваться в красный цвет, а при уходе указателя мыши — блок будет обратно окрашиваться в синий цвет.

#### Порядок событий
Как вы можете видеть из приведённого выше списка, действие пользователя может вызвать несколько событий.

Например, клик мышью вначале вызывает `mousedown`, когда кнопка нажата, затем `mouseup` и click, когда она отпущена.

В случае, когда одно действие инициирует несколько событий, порядок их выполнения фиксирован. То есть обработчики событий вызываются в следующем порядке: `mousedown` → `mouseup` → `click`.

Ниже показана запись событий мыши, зафиксированных регистратором (скриптом).

![Mouse events](../img/mouse-events-logger.png)

В окне теста ниже все события мыши записываются, и если задержка между ними более 1 секунды, то они разделяются горизонтальной чертой. Зафиксирован следующий порядок вызов событий: левый клик, правый клик, клик средней кнопкой (колесом) и двойной клик левой кнопкой мыши.

Кроме того, мы можем видеть свойство `button`, которое позволяет нам определять кнопку мыши; это объясняется ниже.[^mouse-events-basics]

#### MouseEvent
Объект `Event` является общим для всех событий. Однако для разных типов событий существуют также свои объекты событий, которые добавляют ряд своих свойств. Так, для работы с событиями указателя мыши определен объект **`MouseEvent`**, который добавляет следующие свойства:[^9.5]

- **`altKey`**: возвращает `true`, если была нажата клавиша `Alt` во время генерации события

- **`button`**: содержит номер нажатой кнопки мыши

- **`buttons`**: содержит номер, который представляет нажатую кнопку мыши. 1 обозначает левую кнопку мыши, 2 — правую кнопку мыши, 4 — колесо мыши или среднюю кнопку мыши, 8 — четвертую кнопку мыши, а 16 — пятую кнопку мыши. Если при срабатывании события было нажато несколько кнопок, это свойство содержат сумму соответствующих чисел.

- **`clientX`**: определяет координату Х окна браузера, на которой находился указатель мыши во время генерации события

- **`clientY`**: определяет координату Y окна браузера, на которой находился указатель мыши во время генерации события

- **`ctrlKey`**: возвращает `true`, если была нажата клавиша <kbd>Ctrl</kbd> во время генерации события

- **`movementX`**: содержит координату Х относительно предыдущей координаты X при последнем событии перемещения мыши

- **`movementY`**: содержит координату Y относительно предыдущей координаты Y при последнем событии перемещения мыши

- **`metaKey`**: возвращает `true`, если была нажата во время генерации события метаклавиша клавиатуры

- **`region`**: содержит идентификатор области или элемента, которая относится к событию

- **`relatedTarget`**: определяет вторичный источник возникновения события

- **`screenX`**: определяет координату Х относительно верхнего левого угла экрана монитора, на которой находился указатель мыши во время генерации события

- **`screenY`**: определяет координату Y относительно верхнего левого угла экрана монитора, на которой находился указатель мыши во время генерации события

- **`shiftKey`**: возвращает `true`, если была нажата клавиша <kbd>Shift</kbd> во время генерации события

Определим координаты клика:
```js
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <style>
    #blueRect{
        width:100px;
        height:100px;
        background-color:blue;
    }
    </style>
</head>
<body>
<div id="blueRect"></div>

<script>
function handleClick(e){
    console.log("screenX: " + e.screenX);
    console.log("screenY: " + e.screenY);
    console.log("clientX: " + e.clientX);
    console.log("clientY: " + e.clientY);
}
const blueRect = document.getElementById("blueRect");
blueRect.addEventListener("click", handleClick);
</script>
</body>
</html>
```

#### Кнопки мыши
События, связанные с кликом, всегда имеют свойство `button`, которое позволяет получить конкретную кнопку мыши.

Обычно мы не используем его для событий `click` и `contextmenu`, потому что первое происходит только при щелчке левой кнопкой мыши, а второе – только при щелчке правой кнопкой мыши.

С другой стороны, обработчикам `mousedown` и `mouseup` может потребоваться `event.button`, потому что эти события срабатывают на любую кнопку, таким образом `button` позволяет различать «нажатие правой кнопки» и «нажатие левой кнопки».

Возможными значениями `event.button` являются:

| Состояние кнопки                 | `event.button` |
| -------------------------------- | ------------ |
| Левая кнопка (основная)          | 0            |
| Средняя кнопка (вспомогательная) | 1            |
| Правая кнопка (вторичная)        | 2            |
| Кнопка X1 (назад)                | 3            |
| Кнопка X2 (вперёд)               | 4            |

Большинство мышек имеют только левую и правую кнопку, поэтому возможные значения это 0 или 2. Сенсорные устройства также генерируют аналогичные события, когда кто-то нажимает на них.

Также есть свойство `event.buttons`, в котором все нажатые в данный момент кнопки представлены в виде целого числа, по одному биту на кнопку. На практике это свойство используется очень редко, вы можете найти подробную информацию по адресу [MDN](https://developer.mozilla.org/ru/docs/Web/api/MouseEvent/buttons), если вам это когда-нибудь понадобится.

!!! warning "Устаревшее свойство `event.which`"

    В старом коде вы можете встретить `event.which` свойство – это старый нестандартный способ получения кнопки с возможными значениями:

    - `event.which == 1` – левая кнопка,
    - `event.which == 2` – средняя кнопка,
    - `event.which == 3` – правая кнопка.

    На данный момент `event.which` устарел, нам не следует его использовать.

Средняя кнопка сейчас – скорее экзотика, и используется очень редко.

#### Модификаторы: shift, alt, ctrl и meta
Все события мыши включают в себя информацию о нажатых клавишах-модификаторах.

Свойства события:

- `shiftKey`: <kbd>Shift</kbd>
- `altKey`: <kbd>Alt</kbd> (или <kbd>Opt</kbd> для Mac)
- `ctrlKey`: <kbd>Ctrl</kbd>
- `metaKey`: <knf>Cmd</knf> для Mac

Они равны `true`, если во время события была нажата соответствующая клавиша.

Например, кнопка внизу работает только при комбинации <kbd>Alt</kbd>+<kbd>Shift</kbd>+клик:
```html
<button id="button">Нажми Alt+Shift+Click на мне!</button>

<script>
  button.onclick = function(event) {
    if (event.altKey && event.shiftKey) {
      alert('Ура!');
    }
  };
</script>
```

![Alt+Shit+click](../img/alt-shift-click.png)

!!! warning "Внимание: обычно на Mac используется клавиша `Cmd` вместо `Ctrl`"
    В Windows и Linux клавишами-модификаторами являются <kbd>Alt</kbd>, <kbd>⇧ Shift</kbd> и <kbd>Ctrl</kbd>. На Mac есть ещё одна: <kbd>Cmd</kbd>, которой соответствует свойство `metaKey`.

    В большинстве приложений, когда в Windows/Linux используется <kbd>Ctrl</kbd>, на Mac используется <knf>Cmd</knf>.

    То есть, когда пользователь Windows нажимает <kbd>Ctrl</kbd>+<kbd>Enter</kbd> и <kbd>Ctrl</kbd>+<kbd>A</kbd>, пользователь Mac нажимает <kbd>Cmd</kbd>+<kbd>⏎ Enter</kbd> или <kbd>Cmd</kbd>+<kbd>A</kbd>, и так далее.

    Поэтому, если мы хотим поддерживать такие комбинации, как <kbd>Ctrl</kbd>+клик, то для Mac имеет смысл использовать <kbd>Cmd</kbd>+клик. Это удобней для пользователей Mac.

    Даже если мы и хотели бы заставить людей на Mac использовать именно <kbd>Ctrl</kbd>+клик, это довольно сложно. Проблема в том, что левый клик в сочетании с <kbd>Ctrl</kbd> интерпретируется как правый клик на MacOS и генерирует событие `contextmenu`, а не `click` как на Windows/Linux.

    Поэтому, если мы хотим, чтобы пользователям всех операционных систем было удобно, то вместе с `ctrlKey` нам нужно проверять `metaKey`.

    Для JS-кода это означает, что мы должны проверить `if (event.ctrlKey || event.metaKey)`.

!!! warning "Не забывайте про мобильные устройства"
    Комбинации клавиш хороши в качестве дополнения к рабочему процессу. Так что, если посетитель использует клавиатуру – они работают.

    Но если на их устройстве его нет – тогда должен быть способ жить без клавиш-модификаторов.

#### Координаты: clientX/Y, pageX/Y
Все события мыши имеют координаты двух видов:

1. Относительно окна: `clientX` и `clientY`.
2. Относительно документа: `pageX` и `pageY`.

Мы уже рассмотрели разницу между ними в главе "Координаты" раздела, посвященного DOM.

Если в кратце, то относительные координаты документа `pageX`/`Y` отсчитываются от левого верхнего угла документа и не меняются при прокрутке страницы, в то время как `clientX`/`Y` отсчитываются от левого верхнего угла текущего окна. Когда страница прокручивается, они меняются.

Например, если у нас есть окно размером 500x500, и курсор мыши находится в левом верхнем углу, то значения `clientX` и `clientY` равны `0`, независимо от того, как прокручивается страница.

А если мышь находится в центре окна, то значения `clientX` и `clientY` равны `250` независимо от того, в каком месте документа она находится и до какого места документ прокручен. В этом они похожи на `position:fixed`.

Наведите курсор мыши на поле ввода, чтобы увидеть `clientX`/`clientY` (пример находится в `iframe`, поэтому координаты определяются относительно этого `iframe`):
```html
<input onmousemove="this.value=event.clientX+':'+event.clientY" value="Наведи на меня мышь">
```

Координаты относительно документа `pageX`, `pageY` отсчитываются не от окна, а от левого верхнего угла документа. Подробнее о координатах можно узнать в главе "Координаты" раздела, посвященного DOM.

#### Отключаем выделение
Двойной клик мыши имеет побочный эффект, который может быть неудобен в некоторых интерфейсах: он выделяет текст.

Например, двойной клик на текст ниже выделяет его в дополнение к нашему обработчику:
```html
<span ondblclick="alert('dblclick')">Сделайте двойной клик на мне</span>
```

![Double click](../img/dbl-click_1.png)

Если зажать левую кнопку мыши и, не отпуская кнопку, провести мышью, то также будет выделение, которое в интерфейсах может быть «не кстати».

Есть несколько способов запретить выделение, о которых можно прочитать в главе "Диапазоны и выделение".

В данном случае самым разумным будет отменить действие браузера по умолчанию при событии `mousedown`, это отменит оба этих выделения:
```html
До...
<b ondblclick="alert('Клик!')" onmousedown="return false">
  Сделайте двойной клик на мне
</b>
...После
```

![Double click](../img/dbl-click_2.png)

Теперь выделенный жирным элемент не выделяется при двойном клике, а также на нём нельзя начать выделение, зажав кнопку мыши.

Заметим, что текст внутри него по-прежнему можно выделить, если начать выделение не на самом тексте, а до него или после. Обычно это нормально воспринимается пользователями.

!!! info "Предотвращение копирования"
    Если мы хотим отключить выделение для защиты содержимого страницы от копирования, то мы можем использовать другое событие: `oncopy`.

    ```html
    <div oncopy="alert('Копирование запрещено!');return false">
      Уважаемый пользователь,
      Копирование информации запрещено для вас.
      Если вы знаете JS или HTML, вы можете найти всю нужную вам информацию в исходном коде страницы.
    </div>
    ```

    ![Prevent copy](../img/prevent-copy.png)

    Если вы попытаетесь скопировать текст в `<div>`, у вас это не получится, потому что срабатывание события `oncopy` по умолчанию запрещено.

    Конечно, пользователь имеет доступ к HTML-коду страницы и может взять текст оттуда, но не все знают, как это сделать.

#### Итого
События мыши имеют следующие свойства:

- Кнопка: `button`.

- Клавиши-модификаторы (`true` если нажаты): `altKey`, `ctrlKey`, `shiftKey` и `metaKey` (Mac).

    - Если вы планируете обработать <kbd>Ctrl</kbd>, то не забудьте, что пользователи Mac обычно используют <kbd>Cmd</kbd>, поэтому лучше проверить `if (e.metaKey || e.ctrlKey)`.

- Координаты относительно окна: `clientX`/`clientY`.

- Координаты относительно документа: `pageX`/`pageY`.

Действие по умолчанию события `mousedown` – начало выделения, если в интерфейсе оно скорее мешает, его можно отменить.

В следующей главе мы поговорим о событиях, которые возникают при передвижении мыши, и об отслеживании смены элементов под указателем.

#### Задачи
Создайте список, в котором элементы могут быть выделены, как в файловых менеджерах.

- При клике на элемент списка выделяется только этот элемент (добавляется класс `.selected`), отменяется выделение остальных элементов.
- Если клик сделан вместе с <kbd>Ctrl</kbd> (<kbd>Cmd</kbd> для Mac), то выделение переключается на элементе, но остальные элементы при этом не изменяются.

Демо:

![Selectable list](../img/selectable-list.png)

P.S. В этом задании все элементы списка содержат только текст. Без вложенных тегов.

P.P.S. Предотвратите стандартное для браузера выделение текста при кликах.

<details>
<summary>Решение</summary>

[Код решения](../src/11_events/selectable-list.html)

</details>

### Движение мыши: mouseover/out, mouseenter/leave
В этой главе мы более подробно рассмотрим события, возникающие при движении указателя мыши над элементами страницы.[^mousemove-mouseover-mouseout-mouseenter-mouseleave]

#### События mouseover/mouseout, relatedTarget
Событие `mouseover` происходит в момент, когда курсор оказывается над элементом, а событие `mouseout` – в момент, когда курсор уходит с элемента.

![Mouseover/mousout](../svg/mouseover-mouseout.svg)

Эти события являются особенными, потому что у них имеется свойство `relatedTarget`. Оно «дополняет» `target`. Когда мышь переходит с одного элемента на другой, то один из них будет `target`, а другой `relatedTarget`.

Для события `mouseover`:

- `event.target` – это элемент, *на который* курсор перешёл.
- `event.relatedTarget` – это элемент, *с которого* курсор ушёл (`relatedTarget` → `target`).

Для события `mouseout` наоборот:

- `event.target` – это элемент, *с которого* курсор ушёл.
- `event.relatedTarget` – это элемент, *на который* курсор перешёл (`target` → `relatedTarget`).

В примере ниже каждое лицо и его черты – отдельные элементы. При движении указателя по этим элементам в текстовом поле отображаются происходящие события.

Каждое из них содержит информацию о `target` и `relatedTarget`:

[Тестовый стенд](../src/12_ui/test_01/)

!!! warning "Свойство `relatedTarget` может быть `null`"
    Свойство `relatedTarget` может быть `null`.

    Это нормально и означает, что указатель мыши перешёл не с другого элемента, а из-за пределов окна браузера. Или же, наоборот, ушёл за пределы окна.

    Следует держать в уме такую возможность при использовании `event.relatedTarget` в своём коде. Если, например, написать `event.relatedTarget.tagName`, то при отсутствии `event.relatedTarget` будет ошибка.

#### Пропуск элементов
Событие `mousemove` происходит при движении мыши. Однако, это не означает, что указанное событие генерируется при прохождении каждого пикселя.

Браузер периодически проверяет позицию курсора и, заметив изменения, генерирует события `mousemove`.

Это означает, что если пользователь двигает мышкой очень быстро, то некоторые DOM-элементы могут быть пропущены:

![Mouseover mouseout over elems](../svg/mouseover-mouseout-over-elems.svg)

Если курсор мыши передвинуть очень быстро с элемента `#FROM` на элемент `#TO`, как это показано выше, то лежащие между ними элементы `<div>` (или некоторые из них) могут быть пропущены. Событие `mouseout` может запуститься на элементе `#FROM` и затем сразу же сгенерируется `mouseover` на элементе `#TO`.

Это хорошо с точки зрения производительности, потому что если промежуточных элементов много, вряд ли мы действительно хотим обрабатывать вход и выход для каждого.

С другой стороны, мы должны иметь в виду, что указатель мыши не «посещает» все элементы на своём пути. Он может и «прыгать».

В частности, возможно, что указатель запрыгнет в середину страницы из-за пределов окна браузера. В этом случае значение `relatedTarget` будет `null`, так как курсор пришёл «из ниоткуда»:

![Mouseover mouseout from outside](../svg/mouseover-mouseout-from-outside.svg)

Вы можете проверить это «вживую» на тестовом стенде ниже.

В его HTML есть два элемента, `<div id="child">` вложен в `<div id="parent">`. Если быстро провести мышью над ними, то событие может возникнуть только на внутреннем элементе или только на внешнем, а может вообще не сгенерироваться никаких событий.

Также попробуйте поставить курсор на внутренний элемент, а затем очень быстро сделайте движение мышкой вниз через внешний элемент. Если у вас получится достаточно быстро, то на родительском элементе не будет сгенерировано никаких событий. То есть, мышь пройдёт через внешний элемент, не замечая его.

[Тестовый стенд](../src/12_ui/test_02/)

!!! info "Если был `mouseover`, то будет и `mouseout`"
    Несмотря на то, что при быстрых переходах промежуточные элементы могут игнорироваться, в одном мы можем быть уверены: элемент может быть пропущен только целиком.

    Если указатель «официально» зашёл на элемент, то есть было событие `mouseover`, то при выходе с него обязательно будет `mouseout`.

#### Событие mouseout при переходе на потомка
Важная особенность события `mouseout` – оно генерируется в том числе, когда указатель переходит с элемента на его потомка.

То есть, визуально указатель всё ещё на элементе, но мы получим `mouseout`!

![Mouseover to child](../svg/mouseover-to-child.svg)

Это выглядит странно, но легко объясняется.

**По логике браузера, курсор мыши может быть только над одним элементом в любой момент времени – над самым глубоко вложенным и верхним по z-index.**

Таким образом, если курсор переходит на другой элемент (пусть даже дочерний), то он покидает предыдущий.

Обратите внимание на важную деталь.

Событие `mouseover`, происходящее на потомке, всплывает. Поэтому если на родительском элементе есть такой обработчик, то оно его вызовет.

![Mouseover bubble nested](../svg/mouseover-bubble-nested.svg)

Наглядно увидеть это можно в примере ниже: `<div id="child">` находится внутри `<div id="parent">`. На родителе определены обработчики событий `mouseover`/`out`, которые выводят информацию о них в текстовое поле.

При переходе мышью с внешнего элемента на внутренний, вы увидите сразу два события: `mouseout [target: parent]` (ушли с родителя) и `mouseover [target: child]` (перешли на потомка, событие всплыло).

[Тестовый стенд](../src/12_ui/test_03/)

При переходе с родителя элемента на потомка – на родителе сработают два обработчика: и `mouseout` и `mouseover`:
```js
parent.onmouseout = function(event) {
  /* event.target: внешний элемент */
};
parent.onmouseover = function(event) {
  /* event.target: внутренний элемент (всплыло) */
};
```

Если код внутри обработчиков не смотрит на `target`, то он подумает, что мышь ушла с элемента `parent` и вернулась на него обратно. Но это не так! Мышь никуда не уходила, она просто перешла на потомка.

Если при уходе с элемента что-то происходит, например, запускается анимация, то такая интерпретация происходящего может давать нежелательные побочные эффекты.

Чтобы этого избежать, можно смотреть на `relatedTarget` и, если мышь всё ещё внутри элемента, то игнорировать такие события.

Или же можно использовать другие события: `mouseenter` и `mouseleave`, которые мы сейчас изучим, с ними такая проблема не возникает.

#### События mouseenter и mouseleave
События `mouseenter`/`mouseleave` похожи на `mouseover`/`mouseout`. Они тоже генерируются, когда курсор мыши переходит на элемент или покидает его.

Но есть и пара важных отличий:

1. Переходы внутри элемента, на его потомки и с них, не считаются.
2. События `mouseenter`/`mouseleave` не всплывают.

События `mouseenter`/`mouseleave` предельно просты и понятны.

Когда указатель появляется над элементом – генерируется `mouseenter`, причём не имеет значения, где именно указатель: на самом элементе или на его потомке.

Событие `mouseleave` происходит, когда курсор покидает элемент.

Вот тот же пример, что и выше, но на этот раз на верхнем элементе стоят обработчики `mouseenter`/`mouseleave` вместо `mouseover`/`mouseout`.

Как можно увидеть, генерируются только события, связанные с движением курсора относительно верхнего `<div>`. Ничего не произойдёт при переходе на внутренний `<div>` и обратно. Переходы на потомки игнорируются.

[Тестовый стенд](../src/12_ui/test_04/)

#### Делегирование событий
События `mouseenter`/`leave` просты и легки в использовании. Но они не всплывают. Таким образом, мы не можем их делегировать.

Представьте ситуацию, когда мы хотим обрабатывать события, сгенерированные при движении курсора по ячейкам таблицы. И в таблице сотни ячеек.

Очевидное решение – определить обработчик на родительском элементе `<table>` и там обрабатывать возникающие события. Но, так как `mouseenter`/`leave` не всплывают, то если событие происходит на ячейке `<td>`, то только обработчик на `<td>` может поймать его.

Обработчики событий `mouseenter`/`leave` на `<table>` срабатывают, если курсор оказывается над таблицей в целом или же уходит с неё. Невозможно получить какую-либо информацию о переходах между ячейками внутри таблицы.

Что ж, не проблема – будем использовать `mouseover`/`mouseout`.

Начнём с простых обработчиков, которые выделяют текущий элемент под указателем мыши:
```js
// выделим элемент под мышью
table.onmouseover = function(event) {
  let target = event.target;
  target.style.background = 'pink';
};

table.onmouseout = function(event) {
  let target = event.target;
  target.style.background = '';
};
```

Вот они в действии. При переходе между элементами этой таблицы, текущий будет подсвечен:

[Тестовый стенд](../src/12_ui/test_05/)

![Bagua square](../img/bagua-square_1.png)

В нашем случае мы хотим обрабатывать переходы именно между ячейками `<td>`: вход на ячейку и выход с неё. Прочие переходы, в частности, внутри ячейки `<td>` или вообще вне любых ячеек, нас не интересуют, хорошо бы их отфильтровать.

Можно достичь этого так:

- Запоминать текущую ячейку `<td>` в переменную, которую назовём `currentElem.
- На `mouseover` – игнорировать событие, если мы всё ещё внутри той же самой ячейки `<td>`.
- На `mouseout` – игнорировать событие, если это не уход с текущей ячейки `<td>`.

Вот пример кода, учитывающего все ситуации:
```js
// ячейка <td> под курсором в данный момент (если есть)
let currentElem = null;

table.onmouseover = function(event) {
  // перед тем, как войти на следующий элемент, курсор всегда покидает предыдущий
  // если currentElem есть, то мы ещё не ушли с предыдущего <td>,
  // это переход внутри - игнорируем такое событие
  if (currentElem) return;

  let target = event.target.closest('td');

  // переход не на <td> - игнорировать
  if (!target) return;

  // переход на <td>, но вне нашей таблицы (возможно при вложенных таблицах)
  // игнорировать
  if (!table.contains(target)) return;

  // ура, мы зашли на новый <td>
  currentElem = target;
  target.style.background = 'pink';
};


table.onmouseout = function(event) {
  // если мы вне <td>, то игнорируем уход мыши
  // это какой-то переход внутри таблицы, но вне <td>,
  // например с <tr> на другой <tr>
  if (!currentElem) return;

  // мы покидаем элемент – но куда? Возможно, на потомка?
  let relatedTarget = event.relatedTarget;

  while (relatedTarget) {
    // поднимаемся по дереву элементов и проверяем – внутри ли мы currentElem или нет
    // если да, то это переход внутри элемента – игнорируем
    if (relatedTarget == currentElem) return;

    relatedTarget = relatedTarget.parentNode;
  }

  // мы действительно покинули элемент
  currentElem.style.background = '';
  currentElem = null;
};
```

Полный пример со всеми деталями:

[Тестовый стенд](../src/12_ui/test_06/)

Можно попробовать подвигать курсор между ячейками и внутри них. Быстро или медленно – без разницы. В отличие от предыдущего примера выделяется только сама ячейка `<td>`.

#### Итого
Мы рассмотрели события `mouseover`, `mouseout`, `mousemove`, `mouseenter` и `mouseleave`.

Особенности, на которые стоит обратить внимание:

- При быстром движении мыши события не будут возникать на промежуточных элементах.
- События `mouseover`/`out` и `mouseenter`/`leave` имеют дополнительное свойство: `relatedTarget`. Оно дополняет свойство `target` и содержит ссылку на элемент, с/на который мы переходим.

События `mouseover`/`out` возникают, даже когда происходит переход с родительского элемента на потомка. С точки зрения браузера, курсор мыши может быть только над одним элементом в любой момент времени – над самым глубоко вложенным.

События `mouseenter`/`leave` в этом отличаются. Они генерируются, когда курсор переходит на элемент в целом или уходит с него. Также они не всплывают.

#### Задачи

##### Улучшенная подсказка

Напишите JavaScript код, который показывает подсказку над элементом с атрибутом `data-tooltip`. Значение атрибута должно становиться текстом подсказки.

Это похоже на задачу [Поведение "подсказка"](./11_events.md#поведение-подсказка), но здесь элементы с подсказками могут быть вложены друг в друга. Показываться должна подсказка на самом глубоко вложенном элементе.

Только одна подсказка может быть показана в любой момент времени.

Например:
```html
<div data-tooltip="Здесь - домашний интерьер" id="house">
  <div data-tooltip="Здесь - крыша" id="roof"></div>
  ...
  <a href="https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%B8_%D0%BF%D0%BE%D1%80%D0%BE%D1%81%D1%91%D0%BD%D0%BA%D0%B0" data-tooltip="Читать далее…">Наведи курсор на меня</a>
</div>
```

Результат в iframe:

![Improved tooltip](../img/improved-tooltip_1.png)

![Improved tooltip](../img/improved-tooltip_2.png)

<details>
<summary>Решение</summary>

![Код решения](../src/12_ui/improved-tooltip.html)

</details>

##### "Умная" подсказка

Напишите функцию, которая показывает подсказку над элементом только в случае, когда пользователь передвигает мышь *на него*, но не *через него*.

Другими словами, если пользователь подвинул курсор на элементе и остановился – показывать подсказку. А если он просто быстро провёл курсором по элементу, то не надо ничего показывать. Кому понравится лишнее мелькание?

Технически, мы можем измерять скорость прохода курсора мыши над элементом, и если она низкая, то можно посчитать, что пользователь остановил курсор над элементом, и показать ему подсказку. А если скорость высокая, то тогда не показывать.

Создайте для этого универсальный объект `new HoverIntent(options)`.

Его настройки `options`:

- `elem` – отслеживаемый элемент.
- `over` – функция, вызываемая, при заходе на элемент, считаем что заход – это когда курсор медленно двигается или остановился над элементом.
- `out` – функция, вызываемая при уходе курсора с элемента (если был заход).

Пример использования такого объекта для показа подсказки:
```js
// пример подсказки
let tooltip = document.createElement('div');
tooltip.className = "tooltip";
tooltip.innerHTML = "Tooltip";

// объект будет отслеживать движение мыши и вызывать функции over/out
new HoverIntent({
  elem,
  over() {
    tooltip.style.left = elem.getBoundingClientRect().left + 'px';
    tooltip.style.top = elem.getBoundingClientRect().bottom + 5 + 'px';
    document.body.append(tooltip);
  },
  out() {
    tooltip.remove();
  }
});
```

Если двигать курсор над «часами» быстро, то ничего не произойдёт, а если вы замедлите движение курсора над элементом или остановите его, то будет показана подсказка.

Обратите внимание: подсказка не должна пропадать (мигать), когда курсор переходит между дочерними элементами часов.

<details>
<summary>Решение</summary>

Алгоритм выглядит просто:

1. Назначаем обработчики `onmouseover`/`out` на элементе. Также можно было бы использовать `onmouseenter`/`leave`, но они менее универсальны и не сработают с делегированием.
2. Когда курсор переходит на элемент, начинаем измерять скорость его движения, используя `mousemove`.
3. Если скорость низкая, то вызываем `over`.
4. Когда мы выходим из элемента, если запускали `over`, вызываем `out`.

Но как измерить скорость?

Первая идея может быть такой: запускать нашу функцию каждые `100ms` и находить разницу между прежними и текущими координатами курсора. Если она мала, то значит и скорость низкая.

К сожалению, в JavaScript нет возможности получать текущие координаты мыши. Не существует функции типа `получитьТекущиеКоординатыМыши()`.

Единственный путь – это слушать события мыши, например `mousemove`, и координаты брать из объекта события.

Так что поставим обработчик на `mousemove`, чтобы отслеживать координаты и запоминать их. И будем сравнивать результаты каждые `100ms`.

P.S. Обратите внимание: тесты для решения этой задачи используют `dispatchEvent`, чтобы проверить, что подсказка работает корректно.

![Код решения](../src/12_ui/clever-tooltip)

</details>

### Перетаскивание элементов

#### Drag'n'Drop с событиями мыши
**Drag-and-Drop API** позволяет переносить различные элементы мышью на определенную позицию на веб-странице. При перемещении элементов у нас есть <dfn title="источник перемещения">источник перемещения</dfn> — элемент, который перемещаем мышью, и <dfn title="цель перемещения">цель перемещения</dfn> — целевая область на веб-странице (другой элемент), на которую надо переместить источник перемещения.[^25.1]

Чтобы определить элемент на веб-странице, который можно перемещать (источник перетаскивания), нужно для этого элемент определить атрибут **`draggable`** со значением **`true`**. Теоретически в качестве перетаскиваемого элемента может выступать любой элемент веб-страницы. Например:
```html
<div style="width:50px;height:50px; background-color: red;" draggable="true"></div>
```

По умолчанию элементы не являются перетаскиваемыми.

В качестве цели перетаскиванию может служить произвольный элемент веб-страницы.

После того, как элемент определен как перемещаемый, надо также определить действия, выполняемые при перемещении элемента. Во время операции перетаскивания запускается ряд различных событий:

- **`dragstart`**: генерируется, когда начинается перетаскивание элемента

- **`drag`**: генерируется постоянно по мере того, как элемент перетаскивается

- **`dragend`**: генерируется, когда перетаскивание элемента завершено

- **`dragenter`**: генерируется, когда элемент входит в границы целевой области

- **`dragover`**: генерируется постоянно (несколько раз в секунду) по мере того, как элемент перетаскивается над целевой областью

- **`dragleave`**: генерируется, когда элемент покидает целевую область

- **`drop`**: генерируется, перетаскиваемый элемент отпускается на целевой области

Обработчики всех выше перечисленных событий перемещения в качестве параметра получают объект типа **`DragEvent`**. Этот тип наследует свойства от `MouseEvent` и соответственно типа `Event`.

Обработчик события **`dragstart`** определяется для перетаскиваемого элемента, а обработчики остальных событий определяются для области, на которую надо переместить элемент. Например:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
    <style>
    #source { width:50px; height:50px; background-color: red; display: inline-block;}
    #target {width: 200px; height: 150px; overflow: hidden; border: #ccc 1px dashed;}
    div{margin:5px;}
    </style>
</head>
<body>
<div id="source" draggable="true"></div>
<div id="target"></div>
<script>
const source = document.getElementById("source");
source.addEventListener("dragstart", () => console.log("Drag operation started"));

const target = document.getElementById("target");
target.addEventListener("dragover", (event) => {
    event.preventDefault();
    console.log("Dragover operation");
});
target.addEventListener("drop", () => console.log("Drag operation finished"));
</script>
</body>
</html>
```

В данном случае перемещаемый элемент имеет идентификатор `source`, и для него регистрируется обработчик события "dragstart". Оно будет возникать, когда мы захватим элемент указателем мыши и начнем перемещать.

Область, на которую перемещаем элемент, представляет другой элемент с идентификатором `target`. Для демонстрации для него регистрируем обработчики событий "dragover" и "drop". Событие "dragover" будет возникать, когда элемент `item` будет перемещаться поверх элемента `target`. Чтобы предупредить генерацию события "drop" во время перемещения, в обработчике этого события вызывается метод `event.preventDefault()`. Когда мы отпустим элемент `item` на элемент `target`, будет сгенерировано событие "drop".

![Drag&Drop API в JavaScript](../img/dragdrop3.png)

Однако в выше приведенном примере в реальности перетаскиваемый элемент пока никуда не перемещается. Потому что нам надо установать перемещаемые данные и при завершении перемещения получить их. Например:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
    <style>
    #source { width:50px; height:50px; background-color: red; display: inline-block;}
    #target {width: 200px; height: 150px; overflow: hidden; border: #ccc 1px dashed;}
    div{margin:5px;}
    </style>
</head>
<body>
<div id="source" draggable="true"></div>
<div id="target"></div>
<script>
let dragged = null; // перемещенные данные
// источник перемещения
const source = document.getElementById("source")
// в обработчике устанавливаем ссылку на перетаскиваемый элемент
source.addEventListener("dragstart", (e) => dragged = e.target);

// целевая область перемещения
const target = document.getElementById("target");
// предупреждаем событие drop
target.addEventListener("dragover", (e) => e.preventDefault());
// копируем перетаскиваемый элемент и помещаем его копию на целевую область
target.addEventListener("drop", (e) => e.target.appendChild(dragged.cloneNode()));
</script>
</body>
</html>
```

Здесь при начале перетаскивания мы сохраняем перемещаемый объект в переменную `dragged`
```js
source.addEventListener("dragstart", (e) => dragged = e.target);
```

При окончании перетаскивания помещаем копию элемента `source` на элемент `target`
```js
target.addEventListener("drop", (e) => e.target.appendChild(dragged.cloneNode()));
```

Таким образом, при перетаскивании на область `target` будут добавляться копии элемента `source`:

![Drag-and-Drop API в JavaScript](../img/dragdrop1.png)

В качестве альтернативы мы можем выполнить полное перемещение перетаскиваемого элемента:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
    <style>
    #source { width:50px; height:50px; background-color: red; display: inline-block;}
    #target {width: 200px; height: 150px; overflow: hidden; border: #ccc 1px dashed;}
    div{margin:5px;}
    </style>
</head>
<body>
<div id="target"></div>
<div id="source" draggable="true"></div>
<script>
let dragged = null; // перемещенные данные
// источник перемещения
const source = document.getElementById("source")
// в обработчике устанавливаем ссылку на перетаскиваемый элемент
source.addEventListener("dragstart", (e) => dragged = e.target);

// целевая область перемещения
const target = document.getElementById("target");
// предупреждаем событие drop
target.addEventListener("dragover", (e) => e.preventDefault());
// полностью перемещаем перетаскиваемый элемент на целевую область
target.addEventListener("drop", (e) => {
    dragged.parentNode.removeChild(dragged);
    e.target.appendChild(dragged);
});
</script>
</body>
</html>
```

Здесь в обработчике "drop" сначала удаляем перетаскиваемый элемент из родительского контейнера (в данном случае элемента `body`), а затем добавляем его на целевую область:
```js
target.addEventListener("drop", (e) => {
    dragged.parentNode.removeChild(dragged);
    e.target.appendChild(dragged);
});
```

![Перемещение элементов с помощью Drag-and-Drop API в JavaScript](../img/dragdrop2.png)

### События клавиатуры
Другим распространенным типом событий являются события клавиатуры.[^9.6]

- `keydown`: возникает при нажатии клавиши клавиатуры и длится, пока нажата клавиша

- `keyup`: возникает при отпускании клавиши клавиатуры

- `keypress`: возникает при нажатии клавиши клавиатуры, но после события `keydown` и до события `keyup`. Надо учитывать, что данное событие генерируется только для тех клавиш, которые формируют вывод в виде символов, например, при печати символов. Нажатия на остальные клавиши, например, на <kbd>Alt</kbd>, не учитываются.

Для работы с событиями клавиатуры определен объект **`KeyboardEvent`**, который добавляет к свойствам объекта `Event` ряд специфичных для клавиатуры свойств:

- **`altKey`**: возвращает `true`, если была нажата клавиша <kbd>Alt</kbd> во время генерации события

- **`key`**: возвращает символ нажатой клавиши, например, при нажатии на клавишу <kbd>T</kbd> это свойство будет содержать "T". А если нажата клавиша <kbd>Я</kbd>, то это свойство будет содержать "Я"

- **`code`**: возвращает строковое представление нажатой клавиши физической клавиатуры QWERTY, например, при нажатии на клавишу <kbd>T</kbd> это свойство будет содержать "KeyT", а при нажатии на клавишу <kbd>;</kbd> (точка запятой), то свойство возвратит "Semicolon".

  При использовании этого свойства следует учитывать ряд момент. Прежде всего используется клавиатура QWERTY. То есть мы переключим раскладку, к примеру, на русскоязычную и нажмем на клавишу <kbd>Я</kbd>, то значением будет "KeyZ" — на клавиатуре QWERTY клавиша <kbd>Z</kbd> представляет ту же клавишу, что и на русскоязычной раскладке <kbd>Я</kbd>

  Другой момент — учитывается именно физическая клавитура. Если нажата клавиша на виртуальной клавиатуре, то возвращаемое значение будет устанавливаться браузером исходя из того, какой клавише на физической клавиатуре соответствовало нажатие.

- **`ctrlKey`**: возвращает `true`, если была нажата клавиша <kbd>Ctrl</kbd> во время генерации события

- **`metaKey`**: возвращает `true`, если была нажата во время генерации события метаклавиша клавиатуры

- **`shiftKey`**: возвращает `true`, если была нажата клавиша <kbd>Shift</kbd> во время генерации события

Например, мы можем с помощью клавиш клавиатуры перемещать элемент на веб-странице:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>METANIT.COM</title>
    <style>
    #blueRect{
        width:100px;
        height:100px;
        background-color:blue;
    }
    </style>
</head>
<body>
<div id="blueRect"></div>

<script>
const blueRect = document.getElementById("blueRect");
// получаем стиль для blueRect
const blueRectStyle = window.getComputedStyle(blueRect);
// устанавливаем обработчик нажатия клавиши
window.addEventListener("keydown", moveRect);

function moveRect(e){
    const left = parseInt(blueRectStyle.marginLeft); //смещение от левого края
    const top = parseInt(blueRectStyle.marginTop);  // смещения от левой границы

    switch(e.key){

        case "ArrowLeft":  // если нажата клавиша влево
            if(left>0)
                blueRect.style.marginLeft = left - 10 + "px";
            break;
        case "ArrowUp":   // если нажата клавиша вверх
            if(top>0)
                blueRect.style.marginTop = top - 10 + "px";
            break;
        case "ArrowRight":   // если нажата клавиша вправо
            if(left < document.documentElement.clientWidth - 100)
                blueRect.style.marginLeft = left + 10 + "px";
            break;
        case "ArrowDown":   // если нажата клавиша вниз
            if(top < document.documentElement.clientHeight - 100)
                blueRect.style.marginTop = top + 10 + "px";
            break;
    }
}
</script>
</body>
</html>
```

В данном случае обрабатывается событие `keydown`, в обработчке которого управляем стилевыми свойствами элемента `blueRect`. Так как при прикреплении обработчика стиль элемента может быть не установлен, то явным образом вычисляем его с помощью метода `window.getComputedStyle()`:
```js
const blueRectStyle = window.getComputedStyle(blueRect);
```
В обработчике события из этого стиля выбираем значения свойств `marginLeft` и `marginTop`.

```js
const left = parseInt(blueRectStyle.marginLeft); //смещение от левого края
const top = parseInt(blueRectStyle.marginTop);  // смещения от левой границы
```

Затем м помощью свойства `e.key` получаем нажатую клавишу. Список кодов клавиш клавиатуры можно посмотреть на странице https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values.

Здесь нам интересуют четыре клавиши: вверх, вниз, влево, вправо. Им соответственно будут соответствовать названия "ArrowUp", "ArrowDown", "ArrowLeft" и "ArrowRight". Если одна из них нажата, производим действия: увеличение или уменьшение отступа элемента от верхней или левой границы. Ну и чтобы элемент не выходил за границы окна, проверяем предельные значения с помощью `document.documentElement.clientWidth` (ширина корневого элемента) и `document.documentElement.clientHeight` (высота корневого элемента).

Стоит отметить, что этот код не очень оптимален, поскольку для проверки значений нам приходится вычислять положение `blueRect` по горизонтали и вертикали. Плюс необходимо вычислять при каждом вызове обработчика проверяем правый (`document.documentElement.clientWidth - 100`) и нижний край (`document.documentElement.clientHeight - 100;`) области документа, чтобы `blueRect` не вышел за предел видимого пространства. В этом случае мы можем добавить дополнительные абстракции в виде текущих координат `blueRect` и положения правой и нижней границ видимой области. Так, изменим код JavaScript следующим образом:
```js
const blueRect = document.getElementById("blueRect");
const position = [20, 20];  // позиция blueRect

// перемещаем blueRect на позицию в position
function setPosition() {
    blueRect.style.marginLeft = position[0] + "px";
    blueRect.style.marginTop = position[1] + "px";
}

function init(){
    const rightLimit = document.documentElement.clientWidth - 100;  // правый край
    const bottomLimit = document.documentElement.clientHeight - 100;    // нижний край

    setPosition();  // устанавливаем начальную позицию для blueRect

    function moveRect(e){
        switch(e.key){

        case "ArrowLeft":  // если нажата клавиша влево
            if(position[0] > 0)
                position[0] = position[0] - 10;
            break;
        case "ArrowUp":   // если нажата клавиша вверх
            if(position[1] > 0)
                position[1] = position[1] - 10;
            break;
        case "ArrowRight":   // если нажата клавиша вправо
            if(position[0] < rightLimit)
                position[0] = position[0] + 10;
            break;
        case "ArrowDown":   // если нажата клавиша вниз
            if(position[1] < bottomLimit)
                position[1] = position[1] + 10;
            break;
        }
        setPosition();
    }
    window.addEventListener("keydown", moveRect);
}
//  при загрузке страницы выполняем функцию init
window.addEventListener("load", init);
```

Теперь координаты `blueRect` хранятся в массиве `position`, где первое значение — это отступ слева, а второе значение — отступ сверху. Чтобы по этим координатам установить реальную позицию `blueRect` на странице определена функция `setPosition`.

```js
const position = [20, 20];  // позиция blueRect

// перемещаем blueRect на позицию в position
function setPosition() {
    blueRect.style.marginLeft = position[0] + "px";
    blueRect.style.marginTop = position[1] + "px";
}
```

Прикрепляем к событию загрузки окна — **`load`** обработчик — функцию `init`:
```js
window.addEventListener("load", init);
```

В функции `init` определяем правый и нижний край для перемещения `blueRect`, а также устанавливаем его начальную позицию:
```js
const rightLimit = document.documentElement.clientWidth - 100;  // правый край
const bottomLimit = document.documentElement.clientHeight - 100;    // нижний край
setPosition();  // устанавливаем начальную позицию для blueRect
```

Далее определяем обработчик `moveRect`, в котором изменяем значения в массиве `position`:
```js
function moveRect(e){
    switch(e.key){

    case "ArrowLeft":  // если нажата клавиша влево
        if(position[0] > 0)
            position[0] = position[0] - 10;
        break;
    //............
    }
    setPosition();
}
```

И после всех изменений переустанавливаем позицию с помощью функции `setPosition`.

В конце прикрепляем обработчик к нажатию клавиши клавиатуры:
```js
window.addEventListener("keydown", moveRect);
```

### Глоссарий
[^9.5]: [События мыши](https://metanit.com/web/javascript/9.5.php)
[^9.6]: [События клавиатуры](https://metanit.com/web/javascript/9.6.php)
[^mouse-events-basics]: [Основы событий мыши](https://learn.javascript.ru/mouse-events-basics)
[^mousemove-mouseover-mouseout-mouseenter-mouseleave]: [Движение мыши: mouseover/out, mouseenter/leave](https://learn.javascript.ru/mousemove-mouseover-mouseout-mouseenter-mouseleave)
[^25.1]: [Перетаскивание элементов с помощью Drag-and-Drop API](https://metanit.com/web/javascript/25.1.php)
