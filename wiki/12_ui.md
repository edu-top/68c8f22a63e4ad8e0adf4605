## Интерфейсные события

- [Интерфейсные события](#интерфейсные-события)
  - [События мыши](#события-мыши)
    - [Типы событий мыши](#типы-событий-мыши)
    - [Порядок событий](#порядок-событий)
    - [MouseEvent](#mouseevent)
    - [Кнопки мыши](#кнопки-мыши)
    - [Модификаторы: shift, alt, ctrl и meta](#модификаторы-shift-alt-ctrl-и-meta)
    - [Координаты: clientX/Y, pageX/Y](#координаты-clientxy-pagexy)
    - [Отключаем выделение](#отключаем-выделение)
    - [Итого](#итого)
    - [Задачи](#задачи)
  - [События клавиатуры](#события-клавиатуры)
  - [Глоссарий](#глоссарий)

### События мыши
В этой секции более детально будут рассмотрены события мыши и их свойства. События мыши представляют собой одну из наиболее часто используемых групп событий.

Сразу заметим: эти события бывают не только из-за мыши, но и эмулируются на других устройствах, в частности, на мобильных, для совместимости.

#### Типы событий мыши

- `mousedown`: возникает при нахождении указателя мыши на элементе, когда кнопка мыши находится в нажатом состоянии

- `mouseup`: возникает при нахождении указателя мыши на элементе во время отпускания кнопки мыши

- `click`: возникает при нажатии указателем мыши на элемент. Вызывается при `mousedown` , а затем `mouseup` над одним и тем же элементом, если использовалась левая кнопка мыши.

- `dblclick`: возникает при двойном нажатии указателем мыши на элемент

- `contextmenu`: вызывается при попытке открытия контекстного меню, как правило, нажатием правой кнопки мыши. Но, заметим, это не совсем событие мыши, оно может вызываться и специальной клавишей клавиатуры.

- `mousemove`: возникает при прохождении указателя мыши над элементом. Каждое движение мыши над элементом генерирует это событие.

- `mouseover`: возникает при вхождении указателя мыши в границы элемента

- `mouseout`: возникает, когда указатель мыши выходит за пределы элемента

- `mouseenter`: возникает при вхождении указателя мыши в границы элемента

- `mouseleave`: возникает, когда указатель мыши выходит за пределы элемента

Отдельно стоит сказать про разницу между последними четырьмя событиями. `mouseenter` и `mouseleave` срабатывают только тогда, когда пересекается внешний край соответствующего элемента. А события `mouseover` и `mouseout` также срабатывают, когда другой элемент находится внутри соответствующего элемента и курсор мыши перемещается во внутренний элемент (т.е. уходит от внешнего элемента) или покидает внутренний элемент (то есть перемещается на внешний элемент).

Например, обработаем события `mouseover` и `mouseout`:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>METANIT.COM</title>
    <style>
    #blueRect{
        width:100px;
        height:100px;
        background-color:blue;
    }
    </style>
</head>
<body>
<div id="blueRect"></div>

<script>
function setColor(e){
    if(e.type==="mouseover")
        e.target.style.backgroundColor = "red";
    else if(e.type==="mouseout")
        e.target.style.backgroundColor = "blue";
}
const blueRect = document.getElementById("blueRect");
blueRect.addEventListener("mouseover", setColor);
blueRect.addEventListener("mouseout", setColor);
</script>
</body>
</html>
```

Теперь при наведении указателя мыши на блок `blueRect` он будет окрашиваться в красный цвет, а при уходе указателя мыши — блок будет обратно окрашиваться в синий цвет.

#### Порядок событий
Как вы можете видеть из приведённого выше списка, действие пользователя может вызвать несколько событий.

Например, клик мышью вначале вызывает `mousedown`, когда кнопка нажата, затем `mouseup` и click, когда она отпущена.

В случае, когда одно действие инициирует несколько событий, порядок их выполнения фиксирован. То есть обработчики событий вызываются в следующем порядке: `mousedown` → `mouseup` → `click`.

Ниже показана запись событий мыши, зафиксированных регистратором (скриптом).

![Mouse events](../img/mouse-events-logger.png)

В окне теста ниже все события мыши записываются, и если задержка между ними более 1 секунды, то они разделяются горизонтальной чертой. Зафиксирован следующий порядок вызов событий: левый клик, правый клик, клик средней кнопкой (колесом) и двойной клик левой кнопкой мыши.

Кроме того, мы можем видеть свойство `button`, которое позволяет нам определять кнопку мыши; это объясняется ниже.[^mouse-events-basics]

#### MouseEvent
Объект `Event` является общим для всех событий. Однако для разных типов событий существуют также свои объекты событий, которые добавляют ряд своих свойств. Так, для работы с событиями указателя мыши определен объект **`MouseEvent`**, который добавляет следующие свойства:[^9.5]

- **`altKey`**: возвращает `true`, если была нажата клавиша `Alt` во время генерации события

- **`button`**: содержит номер нажатой кнопки мыши

- **`buttons`**: содержит номер, который представляет нажатую кнопку мыши. 1 обозначает левую кнопку мыши, 2 — правую кнопку мыши, 4 — колесо мыши или среднюю кнопку мыши, 8 — четвертую кнопку мыши, а 16 — пятую кнопку мыши. Если при срабатывании события было нажато несколько кнопок, это свойство содержат сумму соответствующих чисел.

- **`clientX`**: определяет координату Х окна браузера, на которой находился указатель мыши во время генерации события

- **`clientY`**: определяет координату Y окна браузера, на которой находился указатель мыши во время генерации события

- **`ctrlKey`**: возвращает `true`, если была нажата клавиша <kbd>Ctrl</kbd> во время генерации события

- **`movementX`**: содержит координату Х относительно предыдущей координаты X при последнем событии перемещения мыши

- **`movementY`**: содержит координату Y относительно предыдущей координаты Y при последнем событии перемещения мыши

- **`metaKey`**: возвращает `true`, если была нажата во время генерации события метаклавиша клавиатуры

- **`region`**: содержит идентификатор области или элемента, которая относится к событию

- **`relatedTarget`**: определяет вторичный источник возникновения события

- **`screenX`**: определяет координату Х относительно верхнего левого угла экрана монитора, на которой находился указатель мыши во время генерации события

- **`screenY`**: определяет координату Y относительно верхнего левого угла экрана монитора, на которой находился указатель мыши во время генерации события

- **`shiftKey`**: возвращает `true`, если была нажата клавиша <kbd>Shift</kbd> во время генерации события

Определим координаты клика:
```js
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <style>
    #blueRect{
        width:100px;
        height:100px;
        background-color:blue;
    }
    </style>
</head>
<body>
<div id="blueRect"></div>

<script>
function handleClick(e){
    console.log("screenX: " + e.screenX);
    console.log("screenY: " + e.screenY);
    console.log("clientX: " + e.clientX);
    console.log("clientY: " + e.clientY);
}
const blueRect = document.getElementById("blueRect");
blueRect.addEventListener("click", handleClick);
</script>
</body>
</html>
```

#### Кнопки мыши
События, связанные с кликом, всегда имеют свойство `button`, которое позволяет получить конкретную кнопку мыши.

Обычно мы не используем его для событий `click` и `contextmenu`, потому что первое происходит только при щелчке левой кнопкой мыши, а второе – только при щелчке правой кнопкой мыши.

С другой стороны, обработчикам `mousedown` и `mouseup` может потребоваться `event.button`, потому что эти события срабатывают на любую кнопку, таким образом `button` позволяет различать «нажатие правой кнопки» и «нажатие левой кнопки».

Возможными значениями `event.button` являются:

| Состояние кнопки                 | `event.button` |
| -------------------------------- | ------------ |
| Левая кнопка (основная)          | 0            |
| Средняя кнопка (вспомогательная) | 1            |
| Правая кнопка (вторичная)        | 2            |
| Кнопка X1 (назад)                | 3            |
| Кнопка X2 (вперёд)               | 4            |

Большинство мышек имеют только левую и правую кнопку, поэтому возможные значения это 0 или 2. Сенсорные устройства также генерируют аналогичные события, когда кто-то нажимает на них.

Также есть свойство `event.buttons`, в котором все нажатые в данный момент кнопки представлены в виде целого числа, по одному биту на кнопку. На практике это свойство используется очень редко, вы можете найти подробную информацию по адресу [MDN](https://developer.mozilla.org/ru/docs/Web/api/MouseEvent/buttons), если вам это когда-нибудь понадобится.

!!! warning "Устаревшее свойство `event.which`"

    В старом коде вы можете встретить `event.which` свойство – это старый нестандартный способ получения кнопки с возможными значениями:

    - `event.which == 1` – левая кнопка,
    - `event.which == 2` – средняя кнопка,
    - `event.which == 3` – правая кнопка.

    На данный момент `event.which` устарел, нам не следует его использовать.

Средняя кнопка сейчас – скорее экзотика, и используется очень редко.

#### Модификаторы: shift, alt, ctrl и meta
Все события мыши включают в себя информацию о нажатых клавишах-модификаторах.

Свойства события:

- `shiftKey`: <kbd>Shift</kbd>
- `altKey`: <kbd>Alt</kbd> (или <kbd>Opt</kbd> для Mac)
- `ctrlKey`: <kbd>Ctrl</kbd>
- `metaKey`: <knf>Cmd</knf> для Mac

Они равны `true`, если во время события была нажата соответствующая клавиша.

Например, кнопка внизу работает только при комбинации <kbd>Alt</kbd>+<kbd>Shift</kbd>+клик:
```html
<button id="button">Нажми Alt+Shift+Click на мне!</button>

<script>
  button.onclick = function(event) {
    if (event.altKey && event.shiftKey) {
      alert('Ура!');
    }
  };
</script>
```

![Alt+Shit+click](../img/alt-shift-click.png)

!!! warning "Внимание: обычно на Mac используется клавиша `Cmd` вместо `Ctrl`"
    В Windows и Linux клавишами-модификаторами являются <kbd>Alt</kbd>, <kbd>⇧ Shift</kbd> и <kbd>Ctrl</kbd>. На Mac есть ещё одна: <kbd>Cmd</kbd>, которой соответствует свойство `metaKey`.

    В большинстве приложений, когда в Windows/Linux используется <kbd>Ctrl</kbd>, на Mac используется <knf>Cmd</knf>.

    То есть, когда пользователь Windows нажимает <kbd>Ctrl</kbd>+<kbd>Enter</kbd> и <kbd>Ctrl</kbd>+<kbd>A</kbd>, пользователь Mac нажимает <kbd>Cmd</kbd>+<kbd>⏎ Enter</kbd> или <kbd>Cmd</kbd>+<kbd>A</kbd>, и так далее.

    Поэтому, если мы хотим поддерживать такие комбинации, как <kbd>Ctrl</kbd>+клик, то для Mac имеет смысл использовать <kbd>Cmd</kbd>+клик. Это удобней для пользователей Mac.

    Даже если мы и хотели бы заставить людей на Mac использовать именно <kbd>Ctrl</kbd>+клик, это довольно сложно. Проблема в том, что левый клик в сочетании с <kbd>Ctrl</kbd> интерпретируется как правый клик на MacOS и генерирует событие `contextmenu`, а не `click` как на Windows/Linux.

    Поэтому, если мы хотим, чтобы пользователям всех операционных систем было удобно, то вместе с `ctrlKey` нам нужно проверять `metaKey`.

    Для JS-кода это означает, что мы должны проверить `if (event.ctrlKey || event.metaKey)`.

!!! warning "Не забывайте про мобильные устройства"
    Комбинации клавиш хороши в качестве дополнения к рабочему процессу. Так что, если посетитель использует клавиатуру – они работают.

    Но если на их устройстве его нет – тогда должен быть способ жить без клавиш-модификаторов.

#### Координаты: clientX/Y, pageX/Y
Все события мыши имеют координаты двух видов:

1. Относительно окна: `clientX` и `clientY`.
2. Относительно документа: `pageX` и `pageY`.

Мы уже рассмотрели разницу между ними в главе "Координаты" раздела, посвященного DOM.

Если в кратце, то относительные координаты документа `pageX`/`Y` отсчитываются от левого верхнего угла документа и не меняются при прокрутке страницы, в то время как `clientX`/`Y` отсчитываются от левого верхнего угла текущего окна. Когда страница прокручивается, они меняются.

Например, если у нас есть окно размером 500x500, и курсор мыши находится в левом верхнем углу, то значения `clientX` и `clientY` равны `0`, независимо от того, как прокручивается страница.

А если мышь находится в центре окна, то значения `clientX` и `clientY` равны `250` независимо от того, в каком месте документа она находится и до какого места документ прокручен. В этом они похожи на `position:fixed`.

Наведите курсор мыши на поле ввода, чтобы увидеть `clientX`/`clientY` (пример находится в `iframe`, поэтому координаты определяются относительно этого `iframe`):
```html
<input onmousemove="this.value=event.clientX+':'+event.clientY" value="Наведи на меня мышь">
```

Координаты относительно документа `pageX`, `pageY` отсчитываются не от окна, а от левого верхнего угла документа. Подробнее о координатах можно узнать в главе "Координаты" раздела, посвященного DOM.

#### Отключаем выделение
Двойной клик мыши имеет побочный эффект, который может быть неудобен в некоторых интерфейсах: он выделяет текст.

Например, двойной клик на текст ниже выделяет его в дополнение к нашему обработчику:
```html
<span ondblclick="alert('dblclick')">Сделайте двойной клик на мне</span>
```

![Double click](../img/dbl-click_1.png)

Если зажать левую кнопку мыши и, не отпуская кнопку, провести мышью, то также будет выделение, которое в интерфейсах может быть «не кстати».

Есть несколько способов запретить выделение, о которых можно прочитать в главе "Диапазоны и выделение".

В данном случае самым разумным будет отменить действие браузера по умолчанию при событии `mousedown`, это отменит оба этих выделения:
```html
До...
<b ondblclick="alert('Клик!')" onmousedown="return false">
  Сделайте двойной клик на мне
</b>
...После
```

![Double click](../img/dbl-click_2.png)

Теперь выделенный жирным элемент не выделяется при двойном клике, а также на нём нельзя начать выделение, зажав кнопку мыши.

Заметим, что текст внутри него по-прежнему можно выделить, если начать выделение не на самом тексте, а до него или после. Обычно это нормально воспринимается пользователями.

!!! info "Предотвращение копирования"
    Если мы хотим отключить выделение для защиты содержимого страницы от копирования, то мы можем использовать другое событие: `oncopy`.

    ```html
    <div oncopy="alert('Копирование запрещено!');return false">
      Уважаемый пользователь,
      Копирование информации запрещено для вас.
      Если вы знаете JS или HTML, вы можете найти всю нужную вам информацию в исходном коде страницы.
    </div>
    ```

    ![Prevent copy](../img/prevent-copy.png)

    Если вы попытаетесь скопировать текст в `<div>`, у вас это не получится, потому что срабатывание события `oncopy` по умолчанию запрещено.

    Конечно, пользователь имеет доступ к HTML-коду страницы и может взять текст оттуда, но не все знают, как это сделать.

#### Итого
События мыши имеют следующие свойства:

- Кнопка: `button`.

- Клавиши-модификаторы (`true` если нажаты): `altKey`, `ctrlKey`, `shiftKey` и `metaKey` (Mac).

    - Если вы планируете обработать <kbd>Ctrl</kbd>, то не забудьте, что пользователи Mac обычно используют <kbd>Cmd</kbd>, поэтому лучше проверить `if (e.metaKey || e.ctrlKey)`.

- Координаты относительно окна: `clientX`/`clientY`.

- Координаты относительно документа: `pageX`/`pageY`.

Действие по умолчанию события `mousedown` – начало выделения, если в интерфейсе оно скорее мешает, его можно отменить.

В следующей главе мы поговорим о событиях, которые возникают при передвижении мыши, и об отслеживании смены элементов под указателем.

#### Задачи
Создайте список, в котором элементы могут быть выделены, как в файловых менеджерах.

- При клике на элемент списка выделяется только этот элемент (добавляется класс `.selected`), отменяется выделение остальных элементов.
- Если клик сделан вместе с <kbd>Ctrl</kbd> (<kbd>Cmd</kbd> для Mac), то выделение переключается на элементе, но остальные элементы при этом не изменяются.

Демо:

![Selectable list](../img/selectable-list.png)

P.S. В этом задании все элементы списка содержат только текст. Без вложенных тегов.

P.P.S. Предотвратите стандартное для браузера выделение текста при кликах.

<details>
<summary>Решение</summary>

[Код решения](../src/11_events/selectable-list.html)

</details>

### События клавиатуры
Другим распространенным типом событий являются события клавиатуры.[^9.6]

- `keydown`: возникает при нажатии клавиши клавиатуры и длится, пока нажата клавиша

- `keyup`: возникает при отпускании клавиши клавиатуры

- `keypress`: возникает при нажатии клавиши клавиатуры, но после события `keydown` и до события `keyup`. Надо учитывать, что данное событие генерируется только для тех клавиш, которые формируют вывод в виде символов, например, при печати символов. Нажатия на остальные клавиши, например, на <kbd>Alt</kbd>, не учитываются.

Для работы с событиями клавиатуры определен объект **`KeyboardEvent`**, который добавляет к свойствам объекта `Event` ряд специфичных для клавиатуры свойств:

- **`altKey`**: возвращает `true`, если была нажата клавиша <kbd>Alt</kbd> во время генерации события

- **`key`**: возвращает символ нажатой клавиши, например, при нажатии на клавишу <kbd>T</kbd> это свойство будет содержать "T". А если нажата клавиша <kbd>Я</kbd>, то это свойство будет содержать "Я"

- **`code`**: возвращает строковое представление нажатой клавиши физической клавиатуры QWERTY, например, при нажатии на клавишу <kbd>T</kbd> это свойство будет содержать "KeyT", а при нажатии на клавишу <kbd>;</kbd> (точка запятой), то свойство возвратит "Semicolon".

  При использовании этого свойства следует учитывать ряд момент. Прежде всего используется клавиатура QWERTY. То есть мы переключим раскладку, к примеру, на русскоязычную и нажмем на клавишу <kbd>Я</kbd>, то значением будет "KeyZ" — на клавиатуре QWERTY клавиша <kbd>Z</kbd> представляет ту же клавишу, что и на русскоязычной раскладке <kbd>Я</kbd>

  Другой момент — учитывается именно физическая клавитура. Если нажата клавиша на виртуальной клавиатуре, то возвращаемое значение будет устанавливаться браузером исходя из того, какой клавише на физической клавиатуре соответствовало нажатие.

- **`ctrlKey`**: возвращает `true`, если была нажата клавиша <kbd>Ctrl</kbd> во время генерации события

- **`metaKey`**: возвращает `true`, если была нажата во время генерации события метаклавиша клавиатуры

- **`shiftKey`**: возвращает `true`, если была нажата клавиша <kbd>Shift</kbd> во время генерации события

Например, мы можем с помощью клавиш клавиатуры перемещать элемент на веб-странице:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>METANIT.COM</title>
    <style>
    #blueRect{
        width:100px;
        height:100px;
        background-color:blue;
    }
    </style>
</head>
<body>
<div id="blueRect"></div>

<script>
const blueRect = document.getElementById("blueRect");
// получаем стиль для blueRect
const blueRectStyle = window.getComputedStyle(blueRect);
// устанавливаем обработчик нажатия клавиши
window.addEventListener("keydown", moveRect);

function moveRect(e){
    const left = parseInt(blueRectStyle.marginLeft); //смещение от левого края
    const top = parseInt(blueRectStyle.marginTop);  // смещения от левой границы

    switch(e.key){

        case "ArrowLeft":  // если нажата клавиша влево
            if(left>0)
                blueRect.style.marginLeft = left - 10 + "px";
            break;
        case "ArrowUp":   // если нажата клавиша вверх
            if(top>0)
                blueRect.style.marginTop = top - 10 + "px";
            break;
        case "ArrowRight":   // если нажата клавиша вправо
            if(left < document.documentElement.clientWidth - 100)
                blueRect.style.marginLeft = left + 10 + "px";
            break;
        case "ArrowDown":   // если нажата клавиша вниз
            if(top < document.documentElement.clientHeight - 100)
                blueRect.style.marginTop = top + 10 + "px";
            break;
    }
}
</script>
</body>
</html>
```

В данном случае обрабатывается событие `keydown`, в обработчке которого управляем стилевыми свойствами элемента `blueRect`. Так как при прикреплении обработчика стиль элемента может быть не установлен, то явным образом вычисляем его с помощью метода `window.getComputedStyle()`:
```js
const blueRectStyle = window.getComputedStyle(blueRect);
```
В обработчике события из этого стиля выбираем значения свойств `marginLeft` и `marginTop`.

```js
const left = parseInt(blueRectStyle.marginLeft); //смещение от левого края
const top = parseInt(blueRectStyle.marginTop);  // смещения от левой границы
```

Затем м помощью свойства `e.key` получаем нажатую клавишу. Список кодов клавиш клавиатуры можно посмотреть на странице https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values.

Здесь нам интересуют четыре клавиши: вверх, вниз, влево, вправо. Им соответственно будут соответствовать названия "ArrowUp", "ArrowDown", "ArrowLeft" и "ArrowRight". Если одна из них нажата, производим действия: увеличение или уменьшение отступа элемента от верхней или левой границы. Ну и чтобы элемент не выходил за границы окна, проверяем предельные значения с помощью `document.documentElement.clientWidth` (ширина корневого элемента) и `document.documentElement.clientHeight` (высота корневого элемента).

Стоит отметить, что этот код не очень оптимален, поскольку для проверки значений нам приходится вычислять положение `blueRect` по горизонтали и вертикали. Плюс необходимо вычислять при каждом вызове обработчика проверяем правый (`document.documentElement.clientWidth - 100`) и нижний край (`document.documentElement.clientHeight - 100;`) области документа, чтобы `blueRect` не вышел за предел видимого пространства. В этом случае мы можем добавить дополнительные абстракции в виде текущих координат `blueRect` и положения правой и нижней границ видимой области. Так, изменим код JavaScript следующим образом:
```js
const blueRect = document.getElementById("blueRect");
const position = [20, 20];  // позиция blueRect

// перемещаем blueRect на позицию в position
function setPosition() {
    blueRect.style.marginLeft = position[0] + "px";
    blueRect.style.marginTop = position[1] + "px";
}

function init(){
    const rightLimit = document.documentElement.clientWidth - 100;  // правый край
    const bottomLimit = document.documentElement.clientHeight - 100;    // нижний край

    setPosition();  // устанавливаем начальную позицию для blueRect

    function moveRect(e){
        switch(e.key){

        case "ArrowLeft":  // если нажата клавиша влево
            if(position[0] > 0)
                position[0] = position[0] - 10;
            break;
        case "ArrowUp":   // если нажата клавиша вверх
            if(position[1] > 0)
                position[1] = position[1] - 10;
            break;
        case "ArrowRight":   // если нажата клавиша вправо
            if(position[0] < rightLimit)
                position[0] = position[0] + 10;
            break;
        case "ArrowDown":   // если нажата клавиша вниз
            if(position[1] < bottomLimit)
                position[1] = position[1] + 10;
            break;
        }
        setPosition();
    }
    window.addEventListener("keydown", moveRect);
}
//  при загрузке страницы выполняем функцию init
window.addEventListener("load", init);
```

Теперь координаты `blueRect` хранятся в массиве `position`, где первое значение — это отступ слева, а второе значение — отступ сверху. Чтобы по этим координатам установить реальную позицию `blueRect` на странице определена функция `setPosition`.

```js
const position = [20, 20];  // позиция blueRect

// перемещаем blueRect на позицию в position
function setPosition() {
    blueRect.style.marginLeft = position[0] + "px";
    blueRect.style.marginTop = position[1] + "px";
}
```

Прикрепляем к событию загрузки окна — **`load`** обработчик — функцию `init`:
```js
window.addEventListener("load", init);
```

В функции `init` определяем правый и нижний край для перемещения `blueRect`, а также устанавливаем его начальную позицию:
```js
const rightLimit = document.documentElement.clientWidth - 100;  // правый край
const bottomLimit = document.documentElement.clientHeight - 100;    // нижний край
setPosition();  // устанавливаем начальную позицию для blueRect
```

Далее определяем обработчик `moveRect`, в котором изменяем значения в массиве `position`:
```js
function moveRect(e){
    switch(e.key){

    case "ArrowLeft":  // если нажата клавиша влево
        if(position[0] > 0)
            position[0] = position[0] - 10;
        break;
    //............
    }
    setPosition();
}
```

И после всех изменений переустанавливаем позицию с помощью функции `setPosition`.

В конце прикрепляем обработчик к нажатию клавиши клавиатуры:
```js
window.addEventListener("keydown", moveRect);
```

### Глоссарий
[^9.5]: [События мыши](https://metanit.com/web/javascript/9.5.php)
[^9.6]: [События клавиатуры](https://metanit.com/web/javascript/9.6.php)
[^mouse-events-basics]: [Основы событий мыши](https://learn.javascript.ru/mouse-events-basics)
[^mousemove-mouseover-mouseout-mouseenter-mouseleave]: [Движение мыши: mouseover/out, mouseenter/leave](https://learn.javascript.ru/mousemove-mouseover-mouseout-mouseenter-mouseleave)
