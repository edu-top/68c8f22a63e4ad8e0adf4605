## Объекты

- [Объекты](#объекты)
  - [Введение в объекты](#введение-в-объекты)
    - [Создание нового объекта](#создание-нового-объекта)
    - [Свойства объекта](#свойства-объекта)
    - [Методы объекта](#методы-объекта)
    - [Синтаксис массивов](#синтаксис-массивов)
      - [Строки в качестве свойств и методов](#строки-в-качестве-свойств-и-методов)
      - [Динамическое определение имен свойств и методов](#динамическое-определение-имен-свойств-и-методов)
    - [Удаление свойств](#удаление-свойств)
    - [Создание объекта из переменных и констант](#создание-объекта-из-переменных-и-констант)
    - [Фукция Object.fromEntries()](#фукция-objectfromentries)
  - [Ключевое слово this](#ключевое-слово-this)
    - [Глобальный контекст и объект globalThis](#глобальный-контекст-и-объект-globalthis)
    - [Контекст функции](#контекст-функции)
    - [Контекст объекта](#контекст-объекта)
    - [Динамическое определение контекста](#динамическое-определение-контекста)
    - [Контекст во вложенных функциях](#контекст-во-вложенных-функциях)
    - [Явная привязка](#явная-привязка)
    - [Метод bind](#метод-bind)
    - [this и стрелочные функции](#this-и-стрелочные-функции)
  - [Вложенные объекты и массивы в объектах](#вложенные-объекты-и-массивы-в-объектах)
  - [Копирование и сравнение объектов](#копирование-и-сравнение-объектов)
    - [Копирование объектов](#копирование-объектов)
    - [Метод Object.assign](#метод-objectassign)
      - [Копирование из нескольких объектов](#копирование-из-нескольких-объектов)
      - [Копирование одноименных свойств](#копирование-одноименных-свойств)
      - [Копирование свойств-объектов](#копирование-свойств-объектов)
    - [Копирование объекта с помощью spread-оператора](#копирование-объекта-с-помощью-spread-оператора)
    - [Сравнение объектов](#сравнение-объектов)
  - [Практическая работа. Работа с объектами](#практическая-работа-работа-с-объектами)
    - [Задание](#задание)
  - [Источники информации](#источники-информации)

Объектно-ориентированное программирование на сегодняшний день является одной из господствующих парадигм в разработке приложений, и в JavaScript мы также можем использовать все преимущества ООП. В то же время применительно к JavaScript объектно-ориентированное программирование имеет некоторые особенности.

### Введение в объекты
В прошлых темах мы работали с примитивными данными — числами, строками, но данные не всегда представляют примитивные типы. Например, если в нашей программе нам надо описать сущность человека, у которого есть имя, возраст, пол и так далее, то естественно мы не сможем представить сущность человека в виде числа или строки. Нам потребуется несколько строк или чисел, чтобы должным образом описать человека. В этом плане человек будет выступать как сложная комплексная структура, у которого будут отдельные свойства — возраст, рост, имя, фамилия и т.д.

Для работы с подобными структурами в JavaScript используются **объекты**. Каждый объект может хранить свойства, которые описывают его **состояние**, и методы, которые описывают его **поведение**.

#### Создание нового объекта
Есть несколько способов создания нового объекта.

Первый способ заключается в использовании конструктора `Object`:
```js
const user = new Object();
```

В данном случае объект называется `user`.

Выражение `new Object()` представляет вызов конструктора — функции, создающей новый объект. Для вызова конструктора применяется оператор **`new`**. Вызов конструктора фактически напоминает вызов обычной функции.

Второй способ создания объекта представляет использование фигурных скобок (литеральная нотация):
```js
const user = {};
```

На сегодняшний день более распространенным является второй способ.

#### Свойства объекта
После создания объекта мы можем определить в нем свойства. Чтобы определить свойство, надо после названия объекта через точку указать имя свойства и присвоить ему значение:
```js
const user = {};
user.name = "Tom";
user.age = 26;
```

В данном случае объявляются два свойства `name` и `age`, которым присваиваются соответствующие значения. После этого мы можем использовать эти свойства, например, вывести их значения в консоли:
```js
console.log(user.name);
console.log(user.age);
```

Также можно определить свойства при определении объекта:
```js
const user = {

    name: "Tom",
    age: 26
};
```

В этом случае для присвоения значения свойству используется символ двоеточия, а после определения свойства ставится запятая (а не точка с запятой).

Кроме того, доступен сокращенный способ определения свойств:
```js
const name = "Tom";
const age = 34;
const user = {name, age};
console.log(user.name);     // Tom
console.log(user.age);      // 34
```

В данном случае названия переменных также являются и названиями свойств объекта. И таким образом можно создавать более сложные конструкции:
```js
const name = "Tom";
const age = 34;
const user = {name, age};

const teacher = {user, course: "JavaScript"};
console.log(teacher.user);      // {name: "Tom", age: 34}
console.log(teacher.course);    // JavaScript
```

#### Методы объекта
Методы объекта определяют его поведение или действия, которые он производит. Методы представляют собой функции. Например, определим метод, который бы выводил имя и возраст человека:
```js
const user = {};
user.name = "Tom";
user.age = 26;
user.display = function(){

    console.log(user.name);
    console.log(user.age);
};

// вызов метода
user.display();
```

Как и в случае с функциями методы сначала определяются, а потом уже вызываются.

Также методы могут определяться непосредственно при определении объекта:
```js
const user = {

    name: "Tom",
    age: 26,
    display: function(){

        console.log(this.name);
        console.log(this.age);
    }
};
```

Как и в случае со свойствами, методу присваивается ссылка на функцию с помощью знака двоеточия.

Чтобы обратиться к свойствам или методам объекта внутри этого объекта, используется ключевое слово **`this`**. Оно означает ссылку на текущий объект.

Также можно использовать сокращенный способ определения методов, когда двоеточие и слово `function` опускаются:
```js
let user = {

    name: "Tom",
    age: 26,
    display(){

        console.log(this.name, this.age);
    },
    move(place){
        console.log(this.name, "goes to", place);
    }
};
user.display(); // Tom 26
user.move("the shop");  // Tom goes to the shop
```

#### Синтаксис массивов
Существует также альтернативный способ определения свойств и методов с помощью синтаксиса массивов:
```js
const user = {};
user["name"] = "Tom";
user["age"] = 26;
user["display"] = function(){

    console.log(user.name);
    console.log(user.age);
};

// вызов метода
user["display"]();
```

Название каждого свойства или метода заключается в кавычки и в квадратные скобки, затем им также присваивается значение. Например, `user["age"] = 26`.

При обращении к этим свойствам и методам можно использовать либо нотацию точки (`user.name`), либо обращаться так: `user["name"]`.

Также можно определить свойства и методы через синтаксис массивов напрямую при создании объекта:
```js
const user = {
    ["name"]: "Tom",
    ["age"]: 26,
    ["display"]: function(){

        console.log(user.name);
        console.log(user.age);
    }
};
user["display"]();
```

##### Строки в качестве свойств и методов
Также следует отметить, что названия свойств и методов объекта всегда представляют строки. То есть мы могли предыдущее определение объекта переписать так:
```js
const user = {
    "name": "Tom",
    "age": 26,
    "display": function(){

        console.log(user.name);
        console.log(user.age);
    }
};
// вызов метода
user.display();
```

С одной стороны, разницы никакой нет между двумя определениями. С другой стороны, бывают случаи, где заключение названия в строку могут помочь. Например, если название свойства состоит из двух слов, разделенных пробелом:
```js
const user = {
    name: "Tom",
    age: 26,
    "full name": "Tom Johns",
    "display info": function(){

        console.log(user.name);
        console.log(user.age);
    }
};
console.log(user["full name"]);
user["display info"]();
```

Только в этом случае для обращении к подобным свойствам и методам мы должны использовать синтаксис массивов.

##### Динамическое определение имен свойств и методов
Синтаксис массивов открывает нам другую возможность — определение имени свойства вне объекта:
```js
const prop1  = "name";
const prop2  = "age";
const tom = {
    [prop1]: "Tom",
    [prop2]: 37
};
console.log(tom);           // {name: "Tom", age: 37}
console.log(tom.name);      // Tom
console.log(tom["age"]);    // 37
```

Благодая этому, например, можно динамически создавать объекты с произвольными названиями свойств:
```js
function createObject(propName, propValue){
    return {
            [propName]: propValue,
            print(){
                console.log(`${propName}: ${propValue}`);
            }
    };
}
const person = createObject("name", "Tom");
person.print();     // name: Tom

const book = createObject("title", "JavaScript Reference");
book.print();   // title: JavaScript Reference
```

#### Удаление свойств
Выше мы посмотрели, как можно динамически добавлять новые свойства к объекту. Однако также мы можем удалять свойства и методы с помощью оператора **`delete`**. И как и в случае с добавлением мы можем удалять свойства двумя способами. Первый способ — использование нотации точки:
```js
delete объект.свойство
```

Либо использовать синтаксис массивов:
```js
delete объект["свойство"]
```

Например, удалим свойство:
```js
let user = {};
user.name = "Tom";
user.age = 26;
user.display = function(){

    console.log(user.name);
    console.log(user.age);
};

console.log(user.name); // Tom
delete user.name; // удаляем свойство
// альтернативный вариант
// delete user["name"];
console.log(user.name); // undefined
```

После удаления свойство будет не определено, поэтому при попытке обращения к нему, программа вернет значение **`undefined`**.

#### Создание объекта из переменных и констант
При создании объекта его свойствам могут передаваться значения переменных, констант или динамически вычисляемые результаты функций:
```js
function getSalary(status){
    if(status==="senior") return 1500;
    else return 500;
}
const name = "Tom";
const age = 37;
const person = { name: name, age: age, salary: getSalary()};

console.log(person);    // {name: "Tom", age: 37, salary: 500}
```

Но если названия констант/переменных совпадает с названиями свойств, то можно сократить передачу значений:
```js
const name = "Tom";
const age = 37;
const salary = 500;
const person = { name, age, salary};

console.log(person);    // {name: "Tom", age: 37, salary: 500}
```

В данном случае объект `person` автоматически получит свойства, названия которых будут соответствовать названиям констант, а в качестве значений иметь значения этих констант.

То же самое относится к передаче функций методам объекта:
```js
function display(){
    console.log(this.name, this.age);
}
const move = function(place){ console.log(this.name, "goes to", place)};
const name = "Tom";
const age = 37;
const salary = 500;
const person = { name, age, salary, display, move};

person.display();       // Tom 37
person.move("cinema");  // Tom goes to cinema
```

В данном случае объект `person` имеет два метода, которые соответствуют переданным в объект функциям — `display()` и `move()`. Стоит отметить, что при такой передаче функций методам объекта, мы по прежнему можем использовать в этих функциях ключевое слово `this` для обращения к функциональности объекта. Однако стоит быть осторожным при передаче лямбд-выражений, поскольку для глобальных лямбд-выражений `this` будет представлять объект окна браузера:
```js
const move = (place)=>{ console.log(this.name, "goes to", place); console.log(this);};
const name = "Tom";

const person = { name, move};
person.move("cinema");  //  goes to cinema
```

#### Фукция Object.fromEntries()
С помощью функции **`Object.fromEntries()`** можно создать объект из набора пар ключ-значение, где ключ потом будет представляет название свойства. Например, создадим объект из массивов:
```js
const personData = [ ["name", "Tom"], ["age", 37]];
const person = Object.fromEntries(personData);
console.log(person);        // {name: "Tom", age: 37}
console.log(person.name);    // Tom
```

Здесь объект создается из массива `personData`, который содержит два подмассива. Каждый подмассив содержит два элемента и фактически представляет пару ключ-значение. Первый элемент представляет ключ, а второй — значение.[^4.1]

### Ключевое слово this
Поведение ключевого слова **`this`** зависит от контекста, в котором оно используется, и от того, в каком режиме оно используется — строгом или нестрогом.

#### Глобальный контекст и объект globalThis
В глобальном контексте `this` ссылается на глобальный объект. Что такое "глобальный объект" в JavaScript? Это зависит от среды, в которой выполняется код. Так, в веб-браузере `this` представляет объект **`window`** — объект, который представляет окно браузера. В среде Node.js `this` представляет объект **`global`**. А для веб-воркеров `this` представляет объект **`self`**.

Например, в веб-браузере при выполнении следующего кода:
```js
console.log(this);
```

мы получим консольный вывод вроде следующего
```
Window {window: Window, self: Window, document: document, name: "", location: Location, …}
```

В стандарт ES2020 было добавлено определение объекта **`globalThis`**, который позволяет ссылаться на глобальный конекст вне зависимости, в какой среде и в какой ситуации выполняется код:
```js
console.log(globalThis);
```

#### Контекст функции
В пределах функции `this` ссылается на внешний контекст. Для функций, определенных в глобальном контексте, — это объект **`globalThis`**. Например:
```js
function foo(){
    var bar = "local";
    console.log(this.bar);
}

var bar = "global";

foo();  // global
```

Если бы мы не использовали бы `this`, то обращение шло бы к локальной переменной, определенной внутри функции.

```js
function foo(){
    var bar = "local";
    console.log(bar);
}

var bar = "global";

foo();  // local
```

Но если бы мы использовали строгий режим (strict mode), то `this` в этом случае имело бы значение `undefined`:
```js
"use strict";
function foo(){
    var bar = "local";
    console.log(this.bar);
}

var bar = "global";

foo();  // ошибка - this - undefined
```

#### Контекст объекта
В контексте объекта, в том числе в его методах, ключевое слово `this` ссылается на этот же объект:
```js
const obj = {
    bar: "object",
    foo: function(){
        console.log(this.bar);
    }
}
var bar = "global";
obj.foo();  // object
```

#### Динамическое определение контекста
Код функции всегда использует в качестве `this` внешний контекст, в которым этот код вызывается (именно вызывается, а не определяется). Рассмотрим более сложный пример:
```js
function foo(){
    var bar = "foo_bar";
    console.log(this.bar);
}

const obj1 = {bar:"obj1_bar", foo: foo};
const obj2 = {bar:"obj2_bar", foo: foo};

var bar = "global_bar";

foo();  // global_bar
obj1.foo();   // obj1_bar
obj2.foo();   // obj2_bar
```

Здесь определена глобальная переменная `bar` ("global_bar"). И также в функции `foo` определена локальная переменная `bar` ("foo_bar"). Значение какой переменной будет выводиться в функции `foo`? Функция foo использует определение переменной, которое определено во внешнем контексте. Для функции `foo` по умолчанию это глобальный контекст, поэтому она выводит значение глобальной переменной (так как данный скрипт запускается в нестрогом режиме, а значит ключевое слово `this` в функции `foo` ссылается на внешний контекст).

Иначе дело обстоит с объектами. Они определяют свой собственный контекст, в котором существует свое свойство `bar`. И при вызове метода `foo` внешним контекстом по отношению к функции будет контекст объектов `obj1` и `obj2`.

Подобное поведение может привести к некоторому непонимаю в отдельных случаях. Так, рассмотрим другую ситуацию:
```js
var bar = "global_bar";

const obj1 = {
    bar: "obj1_bar",
    foo: function(){
        console.log(this.bar);  // bar = "obj1_bar"
    }
}
const obj2 = {bar: "obj2_bar", foo: obj1.foo}; // bar = "obj2_bar"

const foo = obj1.foo;   // bar = "global_bar"

obj1.foo(); // obj1_bar
obj2.foo(); // obj2_bar
foo();      // global_bar
```

Здесь в объекте `obj1` определена функция `foo`:
```js
const obj1 = {
    bar: "obj1_bar",
    foo: function(){
        console.log(this.bar);  // bar = "obj1_bar"
    }
}
```

Эта функция `foo` будет брать значение для `this.bar` из внешнего контекста — из объекта `obj1`, соответственно `this.bar = "obj1_bar"`.

Объект `obj2` использует функцию `foo` из объекта `obj1`:
```js
const obj2 = {bar: "obj2_bar", foo: obj1.foo};
```

Однако функция `obj1.foo` также будет искать значение для `this.bar` опять же во внешнем котексте, а здесь это объект `obj2`. А в объекте `obj2` это значение равно "obj2_bar".

То же самое с глобальной переменной `foo`, которая ссылается на ту же функцию, что и метод `obj1.foo`:
```js
const foo = obj1.foo;
```

В этом случае также будет происходить поиск значения для `this.bar`, но теперь в контексте функции `foo`. А это глобальный контекст, где определена переменная `var bar = "global_bar"`.

#### Контекст во вложенных функциях
Если мы вызываем функцию из другой функции, вызываемая функция также будет использовать внешний контекст:
```js
var bar = "global bar";

function foo(){
    var bar = "foo bar";
    function moo(){

        console.log(this.bar);
    }
    moo();
}
foo();  // global bar
```

Здесь функция `foo()` в качестве `this.bar` использует значение переменной `bar` из внешнего контекста, то есть значение глобальной переменной `bar`. Функция `moo()` также в качестве `this.bar` использует значение переменной `bar` из внешнего контекста, то есть `this.bar` для внешней функции `foo`, которое в свою очередь представляет значение глобальной переменной `bar`. Поэтому в итоге консоль выведет "global bar", а не "foo bar".

#### Явная привязка
С помощью методов `call()` и `apply()` можно задать явную привязку функции к определенному контексту:
```js
function foo(){
    console.log(this.bar);
}

var obj = {bar: "obj_bar"}
var bar = "global_bar";
foo();              // global_bar
foo.apply(obj);     // obj_bar
// или
// foo.call(obj);
```

Во втором случае функция `foo` привязывается к объекту `obj`, который и определяет ее контекст. Поэтому во втором случае консоль выведет "obj_bar".

#### Метод bind
Метод `f.bind(o)` позволяет создать новую функцию с тем же телом и областью видимости, что и функция `f`, но с привязкой к объекту `o`:
```js
function foo(){
    console.log(this.bar);
}

const obj = {bar: "object"}
var bar = "global";
foo();  // global
const func = foo.bind(obj);
func(); // object
```

#### this и стрелочные функции
В стрелочных функциях в качестве **`this`** используется контекст окружения, а не само окружение, в котором определена стрелочная функция. Рассмотрим следующий пример:
```js
const person = {
    name: "Tom",
    say:()=> console.log(`Меня зовут ${this.name}`)
}
person.say();   // Меня зовут
```

Здесь стрелочная функция `say()` обращается к некому свойству `this.name`, но что здесь представляет `this`? Для внешнего контекста, в котором определена стрелочная функция, то есть для контекста объекта `person`, `this` представляет глобальный объект (объект окна браузера). Однако глобальной переменной `name` не определено, поэтому на консоль будет выведено:
```
Меня зовут
```

Теперь немного изменим пример:
```js
const person = {
    name: "Tom",
    hello(){
        console.log("Привет");
        let say = ()=> console.log(`Меня зовут ${this.name}`);
        say();
    }
}
person.hello();
```

Теперь стрелочная функция определена в методе `hello()`. `this` для этого метода представляет текущий объект `person`, где определен данный метод. Поэтому и в стрелочной функции `this` будет представлять объект `person`, а `this.name` — свойство `name` этого объекта. Поэтому при выполнении программы мы получим:
```
Привет
Меня зовут Tom
```


Несмотря на то что, стрелочные функции могут добавить забот при работе `this`, в то же время они могут решить ряд проблем. Так, при работе с несколькими контекстами мы вынуждены учитывать, в каком контексте определяется переменная. Например, возьмем следующий код:
```js
const school ={
    title: "Oxford",
    courses: ["JavaScript", "TypeScript", "Java", "Go"],
    printCourses(){
        this.courses.forEach(function(course){
            console.log(this.title, course);
        })
    }
}
school.printCourses();
```

Функция `printCourses` проходит по всем курсам из массива и при их выводе предваряет их значением свойства `title`. Однако на консоли при запуске программы мы увидим следующее:
```
undefined "JavaScript"
undefined "TypeScript"
undefined "Java"
undefined "Go"
```

Мы видим, что значение `this.title` не определено, так как `this` как контекст объекта замещается глобальным контекстом. В этом случае нам надо передать подобное значение `this.title` или весь контекст объекта.

```js
const school ={
    title: "Oxford",
    courses: ["JavaScript", "TypeScript", "Java", "Go"],
    printCourses(){
        const that = this;
        this.courses.forEach(function(course){
            console.log(that.title, course);
        })
    }
}
school.printCourses();
```

Стрелочные функции также позволяют решить данную проблему:
```js
const school ={
    title: "Oxford",
    courses: ["JavaScript", "TypeScript", "Java", "Go"],
    printCourses(){
        this.courses.forEach((course)=>console.log(this.title, course))
    }
}
school.printCourses();
```

Контекстом для стрелочной функции в данном случае будет выступать контекст объекта `school`. Соответственно, нам не надо определять дополнительные переменые для передачи данных в функцию.[^4.10]

### Вложенные объекты и массивы в объектах
Одни объекты могут содержать в качестве свойств другие объекты. Например, есть объект страны, у которой можно выделить ряд свойств. Одно из этих свойств может представлять столицу. Но у столицы мы также можем выделить свои свойства, например, название, численность населения, год основания:
```js
const country = {

    name: "Германия",
    language: "немецкий",
    capital:{

        name: "Берлин",
        population: 3375000,
        year: 1237
    }
};
console.log("Столица:", country.capital.name); // Берлин
console.log("Население:", country["capital"]["population"]); // 3375000
console.log("Год основания:", country.capital["year"]); // 1237
```

Консольный вывод:
```
Столица: Берлин
Население: 3375000
Год основания: 1237
```

Для доступа к свойствам таких вложенных объектов мы можем использовать стандартную нотацию точки:
```js
country.capital.name
```

Либо обращаться к ним как к элементам массивов:
```js
country["capital"]["population"]
```

Также допустим смешанный вид обращения:
```js
country.capital["year"]
```

В качестве свойств также могут использоваться массивы, в том числе массивы других объектов:
```js
const country = {

    name: "Швейцария",
    languages: ["немецкий", "французский", "итальянский"],
    capital:{

        name: "Берн",
        population: 126598
    },
    cities: [
        { name: "Цюрих", population: 378884},
        { name: "Женева", population: 188634},
        { name: "Базель", population: 164937}
    ]
};

// вывод всех элементов из country.languages
console.log("Официальные языки Швейцарии");
for(const lang of country.languages){
  console.log(lang);
}
console.log("\n");  // для разделения языков от городов

// вывод всех элементов из country.cities
console.log("Города Швейцарии");
for(const city of country.cities){
  console.log(city.name);
}
```

В объекте `country` имеется свойство `languages`, содержащее массив строк, а также свойство cities, хранящее массив однотипных объектов.

С этими массивами мы можем работать также, как и с любыми другими, например, перебрать с помощью цикла **`for`**. При переборе массива объектов каждый текущий элемент будет представлять отдельный объект, поэтому мы можем обратиться к его свойствам и методам:
```js
for(const city of country.cities){
  console.log(city.name);
}
```

Либо для перебора мы могли бы использовать другой тип цикла **`for`** и также пройтись по всем элементам массива:
```js
for(let i=0; i < country.cities.length; i++){
    console.log(country.cities[i].name);
}
```

В итоге браузер выведет содержимое этих массивов:[^4.2]
```
Официальные языки Швейцарии
немецкий
французский
итальянский

Города Швейцарии
Цюрих
Женева
Базель
```

### Копирование и сравнение объектов

#### Копирование объектов
В отличие от данных примитивных типов данные объектов копируются по ссылке. Что это значит? Рассмотрим следующий пример:
```js
const tom = { name: "Tom"};
const bob = tom;
// проверяем свойство name у обоих констант
console.log(tom.name);  // Tom
console.log(bob.name);  // Tom

// меняем свойство name у константы bob
bob.name = "Bob";
// повторно проверяем свойство name у обоих констант
console.log("После изменения")
console.log(tom.name);  // Bob
console.log(bob.name);  // Bob
```

Вначале определяется обычный объект `tom` с одним свойством `name`. Затем присваиваем значение этого объекта константе `bob`
```js
const bob = tom;
```

В данном случае константа `bob` получае ссылку или условно говоря адрес константы `tom`, поэтому после этого присвоения обе константы по сути указывают на один и тот же объект в памяти. Соответственно изменения, произведенные через одну константу:
```js
bob.name = "Bob";
```

Затронут и другую константу — `tom`:
```js
console.log(tom.name);  // Bob
```

Более того, добавим к объекту новое свойство через одну из констант:
```js
const tom = { name: "Tom"};
const bob = tom;
// добавляем константе bob новое свойство - age
bob.age = 37;
// и видим, что для tom тоже добавлено новое свойство
console.log(tom.age);   // 37
```

После добавления свойства `age` константе `bob` можно увидеть, что у константы `tom` то же появилось это свойство, потому что опять же обе константы представляют один и тот же объект.

Что же если мы хотим скопировать из свойства объекта, но при этом обе константы или переменных указывали бы на совершенно разные объекты, изменения одного из которых никак бы не затрагивали другой? В этом случае мы можем воспользоваться встроенным методом **`Object.assign()`**.

#### Метод Object.assign
Метод **`Object.assign()`** принимает два параметра:
```js
Object.assign(target, ...sources)
```

Первый параметр — `target` представляет объект, в который надо скопировать свойства. Второй параметр — `...sources` — набор объектов, из которых надо скопировать свойства (то есть мы можем скопировать свойства сразу из нескольких объектов)

Возвращает метод объект `target`, в который скопированы свойства из объектов `sources`.

Например:
```js
const tom = { name: "Tom", age: 37};
const bob = Object.assign({}, tom);
bob.name = "Bob";
bob.age = 41;

console.log(`Объект tom. Name: ${tom.name}   Age: ${tom.age}`);
console.log(`Объект bob. Name: ${bob.name}   Age: ${bob.age}`);
```

В данном случае вызов `Object.assign({}, tom)` означает, что мы копируем данные из объекта tom в пустой объект `{}`. Результатом этого копирования стал объект `bob`. Причем это совсем другой объект, нежели `tom`. И любые изменения с константой `bob` здесь никак не затронут константу `tom`.

Консольный вывод программы:
```
Объект tom. Name: Tom   Age: 37
Объект bob. Name: Bob   Age: 41
```

##### Копирование из нескольких объектов
Подобным образом можно копировать данные из нескольких объектов:
```js
const tom = { name: "Tom"};
const sam = { age: 37};
const person = { height: 170};
Object.assign(person, tom, sam);    // копируем из tom и sam в person
console.log(person);    // {height: 170, name: "Tom", age: 37}
```

Здесь копируются все свойства из объектов `tom` и `sam` в объект `person`. В итоге после копирования объект `person` будет иметь три свойства.

##### Копирование одноименных свойств
Если объекты, из которых выполняется копирование, содержат одинаковые свойства, то свойства из последних объектов замещают свойства предыдущих:
```js
const tom = { name: "Tom", age: 37};
const sam = { age: 45};
const person = { height: 170};
Object.assign(person, tom, sam);
console.log(person);    // {height: 170, name: "Tom", age: 45}
```

Здесь оба объекта — `tom` и `sam` — содержат свойство `age`, но в объекте `person` свойство `age` равно 45 — значение из объекта `sam`, потому что копирование из объекта `sam` произодится в последнюю очередь.

##### Копирование свойств-объектов
Несмотря на то, что `Object.assign()` прекрасно работает для простых объектов, но что будет, если свойство копируемого объекта также представляет объект:
```js
const tom = { name: "Tom", company: {title: "Microsoft"}};
const bob = Object.assign({}, tom);
bob.name = "Bob";
bob.company.title = "Google";
console.log(tom.name);      // Tom
console.log(tom.company.title);     // Google
```

Здесь свойство `company` объекта `tom` представляет объект с одним свойством. И при копировании объект `bob` получит не копию значения `tom.company`, а ссылку на этот объект. Поэтому изменения `bob.company` затронут и `tom.company`.

#### Копирование объекта с помощью spread-оператора
**spread-оператор `...`** позволяет разложить объект на различные пары свойство-значение, которые можно передать другому объекту.

```js
const tom = { name: "Tom", age: 37, company: "Google"};
const bob = {...tom}
bob.name = "Bob";

console.log(tom);   // {name: "Tom", age: 37, company: "Google"}
console.log(bob);   // {name: "Bob", age: 37, company: "Google"}
```

В данном случае объекту `bob` передаются копии свойств объекта `tom`.

Если какие-то свойства нового объекта должны иметь другие значения (как в примере выше свойство `name`), то их можно указать в конце:
```js
const tom = { name: "Tom", age: 37, company: "Google"};
const bob = {...tom, name: "Bob"};

console.log(bob);   // {name: "Bob", age: 37, company: "Google"}
```

Как видно из предыдущего примера, обе константы после копирования представляют ссылки на разные объекты, и изменения одного из них никак не затронет другой объект.

Тем не менее если объекты содержат вложенные объекты, то эти вложенные объекты при копировании опять же по сути будут представлять ссылки на один и тот же объект:
```js
const tom = { name: "Tom", age: 37, company: {title: "Microsoft"}};
const bob = {...tom}
bob.name = "Bob";
bob.company.title = "Google";

console.log(`${tom.name} - ${tom.company.title}`);  // Tom - Google
console.log(`${bob.name} - ${bob.company.title}`);  // Bob - Google
```

#### Сравнение объектов
Сравним два объекта с помощью стандартных операций сравнения и эквивалентности:
```js
const tom = { name: "Tom"};
const bob = { name: "Bob"};
console.log(tom == bob);    // false
console.log(tom === bob);   // false
```

Оба оператора в данном случае возвратят значение `false`, то есть объекты не равны. Причем даже если значения свойств объектов будет одинаковым, то мы все равно в обоих случаях получим `false`
```js
const tom = { name: "Tom"};
const bob = { name: "Tom"};
console.log(tom == bob);    // false
console.log(tom === bob);   // false
```

Однако, что будет, если обе константы (переменных) хранят ссылку на один и тот же объект:
```js
const tom = { name: "Tom"};
const bob = tom;
console.log(tom == bob);    // true
console.log(tom === bob);   // true
```

В этом случае в обоих случаях мы получим `true`, поскольку значения обоих констант равны, так как по сути это одно и то же значение.


### Практическая работа. Работа с объектами

#### Задание
1. Задать объект `room` и его параметры:

   - ключ `height` со значением `3`;
   - ключ `width` со значением `5.5`;
   - ключ `length` со значением `3.2`;
   - ключ `tv` со значением `"Samsung"`;
   - ключ `big` со значением `true`.

   Вывести в консоль все параметры объекта `room` по очереди. Предусмотреть метод для определения площади и объема помещения.

2. Создать объект «Книга» с полями на основе данных, предоставляемых пользователем: *название*, *автор*, *год издания*. Добавить в объект «Книга» метод, который возвращает строку с информацией о книге в формате: «Название — Автор (Год)».

3. Создать объект «Пользователь» с полями на основе данных, вводимых пользователем: логин, пароль, фамилия, имя, отчество. Автоматически при создании объекта назначать ему роль наблюдателя. Реализовать метод для смены роли пользователя на одну из предустановленных в системе (администратор, модератор, наблюдатель). Добавить в объект «Пользователь» метод для вывода информации в формате: «*логин*: *Фамилия И.О.* (*роль*)». Логин и пароль должны быть обязательными для введения, если фамилия, имя или отчество неизвестны (не определены пользователем), то на их месте ставить прочерки (`-`).

4. Создать объект «Фильм» с динамическими свойствами: название, режиссер, год выпуска, список актеров (массив объектов). Объекты, соответствующие режиссеру и актерам, должны содержать фамилию, имя, отчество, пол и год рождения. Предусмотреть методы для добавления или удаления актеров, а также замены режиссера.

5. Создать объект, где ключами будут имена дней недели, а значениями — расписание занятий на каждый день в массива объектов, содержащих номер пары, название учебного предмета, номер группы и фамилию преподавателя. Добавить возможность изменять расписание.

### Источники информации
[^4.1]: [Объектно-ориентированное программирование](https://metanit.com/web/javascript/4.1.php)
[^4.10]: [Ключевое слово this](https://metanit.com/web/javascript/4.10.php)
[^4.2]: [Вложенные объекты и массивы в объектах](https://metanit.com/web/javascript/4.2.php)
[^4.13]: [Копирование и сравнение объектов](https://metanit.com/web/javascript/4.13.php)
