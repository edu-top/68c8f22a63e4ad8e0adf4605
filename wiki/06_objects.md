## Объекты

- [Объекты](#объекты)
  - [Введение в объекты](#введение-в-объекты)
    - [Создание нового объекта](#создание-нового-объекта)
    - [Свойства объекта](#свойства-объекта)
    - [Методы объекта](#методы-объекта)
    - [Синтаксис массивов](#синтаксис-массивов)
      - [Строки в качестве свойств и методов](#строки-в-качестве-свойств-и-методов)
      - [Динамическое определение имен свойств и методов](#динамическое-определение-имен-свойств-и-методов)
    - [Удаление свойств](#удаление-свойств)
    - [Создание объекта из переменных и констант](#создание-объекта-из-переменных-и-констант)
    - [Фукция Object.fromEntries()](#фукция-objectfromentries)
  - [Ключевое слово this](#ключевое-слово-this)
    - [Глобальный контекст и объект globalThis](#глобальный-контекст-и-объект-globalthis)
    - [Контекст функции](#контекст-функции)
    - [Контекст объекта](#контекст-объекта)
    - [Динамическое определение контекста](#динамическое-определение-контекста)
    - [Контекст во вложенных функциях](#контекст-во-вложенных-функциях)
    - [Явная привязка](#явная-привязка)
    - [Метод bind](#метод-bind)
    - [this и стрелочные функции](#this-и-стрелочные-функции)
  - [Вложенные объекты и массивы в объектах](#вложенные-объекты-и-массивы-в-объектах)
  - [Копирование и сравнение объектов](#копирование-и-сравнение-объектов)
    - [Копирование объектов](#копирование-объектов)
    - [Метод Object.assign](#метод-objectassign)
      - [Копирование из нескольких объектов](#копирование-из-нескольких-объектов)
      - [Копирование одноименных свойств](#копирование-одноименных-свойств)
      - [Копирование свойств-объектов](#копирование-свойств-объектов)
    - [Копирование объекта с помощью spread-оператора](#копирование-объекта-с-помощью-spread-оператора)
    - [Сравнение объектов](#сравнение-объектов)
  - [Проверка наличия и перебор методов и свойств](#проверка-наличия-и-перебор-методов-и-свойств)
    - [Перебор свойств и методов](#перебор-свойств-и-методов)
    - [Функции Object.entries, Object.keys, Object.values](#функции-objectentries-objectkeys-objectvalues)
      - [Object.entries()](#objectentries)
      - [Object.keys()](#objectkeys)
      - [Object.values()](#objectvalues)
  - [Объекты в функциях](#объекты-в-функциях)
    - [Объект как результат функции](#объект-как-результат-функции)
    - [Объект как параметр](#объект-как-параметр)
  - [Функция как объект. Методы call и apply](#функция-как-объект-методы-call-и-apply)
  - [Деструктуризация](#деструктуризация)
    - [Получение оставшихся свойств объекта с помощью rest-оператора](#получение-оставшихся-свойств-объекта-с-помощью-rest-оператора)
    - [Деструктуризация массивов](#деструктуризация-массивов)
      - [Получение оставшихся элементов массива в другой массив](#получение-оставшихся-элементов-массива-в-другой-массив)
      - [Пропуск элементов](#пропуск-элементов)
      - [Деструктуризация многомерных массивов](#деструктуризация-многомерных-массивов)
    - [Деструктуризация объектов из массивов](#деструктуризация-объектов-из-массивов)
    - [Деструктуризация параметров](#деструктуризация-параметров)
    - [Обмен значениями](#обмен-значениями)
  - [Безопасный доступ к свойствам и методам](#безопасный-доступ-к-свойствам-и-методам)
    - [Проверка свойства](#проверка-свойства)
    - [Проверка свойства-массива](#проверка-свойства-массива)
    - [Проверка метода](#проверка-метода)
    - [Цепочка проверок](#цепочка-проверок)
  - [Константные объекты. Запрет изменения объекта](#константные-объекты-запрет-изменения-объекта)
    - [Запрет расширения объектов](#запрет-расширения-объектов)
    - [Закрытие объектов](#закрытие-объектов)
    - [Запрет на изменение значений свойств](#запрет-на-изменение-значений-свойств)
  - [Практическая работа. Работа с объектами](#практическая-работа-работа-с-объектами)
    - [Задание](#задание)
  - [Источники информации](#источники-информации)

### Введение в объекты
В прошлых темах мы работали с примитивными данными — числами, строками, но данные не всегда представляют примитивные типы. Например, если в нашей программе нам надо описать сущность человека, у которого есть имя, возраст, пол и так далее, то естественно мы не сможем представить сущность человека в виде числа или строки. Нам потребуется несколько строк или чисел, чтобы должным образом описать человека. В этом плане человек будет выступать как сложная комплексная структура, у которого будут отдельные свойства — возраст, рост, имя, фамилия и т.д.

Для работы с подобными структурами в JavaScript используются **объекты**. Каждый объект может хранить свойства, которые описывают его **состояние**, и методы, которые описывают его **поведение**.

#### Создание нового объекта
Есть несколько способов создания нового объекта.

Первый способ заключается в использовании конструктора `Object`:
```js
const user = new Object();
```

В данном случае объект называется `user`.

Выражение `new Object()` представляет вызов конструктора — функции, создающей новый объект. Для вызова конструктора применяется оператор **`new`**. Вызов конструктора фактически напоминает вызов обычной функции.

Второй способ создания объекта представляет использование фигурных скобок (литеральная нотация):
```js
const user = {};
```

На сегодняшний день более распространенным является второй способ.

#### Свойства объекта
После создания объекта мы можем определить в нем свойства. Чтобы определить свойство, надо после названия объекта через точку указать имя свойства и присвоить ему значение:
```js
const user = {};
user.name = "Tom";
user.age = 26;
```

В данном случае объявляются два свойства `name` и `age`, которым присваиваются соответствующие значения. После этого мы можем использовать эти свойства, например, вывести их значения в консоли:
```js
console.log(user.name);
console.log(user.age);
```

Также можно определить свойства при определении объекта:
```js
const user = {

    name: "Tom",
    age: 26
};
```

В этом случае для присвоения значения свойству используется символ двоеточия, а после определения свойства ставится запятая (а не точка с запятой).

Кроме того, доступен сокращенный способ определения свойств:
```js
const name = "Tom";
const age = 34;
const user = {name, age};
console.log(user.name);     // Tom
console.log(user.age);      // 34
```

В данном случае названия переменных также являются и названиями свойств объекта. И таким образом можно создавать более сложные конструкции:
```js
const name = "Tom";
const age = 34;
const user = {name, age};

const teacher = {user, course: "JavaScript"};
console.log(teacher.user);      // {name: "Tom", age: 34}
console.log(teacher.course);    // JavaScript
```

#### Методы объекта
Методы объекта определяют его поведение или действия, которые он производит. Методы представляют собой функции. Например, определим метод, который бы выводил имя и возраст человека:
```js
const user = {};
user.name = "Tom";
user.age = 26;
user.display = function(){

    console.log(user.name);
    console.log(user.age);
};

// вызов метода
user.display();
```

Как и в случае с функциями методы сначала определяются, а потом уже вызываются.

Также методы могут определяться непосредственно при определении объекта:
```js
const user = {

    name: "Tom",
    age: 26,
    display: function(){

        console.log(this.name);
        console.log(this.age);
    }
};
```

Как и в случае со свойствами, методу присваивается ссылка на функцию с помощью знака двоеточия.

Чтобы обратиться к свойствам или методам объекта внутри этого объекта, используется ключевое слово **`this`**. Оно означает ссылку на текущий объект.

Также можно использовать сокращенный способ определения методов, когда двоеточие и слово `function` опускаются:
```js
let user = {

    name: "Tom",
    age: 26,
    display(){

        console.log(this.name, this.age);
    },
    move(place){
        console.log(this.name, "goes to", place);
    }
};
user.display(); // Tom 26
user.move("the shop");  // Tom goes to the shop
```

#### Синтаксис массивов
Существует также альтернативный способ определения свойств и методов с помощью синтаксиса массивов:
```js
const user = {};
user["name"] = "Tom";
user["age"] = 26;
user["display"] = function(){

    console.log(user.name);
    console.log(user.age);
};

// вызов метода
user["display"]();
```

Название каждого свойства или метода заключается в кавычки и в квадратные скобки, затем им также присваивается значение. Например, `user["age"] = 26`.

При обращении к этим свойствам и методам можно использовать либо нотацию точки (`user.name`), либо обращаться так: `user["name"]`.

Также можно определить свойства и методы через синтаксис массивов напрямую при создании объекта:
```js
const user = {
    ["name"]: "Tom",
    ["age"]: 26,
    ["display"]: function(){

        console.log(user.name);
        console.log(user.age);
    }
};
user["display"]();
```

##### Строки в качестве свойств и методов
Также следует отметить, что названия свойств и методов объекта всегда представляют строки. То есть мы могли предыдущее определение объекта переписать так:
```js
const user = {
    "name": "Tom",
    "age": 26,
    "display": function(){

        console.log(user.name);
        console.log(user.age);
    }
};
// вызов метода
user.display();
```

С одной стороны, разницы никакой нет между двумя определениями. С другой стороны, бывают случаи, где заключение названия в строку могут помочь. Например, если название свойства состоит из двух слов, разделенных пробелом:
```js
const user = {
    name: "Tom",
    age: 26,
    "full name": "Tom Johns",
    "display info": function(){

        console.log(user.name);
        console.log(user.age);
    }
};
console.log(user["full name"]);
user["display info"]();
```

Только в этом случае для обращении к подобным свойствам и методам мы должны использовать синтаксис массивов.

##### Динамическое определение имен свойств и методов
Синтаксис массивов открывает нам другую возможность — определение имени свойства вне объекта:
```js
const prop1  = "name";
const prop2  = "age";
const tom = {
    [prop1]: "Tom",
    [prop2]: 37
};
console.log(tom);           // {name: "Tom", age: 37}
console.log(tom.name);      // Tom
console.log(tom["age"]);    // 37
```

Благодая этому, например, можно динамически создавать объекты с произвольными названиями свойств:
```js
function createObject(propName, propValue){
    return {
            [propName]: propValue,
            print(){
                console.log(`${propName}: ${propValue}`);
            }
    };
}
const person = createObject("name", "Tom");
person.print();     // name: Tom

const book = createObject("title", "JavaScript Reference");
book.print();   // title: JavaScript Reference
```

#### Удаление свойств
Выше мы посмотрели, как можно динамически добавлять новые свойства к объекту. Однако также мы можем удалять свойства и методы с помощью оператора **`delete`**. И как и в случае с добавлением мы можем удалять свойства двумя способами. Первый способ — использование нотации точки:
```js
delete объект.свойство
```

Либо использовать синтаксис массивов:
```js
delete объект["свойство"]
```

Например, удалим свойство:
```js
let user = {};
user.name = "Tom";
user.age = 26;
user.display = function(){

    console.log(user.name);
    console.log(user.age);
};

console.log(user.name); // Tom
delete user.name; // удаляем свойство
// альтернативный вариант
// delete user["name"];
console.log(user.name); // undefined
```

После удаления свойство будет не определено, поэтому при попытке обращения к нему, программа вернет значение **`undefined`**.

#### Создание объекта из переменных и констант
При создании объекта его свойствам могут передаваться значения переменных, констант или динамически вычисляемые результаты функций:
```js
function getSalary(status){
    if(status==="senior") return 1500;
    else return 500;
}
const name = "Tom";
const age = 37;
const person = { name: name, age: age, salary: getSalary()};

console.log(person);    // {name: "Tom", age: 37, salary: 500}
```

Но если названия констант/переменных совпадает с названиями свойств, то можно сократить передачу значений:
```js
const name = "Tom";
const age = 37;
const salary = 500;
const person = { name, age, salary};

console.log(person);    // {name: "Tom", age: 37, salary: 500}
```

В данном случае объект `person` автоматически получит свойства, названия которых будут соответствовать названиям констант, а в качестве значений иметь значения этих констант.

То же самое относится к передаче функций методам объекта:
```js
function display(){
    console.log(this.name, this.age);
}
const move = function(place){ console.log(this.name, "goes to", place)};
const name = "Tom";
const age = 37;
const salary = 500;
const person = { name, age, salary, display, move};

person.display();       // Tom 37
person.move("cinema");  // Tom goes to cinema
```

В данном случае объект `person` имеет два метода, которые соответствуют переданным в объект функциям — `display()` и `move()`. Стоит отметить, что при такой передаче функций методам объекта, мы по прежнему можем использовать в этих функциях ключевое слово `this` для обращения к функциональности объекта. Однако стоит быть осторожным при передаче лямбд-выражений, поскольку для глобальных лямбд-выражений `this` будет представлять объект окна браузера:
```js
const move = (place)=>{ console.log(this.name, "goes to", place); console.log(this);};
const name = "Tom";

const person = { name, move};
person.move("cinema");  //  goes to cinema
```

#### Фукция Object.fromEntries()
С помощью функции **`Object.fromEntries()`** можно создать объект из набора пар ключ-значение, где ключ потом будет представляет название свойства. Например, создадим объект из массивов:
```js
const personData = [ ["name", "Tom"], ["age", 37]];
const person = Object.fromEntries(personData);
console.log(person);        // {name: "Tom", age: 37}
console.log(person.name);    // Tom
```

Здесь объект создается из массива `personData`, который содержит два подмассива. Каждый подмассив содержит два элемента и фактически представляет пару ключ-значение. Первый элемент представляет ключ, а второй — значение.[^4.1]

### Ключевое слово this
Поведение ключевого слова **`this`** зависит от контекста, в котором оно используется, и от того, в каком режиме оно используется — строгом или нестрогом.

#### Глобальный контекст и объект globalThis
В глобальном контексте `this` ссылается на глобальный объект. Что такое "глобальный объект" в JavaScript? Это зависит от среды, в которой выполняется код. Так, в веб-браузере `this` представляет объект **`window`** — объект, который представляет окно браузера. В среде Node.js `this` представляет объект **`global`**. А для веб-воркеров `this` представляет объект **`self`**.

Например, в веб-браузере при выполнении следующего кода:
```js
console.log(this);
```

мы получим консольный вывод вроде следующего
```
Window {window: Window, self: Window, document: document, name: "", location: Location, …}
```

В стандарт ES2020 было добавлено определение объекта **`globalThis`**, который позволяет ссылаться на глобальный конекст вне зависимости, в какой среде и в какой ситуации выполняется код:
```js
console.log(globalThis);
```

#### Контекст функции
В пределах функции `this` ссылается на внешний контекст. Для функций, определенных в глобальном контексте, — это объект **`globalThis`**. Например:
```js
function foo(){
    var bar = "local";
    console.log(this.bar);
}

var bar = "global";

foo();  // global
```

Если бы мы не использовали бы `this`, то обращение шло бы к локальной переменной, определенной внутри функции.

```js
function foo(){
    var bar = "local";
    console.log(bar);
}

var bar = "global";

foo();  // local
```

Но если бы мы использовали строгий режим (strict mode), то `this` в этом случае имело бы значение `undefined`:
```js
"use strict";
function foo(){
    var bar = "local";
    console.log(this.bar);
}

var bar = "global";

foo();  // ошибка - this - undefined
```

#### Контекст объекта
В контексте объекта, в том числе в его методах, ключевое слово `this` ссылается на этот же объект:
```js
const obj = {
    bar: "object",
    foo: function(){
        console.log(this.bar);
    }
}
var bar = "global";
obj.foo();  // object
```

#### Динамическое определение контекста
Код функции всегда использует в качестве `this` внешний контекст, в которым этот код вызывается (именно вызывается, а не определяется). Рассмотрим более сложный пример:
```js
function foo(){
    var bar = "foo_bar";
    console.log(this.bar);
}

const obj1 = {bar:"obj1_bar", foo: foo};
const obj2 = {bar:"obj2_bar", foo: foo};

var bar = "global_bar";

foo();  // global_bar
obj1.foo();   // obj1_bar
obj2.foo();   // obj2_bar
```

Здесь определена глобальная переменная `bar` ("global_bar"). И также в функции `foo` определена локальная переменная `bar` ("foo_bar"). Значение какой переменной будет выводиться в функции `foo`? Функция foo использует определение переменной, которое определено во внешнем контексте. Для функции `foo` по умолчанию это глобальный контекст, поэтому она выводит значение глобальной переменной (так как данный скрипт запускается в нестрогом режиме, а значит ключевое слово `this` в функции `foo` ссылается на внешний контекст).

Иначе дело обстоит с объектами. Они определяют свой собственный контекст, в котором существует свое свойство `bar`. И при вызове метода `foo` внешним контекстом по отношению к функции будет контекст объектов `obj1` и `obj2`.

Подобное поведение может привести к некоторому непонимаю в отдельных случаях. Так, рассмотрим другую ситуацию:
```js
var bar = "global_bar";

const obj1 = {
    bar: "obj1_bar",
    foo: function(){
        console.log(this.bar);  // bar = "obj1_bar"
    }
}
const obj2 = {bar: "obj2_bar", foo: obj1.foo}; // bar = "obj2_bar"

const foo = obj1.foo;   // bar = "global_bar"

obj1.foo(); // obj1_bar
obj2.foo(); // obj2_bar
foo();      // global_bar
```

Здесь в объекте `obj1` определена функция `foo`:
```js
const obj1 = {
    bar: "obj1_bar",
    foo: function(){
        console.log(this.bar);  // bar = "obj1_bar"
    }
}
```

Эта функция `foo` будет брать значение для `this.bar` из внешнего контекста — из объекта `obj1`, соответственно `this.bar = "obj1_bar"`.

Объект `obj2` использует функцию `foo` из объекта `obj1`:
```js
const obj2 = {bar: "obj2_bar", foo: obj1.foo};
```

Однако функция `obj1.foo` также будет искать значение для `this.bar` опять же во внешнем котексте, а здесь это объект `obj2`. А в объекте `obj2` это значение равно "obj2_bar".

То же самое с глобальной переменной `foo`, которая ссылается на ту же функцию, что и метод `obj1.foo`:
```js
const foo = obj1.foo;
```

В этом случае также будет происходить поиск значения для `this.bar`, но теперь в контексте функции `foo`. А это глобальный контекст, где определена переменная `var bar = "global_bar"`.

#### Контекст во вложенных функциях
Если мы вызываем функцию из другой функции, вызываемая функция также будет использовать внешний контекст:
```js
var bar = "global bar";

function foo(){
    var bar = "foo bar";
    function moo(){

        console.log(this.bar);
    }
    moo();
}
foo();  // global bar
```

Здесь функция `foo()` в качестве `this.bar` использует значение переменной `bar` из внешнего контекста, то есть значение глобальной переменной `bar`. Функция `moo()` также в качестве `this.bar` использует значение переменной `bar` из внешнего контекста, то есть `this.bar` для внешней функции `foo`, которое в свою очередь представляет значение глобальной переменной `bar`. Поэтому в итоге консоль выведет "global bar", а не "foo bar".

#### Явная привязка
С помощью методов `call()` и `apply()` можно задать явную привязку функции к определенному контексту:
```js
function foo(){
    console.log(this.bar);
}

var obj = {bar: "obj_bar"}
var bar = "global_bar";
foo();              // global_bar
foo.apply(obj);     // obj_bar
// или
// foo.call(obj);
```

Во втором случае функция `foo` привязывается к объекту `obj`, который и определяет ее контекст. Поэтому во втором случае консоль выведет "obj_bar".

#### Метод bind
Метод `f.bind(o)` позволяет создать новую функцию с тем же телом и областью видимости, что и функция `f`, но с привязкой к объекту `o`:
```js
function foo(){
    console.log(this.bar);
}

const obj = {bar: "object"}
var bar = "global";
foo();  // global
const func = foo.bind(obj);
func(); // object
```

#### this и стрелочные функции
В стрелочных функциях в качестве **`this`** используется контекст окружения, а не само окружение, в котором определена стрелочная функция. Рассмотрим следующий пример:
```js
const person = {
    name: "Tom",
    say:()=> console.log(`Меня зовут ${this.name}`)
}
person.say();   // Меня зовут
```

Здесь стрелочная функция `say()` обращается к некому свойству `this.name`, но что здесь представляет `this`? Для внешнего контекста, в котором определена стрелочная функция, то есть для контекста объекта `person`, `this` представляет глобальный объект (объект окна браузера). Однако глобальной переменной `name` не определено, поэтому на консоль будет выведено:
```
Меня зовут
```

Теперь немного изменим пример:
```js
const person = {
    name: "Tom",
    hello(){
        console.log("Привет");
        let say = ()=> console.log(`Меня зовут ${this.name}`);
        say();
    }
}
person.hello();
```

Теперь стрелочная функция определена в методе `hello()`. `this` для этого метода представляет текущий объект `person`, где определен данный метод. Поэтому и в стрелочной функции `this` будет представлять объект `person`, а `this.name` — свойство `name` этого объекта. Поэтому при выполнении программы мы получим:
```
Привет
Меня зовут Tom
```


Несмотря на то что, стрелочные функции могут добавить забот при работе `this`, в то же время они могут решить ряд проблем. Так, при работе с несколькими контекстами мы вынуждены учитывать, в каком контексте определяется переменная. Например, возьмем следующий код:
```js
const school ={
    title: "Oxford",
    courses: ["JavaScript", "TypeScript", "Java", "Go"],
    printCourses(){
        this.courses.forEach(function(course){
            console.log(this.title, course);
        })
    }
}
school.printCourses();
```

Функция `printCourses` проходит по всем курсам из массива и при их выводе предваряет их значением свойства `title`. Однако на консоли при запуске программы мы увидим следующее:
```
undefined "JavaScript"
undefined "TypeScript"
undefined "Java"
undefined "Go"
```

Мы видим, что значение `this.title` не определено, так как `this` как контекст объекта замещается глобальным контекстом. В этом случае нам надо передать подобное значение `this.title` или весь контекст объекта.

```js
const school ={
    title: "Oxford",
    courses: ["JavaScript", "TypeScript", "Java", "Go"],
    printCourses(){
        const that = this;
        this.courses.forEach(function(course){
            console.log(that.title, course);
        })
    }
}
school.printCourses();
```

Стрелочные функции также позволяют решить данную проблему:
```js
const school ={
    title: "Oxford",
    courses: ["JavaScript", "TypeScript", "Java", "Go"],
    printCourses(){
        this.courses.forEach((course)=>console.log(this.title, course))
    }
}
school.printCourses();
```

Контекстом для стрелочной функции в данном случае будет выступать контекст объекта `school`. Соответственно, нам не надо определять дополнительные переменые для передачи данных в функцию.[^4.10]

### Вложенные объекты и массивы в объектах
Одни объекты могут содержать в качестве свойств другие объекты. Например, есть объект страны, у которой можно выделить ряд свойств. Одно из этих свойств может представлять столицу. Но у столицы мы также можем выделить свои свойства, например, название, численность населения, год основания:
```js
const country = {

    name: "Германия",
    language: "немецкий",
    capital:{

        name: "Берлин",
        population: 3375000,
        year: 1237
    }
};
console.log("Столица:", country.capital.name); // Берлин
console.log("Население:", country["capital"]["population"]); // 3375000
console.log("Год основания:", country.capital["year"]); // 1237
```

Консольный вывод:
```
Столица: Берлин
Население: 3375000
Год основания: 1237
```

Для доступа к свойствам таких вложенных объектов мы можем использовать стандартную нотацию точки:
```js
country.capital.name
```

Либо обращаться к ним как к элементам массивов:
```js
country["capital"]["population"]
```

Также допустим смешанный вид обращения:
```js
country.capital["year"]
```

В качестве свойств также могут использоваться массивы, в том числе массивы других объектов:
```js
const country = {

    name: "Швейцария",
    languages: ["немецкий", "французский", "итальянский"],
    capital:{

        name: "Берн",
        population: 126598
    },
    cities: [
        { name: "Цюрих", population: 378884},
        { name: "Женева", population: 188634},
        { name: "Базель", population: 164937}
    ]
};

// вывод всех элементов из country.languages
console.log("Официальные языки Швейцарии");
for(const lang of country.languages){
  console.log(lang);
}
console.log("\n");  // для разделения языков от городов

// вывод всех элементов из country.cities
console.log("Города Швейцарии");
for(const city of country.cities){
  console.log(city.name);
}
```

В объекте `country` имеется свойство `languages`, содержащее массив строк, а также свойство cities, хранящее массив однотипных объектов.

С этими массивами мы можем работать также, как и с любыми другими, например, перебрать с помощью цикла **`for`**. При переборе массива объектов каждый текущий элемент будет представлять отдельный объект, поэтому мы можем обратиться к его свойствам и методам:
```js
for(const city of country.cities){
  console.log(city.name);
}
```

Либо для перебора мы могли бы использовать другой тип цикла **`for`** и также пройтись по всем элементам массива:
```js
for(let i=0; i < country.cities.length; i++){
    console.log(country.cities[i].name);
}
```

В итоге браузер выведет содержимое этих массивов:[^4.2]
```
Официальные языки Швейцарии
немецкий
французский
итальянский

Города Швейцарии
Цюрих
Женева
Базель
```

### Копирование и сравнение объектов

#### Копирование объектов
В отличие от данных примитивных типов данные объектов копируются по ссылке. Что это значит? Рассмотрим следующий пример:
```js
const tom = { name: "Tom"};
const bob = tom;
// проверяем свойство name у обоих констант
console.log(tom.name);  // Tom
console.log(bob.name);  // Tom

// меняем свойство name у константы bob
bob.name = "Bob";
// повторно проверяем свойство name у обоих констант
console.log("После изменения")
console.log(tom.name);  // Bob
console.log(bob.name);  // Bob
```

Вначале определяется обычный объект `tom` с одним свойством `name`. Затем присваиваем значение этого объекта константе `bob`
```js
const bob = tom;
```

В данном случае константа `bob` получае ссылку или условно говоря адрес константы `tom`, поэтому после этого присвоения обе константы по сути указывают на один и тот же объект в памяти. Соответственно изменения, произведенные через одну константу:
```js
bob.name = "Bob";
```

Затронут и другую константу — `tom`:
```js
console.log(tom.name);  // Bob
```

Более того, добавим к объекту новое свойство через одну из констант:
```js
const tom = { name: "Tom"};
const bob = tom;
// добавляем константе bob новое свойство - age
bob.age = 37;
// и видим, что для tom тоже добавлено новое свойство
console.log(tom.age);   // 37
```

После добавления свойства `age` константе `bob` можно увидеть, что у константы `tom` то же появилось это свойство, потому что опять же обе константы представляют один и тот же объект.

Что же если мы хотим скопировать из свойства объекта, но при этом обе константы или переменных указывали бы на совершенно разные объекты, изменения одного из которых никак бы не затрагивали другой? В этом случае мы можем воспользоваться встроенным методом **`Object.assign()`**.

#### Метод Object.assign
Метод **`Object.assign()`** принимает два параметра:
```js
Object.assign(target, ...sources)
```

Первый параметр — `target` представляет объект, в который надо скопировать свойства. Второй параметр — `...sources` — набор объектов, из которых надо скопировать свойства (то есть мы можем скопировать свойства сразу из нескольких объектов)

Возвращает метод объект `target`, в который скопированы свойства из объектов `sources`.

Например:
```js
const tom = { name: "Tom", age: 37};
const bob = Object.assign({}, tom);
bob.name = "Bob";
bob.age = 41;

console.log(`Объект tom. Name: ${tom.name}   Age: ${tom.age}`);
console.log(`Объект bob. Name: ${bob.name}   Age: ${bob.age}`);
```

В данном случае вызов `Object.assign({}, tom)` означает, что мы копируем данные из объекта tom в пустой объект `{}`. Результатом этого копирования стал объект `bob`. Причем это совсем другой объект, нежели `tom`. И любые изменения с константой `bob` здесь никак не затронут константу `tom`.

Консольный вывод программы:
```
Объект tom. Name: Tom   Age: 37
Объект bob. Name: Bob   Age: 41
```

##### Копирование из нескольких объектов
Подобным образом можно копировать данные из нескольких объектов:
```js
const tom = { name: "Tom"};
const sam = { age: 37};
const person = { height: 170};
Object.assign(person, tom, sam);    // копируем из tom и sam в person
console.log(person);    // {height: 170, name: "Tom", age: 37}
```

Здесь копируются все свойства из объектов `tom` и `sam` в объект `person`. В итоге после копирования объект `person` будет иметь три свойства.

##### Копирование одноименных свойств
Если объекты, из которых выполняется копирование, содержат одинаковые свойства, то свойства из последних объектов замещают свойства предыдущих:
```js
const tom = { name: "Tom", age: 37};
const sam = { age: 45};
const person = { height: 170};
Object.assign(person, tom, sam);
console.log(person);    // {height: 170, name: "Tom", age: 45}
```

Здесь оба объекта — `tom` и `sam` — содержат свойство `age`, но в объекте `person` свойство `age` равно 45 — значение из объекта `sam`, потому что копирование из объекта `sam` произодится в последнюю очередь.

##### Копирование свойств-объектов
Несмотря на то, что `Object.assign()` прекрасно работает для простых объектов, но что будет, если свойство копируемого объекта также представляет объект:
```js
const tom = { name: "Tom", company: {title: "Microsoft"}};
const bob = Object.assign({}, tom);
bob.name = "Bob";
bob.company.title = "Google";
console.log(tom.name);      // Tom
console.log(tom.company.title);     // Google
```

Здесь свойство `company` объекта `tom` представляет объект с одним свойством. И при копировании объект `bob` получит не копию значения `tom.company`, а ссылку на этот объект. Поэтому изменения `bob.company` затронут и `tom.company`.

#### Копирование объекта с помощью spread-оператора
**spread-оператор `...`** позволяет разложить объект на различные пары свойство-значение, которые можно передать другому объекту.

```js
const tom = { name: "Tom", age: 37, company: "Google"};
const bob = {...tom}
bob.name = "Bob";

console.log(tom);   // {name: "Tom", age: 37, company: "Google"}
console.log(bob);   // {name: "Bob", age: 37, company: "Google"}
```

В данном случае объекту `bob` передаются копии свойств объекта `tom`.

Если какие-то свойства нового объекта должны иметь другие значения (как в примере выше свойство `name`), то их можно указать в конце:
```js
const tom = { name: "Tom", age: 37, company: "Google"};
const bob = {...tom, name: "Bob"};

console.log(bob);   // {name: "Bob", age: 37, company: "Google"}
```

Как видно из предыдущего примера, обе константы после копирования представляют ссылки на разные объекты, и изменения одного из них никак не затронет другой объект.

Тем не менее если объекты содержат вложенные объекты, то эти вложенные объекты при копировании опять же по сути будут представлять ссылки на один и тот же объект:
```js
const tom = { name: "Tom", age: 37, company: {title: "Microsoft"}};
const bob = {...tom}
bob.name = "Bob";
bob.company.title = "Google";

console.log(`${tom.name} - ${tom.company.title}`);  // Tom - Google
console.log(`${bob.name} - ${bob.company.title}`);  // Bob - Google
```

#### Сравнение объектов
Сравним два объекта с помощью стандартных операций сравнения и эквивалентности:
```js
const tom = { name: "Tom"};
const bob = { name: "Bob"};
console.log(tom == bob);    // false
console.log(tom === bob);   // false
```

Оба оператора в данном случае возвратят значение `false`, то есть объекты не равны. Причем даже если значения свойств объектов будет одинаковым, то мы все равно в обоих случаях получим `false`
```js
const tom = { name: "Tom"};
const bob = { name: "Tom"};
console.log(tom == bob);    // false
console.log(tom === bob);   // false
```

Однако, что будет, если обе константы (переменных) хранят ссылку на один и тот же объект:
```js
const tom = { name: "Tom"};
const bob = tom;
console.log(tom == bob);    // true
console.log(tom === bob);   // true
```

В этом случае в обоих случаях мы получим `true`, поскольку значения обоих констант равны, так как по сути это одно и то же значение.

### Проверка наличия и перебор методов и свойств
При динамическом определении в объекте новых свойств и методов перед их использованием бывает важно проверить, а есть ли уже такие методы и свойства. Для этого в javascript может использоваться оператор **`in`**. Он имеет следующий синтаксис:
```js
"свойство|метод" in объект
```

в кавычках идет название свойства или метода, а после **`in`** — название объекта. Если свойство или метод с подобным именем имеется, то оператор возвращает `true`. Если нет — то возвращается `false`.

Например, узнаем, есть ли в объекте ряд свойств:
```js
const user = {};
user.name = "Tom";
user.age = 26;
user.print = function(){

    console.log(this.name);
    console.log(this.age);
};
const hasNameProp = "name" in user;
console.log(hasNameProp); // true - свойство name есть в user

const hasWeightProp = "weight" in user;
console.log(hasWeightProp); // false - в user нет свойства или метода под названием weight
```

С помощью выражения `"name" in user` проверяем, есть ли в объекте `user` свойство `"name"` и результат проверки передаем в константу `hasNameProp`. Далее анологичным образом проверяем наличие свойства `wheight`.

Подобным образом можно проверить и наличие методов:
```js
const hasPrintMethod = "print" in user;
console.log(hasPrintMethod); // true - в user есть метод print
```

Альтернативный способ заключается в проверке на значение **`undefined`**. Если свойство или метод равен `undefined`, то эти свойство или метод не определены:
```js
const hasNameProp = user.name!==undefined;
console.log(hasNameProp); // true
const hasWeightProp = user.weight!==undefined;
console.log(hasWeightProp); // false
```

И так как объекты представляют тип `Object`, а значит, имеет все его методы и свойства, то объекты также могут использовать метод **`hasOwnProperty()`**, который определен в типе `Object`:
```js
const hasNameProp = user.hasOwnProperty("name");
console.log(hasNameProp); // true
const hasPrintMethod = user.hasOwnProperty("print");
console.log(hasPrintMethod); // true
const hasWeightProp = user.hasOwnProperty("weight");
console.log(hasWeightProp); // false
```

#### Перебор свойств и методов
С помощью цикла `for..in` мы можем перебрать объект как обычный массив и получить все его свойства и методы и их значения:
```js
const tom = {
    name: "Tom",
    age: 26,
    print(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    }
};

for(const prop in tom) {
    console.log(prop, " : ", tom[prop]);
}
```

И при запуске консоль браузера отобразит следующий вывод:
```
name : Tom
age : 26
print : print(){
	console.log(`Name: ${this.name}  Age: ${this.age}`);
}
```

#### Функции Object.entries, Object.keys, Object.values
С помощью дополнительных функций **`Object.entries`**, **`Object.keys`** и **`Object.values`** можно получить все свойства (в том числе методы) объекта и их значения.[^4.3]

##### Object.entries()
Функция **`Object.entries()`** в качестве параметра принимает объект и возвращает массив пар "название_свойства - значение", где каждая пара свойство-значение представляет массив. Например:
```js
const tom = {
    name: "Tom",
    age: 26,
    print(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    }
};

for(const prop of Object.entries(tom)) {
    console.log(prop);
}
```

Консольный вывод:
```
["name", "Tom"]
["age", 26]
["print", ƒ]
```

##### Object.keys()
Функция **`Object.keys()`** позволяет получить массив названий всех свойств объекта. Например, возьмем выше определенный объект `tom`:
```js
const tom = {
    name: "Tom",
    age: 26,
    print(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    }
};
console.log(Object.keys(tom)); // ["name", "age", "print"]
```

Соответственно можно перебрать этот набор и получить значения свойств:
```js
for(const prop of Object.keys(tom)) {
    const value = tom[prop];    // получаем по названию значение свойства
    console.log(prop,value);
}
```

Консольный вывод:
```
name Tom
age 26
print ƒ print(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    }
```

##### Object.values()
Функция **`Object.values()`** возвращает массив, который содержит все значения свойств объекта:
```js
const tom = {
    name: "Tom",
    age: 26,
    print(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    }
};
console.log(Object.values(tom)); // ["Tom", 26, print()]
```

### Объекты в функциях

#### Объект как результат функции
Функции могут возвращать объекты. Этот может потребоваться в различных задачах. Например, вынесем создание объекта в отдельную функцию:
```js
function createUser(pName, pAge) {
    return {
        name: pName,
        age: pAge,
        print: function() {
            console.log(`Name: ${this.name}  Age: ${this.age}`);
        }
    };
};
const tom = createUser("Tom", 26);
tom.print();
const alice = createUser("Alice", 24);
alice.print();
```

Здесь функция `createUser()` получает значения `pName` и `pAge` и по ним создает новый объект, который является возвращаемым результатом. Результат работы программы:
```
Name: Tom  Age: 26
Name: Alice  Age: 24
```

Преимуществом вынесения создания объекта в функцию является то, что далее мы можем создать несколько однотипных объектов с разными значениями, то есть выстапть в роли фабрики или конструктора. Кроме того, в подобной функции мы можем проверить переданные значения на корректность и в случае из некорректности как-то прореагировать:
```js
function createUser(pName, pAge) {

  if(pAge < 1 || pAge > 110){       // если возраст меньше 1 или больще 110
      console.log("Age is invalid")
      pAge=1;
  }
    return {
        name: pName,
        age: pAge,
        print: function() {
            console.log(`Name: ${this.name}  Age: ${this.age}`);
        }
    };
};
const tom = createUser("Tom", 26);
tom.print();
const alice = createUser("Alice", 12345);
alice.print();
```

Здесь проверяется параметр `pAge`, который представляет возвраст пользователя. Понятно, что теоретически это может быть любое число, которое может выходить за разумные пределы, например, быть отрицательным. И в данном случае мы проверяем `pAge` на соответствие этому пределу. Если значение `pAge` не соответствует пределу, то присваиваем ему значение по умолчанию — в данном случае 1, и выводим диагностическое сообщение. Консольный вывод программы:
```
Name: Tom  Age: 26
Age is invalid
Name: Alice  Age: 1
```

Также возращение объекта может быть полезно, если нам надо ввернуть из функции больше одного результата — в этом случае мы можем объединить их в один объект. Например, функция принимает массив и находит в нем минимальное и максимальное значения:
```js
function getMinMax(numbers){

  // если массив пуст, минимальное и максимальное значения неопределены
  if(numbers.length === 0) return {min: undefined, max: undefined};

  let minNumber = numbers[0];
  let maxNumber = numbers[0];
  for(let i=1; i< numbers.length; i++){

    if(minNumber > numbers[i]) minNumber = numbers[i];
    if(maxNumber < numbers[i]) maxNumber = numbers[i];
  }
  return {min: minNumber, max: maxNumber};
}

const nums = [1, 2, 3, 4, 5];
const result = getMinMax(nums);
console.log("Min:", result.min);    // Min: 1
console.log("Max:", result.max);    // Max: 5
```

Здесь в функции `getMinMax` получаем массив. Если массив не содержит чисел, то возвращаем объект, где поля `min` и `max` имеют значения `undefined`. Иначе проходим по всему массиву и вычисляем максимальное и минимальное значения и возвращаем их в виде одного объекта.

#### Объект как параметр
Как и все другие значения, объект может передаваться в качестве параметра в функцию:
```js
function printPerson(person){

  console.log("Name:", person.name);
  console.log("Age:", person.age);
}

const tom = {name: "Tom", age: 39};
const alice = {name: "Alice", age: 35};

printPerson(tom);
printPerson(alice);
```

Здесь в функцию `printPerson` передается объект, который, как предполагается, будет иметь два свойства: `name` и `age`.

При этом стоит учитывать, что объект — ссылочный тип, а переменная/константа/параметр, которые представляют объект, фактически хранят ссылку на объект в памяти, а не сам объект. Соответственно при передаче в функцию объекта параметру передается копия ссылки на этот объект. И через эту ссылку функция может изменять различные свойства объекта:
```js
function setAge(person, pAge){

  person.age = pAge;
}

const sam = {name: "Sam", age: 29};
console.log("Before setAge:", sam.age);
setAge(sam, 30);
console.log("After setAge:", sam.age);
```

Здесь сначала определяем константу `sam`, которая представляет объект со свойствами `name` и `age`:
```js
const sam = {name: "Sam", age: 29};
```

Фактически константа `sam` хранит ссылку на область памяти, где расположен объект.

Затем вызывается функция `setAge`, которая получает объект `person` и изменяет у него свойство `age`.

```js
setAge(sam, 30);
```

Поскольку объекты передаются по ссылке, то функция `setAge` получит **копию ссылки**, которая хранится в константе `sam`. То есть после этого константа `sam` и первый параметр функции `setAge` будут представлять **две разные ссылки**, но указывать они будут на один и тот же объект в памяти. Поэтому если внутри функции `setAge` мы изменим свойство этого объекта, то при обращении у объекта `sam` свойство тоже изменится, так как в реальности это один и тот же объект. В итоге браузер нам выведет:
```
Before setAge: 29
After setAge: 30
```

Но если параметру внутри функции присваивается другой объект, то фактически ссылка меняет свое значение и начинает указывать на дргую область памяти:
```js
function setDefault(person){

  person = {name: "Undefined", age: 0};
}

let sam = {name: "Sam", age: 29};
console.log("Before setDefault:", sam.name);
setDefault(sam);
console.log("After setDefault:", sam.name);
```

При передаче переменной `sam` в функцию `setDefault` параметр этой функции и переменная `sam` будут представлять две разные ссылки, но указывать на один и тот же обеъект в памяти:
```js
setDefault(sam);
```

Но потом внутри функции мы изменяем значение параметра:
```js
person = {name: "Undefined", age: 0};
```

В итоге ссылке, которая хранится в параметре `person`, присвается новый объект. Но поскольку переменная `sam` и параметр `person` представляют две разные ссылки, то это присваивание никак не затронет объект `sam`.[^4.4]

### Функция как объект. Методы call и apply
В JavaScript функция тоже является объектом — объектом **`Function`** и тоже имеет прототип, свойства, методы. Все функции, которые используются в программе, являются объектами `Function` и имеют все его свойства и методы.

Например, мы можем создать функцию с помощью конструктора `Function`:
```js
const square = new Function("n", "return n * n;");
console.log(square(5));     // 25
```

В конструктор `Function` может передаваться ряд параметров. Последний параметр представляет собой само тело функции в виде строки. Фактически строка содержит код javascript. Предыдущие аргументы содержат названия параметров. В данном случае определяется функция возведения числа в квадрат, которая имеет один параметр `n`.

Среди свойств объекта Function можно выделить следующие:

- **`arguments`**: массив аргументов, передаваемых в функцию

- **`length`**: определяет количество аргументов, которые ожидает функция

- **`caller`**: определяет функцию, вызвавшую текущую выполняющуюся функцию

- **`name`**: имя функции

- **`prototype`**: прототип функции

С помощью прототипа мы можем определить дополнительные свойства:
```js
function sayHello(){

    console.log("Hello");
}
// изменяем прототип для всех функций
Function.prototype.program ="Hello World";

console.log(sayHello.program); // Hello World
```

Среди методов надо отметить методы **`call()`** и **`apply()`**.

Метод **`call()`** вызывает функцию с указанным значением `this` и аргументами:
```js
function sum(x, y){

    return x + y;
}
const result = sum.call(this, 3, 8);

console.log(result); // 11
```

**`this`** указывает на объект, для которого вызывается функция — в данном случае это глобальный объект `window`. После `this` передаются значения для параметров.[^4.8]

При передаче объекта через первый параметр, мы можем ссылаться на него через ключевое слово **`this`**:
```js
function User (name, age) {
    this.name = name;
    this.age = age;
}
const tom = new User("Tom", 39);
function print(){
    console.log("Name:", this.name);
}
print.call(tom); // Name: Tom
```

В данном случае передается только одно значение, поскольку функция `print` не принимает параметров. То есть функция будет вызываться для объекта `tom`.

Если нам не важен объект, для которого вызывается функция, то можно передать значение `null`:
```js
function sum(x, y){

    return x + y;
}
const result = sum.call(null, 3, 8);

console.log(result); // 11
```

На метод `call()` похож метод **`apply()`**, который также вызывает функцию и в качестве первого параметра также получает объект, для которого функция вызывается. Только теперь в качестве второго параметра передается массив аргументов:
```js
function sum(x, y){

    return x + y;
}
const result = sum.apply(null, [3, 8]);

console.log(result); // 11
```

### Деструктуризация
Деструктуризация (destructuring) позволяет извлечь из объекта отдельные значения в переменные или константы:
```js
const user = {
    name: "Tom",
    age: 24,
    phone: "+367438787",
    email: "tom@gmail.com"
};
const {name, email} = user;
console.log(name);      // Tom
console.log(email);     // tom@gmail.com
```

При деструктуризации объекта переменные помещаются в фигурные скобки и им присваивается объект. Сопоставление между свойствами объекта и переменными/константами идет по имени.

Мы можем указать, что мы хотим получить значения свойств объекта в переменные/константы с другим именем:
```js
const user = {
    name: "Tom",
    age: 24,
    phone: "+367438787",
    email: "tom@gmail.com"
};
const {name: userName, email: mailAddress} = user;
console.log(userName);      // Tom
console.log(mailAddress);   // tom@gmail.com
```

В данном случае свойство `name` сопоставляется с переменной `userName`, а поле `email` — с переменной `mailAddress`.

Также можно задать для переменных/констант значения по умолчанию, если в объекте вдруг не окажется соответствующих свойств:
```js
const user = {
    name: "Tom",
    age: 24,
};
const {name  = "Sam", email: mailAddress = "sam@gmail.com"} = user;
console.log(name);              // Tom
console.log(mailAddress);       // sam@gmail.com
```

Если переменная/константа при деструктуризации сопоставляется со свойством, который представляет сложный объект, то после деструктуризации эта переменная/константа также будет представлять сложный объект:
```js
const user = {
    name: "Tom",
    age: 24,
    account: {
        login: "tom555",
        password: "qwerty"
    }
};
const {account} = user;
console.log(account.login);         // tom555
console.log(account.password);      // qwerty
```

Но если нам мы хотим получить отдельные значения из вложенного сложного объекта, как в примере выше объект `account` внутри объекта `user`, то нам необязательно получать весь этот объект — мы также можем для его свойств предоставить отдельные переменные/константы:
```js
const user = {
    name: "Tom",
    age: 24,
    account: {
        login: "tom555",
        password: "qwerty"
    }
};
const {name, account: {login}} =  user;
console.log(name);      // Tom
console.log(login);     // tom555
```

Здесь мы получаем в переменную `login` значение свойства `user.account.login`.

#### Получение оставшихся свойств объекта с помощью rest-оператора
**rest-оператор** или оператор **`...`** позволяет получить оставшиеся свойства объекта, которые не сооставлены с переменными/константами, в отдельную переменную/константу:
```js
const tom = {
    name: "Tom",
    age: 24,
    phone: "+367438787",
    email: "tom@gmail.com"
};
const {name, age, ...contacts} = tom;
console.log(name);      // Tom
console.log(age);       // 24
console.log(contacts);  // {phone: "+367438787", email: "tom@gmail.com"}
```

В данном случае мы раскладываем объект tom на три константы: `name`, `age` и `contacts`. Константы `name` и `age` сопоставляются со свойствами объекта `tom` по имени. А константа `contacts` получает все оставшиеся несопоставленные свойства объекта. Однако чтобы их получить, перед названием константы указыватся оператор **`...`**: `...contacts`. То есть в данном случае константа `contacts` будет предлагать объект, который будет содержать свойства `email` и `phone` объекта `tom`.

Стоит отметить, что переменная/константа, которая получает все оставшиеся свойства объекта, всегда будет представлять объект, даже если она получит только одно свойства из объекта.

#### Деструктуризация массивов
Также можно разложить массивы:
```js
const users = ["Tom", "Sam", "Bob"];
const [a, b, c] = users;

console.log(a);     // Tom
console.log(b);     // Sam
console.log(c);     // Bob
```

При деструктуризации массива переменные помещаются в квадратные скобки и последовательно получают значения элементов массива.

Если переменных/констант меньше, чем элементов массива, то оставшиеся элементы массива просто опускаются.

```js
const users = ["Tom", "Sam", "Bob"];
const [a, b] = users;

console.log(a);     // Tom
console.log(b);     // Sam
```

Если переменных/констант больше, чем элементов массива, то несопоставленные переменные/константы получают значение `undefined`:
```js
const users = ["Tom", "Sam", "Bob"];
const [a, b, c, d] = users;

console.log(a);     // Tom
console.log(b);     // Sam
console.log(c);     // Bob
console.log(d);     // undefined
```

##### Получение оставшихся элементов массива в другой массив
С помощью оператора **`...`** также можно получить все оставшиеся элементы массива в виде другого массива:
```js
const users = ["Tom", "Sam", "Bob", "Mike"];
const [tom, ...others] = users;

console.log(tom);       // Tom
console.log(others);    // ["Sam", "Bob", "Mike"]
```

Здесь массив `others` будет содержать три последних элемента массива.

##### Пропуск элементов
При этом мы можем пропустить ряд элементов массива, оставив вместо имен переменных пропуски:
```js
const users = ["Tom", "Sam", "Bob", "Ann", "Alice", "Kate"];
const [first,,,,fifth] = users;

console.log(first);     // Tom
console.log(fifth);     // Alice
```

Выражение `first,,,,fifth` указывает, что мы хотим получить первый элемент массива в переменную `first`, затем пропустить три элемента и получить пятый элемент в переменную `fifth`.

Подобным образом можно получить, например, второй и четвертый элементы:
```js
const users = ["Tom", "Sam", "Bob", "Ann", "Alice", "Kate"];
const [,second,,forth] = users;

console.log(second);        // Sam
console.log(forth);         // Ann
```

##### Деструктуризация многомерных массивов
```js
const coordinates = [[1,2,3], [4,5,6], [7,8,9]];

const [
    [x1,y1,z1],
    [x2,y2,z2],
    [x3,y3,z3]
] = coordinates;
```

#### Деструктуризация объектов из массивов
Можно совместить получение данных из массива и объекта:
```js
const people = [
    {name: "Tom", age: 34},
    {name: "Bob", age: 23},
    {name: "Sam", age: 32}
];
const [,{name}] = people;

console.log(name);      // Bob
```

В данном случае получаем значение свойства `name` второго объекта в массиве.[^4.11]

Другой пример — деструктуризация объектов при переборе массива объектов:
```js
const people = [
    {name: "Tom", age: 34},
    {name: "Bob", age: 23},
    {name: "Sam", age: 32}
];
const [,{name}] = people;
for(let {name: username, age: userage} of people){
    console.log(`Name: ${username}  Age: ${userage}`);
}
// консольный вывод
// Name: Tom  Age: 34
// Name: Bob  Age: 23
// Name: Sam  Age: 32
```

#### Деструктуризация параметров
Если в функцию в качестве параметра передается массив или объект, то его также можно подобным образом разложить на отдельные значения:
```js
function display({name:userName, age:userAge}){
    console.log(userName, userAge);
}
function sum([a, b, c]){
    const result = a + b + c;
    console.log(result);
}
const user = {name:"Alice", age:33, email: "alice@gmail.com"};

const numbers = [3, 5, 7, 8];

display(user);  // Alice 33
sum(numbers);   // 15
```

#### Обмен значениями
Благодаря деструктуризации очень просто стало проводить обмен значениями между двумя переменными:
```js
let first = "Tom";
let second = "Bob";
[first, second] = [second, first];

console.log(first);     // Bob
console.log(second);    // Tom
```

Что упрощает решение ряда задач. Например, используем деструктуризацию для простейшей сортировки массива:
```js
let nums = [9, 3, 5, 2, 1, 4, 8, 6];
for(let i = 0; i < nums.length; i++)
    for(let j = 0; j < nums.length; j++)
        if (nums[i] < nums[j]) [nums[j], nums[i]] = [nums[i], nums[j]];

console.log(nums);  // [1, 2, 3, 4, 5, 6, 8, 9]
```

### Безопасный доступ к свойствам и методам
Оператор **`?.`** или optional chaning-оператор позволяет проверить объект и его свойства и методы на `null` и `undefined`, и если объект или его свойства/методы определены, то обратиться к его свойствам или методам:
```js
const tom = null;
const bob = {name: "Bob"};

function printName(person){
    console.log(person.name);
}
printName(tom); // Uncaught TypeError: Cannot read properties of null (reading "name")
printName(bob);
```

В данном случае переменная `tom` равна `null`, соответственно у ней нет свойства `name`. Соответственно при передаче этого объекта в функцию `printName` мы получим ошибку. В этом случае мы можем перед обращением к объекту проверять его на `null` и `undefined`:
```js
const tom = null;
const bob = {name: "Bob"};

function printName(person){
    if(person !==null && person !==undefined) console.log(person.name);
}
printName(tom);
printName(bob); // Bob
```

Также мы можем сократить проверку:
```js
function printName(person){
    if(person) console.log(person.name);
}
```

Если person равен `null` или `undefined`, то `if(person)` возвратит `false`.

Однако оператор **`?.`** предлагает более элегантный способ решения:
```js
const tom = null;
const bob = {name: "Bob"};

function printName(person){
    console.log(person?.name);
}
printName(tom); // undefined
printName(bob); // Bob
```

После названия объекта указывается оператор `?.` — если значение не равно `null` и `undefined`, то идет обращение к свойству/методу, которые указаны после точки. Если же значени равно `null`/`undefined`, то обращения к свойству/методу не происходит. И на консоли мы увидим `undefined`.

Данный оператор можно использовать перед обращением как к свойствам, так и к методам объекта:
```js
const tom = undefined;
const bob = {
    name: "Bob", 
    sayHi(){
        console.log(`Hi! I am ${this.name}`);
    }
};

console.log(tom?.name); // undefined
console.log(bob?.name); // Bob
tom?.sayHi();           // не выполняется
bob?.sayHi();           // Hi! I am Bob
```

В данном случае обращение к свойству `name` и методу `sayHi()` происходит только в том случае, если объекты `tom` и `bob` не равны `null`/`undefined`.

Более того далее по цепочке вызывов проверять наличие свойства или метода в объекте.[^4.18]

```js
obj.val?.prop       // проверка свойства
obj.arr?.[index]    // провера массива
obj.func?.(args)    // проверка функции
```

#### Проверка свойства
Объект может быть определен, однако не иметь какого-то свойства:
```js
const tom = { name: "Tom"};
const bob = {
    name: "Bob",
    company: {
        title: "Microsoft"
    }
};

console.log(tom.company?.title);    // undefined
console.log(bob.company?.title);    // Microsoft
```

Подобным образом мы можем обращаться к свойствам объекта с помощью синтаксиса массивов:
```js
const tom = { name: "Tom"};
const bob = {
    name: "Bob",
    company: {
        title: "Microsoft"
    }
};

console.log(tom.company?.["title"]);    // undefined
console.log(bob.company?.["title"]);    // Microsoft
```

#### Проверка свойства-массива
Аналогично мы можем проверять наличие свойства-массива перед обращением к его элементам:
```js
const tom = { name: "Tom"};
const bob = {
    name: "Bob",
    languages: ["javascript", "typescript"]
};

console.log(tom.languages?.[0]);    // undefined
console.log(bob.languages?.[0]);    // javascript
```

#### Проверка метода
Объект также может не иметь вызываемого у него метода. Если метод не определен, то при обращении к неопределенному методу мы столкнемся с ошибкой, и в этом случае также можно проверять наличие метода:
```js
const tom = { name: "Tom"};
const bob = {
    name: "Bob",
    say(words){
        console.log(words);
    }
};

console.log(tom.say?.("my name is Tom"));   // undefined
console.log(bob.say?.("my name is Bob"));   // my name is Bob
```

#### Цепочка проверок
С помощью оператора `?.` можно создавать цепочки проверок, последовательно проверяя, представляет ли значение `null`/`undefined`:
```js
const sam = {name: "Sam"};
const tom = {
    name: "Tom",
    company: { title: "Google"}
};
const bob = {
    name: "Bob",
    company: {
        title: "Microsoft",
        print(){
            console.log(`Компания ${this.title}`)
        }
    }
};
sam?.company?.print?.();    // не вызывается - нет свойства company
tom?.company?.print?.();    // не вызывается - нет метода print
bob?.company?.print?.();    // Компания Microsoft
```

### Константные объекты. Запрет изменения объекта
Язык JavaScript позволяет нам динамически менять свойства объектов, добавлять в объекты новые свойства и методы или удалять уже имеющиеся. Однако, подобные изменения объекта могут быть нежелательны. И JavaScript предоставляет для этого три механизма:

- Запрет расширения объектов

- Закрытие (sealing) объектов

- Заморозка (freezing) объектов

#### Запрет расширения объектов
Метод **`Object.preventExtensions()`** позволяет запретить расширение объекта, то есть в этот объект нельзя добавлять новые свойства и методы. Метод **`Object.preventExtensions()`** в качестве параметра принимает целевой объект, для которого надо установить запрет на расширение.

Сначала возьмем пример, где мы успешно добавляем новое свойство:
```js
const tom = {name: "Tom"};
// добавляем в объект tom новое свойство - company
tom.company = "Localhost";

console.log(`Name: ${tom.name}  Company: ${tom.company}`); // Name: Tom  Company: Localhost
```

Здесь в объект `tom` добавляется новое свойство `company`. После добавления мы можем использовать это свойство.

Теперь запретим расширение, применив метод **`Object.preventExtensions()`**:
```js
const tom = {name: "Tom"};
Object.preventExtensions(tom);  // запрещаем расширение объекта tom
tom.company = "Localhost";  // пытаемся добавить в объект tom новое свойство
console.log(`Name: ${tom.name}  Company: ${tom.company}`); // Name: Tom  Company: undefined
```

В итоге даже если мы попытаемся определить для объекта новое свойство, оно не будет добавлено. А при попытке обратиться к подобному свойству мы получим **`undefined`**.

Иногда может возникнуть необходимость определить, является ли объект расширяемым. Например, если объект расширяем, мы можем добавить в его свойства и затем использовать эти свойства. Для проверки расширяемости можно использовать метод **`Object.isExtensible()`**. В этот метод передается тестируемый объект. И если объект поддерживает расширение, то метод возвращает **`true`**, иначе возвращается **`false`**:
```js
const tom = {name: "Tom"};
console.log(Object.isExtensible(tom));  // true
Object.preventExtensions(tom);  // запрещаем расширение объекта tom
console.log(Object.isExtensible(tom));  // false
```

#### Закрытие объектов
Закрытие или "запечатывание" объектов (sealing) также позволяет запретить расширение объектов. Но кроме того, также запрещает настройку уже существующих свойств. Для закрытия объектов применяется метод **`Object.seal()`**.

Сначала посмотрим, что мы можем сделать с объектом без применения **`Object.seal()`**:
```js
const tom = {name: "Tom"};

// для свойства name запрещаем изменение
Object.defineProperty(tom, "name", { writable: false});
tom.name = "Tomas";

// добавляем новое свойство - age
tom.age = 39;
console.log(`Name: ${tom.name}  Age: ${tom.age}`);  // Name: Tom  Age: 39

// для свойства name разрешаем изменение
Object.defineProperty(tom, "name", { writable: true});
tom.name = "Tomas";
console.log(`Name: ${tom.name}  Age: ${tom.age}`);  // Name: Tomas  Age: 39
```

Итак, мы можем изменить конфигурацию свойства (здесь делаем свойство `name` недоступным для записи). И также мы можем добавить в объект новое свойство.

Теперь применим метод **`Object.seal()`**:
```js
const tom = {name: "Tom"};
Object.seal(tom);       // закрываем объект tom от расширения и изменения конфигурации
// для свойства name запрещаем изменение
Object.defineProperty(tom, "name", { writable: false});
tom.name = "Tomas";

// добавляем новое свойство - age
tom.age = 39;
console.log(`Name: ${tom.name}  Age: ${tom.age}`);  // Name: Tom  Age: undefined

// для свойства name разрешаем изменение
Object.defineProperty(tom, "name", { writable: true}); // Uncaught TypeError: Cannot redefine property: name
```

После закрытия объекта методом `Object.seal(tom)` мы не сможем добавить в объект новое свойство. Соответственно в примере выше свойство `tom.age` будет равно `undefined`. И также мы не сможем повторно изменить конфигурацию свойства. Так, здесь при втором вызове метода `Object.defineProperty()` для свойства name мы столкнемся с ошибкой `"Uncaught TypeError: Cannot redefine property: name"`.

Для проверки, является ли объект закрытым, мы можем использовать метод **`Object.isSealed()`** — если объект закрыт, метод возвращает `true`. Стоит отметить, что поскольку закрытый объект нерасширяем, то метод **`Object.isExtensible()`** возвращает для него `false`:
```js
const tom = {name: "Tom"};
console.log(Object.isExtensible(tom));  // true
console.log(Object.isSealed(tom));      // false
Object.seal(tom);       // закрываем объект tom
console.log(Object.isExtensible(tom));  // false
console.log(Object.isSealed(tom));      // true
```

#### Запрет на изменение значений свойств
Заморозка или **freezing** позволяет запретить изменение значений свойств, то есть позволяет сделать объект в полной мере константным. Так, просто определить объект как обычную константу с помощью оператора **`const`** недостаточно. Например:
```js
const tom = {name: "Tom"};
tom.name= "Tomas";
console.log(tom.name);  // Tomas
```

Здесь мы видим, что свойство объекта изменило свое значение, хотя объект определен как константа.

Оператор `const` лишь влияет на то, что мы не можем присвоить константе новое значение, например, как в следующем случае:
```js
const tom = {name: "Tom"};
tom = {name: "Sam"};    // Ошибка - нельзя константе присвоить значение второй раз
```

Тем не менее значения свойств объекта мы можем изменять.

Чтобы сделать объект действительно константным, необходимо применить специальный метод **`Object.freeze()`**. В этот метод в качестве параметра передается объект, который надо сделать константным:
```js
const tom = {name: "Tom"};
Object.freeze(tom);
tom.name= "Tomas";      // значение свойства нельзя изменить
console.log(tom.name);  // Tom
```

Для проверки, можно ли изменить значения свойств объекта, применяется метод **`Object.isFrozen()`** — если значения свойств изменить нельзя, он возвращает `true`.[^4.20]

Следует отметить, что "замороженный" объект — это крайняя степень запрета изменений на объекте. Соответственно такой объект нерасширяем, и также нельзя изменить конфигурацию его свойств:
```js
const tom = {name: "Tom"};
console.log(Object.isExtensible(tom));  // true
console.log(Object.isSealed(tom));      // false
console.log(Object.isFrozen(tom));      // false
Object.freeze(tom);
console.log(Object.isExtensible(tom));  // false
console.log(Object.isSealed(tom));      // true
console.log(Object.isFrozen(tom));      // true
```

### Практическая работа. Работа с объектами

#### Задание
1. Задать объект `room` и его параметры:

   - ключ `height` со значением `3`;
   - ключ `width` со значением `5.5`;
   - ключ `length` со значением `3.2`;
   - ключ `tv` со значением `"Samsung"`;
   - ключ `big` со значением `true`.

   Вывести в консоль все параметры объекта `room` по очереди. Предусмотреть метод для определения площади и объема помещения.

2. Создать объект «Книга» с полями на основе данных, предоставляемых пользователем: *название*, *автор*, *год издания*. Добавить в объект «Книга» метод, который возвращает строку с информацией о книге в формате: *«Название* — *Автор* (*Год*)».

3. Создать объект «Пользователь» с полями на основе данных, вводимых пользователем: логин, пароль, фамилия, имя, отчество. Автоматически при создании объекта назначать ему роль наблюдателя. Реализовать метод для смены роли пользователя на одну из предустановленных в системе (администратор, модератор, наблюдатель). Добавить в объект «Пользователь» метод для вывода информации в формате: «*логин*: *Фамилия И.О.* (*роль*)». Логин и пароль должны быть обязательными для введения, если фамилия, имя или отчество неизвестны (не определены пользователем), то на их месте ставить прочерки (`-`).

4. Создать объект «Фильм» с динамическими свойствами: название, режиссер, год выпуска, список актеров (массив объектов). Объекты, соответствующие режиссеру и актерам, должны содержать фамилию, имя, отчество, пол и год рождения. Предусмотреть методы для добавления или удаления актеров, а также замены режиссера.

5. Создать объект, где ключами будут имена дней недели, а значениями — расписание занятий на каждый день в массива объектов, содержащих номер пары, название учебного предмета, номер группы и фамилию преподавателя. Добавить возможность изменять расписание.

### Источники информации
[^4.1]: [Объектно-ориентированное программирование](https://metanit.com/web/javascript/4.1.php)
[^4.10]: [Ключевое слово this](https://metanit.com/web/javascript/4.10.php)
[^4.2]: [Вложенные объекты и массивы в объектах](https://metanit.com/web/javascript/4.2.php)
[^4.13]: [Копирование и сравнение объектов](https://metanit.com/web/javascript/4.13.php)
[^4.3]: [Проверка наличия и перебор методов и свойств](https://metanit.com/web/javascript/4.3.php)
[^4.4]: [Объекты в функциях](https://metanit.com/web/javascript/4.4.php)
[^4.8]: [Функция как объект. Методы call и apply](https://metanit.com/web/javascript/4.8.php)
[^4.11]: [Деструктуризация](https://metanit.com/web/javascript/4.11.php)
[^4.18]: [Оператор ?.](https://metanit.com/web/javascript/4.18.php)
[^4.20]: [Константные объекты. Запрет изменения объекта](https://metanit.com/web/javascript/4.20.php)
