## Объекты

- [Объекты](#объекты)
  - [Введение в объекты](#введение-в-объекты)
    - [Создание нового объекта](#создание-нового-объекта)
    - [Свойства объекта](#свойства-объекта)
    - [Методы объекта](#методы-объекта)
    - [Синтаксис массивов](#синтаксис-массивов)
      - [Строки в качестве свойств и методов](#строки-в-качестве-свойств-и-методов)
      - [Динамическое определение имен свойств и методов](#динамическое-определение-имен-свойств-и-методов)
    - [Удаление свойств](#удаление-свойств)
    - [Создание объекта из переменных и констант](#создание-объекта-из-переменных-и-констант)
    - [Фукция Object.fromEntries()](#фукция-objectfromentries)
  - [Ключевое слово this](#ключевое-слово-this)
    - [Глобальный контекст и объект globalThis](#глобальный-контекст-и-объект-globalthis)
    - [Контекст функции](#контекст-функции)
    - [Контекст объекта](#контекст-объекта)
    - [Динамическое определение контекста](#динамическое-определение-контекста)
    - [Контекст во вложенных функциях](#контекст-во-вложенных-функциях)
    - [Явная привязка](#явная-привязка)
    - [Метод bind](#метод-bind)
    - [this и стрелочные функции](#this-и-стрелочные-функции)
  - [Вложенные объекты и массивы в объектах](#вложенные-объекты-и-массивы-в-объектах)
  - [Копирование и сравнение объектов](#копирование-и-сравнение-объектов)
    - [Копирование объектов](#копирование-объектов)
    - [Метод Object.assign](#метод-objectassign)
      - [Копирование из нескольких объектов](#копирование-из-нескольких-объектов)
      - [Копирование одноименных свойств](#копирование-одноименных-свойств)
      - [Копирование свойств-объектов](#копирование-свойств-объектов)
    - [Копирование объекта с помощью spread-оператора](#копирование-объекта-с-помощью-spread-оператора)
    - [Сравнение объектов](#сравнение-объектов)
  - [Проверка наличия и перебор методов и свойств](#проверка-наличия-и-перебор-методов-и-свойств)
    - [Перебор свойств и методов](#перебор-свойств-и-методов)
    - [Функции Object.entries, Object.keys, Object.values](#функции-objectentries-objectkeys-objectvalues)
      - [Object.entries()](#objectentries)
      - [Object.keys()](#objectkeys)
      - [Object.values()](#objectvalues)
  - [Объекты в функциях](#объекты-в-функциях)
    - [Объект как результат функции](#объект-как-результат-функции)
    - [Объект как параметр](#объект-как-параметр)
  - [Функции-конструкторы объектов](#функции-конструкторы-объектов)
    - [Оператор instanceof](#оператор-instanceof)
  - [Расширение объектов. Прототипы](#расширение-объектов-прототипы)
    - [Прототип функций-конструкторов](#прототип-функций-конструкторов)
    - [Конструктор и прототип](#конструктор-и-прототип)
    - [Определение свойств прототипа](#определение-свойств-прототипа)
  - [Практическая работа. Работа с объектами](#практическая-работа-работа-с-объектами)
    - [Задание](#задание)
  - [Источники информации](#источники-информации)

Объектно-ориентированное программирование на сегодняшний день является одной из господствующих парадигм в разработке приложений, и в JavaScript мы также можем использовать все преимущества ООП. В то же время применительно к JavaScript объектно-ориентированное программирование имеет некоторые особенности.

### Введение в объекты
В прошлых темах мы работали с примитивными данными — числами, строками, но данные не всегда представляют примитивные типы. Например, если в нашей программе нам надо описать сущность человека, у которого есть имя, возраст, пол и так далее, то естественно мы не сможем представить сущность человека в виде числа или строки. Нам потребуется несколько строк или чисел, чтобы должным образом описать человека. В этом плане человек будет выступать как сложная комплексная структура, у которого будут отдельные свойства — возраст, рост, имя, фамилия и т.д.

Для работы с подобными структурами в JavaScript используются **объекты**. Каждый объект может хранить свойства, которые описывают его **состояние**, и методы, которые описывают его **поведение**.

#### Создание нового объекта
Есть несколько способов создания нового объекта.

Первый способ заключается в использовании конструктора `Object`:
```js
const user = new Object();
```

В данном случае объект называется `user`.

Выражение `new Object()` представляет вызов конструктора — функции, создающей новый объект. Для вызова конструктора применяется оператор **`new`**. Вызов конструктора фактически напоминает вызов обычной функции.

Второй способ создания объекта представляет использование фигурных скобок (литеральная нотация):
```js
const user = {};
```

На сегодняшний день более распространенным является второй способ.

#### Свойства объекта
После создания объекта мы можем определить в нем свойства. Чтобы определить свойство, надо после названия объекта через точку указать имя свойства и присвоить ему значение:
```js
const user = {};
user.name = "Tom";
user.age = 26;
```

В данном случае объявляются два свойства `name` и `age`, которым присваиваются соответствующие значения. После этого мы можем использовать эти свойства, например, вывести их значения в консоли:
```js
console.log(user.name);
console.log(user.age);
```

Также можно определить свойства при определении объекта:
```js
const user = {

    name: "Tom",
    age: 26
};
```

В этом случае для присвоения значения свойству используется символ двоеточия, а после определения свойства ставится запятая (а не точка с запятой).

Кроме того, доступен сокращенный способ определения свойств:
```js
const name = "Tom";
const age = 34;
const user = {name, age};
console.log(user.name);     // Tom
console.log(user.age);      // 34
```

В данном случае названия переменных также являются и названиями свойств объекта. И таким образом можно создавать более сложные конструкции:
```js
const name = "Tom";
const age = 34;
const user = {name, age};

const teacher = {user, course: "JavaScript"};
console.log(teacher.user);      // {name: "Tom", age: 34}
console.log(teacher.course);    // JavaScript
```

#### Методы объекта
Методы объекта определяют его поведение или действия, которые он производит. Методы представляют собой функции. Например, определим метод, который бы выводил имя и возраст человека:
```js
const user = {};
user.name = "Tom";
user.age = 26;
user.display = function(){

    console.log(user.name);
    console.log(user.age);
};

// вызов метода
user.display();
```

Как и в случае с функциями методы сначала определяются, а потом уже вызываются.

Также методы могут определяться непосредственно при определении объекта:
```js
const user = {

    name: "Tom",
    age: 26,
    display: function(){

        console.log(this.name);
        console.log(this.age);
    }
};
```

Как и в случае со свойствами, методу присваивается ссылка на функцию с помощью знака двоеточия.

Чтобы обратиться к свойствам или методам объекта внутри этого объекта, используется ключевое слово **`this`**. Оно означает ссылку на текущий объект.

Также можно использовать сокращенный способ определения методов, когда двоеточие и слово `function` опускаются:
```js
let user = {

    name: "Tom",
    age: 26,
    display(){

        console.log(this.name, this.age);
    },
    move(place){
        console.log(this.name, "goes to", place);
    }
};
user.display(); // Tom 26
user.move("the shop");  // Tom goes to the shop
```

#### Синтаксис массивов
Существует также альтернативный способ определения свойств и методов с помощью синтаксиса массивов:
```js
const user = {};
user["name"] = "Tom";
user["age"] = 26;
user["display"] = function(){

    console.log(user.name);
    console.log(user.age);
};

// вызов метода
user["display"]();
```

Название каждого свойства или метода заключается в кавычки и в квадратные скобки, затем им также присваивается значение. Например, `user["age"] = 26`.

При обращении к этим свойствам и методам можно использовать либо нотацию точки (`user.name`), либо обращаться так: `user["name"]`.

Также можно определить свойства и методы через синтаксис массивов напрямую при создании объекта:
```js
const user = {
    ["name"]: "Tom",
    ["age"]: 26,
    ["display"]: function(){

        console.log(user.name);
        console.log(user.age);
    }
};
user["display"]();
```

##### Строки в качестве свойств и методов
Также следует отметить, что названия свойств и методов объекта всегда представляют строки. То есть мы могли предыдущее определение объекта переписать так:
```js
const user = {
    "name": "Tom",
    "age": 26,
    "display": function(){

        console.log(user.name);
        console.log(user.age);
    }
};
// вызов метода
user.display();
```

С одной стороны, разницы никакой нет между двумя определениями. С другой стороны, бывают случаи, где заключение названия в строку могут помочь. Например, если название свойства состоит из двух слов, разделенных пробелом:
```js
const user = {
    name: "Tom",
    age: 26,
    "full name": "Tom Johns",
    "display info": function(){

        console.log(user.name);
        console.log(user.age);
    }
};
console.log(user["full name"]);
user["display info"]();
```

Только в этом случае для обращении к подобным свойствам и методам мы должны использовать синтаксис массивов.

##### Динамическое определение имен свойств и методов
Синтаксис массивов открывает нам другую возможность — определение имени свойства вне объекта:
```js
const prop1  = "name";
const prop2  = "age";
const tom = {
    [prop1]: "Tom",
    [prop2]: 37
};
console.log(tom);           // {name: "Tom", age: 37}
console.log(tom.name);      // Tom
console.log(tom["age"]);    // 37
```

Благодая этому, например, можно динамически создавать объекты с произвольными названиями свойств:
```js
function createObject(propName, propValue){
    return {
            [propName]: propValue,
            print(){
                console.log(`${propName}: ${propValue}`);
            }
    };
}
const person = createObject("name", "Tom");
person.print();     // name: Tom

const book = createObject("title", "JavaScript Reference");
book.print();   // title: JavaScript Reference
```

#### Удаление свойств
Выше мы посмотрели, как можно динамически добавлять новые свойства к объекту. Однако также мы можем удалять свойства и методы с помощью оператора **`delete`**. И как и в случае с добавлением мы можем удалять свойства двумя способами. Первый способ — использование нотации точки:
```js
delete объект.свойство
```

Либо использовать синтаксис массивов:
```js
delete объект["свойство"]
```

Например, удалим свойство:
```js
let user = {};
user.name = "Tom";
user.age = 26;
user.display = function(){

    console.log(user.name);
    console.log(user.age);
};

console.log(user.name); // Tom
delete user.name; // удаляем свойство
// альтернативный вариант
// delete user["name"];
console.log(user.name); // undefined
```

После удаления свойство будет не определено, поэтому при попытке обращения к нему, программа вернет значение **`undefined`**.

#### Создание объекта из переменных и констант
При создании объекта его свойствам могут передаваться значения переменных, констант или динамически вычисляемые результаты функций:
```js
function getSalary(status){
    if(status==="senior") return 1500;
    else return 500;
}
const name = "Tom";
const age = 37;
const person = { name: name, age: age, salary: getSalary()};

console.log(person);    // {name: "Tom", age: 37, salary: 500}
```

Но если названия констант/переменных совпадает с названиями свойств, то можно сократить передачу значений:
```js
const name = "Tom";
const age = 37;
const salary = 500;
const person = { name, age, salary};

console.log(person);    // {name: "Tom", age: 37, salary: 500}
```

В данном случае объект `person` автоматически получит свойства, названия которых будут соответствовать названиям констант, а в качестве значений иметь значения этих констант.

То же самое относится к передаче функций методам объекта:
```js
function display(){
    console.log(this.name, this.age);
}
const move = function(place){ console.log(this.name, "goes to", place)};
const name = "Tom";
const age = 37;
const salary = 500;
const person = { name, age, salary, display, move};

person.display();       // Tom 37
person.move("cinema");  // Tom goes to cinema
```

В данном случае объект `person` имеет два метода, которые соответствуют переданным в объект функциям — `display()` и `move()`. Стоит отметить, что при такой передаче функций методам объекта, мы по прежнему можем использовать в этих функциях ключевое слово `this` для обращения к функциональности объекта. Однако стоит быть осторожным при передаче лямбд-выражений, поскольку для глобальных лямбд-выражений `this` будет представлять объект окна браузера:
```js
const move = (place)=>{ console.log(this.name, "goes to", place); console.log(this);};
const name = "Tom";

const person = { name, move};
person.move("cinema");  //  goes to cinema
```

#### Фукция Object.fromEntries()
С помощью функции **`Object.fromEntries()`** можно создать объект из набора пар ключ-значение, где ключ потом будет представляет название свойства. Например, создадим объект из массивов:
```js
const personData = [ ["name", "Tom"], ["age", 37]];
const person = Object.fromEntries(personData);
console.log(person);        // {name: "Tom", age: 37}
console.log(person.name);    // Tom
```

Здесь объект создается из массива `personData`, который содержит два подмассива. Каждый подмассив содержит два элемента и фактически представляет пару ключ-значение. Первый элемент представляет ключ, а второй — значение.[^4.1]

### Ключевое слово this
Поведение ключевого слова **`this`** зависит от контекста, в котором оно используется, и от того, в каком режиме оно используется — строгом или нестрогом.

#### Глобальный контекст и объект globalThis
В глобальном контексте `this` ссылается на глобальный объект. Что такое "глобальный объект" в JavaScript? Это зависит от среды, в которой выполняется код. Так, в веб-браузере `this` представляет объект **`window`** — объект, который представляет окно браузера. В среде Node.js `this` представляет объект **`global`**. А для веб-воркеров `this` представляет объект **`self`**.

Например, в веб-браузере при выполнении следующего кода:
```js
console.log(this);
```

мы получим консольный вывод вроде следующего
```
Window {window: Window, self: Window, document: document, name: "", location: Location, …}
```

В стандарт ES2020 было добавлено определение объекта **`globalThis`**, который позволяет ссылаться на глобальный конекст вне зависимости, в какой среде и в какой ситуации выполняется код:
```js
console.log(globalThis);
```

#### Контекст функции
В пределах функции `this` ссылается на внешний контекст. Для функций, определенных в глобальном контексте, — это объект **`globalThis`**. Например:
```js
function foo(){
    var bar = "local";
    console.log(this.bar);
}

var bar = "global";

foo();  // global
```

Если бы мы не использовали бы `this`, то обращение шло бы к локальной переменной, определенной внутри функции.

```js
function foo(){
    var bar = "local";
    console.log(bar);
}

var bar = "global";

foo();  // local
```

Но если бы мы использовали строгий режим (strict mode), то `this` в этом случае имело бы значение `undefined`:
```js
"use strict";
function foo(){
    var bar = "local";
    console.log(this.bar);
}

var bar = "global";

foo();  // ошибка - this - undefined
```

#### Контекст объекта
В контексте объекта, в том числе в его методах, ключевое слово `this` ссылается на этот же объект:
```js
const obj = {
    bar: "object",
    foo: function(){
        console.log(this.bar);
    }
}
var bar = "global";
obj.foo();  // object
```

#### Динамическое определение контекста
Код функции всегда использует в качестве `this` внешний контекст, в которым этот код вызывается (именно вызывается, а не определяется). Рассмотрим более сложный пример:
```js
function foo(){
    var bar = "foo_bar";
    console.log(this.bar);
}

const obj1 = {bar:"obj1_bar", foo: foo};
const obj2 = {bar:"obj2_bar", foo: foo};

var bar = "global_bar";

foo();  // global_bar
obj1.foo();   // obj1_bar
obj2.foo();   // obj2_bar
```

Здесь определена глобальная переменная `bar` ("global_bar"). И также в функции `foo` определена локальная переменная `bar` ("foo_bar"). Значение какой переменной будет выводиться в функции `foo`? Функция foo использует определение переменной, которое определено во внешнем контексте. Для функции `foo` по умолчанию это глобальный контекст, поэтому она выводит значение глобальной переменной (так как данный скрипт запускается в нестрогом режиме, а значит ключевое слово `this` в функции `foo` ссылается на внешний контекст).

Иначе дело обстоит с объектами. Они определяют свой собственный контекст, в котором существует свое свойство `bar`. И при вызове метода `foo` внешним контекстом по отношению к функции будет контекст объектов `obj1` и `obj2`.

Подобное поведение может привести к некоторому непонимаю в отдельных случаях. Так, рассмотрим другую ситуацию:
```js
var bar = "global_bar";

const obj1 = {
    bar: "obj1_bar",
    foo: function(){
        console.log(this.bar);  // bar = "obj1_bar"
    }
}
const obj2 = {bar: "obj2_bar", foo: obj1.foo}; // bar = "obj2_bar"

const foo = obj1.foo;   // bar = "global_bar"

obj1.foo(); // obj1_bar
obj2.foo(); // obj2_bar
foo();      // global_bar
```

Здесь в объекте `obj1` определена функция `foo`:
```js
const obj1 = {
    bar: "obj1_bar",
    foo: function(){
        console.log(this.bar);  // bar = "obj1_bar"
    }
}
```

Эта функция `foo` будет брать значение для `this.bar` из внешнего контекста — из объекта `obj1`, соответственно `this.bar = "obj1_bar"`.

Объект `obj2` использует функцию `foo` из объекта `obj1`:
```js
const obj2 = {bar: "obj2_bar", foo: obj1.foo};
```

Однако функция `obj1.foo` также будет искать значение для `this.bar` опять же во внешнем котексте, а здесь это объект `obj2`. А в объекте `obj2` это значение равно "obj2_bar".

То же самое с глобальной переменной `foo`, которая ссылается на ту же функцию, что и метод `obj1.foo`:
```js
const foo = obj1.foo;
```

В этом случае также будет происходить поиск значения для `this.bar`, но теперь в контексте функции `foo`. А это глобальный контекст, где определена переменная `var bar = "global_bar"`.

#### Контекст во вложенных функциях
Если мы вызываем функцию из другой функции, вызываемая функция также будет использовать внешний контекст:
```js
var bar = "global bar";

function foo(){
    var bar = "foo bar";
    function moo(){

        console.log(this.bar);
    }
    moo();
}
foo();  // global bar
```

Здесь функция `foo()` в качестве `this.bar` использует значение переменной `bar` из внешнего контекста, то есть значение глобальной переменной `bar`. Функция `moo()` также в качестве `this.bar` использует значение переменной `bar` из внешнего контекста, то есть `this.bar` для внешней функции `foo`, которое в свою очередь представляет значение глобальной переменной `bar`. Поэтому в итоге консоль выведет "global bar", а не "foo bar".

#### Явная привязка
С помощью методов `call()` и `apply()` можно задать явную привязку функции к определенному контексту:
```js
function foo(){
    console.log(this.bar);
}

var obj = {bar: "obj_bar"}
var bar = "global_bar";
foo();              // global_bar
foo.apply(obj);     // obj_bar
// или
// foo.call(obj);
```

Во втором случае функция `foo` привязывается к объекту `obj`, который и определяет ее контекст. Поэтому во втором случае консоль выведет "obj_bar".

#### Метод bind
Метод `f.bind(o)` позволяет создать новую функцию с тем же телом и областью видимости, что и функция `f`, но с привязкой к объекту `o`:
```js
function foo(){
    console.log(this.bar);
}

const obj = {bar: "object"}
var bar = "global";
foo();  // global
const func = foo.bind(obj);
func(); // object
```

#### this и стрелочные функции
В стрелочных функциях в качестве **`this`** используется контекст окружения, а не само окружение, в котором определена стрелочная функция. Рассмотрим следующий пример:
```js
const person = {
    name: "Tom",
    say:()=> console.log(`Меня зовут ${this.name}`)
}
person.say();   // Меня зовут
```

Здесь стрелочная функция `say()` обращается к некому свойству `this.name`, но что здесь представляет `this`? Для внешнего контекста, в котором определена стрелочная функция, то есть для контекста объекта `person`, `this` представляет глобальный объект (объект окна браузера). Однако глобальной переменной `name` не определено, поэтому на консоль будет выведено:
```
Меня зовут
```

Теперь немного изменим пример:
```js
const person = {
    name: "Tom",
    hello(){
        console.log("Привет");
        let say = ()=> console.log(`Меня зовут ${this.name}`);
        say();
    }
}
person.hello();
```

Теперь стрелочная функция определена в методе `hello()`. `this` для этого метода представляет текущий объект `person`, где определен данный метод. Поэтому и в стрелочной функции `this` будет представлять объект `person`, а `this.name` — свойство `name` этого объекта. Поэтому при выполнении программы мы получим:
```
Привет
Меня зовут Tom
```


Несмотря на то что, стрелочные функции могут добавить забот при работе `this`, в то же время они могут решить ряд проблем. Так, при работе с несколькими контекстами мы вынуждены учитывать, в каком контексте определяется переменная. Например, возьмем следующий код:
```js
const school ={
    title: "Oxford",
    courses: ["JavaScript", "TypeScript", "Java", "Go"],
    printCourses(){
        this.courses.forEach(function(course){
            console.log(this.title, course);
        })
    }
}
school.printCourses();
```

Функция `printCourses` проходит по всем курсам из массива и при их выводе предваряет их значением свойства `title`. Однако на консоли при запуске программы мы увидим следующее:
```
undefined "JavaScript"
undefined "TypeScript"
undefined "Java"
undefined "Go"
```

Мы видим, что значение `this.title` не определено, так как `this` как контекст объекта замещается глобальным контекстом. В этом случае нам надо передать подобное значение `this.title` или весь контекст объекта.

```js
const school ={
    title: "Oxford",
    courses: ["JavaScript", "TypeScript", "Java", "Go"],
    printCourses(){
        const that = this;
        this.courses.forEach(function(course){
            console.log(that.title, course);
        })
    }
}
school.printCourses();
```

Стрелочные функции также позволяют решить данную проблему:
```js
const school ={
    title: "Oxford",
    courses: ["JavaScript", "TypeScript", "Java", "Go"],
    printCourses(){
        this.courses.forEach((course)=>console.log(this.title, course))
    }
}
school.printCourses();
```

Контекстом для стрелочной функции в данном случае будет выступать контекст объекта `school`. Соответственно, нам не надо определять дополнительные переменые для передачи данных в функцию.[^4.10]

### Вложенные объекты и массивы в объектах
Одни объекты могут содержать в качестве свойств другие объекты. Например, есть объект страны, у которой можно выделить ряд свойств. Одно из этих свойств может представлять столицу. Но у столицы мы также можем выделить свои свойства, например, название, численность населения, год основания:
```js
const country = {

    name: "Германия",
    language: "немецкий",
    capital:{

        name: "Берлин",
        population: 3375000,
        year: 1237
    }
};
console.log("Столица:", country.capital.name); // Берлин
console.log("Население:", country["capital"]["population"]); // 3375000
console.log("Год основания:", country.capital["year"]); // 1237
```

Консольный вывод:
```
Столица: Берлин
Население: 3375000
Год основания: 1237
```

Для доступа к свойствам таких вложенных объектов мы можем использовать стандартную нотацию точки:
```js
country.capital.name
```

Либо обращаться к ним как к элементам массивов:
```js
country["capital"]["population"]
```

Также допустим смешанный вид обращения:
```js
country.capital["year"]
```

В качестве свойств также могут использоваться массивы, в том числе массивы других объектов:
```js
const country = {

    name: "Швейцария",
    languages: ["немецкий", "французский", "итальянский"],
    capital:{

        name: "Берн",
        population: 126598
    },
    cities: [
        { name: "Цюрих", population: 378884},
        { name: "Женева", population: 188634},
        { name: "Базель", population: 164937}
    ]
};

// вывод всех элементов из country.languages
console.log("Официальные языки Швейцарии");
for(const lang of country.languages){
  console.log(lang);
}
console.log("\n");  // для разделения языков от городов

// вывод всех элементов из country.cities
console.log("Города Швейцарии");
for(const city of country.cities){
  console.log(city.name);
}
```

В объекте `country` имеется свойство `languages`, содержащее массив строк, а также свойство cities, хранящее массив однотипных объектов.

С этими массивами мы можем работать также, как и с любыми другими, например, перебрать с помощью цикла **`for`**. При переборе массива объектов каждый текущий элемент будет представлять отдельный объект, поэтому мы можем обратиться к его свойствам и методам:
```js
for(const city of country.cities){
  console.log(city.name);
}
```

Либо для перебора мы могли бы использовать другой тип цикла **`for`** и также пройтись по всем элементам массива:
```js
for(let i=0; i < country.cities.length; i++){
    console.log(country.cities[i].name);
}
```

В итоге браузер выведет содержимое этих массивов:[^4.2]
```
Официальные языки Швейцарии
немецкий
французский
итальянский

Города Швейцарии
Цюрих
Женева
Базель
```

### Копирование и сравнение объектов

#### Копирование объектов
В отличие от данных примитивных типов данные объектов копируются по ссылке. Что это значит? Рассмотрим следующий пример:
```js
const tom = { name: "Tom"};
const bob = tom;
// проверяем свойство name у обоих констант
console.log(tom.name);  // Tom
console.log(bob.name);  // Tom

// меняем свойство name у константы bob
bob.name = "Bob";
// повторно проверяем свойство name у обоих констант
console.log("После изменения")
console.log(tom.name);  // Bob
console.log(bob.name);  // Bob
```

Вначале определяется обычный объект `tom` с одним свойством `name`. Затем присваиваем значение этого объекта константе `bob`
```js
const bob = tom;
```

В данном случае константа `bob` получае ссылку или условно говоря адрес константы `tom`, поэтому после этого присвоения обе константы по сути указывают на один и тот же объект в памяти. Соответственно изменения, произведенные через одну константу:
```js
bob.name = "Bob";
```

Затронут и другую константу — `tom`:
```js
console.log(tom.name);  // Bob
```

Более того, добавим к объекту новое свойство через одну из констант:
```js
const tom = { name: "Tom"};
const bob = tom;
// добавляем константе bob новое свойство - age
bob.age = 37;
// и видим, что для tom тоже добавлено новое свойство
console.log(tom.age);   // 37
```

После добавления свойства `age` константе `bob` можно увидеть, что у константы `tom` то же появилось это свойство, потому что опять же обе константы представляют один и тот же объект.

Что же если мы хотим скопировать из свойства объекта, но при этом обе константы или переменных указывали бы на совершенно разные объекты, изменения одного из которых никак бы не затрагивали другой? В этом случае мы можем воспользоваться встроенным методом **`Object.assign()`**.

#### Метод Object.assign
Метод **`Object.assign()`** принимает два параметра:
```js
Object.assign(target, ...sources)
```

Первый параметр — `target` представляет объект, в который надо скопировать свойства. Второй параметр — `...sources` — набор объектов, из которых надо скопировать свойства (то есть мы можем скопировать свойства сразу из нескольких объектов)

Возвращает метод объект `target`, в который скопированы свойства из объектов `sources`.

Например:
```js
const tom = { name: "Tom", age: 37};
const bob = Object.assign({}, tom);
bob.name = "Bob";
bob.age = 41;

console.log(`Объект tom. Name: ${tom.name}   Age: ${tom.age}`);
console.log(`Объект bob. Name: ${bob.name}   Age: ${bob.age}`);
```

В данном случае вызов `Object.assign({}, tom)` означает, что мы копируем данные из объекта tom в пустой объект `{}`. Результатом этого копирования стал объект `bob`. Причем это совсем другой объект, нежели `tom`. И любые изменения с константой `bob` здесь никак не затронут константу `tom`.

Консольный вывод программы:
```
Объект tom. Name: Tom   Age: 37
Объект bob. Name: Bob   Age: 41
```

##### Копирование из нескольких объектов
Подобным образом можно копировать данные из нескольких объектов:
```js
const tom = { name: "Tom"};
const sam = { age: 37};
const person = { height: 170};
Object.assign(person, tom, sam);    // копируем из tom и sam в person
console.log(person);    // {height: 170, name: "Tom", age: 37}
```

Здесь копируются все свойства из объектов `tom` и `sam` в объект `person`. В итоге после копирования объект `person` будет иметь три свойства.

##### Копирование одноименных свойств
Если объекты, из которых выполняется копирование, содержат одинаковые свойства, то свойства из последних объектов замещают свойства предыдущих:
```js
const tom = { name: "Tom", age: 37};
const sam = { age: 45};
const person = { height: 170};
Object.assign(person, tom, sam);
console.log(person);    // {height: 170, name: "Tom", age: 45}
```

Здесь оба объекта — `tom` и `sam` — содержат свойство `age`, но в объекте `person` свойство `age` равно 45 — значение из объекта `sam`, потому что копирование из объекта `sam` произодится в последнюю очередь.

##### Копирование свойств-объектов
Несмотря на то, что `Object.assign()` прекрасно работает для простых объектов, но что будет, если свойство копируемого объекта также представляет объект:
```js
const tom = { name: "Tom", company: {title: "Microsoft"}};
const bob = Object.assign({}, tom);
bob.name = "Bob";
bob.company.title = "Google";
console.log(tom.name);      // Tom
console.log(tom.company.title);     // Google
```

Здесь свойство `company` объекта `tom` представляет объект с одним свойством. И при копировании объект `bob` получит не копию значения `tom.company`, а ссылку на этот объект. Поэтому изменения `bob.company` затронут и `tom.company`.

#### Копирование объекта с помощью spread-оператора
**spread-оператор `...`** позволяет разложить объект на различные пары свойство-значение, которые можно передать другому объекту.

```js
const tom = { name: "Tom", age: 37, company: "Google"};
const bob = {...tom}
bob.name = "Bob";

console.log(tom);   // {name: "Tom", age: 37, company: "Google"}
console.log(bob);   // {name: "Bob", age: 37, company: "Google"}
```

В данном случае объекту `bob` передаются копии свойств объекта `tom`.

Если какие-то свойства нового объекта должны иметь другие значения (как в примере выше свойство `name`), то их можно указать в конце:
```js
const tom = { name: "Tom", age: 37, company: "Google"};
const bob = {...tom, name: "Bob"};

console.log(bob);   // {name: "Bob", age: 37, company: "Google"}
```

Как видно из предыдущего примера, обе константы после копирования представляют ссылки на разные объекты, и изменения одного из них никак не затронет другой объект.

Тем не менее если объекты содержат вложенные объекты, то эти вложенные объекты при копировании опять же по сути будут представлять ссылки на один и тот же объект:
```js
const tom = { name: "Tom", age: 37, company: {title: "Microsoft"}};
const bob = {...tom}
bob.name = "Bob";
bob.company.title = "Google";

console.log(`${tom.name} - ${tom.company.title}`);  // Tom - Google
console.log(`${bob.name} - ${bob.company.title}`);  // Bob - Google
```

#### Сравнение объектов
Сравним два объекта с помощью стандартных операций сравнения и эквивалентности:
```js
const tom = { name: "Tom"};
const bob = { name: "Bob"};
console.log(tom == bob);    // false
console.log(tom === bob);   // false
```

Оба оператора в данном случае возвратят значение `false`, то есть объекты не равны. Причем даже если значения свойств объектов будет одинаковым, то мы все равно в обоих случаях получим `false`
```js
const tom = { name: "Tom"};
const bob = { name: "Tom"};
console.log(tom == bob);    // false
console.log(tom === bob);   // false
```

Однако, что будет, если обе константы (переменных) хранят ссылку на один и тот же объект:
```js
const tom = { name: "Tom"};
const bob = tom;
console.log(tom == bob);    // true
console.log(tom === bob);   // true
```

В этом случае в обоих случаях мы получим `true`, поскольку значения обоих констант равны, так как по сути это одно и то же значение.

### Проверка наличия и перебор методов и свойств
При динамическом определении в объекте новых свойств и методов перед их использованием бывает важно проверить, а есть ли уже такие методы и свойства. Для этого в javascript может использоваться оператор **`in`**. Он имеет следующий синтаксис:
```js
"свойство|метод" in объект
```

в кавычках идет название свойства или метода, а после **`in`** — название объекта. Если свойство или метод с подобным именем имеется, то оператор возвращает `true`. Если нет — то возвращается `false`.

Например, узнаем, есть ли в объекте ряд свойств:
```js
const user = {};
user.name = "Tom";
user.age = 26;
user.print = function(){

    console.log(this.name);
    console.log(this.age);
};
const hasNameProp = "name" in user;
console.log(hasNameProp); // true - свойство name есть в user

const hasWeightProp = "weight" in user;
console.log(hasWeightProp); // false - в user нет свойства или метода под названием weight
```

С помощью выражения `"name" in user` проверяем, есть ли в объекте `user` свойство `"name"` и результат проверки передаем в константу `hasNameProp`. Далее анологичным образом проверяем наличие свойства `wheight`.

Подобным образом можно проверить и наличие методов:
```js
const hasPrintMethod = "print" in user;
console.log(hasPrintMethod); // true - в user есть метод print
```

Альтернативный способ заключается в проверке на значение **`undefined`**. Если свойство или метод равен `undefined`, то эти свойство или метод не определены:
```js
const hasNameProp = user.name!==undefined;
console.log(hasNameProp); // true
const hasWeightProp = user.weight!==undefined;
console.log(hasWeightProp); // false
```

И так как объекты представляют тип `Object`, а значит, имеет все его методы и свойства, то объекты также могут использовать метод **`hasOwnProperty()`**, который определен в типе `Object`:
```js
const hasNameProp = user.hasOwnProperty("name");
console.log(hasNameProp); // true
const hasPrintMethod = user.hasOwnProperty("print");
console.log(hasPrintMethod); // true
const hasWeightProp = user.hasOwnProperty("weight");
console.log(hasWeightProp); // false
```

#### Перебор свойств и методов
С помощью цикла `for..in` мы можем перебрать объект как обычный массив и получить все его свойства и методы и их значения:
```js
const tom = {
    name: "Tom",
    age: 26,
    print(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    }
};

for(const prop in tom) {
    console.log(prop, " : ", tom[prop]);
}
```

И при запуске консоль браузера отобразит следующий вывод:
```
name : Tom
age : 26
print : print(){
	console.log(`Name: ${this.name}  Age: ${this.age}`);
}
```

#### Функции Object.entries, Object.keys, Object.values
С помощью дополнительных функций **`Object.entries`**, **`Object.keys`** и **`Object.values`** можно получить все свойства (в том числе методы) объекта и их значения.[^4.3]

##### Object.entries()
Функция **`Object.entries()`** в качестве параметра принимает объект и возвращает массив пар "название_свойства - значение", где каждая пара свойство-значение представляет массив. Например:
```js
const tom = {
    name: "Tom",
    age: 26,
    print(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    }
};

for(const prop of Object.entries(tom)) {
    console.log(prop);
}
```

Консольный вывод:
```
["name", "Tom"]
["age", 26]
["print", ƒ]
```

##### Object.keys()
Функция **`Object.keys()`** позволяет получить массив названий всех свойств объекта. Например, возьмем выше определенный объект `tom`:
```js
const tom = {
    name: "Tom",
    age: 26,
    print(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    }
};
console.log(Object.keys(tom)); // ["name", "age", "print"]
```

Соответственно можно перебрать этот набор и получить значения свойств:
```js
for(const prop of Object.keys(tom)) {
    const value = tom[prop];    // получаем по названию значение свойства
    console.log(prop,value);
}
```

Консольный вывод:
```
name Tom
age 26
print ƒ print(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    }
```

##### Object.values()
Функция **`Object.values()`** возвращает массив, который содержит все значения свойств объекта:
```js
const tom = {
    name: "Tom",
    age: 26,
    print(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    }
};
console.log(Object.values(tom)); // ["Tom", 26, print()]
```

### Объекты в функциях

#### Объект как результат функции
Функции могут возвращать объекты. Этот может потребоваться в различных задачах. Например, вынесем создание объекта в отдельную функцию:
```js
function createUser(pName, pAge) {
    return {
        name: pName,
        age: pAge,
        print: function() {
            console.log(`Name: ${this.name}  Age: ${this.age}`);
        }
    };
};
const tom = createUser("Tom", 26);
tom.print();
const alice = createUser("Alice", 24);
alice.print();
```

Здесь функция `createUser()` получает значения `pName` и `pAge` и по ним создает новый объект, который является возвращаемым результатом. Результат работы программы:
```
Name: Tom  Age: 26
Name: Alice  Age: 24
```

Преимуществом вынесения создания объекта в функцию является то, что далее мы можем создать несколько однотипных объектов с разными значениями, то есть выстапть в роли фабрики или конструктора. Кроме того, в подобной функции мы можем проверить переданные значения на корректность и в случае из некорректности как-то прореагировать:
```js
function createUser(pName, pAge) {

  if(pAge < 1 || pAge > 110){       // если возраст меньше 1 или больще 110
      console.log("Age is invalid")
      pAge=1;
  }
    return {
        name: pName,
        age: pAge,
        print: function() {
            console.log(`Name: ${this.name}  Age: ${this.age}`);
        }
    };
};
const tom = createUser("Tom", 26);
tom.print();
const alice = createUser("Alice", 12345);
alice.print();
```

Здесь проверяется параметр `pAge`, который представляет возвраст пользователя. Понятно, что теоретически это может быть любое число, которое может выходить за разумные пределы, например, быть отрицательным. И в данном случае мы проверяем `pAge` на соответствие этому пределу. Если значение `pAge` не соответствует пределу, то присваиваем ему значение по умолчанию — в данном случае 1, и выводим диагностическое сообщение. Консольный вывод программы:
```
Name: Tom  Age: 26
Age is invalid
Name: Alice  Age: 1
```

Также возращение объекта может быть полезно, если нам надо ввернуть из функции больше одного результата — в этом случае мы можем объединить их в один объект. Например, функция принимает массив и находит в нем минимальное и максимальное значения:
```js
function getMinMax(numbers){

  // если массив пуст, минимальное и максимальное значения неопределены
  if(numbers.length === 0) return {min: undefined, max: undefined};

  let minNumber = numbers[0];
  let maxNumber = numbers[0];
  for(let i=1; i< numbers.length; i++){

    if(minNumber > numbers[i]) minNumber = numbers[i];
    if(maxNumber < numbers[i]) maxNumber = numbers[i];
  }
  return {min: minNumber, max: maxNumber};
}

const nums = [1, 2, 3, 4, 5];
const result = getMinMax(nums);
console.log("Min:", result.min);    // Min: 1
console.log("Max:", result.max);    // Max: 5
```

Здесь в функции `getMinMax` получаем массив. Если массив не содержит чисел, то возвращаем объект, где поля `min` и `max` имеют значения `undefined`. Иначе проходим по всему массиву и вычисляем максимальное и минимальное значения и возвращаем их в виде одного объекта.

#### Объект как параметр
Как и все другие значения, объект может передаваться в качестве параметра в функцию:
```js
function printPerson(person){

  console.log("Name:", person.name);
  console.log("Age:", person.age);
}

const tom = {name: "Tom", age: 39};
const alice = {name: "Alice", age: 35};

printPerson(tom);
printPerson(alice);
```

Здесь в функцию `printPerson` передается объект, который, как предполагается, будет иметь два свойства: `name` и `age`.

При этом стоит учитывать, что объект — ссылочный тип, а переменная/константа/параметр, которые представляют объект, фактически хранят ссылку на объект в памяти, а не сам объект. Соответственно при передаче в функцию объекта параметру передается копия ссылки на этот объект. И через эту ссылку функция может изменять различные свойства объекта:
```js
function setAge(person, pAge){

  person.age = pAge;
}

const sam = {name: "Sam", age: 29};
console.log("Before setAge:", sam.age);
setAge(sam, 30);
console.log("After setAge:", sam.age);
```

Здесь сначала определяем константу `sam`, которая представляет объект со свойствами `name` и `age`:
```js
const sam = {name: "Sam", age: 29};
```

Фактически константа `sam` хранит ссылку на область памяти, где расположен объект.

Затем вызывается функция `setAge`, которая получает объект `person` и изменяет у него свойство `age`.

```js
setAge(sam, 30);
```

Поскольку объекты передаются по ссылке, то функция `setAge` получит **копию ссылки**, которая хранится в константе `sam`. То есть после этого константа `sam` и первый параметр функции `setAge` будут представлять **две разные ссылки**, но указывать они будут на один и тот же объект в памяти. Поэтому если внутри функции `setAge` мы изменим свойство этого объекта, то при обращении у объекта `sam` свойство тоже изменится, так как в реальности это один и тот же объект. В итоге браузер нам выведет:
```
Before setAge: 29
After setAge: 30
```

Но если параметру внутри функции присваивается другой объект, то фактически ссылка меняет свое значение и начинает указывать на дргую область памяти:
```js
function setDefault(person){

  person = {name: "Undefined", age: 0};
}

let sam = {name: "Sam", age: 29};
console.log("Before setDefault:", sam.name);
setDefault(sam);
console.log("After setDefault:", sam.name);
```

При передаче переменной `sam` в функцию `setDefault` параметр этой функции и переменная `sam` будут представлять две разные ссылки, но указывать на один и тот же обеъект в памяти:
```js
setDefault(sam);
```

Но потом внутри функции мы изменяем значение параметра:
```js
person = {name: "Undefined", age: 0};
```

В итоге ссылке, которая хранится в параметре `person`, присвается новый объект. Но поскольку переменная `sam` и параметр `person` представляют две разные ссылки, то это присваивание никак не затронет объект `sam`.[^4.4]

### Функции-конструкторы объектов
Кроме создания новых объектов JavaScript предоставляет нам возможность создавать новые типы объектов с помощью специальных функций — **конструкторов**. Конструктор позволяет определить новый тип объекта. Определение типа может состоять из функции конструктора, методов и свойств.

Для начала определим конструктор:
```js
function Person(pName, pAge) {
    this.name = pName;
    this.age = pAge;
    this.print = function(){
        console.log("Name: ", this.name);
        console.log("Age: ", this.age);
    };
}
```

Конструктор — это обычная функция за тем исключением, что в ней мы можем установить свойства и методы. Для установки свойств и методов используется ключевое слово **`this`**:
```js
this.name = pName;
```

В данном случае устанавливаются два свойства `name` и `age` и один метод `print`.

Как правило, названия конструкторы в отличие от названий обычных функций начинаются с большой буквы.[^4.5]

После этого в программе мы можем определить объект типа `Person` и использовать его свойства и методы:
```js
// определение конструктора объектов типа Person
function Person(pName, pAge) {
    this.name = pName;
    this.age = pAge;
    this.print = function(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    };
}
// определение объекта типа Person
const tom = new Person("Tom", 39);
// обращение к свойству объекта
console.log(tom.name); // Том
// обращение к методу объекта
tom.print();    // Name: Tom  Age: 39
```

Чтобы вызвать конструктор, то есть создать объект типа `Person`, надо использовать ключевое слово **`new`**:
```js
const tom = new Person("Tom", 39);
```

Далее через имя объекта можно обращаться к его свойствам и методам, которые определены внутри функции конструктора:
```js
// обращение к свойству объекта
console.log(tom.name); // Том
// обращение к методу объекта
tom.print();
```

Стоит отметить, что, конечно, мы могли бы определить объект стандартным образом:
```js
const tom = {
    name: "Tom",
    age: 39,
    print: function(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    }
}
```

Однако использование функций-конструкторов позволяет упростить многократное создание однотипных объектов, которые имеют одинаковый набор свойств и методов. То есть фактически мы определяем новый тип объектов. Например:
```js
function Person(pName, pAge) {
    this.name = pName;
    this.age = pAge;
    this.print = function(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    };
}
const tom = new Person("Tom", 39);
const bob = new Person("Bob", 43);
const sam = new Person("Sam", 28);

tom.print();    // Name: Tom  Age: 39
bob.print();    // Name: Bob  Age: 43
sam.print();    // Name: Sam  Age: 28
```

Объекты подобных типов можно также передавать в функции или возвращать из функций, они могут выступать в качестве свойств других объектов, могут храниться в массивах и т.д. Например:
```js
function Person(pName, pAge) {
    this.name = pName;
    this.age = pAge;
    this.print = function(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    };
}
function printPersonName(person){
    console.log(person.name);
}
// массив из трех объектов Person
const people = [new Person("Tom", 39), new Person("Bob", 43), new Person("Sam", 28)];

for(person of people){
    printPersonName(person);
}
```

#### Оператор instanceof
Оператор **`instanceof`** позволяет проверить, с помощью какого конструктора создан объект. Если объект создан с помощью определенного конструктора, то оператор возвращает `true`:
```js
// определение конструктора объектов типа Person
function Person(pName, pAge) {
    this.name = pName;
    this.age = pAge;
    this.print = function(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    };
}
// определение конструктора объектов типа Employee
function Employee(eName, eCompany) {
    this.name = eName;
    this.company = eCompany;
    this.print = function(){
        console.log(`Name: ${this.name}  Company: ${this.company}`);
    };
}
const tom = new Person("Tom", 39);
const bob = new Employee("Bob", "Google");

console.log(tom instanceof Person);       // true - tom является объектом типа Person
console.log(bob instanceof Employee);   // true - bob является объектом типа Employee
console.log(tom instanceof Employee);   // false - tom НЕ является объектом типа Employee
```

### Расширение объектов. Прототипы
JavaScript — это язык, основанный на прототипах, поэтому он не знает никаких классов — по крайней мере, реальных. Вместо этого все в JavaScript основано на объектах. Почти каждый объект в JavaScript основан на прототипе. Исключения — тип `Object` (основа всех объектов) или объекты, прототип которых явно установлен в `null` — не имеют прототипа. Каждый объект также может служить шаблоном, то есть прототипом другого объекта. В этом случае новый объект наследует свойства и методы прототипа.

Прототип объекта хранится в свойстве **`__proto__`**, которое реализованно как псевдоним внутреннего свойства `[[Prototype]]`. Кроме того получить прототип объекта можно с помощью метода **`getPrototypeOf()`**. Например:
```js
const tom = {name: "Tom", age: 39};

// получаем прототип
console.log(tom.__proto__);                 // Object
console.log(Object.getPrototypeOf(tom));    // Object
```

В обоих случаях мы получим один и тот же результат в виде определения типа `Object`:
```
Object
    constructor: ƒ Object()
    hasOwnProperty: ƒ hasOwnProperty()
    isPrototypeOf: f isPrototypeOf()
    propertyIsEnumerable: f propertyIsEnumerable()
    toLocaleString: f toLocaleString()
    toString: f toString()
    valueOf: f valueOf()
    __defineGetter__: f __defineGetter__()
    __defineSetter__: f __defineSetter__()
    __lookupGetter__: f __lookupGetter__()
    __lookupSetter__: f __lookupSetter__()
    __proto__: null
    get __proto__: f __proto__()
    set __proto__: f __proto__()
```

#### Прототип функций-конструкторов
В прошлой теме были рассмотрены функции-конструкторы, который позволяют определить тип объекта и создать объект этого типа. Каждая такая функция-конструктор определяет свой **прототип**, который служит основой для создаваемых объектов. Этот прототип также можно получить с помощью свойства **`prototype`**. Например:
```js
function Person(name, age) {
    this.name = name;
    this.age = age;
    this.print = function(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    };
}

const tom = new Person("Tom", 39);

// получаем прототип
console.log(Person.prototype);
console.log(tom.__proto__);
console.log(Object.getPrototypeOf(tom));
```

Здесь получаем прототип функции-конструктора `Person`. Все три использованных способа получения прототипа аналогичны, и при выводе на консоль во всех трех случаях мы увидим что-то наподобие:
```
{constructor: ƒ}
constructor : ƒ Person(name, age)
[[Prototype]] : Object
```

#### Конструктор и прототип
Важно отличать конструктор и прототип. Прототип — это по сути план объекта, который может состоять из различных частей — методов и переменных, а собственно конструктор — только часть прототипа. Например, возьме выше определенную функцию `Person`:
```js
function Person(name, age) {
    this.name = name;
    this.age = age;
    this.print = function(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    };
}
console.log(Person.prototype);
```

Консольный вывод:
```
{constructor: ƒ}
	constructor: ƒ Person(name, age)
	[[Prototype]]: Object
```

Схематично мы можем представить прототип следующим образом:

![Прототипы функций-конструкторов в JavaScript](../img/4.2.png)

Фактически прототип функции-конструктора `Person` состоит только из конструктора (в который неявно также входят унаследованные от типа `Object` методы типа `toString()`). мы можем получить этот конструктор, использовав свойство **`constructor`**:
```js
console.log(Person.prototype.constructor);
```

Консоль должна вывести что-то наподобие:
```
ƒ Person(name, age) {
	this.name = name;
	this.age = age;
	this.print = function(){
		console.log(`Name: ${this.name}  Age: ${this.age}`);
	};
```

Поскольку свойство `constructor` — это часть прототипа, то к нему обратиться можно и через имя объекта:
```js
const tom = new Person("Tom", 39);
console.log(tom.constructor);
```

Теперь уберем метод `print()` из конструктора и определим его как часть прототипа:
```js
function Person (name, age) {
    this.name = name;
    this.age = age;
}
// функция print определена как часть прототипа
Person.prototype.print = function(){
    console.log(`Name: ${this.name}  Age: ${this.age}`);
};

console.log(Person.prototype);
```

Консольный вывод браузера:
```
{print: ƒ, constructor: ƒ}
	print: ƒ ()
	constructor: ƒ Person(name, age)
	[[Prototype]]: Object
```

Теперь прототип состоит из функции print и конструктора:

![Схема прототипов функций-конструкторов в JavaScript](../img/4.3.png)

При этом вне зависимости от того, как мы определяем методы и свойства - внутри конструктора или как часть прототипа, мы их равным образом можем использовать для объектов данного типа:
```js
function Person(name, age) {
    this.name = name;
    this.age = age;
    this.print = function(){
        console.log(`Name: ${this.name}  Age: ${this.age}`);
    };
}

const tom = new Person("Tom", 39);
const bob = new Person("Bob", 43);

// измененияем прототип
Person.prototype.sayHello = function(){
    console.log(this.name, "says: Hello");
};
tom.print();    // Name: Tom  Age: 39
tom.sayHello(); // Tom says: Hello
bob.print();    // Name: Bob  Age: 43
bob.sayHello(); // Bob says: Hello
```

Причем мы можем определить одни и те же свойства и методы как внутри конструктора, так и как часть прототипа:
```js
// конструктор пользователя
function Person (name, age) {
    this.name = name;
    this.age = age;
    this.print = function(){
        console.log(`[Конструктор] Name: ${this.name}  Age: ${this.age}`);
    };
}
Person.prototype.print = function(){
    console.log(`[Прототип] Name: ${this.name}  Age: ${this.age}`);
};

const tom = new Person("Tom", 39);
const bob = new Person("Bob", 43);
tom.print();    // [Конструктор] Name: Tom  Age: 39
bob.print();    // [Конструктор] Name: Bob  Age: 43
```

В этом случае методы, определенные внутри конструктора, будут скрывать одноименные методы прототипа.

#### Определение свойств прототипа
Подобным образом можно добавлять и свойства. Например, добавим свойство `company`, которое представляет компанию:
```js
const tom = new Person("Tom", 39);
const bob = new Person("Bob", 43);

// добавляем в прототип свойство company
Person.prototype.company = "SuperCorp";
console.log(tom.company);   // SuperCorp
console.log(bob.company);   // SuperCorp
```

Но важно заметить, что значение свойства company будет одно и то же для всех объектов, это разделяемое статическое свойство. В отличие, скажем, от свойства `this.name`, которое хранит значение для определенного объекта.

В то же время мы можем определить в объекте свойство, которое будет назваться также, как и свойство прототипа. В этом случае собственное свойство объекта будет иметь приоритет перед свойством прототипа:
```js
const tom = new Person("Tom", 39);
const bob = new Person("Bob", 43);

Person.prototype.company = "SuperCorp";
bob.company = "MegaCorp";   // определяем свойство с тем же именем на уровне одного объекта
console.log(bob.company);   // MegaCorp - берет свойство из объекта bob
console.log(tom.company);   // SuperCorp - берет свойство из прототипа Person
```

И при обращении к свойству `company` javascript сначала ищет это свойство среди свойств объекта, и если оно не было найдено, тогда обращается к свойствам прототипа. То же самое касается и методов.[^4.6]

### Практическая работа. Работа с объектами

#### Задание
1. Задать объект `room` и его параметры:

   - ключ `height` со значением `3`;
   - ключ `width` со значением `5.5`;
   - ключ `length` со значением `3.2`;
   - ключ `tv` со значением `"Samsung"`;
   - ключ `big` со значением `true`.

   Вывести в консоль все параметры объекта `room` по очереди. Предусмотреть метод для определения площади и объема помещения.

2. Создать объект «Книга» с полями на основе данных, предоставляемых пользователем: *название*, *автор*, *год издания*. Добавить в объект «Книга» метод, который возвращает строку с информацией о книге в формате: *«Название* — *Автор* (*Год*)».

3. Создать объект «Пользователь» с полями на основе данных, вводимых пользователем: логин, пароль, фамилия, имя, отчество. Автоматически при создании объекта назначать ему роль наблюдателя. Реализовать метод для смены роли пользователя на одну из предустановленных в системе (администратор, модератор, наблюдатель). Добавить в объект «Пользователь» метод для вывода информации в формате: «*логин*: *Фамилия И.О.* (*роль*)». Логин и пароль должны быть обязательными для введения, если фамилия, имя или отчество неизвестны (не определены пользователем), то на их месте ставить прочерки (`-`).

4. Создать объект «Фильм» с динамическими свойствами: название, режиссер, год выпуска, список актеров (массив объектов). Объекты, соответствующие режиссеру и актерам, должны содержать фамилию, имя, отчество, пол и год рождения. Предусмотреть методы для добавления или удаления актеров, а также замены режиссера.

5. Создать объект, где ключами будут имена дней недели, а значениями — расписание занятий на каждый день в массива объектов, содержащих номер пары, название учебного предмета, номер группы и фамилию преподавателя. Добавить возможность изменять расписание.

### Источники информации
[^4.1]: [Объектно-ориентированное программирование](https://metanit.com/web/javascript/4.1.php)
[^4.10]: [Ключевое слово this](https://metanit.com/web/javascript/4.10.php)
[^4.2]: [Вложенные объекты и массивы в объектах](https://metanit.com/web/javascript/4.2.php)
[^4.13]: [Копирование и сравнение объектов](https://metanit.com/web/javascript/4.13.php)
[^4.3]: [Проверка наличия и перебор методов и свойств](https://metanit.com/web/javascript/4.3.php)
[^4.4]: [Объекты в функциях](https://metanit.com/web/javascript/4.4.php)
[^4.5]: [Функции-конструкторы объектов](https://metanit.com/web/javascript/4.5.php)
[^4.6]: [Расширение объектов. Прототипы](https://metanit.com/web/javascript/4.6.php)
