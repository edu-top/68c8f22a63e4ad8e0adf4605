## Объекты

- [Объекты](#объекты)
  - [Введение в объекты](#введение-в-объекты)
    - [Создание нового объекта](#создание-нового-объекта)
    - [Свойства объекта](#свойства-объекта)
    - [Методы объекта](#методы-объекта)
    - [Синтаксис массивов](#синтаксис-массивов)
      - [Строки в качестве свойств и методов](#строки-в-качестве-свойств-и-методов)
      - [Динамическое определение имен свойств и методов](#динамическое-определение-имен-свойств-и-методов)
    - [Удаление свойств](#удаление-свойств)
    - [Создание объекта из переменных и констант](#создание-объекта-из-переменных-и-констант)
    - [Фукция Object.fromEntries()](#фукция-objectfromentries)
  - [Ключевое слово this](#ключевое-слово-this)
    - [Глобальный контекст и объект globalThis](#глобальный-контекст-и-объект-globalthis)
    - [Контекст функции](#контекст-функции)
    - [Контекст объекта](#контекст-объекта)
    - [Динамическое определение контекста](#динамическое-определение-контекста)
    - [Контекст во вложенных функциях](#контекст-во-вложенных-функциях)
    - [Явная привязка](#явная-привязка)
    - [Метод bind](#метод-bind)
    - [this и стрелочные функции](#this-и-стрелочные-функции)
  - [Источники информации](#источники-информации)

Объектно-ориентированное программирование на сегодняшний день является одной из господствующих парадигм в разработке приложений, и в JavaScript мы также можем использовать все преимущества ООП. В то же время применительно к JavaScript объектно-ориентированное программирование имеет некоторые особенности.

### Введение в объекты
В прошлых темах мы работали с примитивными данными — числами, строками, но данные не всегда представляют примитивные типы. Например, если в нашей программе нам надо описать сущность человека, у которого есть имя, возраст, пол и так далее, то естественно мы не сможем представить сущность человека в виде числа или строки. Нам потребуется несколько строк или чисел, чтобы должным образом описать человека. В этом плане человек будет выступать как сложная комплексная структура, у которого будут отдельные свойства — возраст, рост, имя, фамилия и т.д.

Для работы с подобными структурами в JavaScript используются **объекты**. Каждый объект может хранить свойства, которые описывают его **состояние**, и методы, которые описывают его **поведение**.

#### Создание нового объекта
Есть несколько способов создания нового объекта.

Первый способ заключается в использовании конструктора `Object`:
```js
const user = new Object();
```

В данном случае объект называется `user`.

Выражение `new Object()` представляет вызов конструктора — функции, создающей новый объект. Для вызова конструктора применяется оператор **`new`**. Вызов конструктора фактически напоминает вызов обычной функции.

Второй способ создания объекта представляет использование фигурных скобок (литеральная нотация):
```js
const user = {};
```

На сегодняшний день более распространенным является второй способ.

#### Свойства объекта
После создания объекта мы можем определить в нем свойства. Чтобы определить свойство, надо после названия объекта через точку указать имя свойства и присвоить ему значение:
```js
const user = {};
user.name = "Tom";
user.age = 26;
```

В данном случае объявляются два свойства `name` и `age`, которым присваиваются соответствующие значения. После этого мы можем использовать эти свойства, например, вывести их значения в консоли:
```js
console.log(user.name);
console.log(user.age);
```

Также можно определить свойства при определении объекта:
```js
const user = {

    name: "Tom",
    age: 26
};
```

В этом случае для присвоения значения свойству используется символ двоеточия, а после определения свойства ставится запятая (а не точка с запятой).

Кроме того, доступен сокращенный способ определения свойств:
```js
const name = "Tom";
const age = 34;
const user = {name, age};
console.log(user.name);     // Tom
console.log(user.age);      // 34
```

В данном случае названия переменных также являются и названиями свойств объекта. И таким образом можно создавать более сложные конструкции:
```js
const name = "Tom";
const age = 34;
const user = {name, age};

const teacher = {user, course: "JavaScript"};
console.log(teacher.user);      // {name: "Tom", age: 34}
console.log(teacher.course);    // JavaScript
```

#### Методы объекта
Методы объекта определяют его поведение или действия, которые он производит. Методы представляют собой функции. Например, определим метод, который бы выводил имя и возраст человека:
```js
const user = {};
user.name = "Tom";
user.age = 26;
user.display = function(){

    console.log(user.name);
    console.log(user.age);
};

// вызов метода
user.display();
```

Как и в случае с функциями методы сначала определяются, а потом уже вызываются.

Также методы могут определяться непосредственно при определении объекта:
```js
const user = {

    name: "Tom",
    age: 26,
    display: function(){

        console.log(this.name);
        console.log(this.age);
    }
};
```

Как и в случае со свойствами, методу присваивается ссылка на функцию с помощью знака двоеточия.

Чтобы обратиться к свойствам или методам объекта внутри этого объекта, используется ключевое слово **`this`**. Оно означает ссылку на текущий объект.

Также можно использовать сокращенный способ определения методов, когда двоеточие и слово `function` опускаются:
```js
let user = {

    name: "Tom",
    age: 26,
    display(){

        console.log(this.name, this.age);
    },
    move(place){
        console.log(this.name, "goes to", place);
    }
};
user.display(); // Tom 26
user.move("the shop");  // Tom goes to the shop
```

#### Синтаксис массивов
Существует также альтернативный способ определения свойств и методов с помощью синтаксиса массивов:
```js
const user = {};
user["name"] = "Tom";
user["age"] = 26;
user["display"] = function(){

    console.log(user.name);
    console.log(user.age);
};

// вызов метода
user["display"]();
```

Название каждого свойства или метода заключается в кавычки и в квадратные скобки, затем им также присваивается значение. Например, `user["age"] = 26`.

При обращении к этим свойствам и методам можно использовать либо нотацию точки (`user.name`), либо обращаться так: `user["name"]`.

Также можно определить свойства и методы через синтаксис массивов напрямую при создании объекта:
```js
const user = {
    ["name"]: "Tom",
    ["age"]: 26,
    ["display"]: function(){

        console.log(user.name);
        console.log(user.age);
    }
};
user["display"]();
```

##### Строки в качестве свойств и методов
Также следует отметить, что названия свойств и методов объекта всегда представляют строки. То есть мы могли предыдущее определение объекта переписать так:
```js
const user = {
    "name": "Tom",
    "age": 26,
    "display": function(){

        console.log(user.name);
        console.log(user.age);
    }
};
// вызов метода
user.display();
```

С одной стороны, разницы никакой нет между двумя определениями. С другой стороны, бывают случаи, где заключение названия в строку могут помочь. Например, если название свойства состоит из двух слов, разделенных пробелом:
```js
const user = {
    name: "Tom",
    age: 26,
    "full name": "Tom Johns",
    "display info": function(){

        console.log(user.name);
        console.log(user.age);
    }
};
console.log(user["full name"]);
user["display info"]();
```

Только в этом случае для обращении к подобным свойствам и методам мы должны использовать синтаксис массивов.

##### Динамическое определение имен свойств и методов
Синтаксис массивов открывает нам другую возможность — определение имени свойства вне объекта:
```js
const prop1  = "name";
const prop2  = "age";
const tom = {
    [prop1]: "Tom",
    [prop2]: 37
};
console.log(tom);           // {name: "Tom", age: 37}
console.log(tom.name);      // Tom
console.log(tom["age"]);    // 37
```

Благодая этому, например, можно динамически создавать объекты с произвольными названиями свойств:
```js
function createObject(propName, propValue){
    return {
            [propName]: propValue,
            print(){
                console.log(`${propName}: ${propValue}`);
            }
    };
}
const person = createObject("name", "Tom");
person.print();     // name: Tom

const book = createObject("title", "JavaScript Reference");
book.print();   // title: JavaScript Reference
```

#### Удаление свойств
Выше мы посмотрели, как можно динамически добавлять новые свойства к объекту. Однако также мы можем удалять свойства и методы с помощью оператора **`delete`**. И как и в случае с добавлением мы можем удалять свойства двумя способами. Первый способ — использование нотации точки:
```js
delete объект.свойство
```

Либо использовать синтаксис массивов:
```js
delete объект["свойство"]
```

Например, удалим свойство:
```js
let user = {};
user.name = "Tom";
user.age = 26;
user.display = function(){

    console.log(user.name);
    console.log(user.age);
};

console.log(user.name); // Tom
delete user.name; // удаляем свойство
// альтернативный вариант
// delete user["name"];
console.log(user.name); // undefined
```

После удаления свойство будет не определено, поэтому при попытке обращения к нему, программа вернет значение **`undefined`**.

#### Создание объекта из переменных и констант
При создании объекта его свойствам могут передаваться значения переменных, констант или динамически вычисляемые результаты функций:
```js
function getSalary(status){
    if(status==="senior") return 1500;
    else return 500;
}
const name = "Tom";
const age = 37;
const person = { name: name, age: age, salary: getSalary()};

console.log(person);    // {name: "Tom", age: 37, salary: 500}
```

Но если названия констант/переменных совпадает с названиями свойств, то можно сократить передачу значений:
```js
const name = "Tom";
const age = 37;
const salary = 500;
const person = { name, age, salary};

console.log(person);    // {name: "Tom", age: 37, salary: 500}
```

В данном случае объект `person` автоматически получит свойства, названия которых будут соответствовать названиям констант, а в качестве значений иметь значения этих констант.

То же самое относится к передаче функций методам объекта:
```js
function display(){
    console.log(this.name, this.age);
}
const move = function(place){ console.log(this.name, "goes to", place)};
const name = "Tom";
const age = 37;
const salary = 500;
const person = { name, age, salary, display, move};

person.display();       // Tom 37
person.move("cinema");  // Tom goes to cinema
```

В данном случае объект `person` имеет два метода, которые соответствуют переданным в объект функциям — `display()` и `move()`. Стоит отметить, что при такой передаче функций методам объекта, мы по прежнему можем использовать в этих функциях ключевое слово `this` для обращения к функциональности объекта. Однако стоит быть осторожным при передаче лямбд-выражений, поскольку для глобальных лямбд-выражений `this` будет представлять объект окна браузера:
```js
const move = (place)=>{ console.log(this.name, "goes to", place); console.log(this);};
const name = "Tom";

const person = { name, move};
person.move("cinema");  //  goes to cinema
```

#### Фукция Object.fromEntries()
С помощью функции **`Object.fromEntries()`** можно создать объект из набора пар ключ-значение, где ключ потом будет представляет название свойства. Например, создадим объект из массивов:
```js
const personData = [ ["name", "Tom"], ["age", 37]];
const person = Object.fromEntries(personData);
console.log(person);        // {name: "Tom", age: 37}
console.log(person.name);    // Tom
```

Здесь объект создается из массива `personData`, который содержит два подмассива. Каждый подмассив содержит два элемента и фактически представляет пару ключ-значение. Первый элемент представляет ключ, а второй — значение.[^4.1]

### Ключевое слово this
Поведение ключевого слова **`this`** зависит от контекста, в котором оно используется, и от того, в каком режиме оно используется — строгом или нестрогом.

#### Глобальный контекст и объект globalThis
В глобальном контексте `this` ссылается на глобальный объект. Что такое "глобальный объект" в JavaScript? Это зависит от среды, в которой выполняется код. Так, в веб-браузере `this` представляет объект **`window`** — объект, который представляет окно браузера. В среде Node.js `this` представляет объект **`global`**. А для веб-воркеров `this` представляет объект **`self`**.

Например, в веб-браузере при выполнении следующего кода:
```js
console.log(this);
```

мы получим консольный вывод вроде следующего
```
Window {window: Window, self: Window, document: document, name: "", location: Location, …}
```

В стандарт ES2020 было добавлено определение объекта **`globalThis`**, который позволяет ссылаться на глобальный конекст вне зависимости, в какой среде и в какой ситуации выполняется код:
```js
console.log(globalThis);
```

#### Контекст функции
В пределах функции `this` ссылается на внешний контекст. Для функций, определенных в глобальном контексте, — это объект **`globalThis`**. Например:
```js
function foo(){
    var bar = "local";
    console.log(this.bar);
}

var bar = "global";

foo();  // global
```

Если бы мы не использовали бы `this`, то обращение шло бы к локальной переменной, определенной внутри функции.

```js
function foo(){
    var bar = "local";
    console.log(bar);
}

var bar = "global";

foo();  // local
```

Но если бы мы использовали строгий режим (strict mode), то `this` в этом случае имело бы значение `undefined`:
```js
"use strict";
function foo(){
    var bar = "local";
    console.log(this.bar);
}

var bar = "global";

foo();  // ошибка - this - undefined
```

#### Контекст объекта
В контексте объекта, в том числе в его методах, ключевое слово `this` ссылается на этот же объект:
```js
const obj = {
    bar: "object",
    foo: function(){
        console.log(this.bar);
    }
}
var bar = "global";
obj.foo();  // object
```

#### Динамическое определение контекста
Код функции всегда использует в качестве `this` внешний контекст, в которым этот код вызывается (именно вызывается, а не определяется). Рассмотрим более сложный пример:
```js
function foo(){
    var bar = "foo_bar";
    console.log(this.bar);
}

const obj1 = {bar:"obj1_bar", foo: foo};
const obj2 = {bar:"obj2_bar", foo: foo};

var bar = "global_bar";

foo();  // global_bar
obj1.foo();   // obj1_bar
obj2.foo();   // obj2_bar
```

Здесь определена глобальная переменная `bar` ("global_bar"). И также в функции `foo` определена локальная переменная `bar` ("foo_bar"). Значение какой переменной будет выводиться в функции `foo`? Функция foo использует определение переменной, которое определено во внешнем контексте. Для функции `foo` по умолчанию это глобальный контекст, поэтому она выводит значение глобальной переменной (так как данный скрипт запускается в нестрогом режиме, а значит ключевое слово `this` в функции `foo` ссылается на внешний контекст).

Иначе дело обстоит с объектами. Они определяют свой собственный контекст, в котором существует свое свойство `bar`. И при вызове метода `foo` внешним контекстом по отношению к функции будет контекст объектов `obj1` и `obj2`.

Подобное поведение может привести к некоторому непонимаю в отдельных случаях. Так, рассмотрим другую ситуацию:
```js
var bar = "global_bar";

const obj1 = {
    bar: "obj1_bar",
    foo: function(){
        console.log(this.bar);  // bar = "obj1_bar"
    }
}
const obj2 = {bar: "obj2_bar", foo: obj1.foo}; // bar = "obj2_bar"

const foo = obj1.foo;   // bar = "global_bar"

obj1.foo(); // obj1_bar
obj2.foo(); // obj2_bar
foo();      // global_bar
```

Здесь в объекте `obj1` определена функция `foo`:
```js
const obj1 = {
    bar: "obj1_bar",
    foo: function(){
        console.log(this.bar);  // bar = "obj1_bar"
    }
}
```

Эта функция `foo` будет брать значение для `this.bar` из внешнего контекста — из объекта `obj1`, соответственно `this.bar = "obj1_bar"`.

Объект `obj2` использует функцию `foo` из объекта `obj1`:
```js
const obj2 = {bar: "obj2_bar", foo: obj1.foo};
```

Однако функция `obj1.foo` также будет искать значение для `this.bar` опять же во внешнем котексте, а здесь это объект `obj2`. А в объекте `obj2` это значение равно "obj2_bar".

То же самое с глобальной переменной `foo`, которая ссылается на ту же функцию, что и метод `obj1.foo`:
```js
const foo = obj1.foo;
```

В этом случае также будет происходить поиск значения для `this.bar`, но теперь в контексте функции `foo`. А это глобальный контекст, где определена переменная `var bar = "global_bar"`.

#### Контекст во вложенных функциях
Если мы вызываем функцию из другой функции, вызываемая функция также будет использовать внешний контекст:
```js
var bar = "global bar";

function foo(){
    var bar = "foo bar";
    function moo(){

        console.log(this.bar);
    }
    moo();
}
foo();  // global bar
```

Здесь функция `foo()` в качестве `this.bar` использует значение переменной `bar` из внешнего контекста, то есть значение глобальной переменной `bar`. Функция `moo()` также в качестве `this.bar` использует значение переменной `bar` из внешнего контекста, то есть `this.bar` для внешней функции `foo`, которое в свою очередь представляет значение глобальной переменной `bar`. Поэтому в итоге консоль выведет "global bar", а не "foo bar".

#### Явная привязка
С помощью методов `call()` и `apply()` можно задать явную привязку функции к определенному контексту:
```js
function foo(){
    console.log(this.bar);
}

var obj = {bar: "obj_bar"}
var bar = "global_bar";
foo();              // global_bar
foo.apply(obj);     // obj_bar
// или
// foo.call(obj);
```

Во втором случае функция `foo` привязывается к объекту `obj`, который и определяет ее контекст. Поэтому во втором случае консоль выведет "obj_bar".

#### Метод bind
Метод `f.bind(o)` позволяет создать новую функцию с тем же телом и областью видимости, что и функция `f`, но с привязкой к объекту `o`:
```js
function foo(){
    console.log(this.bar);
}

const obj = {bar: "object"}
var bar = "global";
foo();  // global
const func = foo.bind(obj);
func(); // object
```

#### this и стрелочные функции
В стрелочных функциях в качестве **`this`** используется контекст окружения, а не само окружение, в котором определена стрелочная функция. Рассмотрим следующий пример:
```js
const person = {
    name: "Tom",
    say:()=> console.log(`Меня зовут ${this.name}`)
}
person.say();   // Меня зовут
```

Здесь стрелочная функция `say()` обращается к некому свойству `this.name`, но что здесь представляет `this`? Для внешнего контекста, в котором определена стрелочная функция, то есть для контекста объекта `person`, `this` представляет глобальный объект (объект окна браузера). Однако глобальной переменной `name` не определено, поэтому на консоль будет выведено:
```
Меня зовут
```

Теперь немного изменим пример:
```js
const person = {
    name: "Tom",
    hello(){
        console.log("Привет");
        let say = ()=> console.log(`Меня зовут ${this.name}`);
        say();
    }
}
person.hello();
```

Теперь стрелочная функция определена в методе `hello()`. `this` для этого метода представляет текущий объект `person`, где определен данный метод. Поэтому и в стрелочной функции `this` будет представлять объект `person`, а `this.name` — свойство `name` этого объекта. Поэтому при выполнении программы мы получим:
```
Привет
Меня зовут Tom
```


Несмотря на то что, стрелочные функции могут добавить забот при работе `this`, в то же время они могут решить ряд проблем. Так, при работе с несколькими контекстами мы вынуждены учитывать, в каком контексте определяется переменная. Например, возьмем следующий код:
```js
const school ={
    title: "Oxford",
    courses: ["JavaScript", "TypeScript", "Java", "Go"],
    printCourses(){
        this.courses.forEach(function(course){
            console.log(this.title, course);
        })
    }
}
school.printCourses();
```

Функция `printCourses` проходит по всем курсам из массива и при их выводе предваряет их значением свойства `title`. Однако на консоли при запуске программы мы увидим следующее:
```
undefined "JavaScript"
undefined "TypeScript"
undefined "Java"
undefined "Go"
```

Мы видим, что значение `this.title` не определено, так как `this` как контекст объекта замещается глобальным контекстом. В этом случае нам надо передать подобное значение `this.title` или весь контекст объекта.

```js
const school ={
    title: "Oxford",
    courses: ["JavaScript", "TypeScript", "Java", "Go"],
    printCourses(){
        const that = this;
        this.courses.forEach(function(course){
            console.log(that.title, course);
        })
    }
}
school.printCourses();
```

Стрелочные функции также позволяют решить данную проблему:
```js
const school ={
    title: "Oxford",
    courses: ["JavaScript", "TypeScript", "Java", "Go"],
    printCourses(){
        this.courses.forEach((course)=>console.log(this.title, course))
    }
}
school.printCourses();
```

Контекстом для стрелочной функции в данном случае будет выступать контекст объекта `school`. Соответственно, нам не надо определять дополнительные переменые для передачи данных в функцию.[^4.10]

### Источники информации
[^4.1]: [Объектно-ориентированное программирование](https://metanit.com/web/javascript/4.1.php)
[^4.10]: [Ключевое слово this](https://metanit.com/web/javascript/4.10.php)
