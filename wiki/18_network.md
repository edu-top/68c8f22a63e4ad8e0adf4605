<link href="../styles.css" rel="stylesheet" />

# Работа с сетью

- [AJAX-запросы и XMLHttpRequest](#ajax-запросы-и-xmlhttprequest)
  - [Объект XMLHttpRequest](#объект-xmlhttprequest)
    - [Методы XMLHttpRequest](#методы-xmlhttprequest)
    - [Свойства XMLHttpRequest](#свойства-xmlhttprequest)
    - [События и обработчики событий XMLHttpRequest](#события-и-обработчики-событий-xmlhttprequest)
    - [Процесс выполнения ajax-запроса](#процесс-выполнения-ajax-запроса)
      - [Определение ресурса на севере](#определение-ресурса-на-севере)
      - [Выполнение ajax-запроса](#выполнение-ajax-запроса)
  - [Загрузка HTML с помощью XMLHttpRequest](#загрузка-html-с-помощью-xmlhttprequest)
    - [Определение сервера](#определение-сервера)
    - [Определение кода html для загрузки](#определение-кода-html-для-загрузки)
    - [Определение главной страницы и загрузка данных](#определение-главной-страницы-и-загрузка-данных)
    - [Управление html-содержимым](#управление-html-содержимым)
    - [Динамическая загрузка компонентов](#динамическая-загрузка-компонентов)
  - [Загрузка XML с помощью XMLHttpRequest](#загрузка-xml-с-помощью-xmlhttprequest)
    - [Определение данных](#определение-данных)
- [Глоссарий](#глоссарий)
- [Источники информации](#источники-информации)

## AJAX-запросы и XMLHttpRequest
*[AJAX]: Asynchronous JavaScript And XML
*[XML]: eXtensible Markup Language
*[JSON]: JavaScript Object Notation
*[MIME]: Multipurpose Internet Mail Extensions
*[SMTP]: Simple Mail Transfer Protocol
*[HTTP]: HyperText Transfer Protocol
*[ASCII]: American Standard Code for Information Interchange

Код javascript может взаимодействовать с каким-нибудь ресурсом в сети интернет, например, с каким-нибудь веб-сайтом или веб-сервисом, грубо говоря с сервером. Для взаимодействия кода javascript с сервером обычно применяется такая технология как **Ajax**. <dfn title="AJAX">AJAX</dfn> представляет технологию для отправки запросов к серверу из клиентского кода JavaScript без перезагрузки страницы. Сам термин расшифровывается как **Asynchronous JavaScript And XML**. То есть изначально AJAX предполагал асинхронное взаимодействие клиента и сервера посредством данных в формате XML. Хотя сейчас XML во многом вытеснил формат JSON.[^13.1]

### Объект XMLHttpRequest
Одним из способов для отправки ajax-запросов является применение объекта **`XMLHttpRequest`**. Данный объект создается с помощью одноименной функции-конструктора:
```js
const xhr = new XMLHttpRequest();
```

#### Методы XMLHttpRequest
Для настройки и отправки ajax-запросов объект `XMLHttpRequest` предоставляет ряд методов:

- `abort()`: прерывает запрос

- `getAllResponseHeaders()`: возвращает все заголовки HTTP-ответа в виде строки

- `getResponseHeader(header)`: возвращает значение заголовка `header`.

- `open(method, url[, async[, user[, password]]])`: инициализирует ajax-запрос.

    Эта функция принимает пять параметров, из которых первые два являются обязательными:

    - `method`: тип запроса ("GET", "POST", "PUT", "DELETE" и т.д.)

    - `url`: адрес ресурса, к которому отправляется запрос

    - `async`: логическое значение, которое указывает, будет ли запрос асинхронным. Если значение `true` (значение по умолчанию), то запрос асинхронный

        Синхронный и асинхронный режим отличаются тем, что запрос в синхронном режиме пока запрос не выполнится, остальной код javascript не может выполняться. Если запрос отправляется в асинхронном режиме, то параллельно с выполнением запроса можно выполнять также и другой код javascript. И в большинстве случаев, как правило, используется именно асинхронный режим.

    - `user`: имя пользователя, которое применяется при его аутентификации на сервере (то есть для определения, какой именно пользователь осуществил запрос), по умолчанию равно `null`

    - `password`: пароль пользователя, который применяется при его аутентификации на сервере, по умолчанию равно `null`

- `overrideMimeType(mime)`: переопределяет MIME-тип, возвращаемый сервером

    <dfn title="MIME">MIME</dfn> (*Multipurpose Internet Mail Extensions*) — это интернет-стандарт, позволяющий передавать по электронной почте (SMTP) и в веб-протоколах (HTTP) данные, отличные от простого ASCII-текста: изображения, видео, звук, документы, а также многосоставные (multipart) письма и символы национальных алфавитов. Он описывает структуру, кодировку и тип вложений.

    Основные аспекты MIME:
    - **Типы данных** (**MIME-типы**): состоят из «типа» и «подтипа» (например, `text/html`, `image/jpeg`, `application/pdf`), которые помогают браузерам и почтовым клиентам понять, как обрабатывать полученный файл.
    - **Функциональность**: позволяет вкладывать файлы, отправлять письма с HTML-версткой и использовать различные кодировки (например, UTF-8).
    - **Структура письма**: MIME-сообщения часто используют `Multipart` для разделения письма на части (текст, вложения).
    - **S/MIME**: Расширение стандарта для обеспечения безопасности электронной почты через шифрование и цифровую подпись. 

    MIME-типы используются в заголовке `Content-Type` для определения типа контента в HTTP-запросах и ответах.

- `send(data)`: отправляет запрос. С помощью необязательного параметра data можно передать данные, которые отправляются на сервер. Если этому параметру не передано никакого значения, то его значение по умолчанию `null`.

- `setRequestHeader(header, value)`: устанавливает значение `value` для заголовка header, который будет отправляться в запросе.

#### Свойства XMLHttpRequest
В дополнение к методам объект `XMLHttpRequest` предоставляет ряд свойств, которые позволяют настроить отправку запроса или извлечт полученные от сервера данные:

- **`response`**: возвращает ответ сервера. Ответ может представлять объекты `ArrayBuffer`, `Blob`, `Document`, объект `JSON`, строку или `null` (если запрос еще не завершен или завершился неудачно)

- **`responseType`**: возвращает тип ответа. Есть следующие типы:

  - `""`: пустая строка

  - `"arraybuffer"`: ответ представляет объект `ArrayBuffer`, которые содержит бинарные данные

  - `"blob"`: ответ представляет объект `Blob`, которые содержит бинарные данные

  - `"document"`: ответ представляет объект `Document` (документ HTML/XML)

  - `"json"`: ответ представляет данные в формате json

  - `"text"`: ответ представляет текст

- **`responseText`**: возвращает ответа сервера в виде строки или значения `null` (если запрос еще не завершен или завершился неудачно).

- **`responseXML`**: возвращает объект `Document` (документ HTML/XML), если ответ от сервера в формате XML/HTML.

- **`readyState`**: хранит состояния запроса, которое представляет число:

  - `0`: объект `XMLHttpRequest` создан, но метод `open()` еще не был вызван для инициализации объекта

  - `1`: метод `open()` был вызван, но запрос еще не был отправлен методом `send()`

  - `2`: запрос был отправлен, заголовки и статус ответа получены и готовы к использованию

  - `3`: ответ получен от сервера

  - `4`: выполнение запроса полностью завершено (даже если получен код ошибки, например, 404)

  Соответственно проверив данное свойство, мы можем понять, на какой стадии находится запрос.

- **`status`**: содержит статусный код ответа HTTP, который пришел от сервера. С помощью статусного кода можно судить об успешности запроса или об ошибках, которые могли бы возникнуть при его выполнении. Например, статусный код 200 указывает на то, что запрос прошел успешно. Код 403 говорит о необходимости авторизации для выполнения запроса, а код 404 сообщает, что ресурс не найден и так далее.

- **`statusText`**: возвращает текст статуса ответа, например, "200 OK".

- **`timeout`**: устанавливает тайм-аут — время в миллисекундах, во время которого может выполняться запрос. Если это время истекло, а запрос еще не завершен, то запрос прерывается.

- **`withCredentials`**: определяет, следует ли включать в запрос учетные данные, например, файлы cookie.

#### События и обработчики событий XMLHttpRequest
Для отслеживания состояния запроса можно применять события `XMLHttpRequest`:

- **`abort`**: срабатывает после прерывания запроса. Для установки обработчика применяется свойство `onabort`

- **`progress`**: срабатывает при выполнения запроса. Для установки обработчика применяется свойство `onprogress`

- **`load`**: срабатывает после выполнения запроса. Для установки обработчика применяется свойство `onload`

- **`loadend`**: срабатывает после успешного выполнения запроса. Для установки обработчика применяется свойство `onloadend`

- **`error`**: срабатывает при возникновении ошибки. Для установки обработчика применяется свойство `onerror`

- **`loadstart`**: срабатывает после запуска запроса. Для установки обработчика применяется свойство `onloadstart`

- **`timeout`**: срабатывает, если запрос прерывается из-за тайм-аута. Для установки обработчика применяется свойство `onimeout`

- **`readystatechange`**: возникает каждый раз, когда изменяется значение свойства `readyState`. Для установки обработчика применяется свойство `onreadystatechange`

Для установки обработчиков событий можно использовать одно из следующих свойств `XMLHttpRequest`:

- **`onabort`**: вызывается, когда запрос был прерван с помощью метода `abort()`.

- **`onerror`**: вызывается при возникновении ошибки.

- **`onload`**: вызывается, когда запрос успешно выполнен и доступен ответ.

- **`onloadend`**: вызывается после успешного выполнения запроса.

- **`onloadstart`**: вызывается после запуска запроса.

- **`onprogress`**: вызывается при выполнении запроса.

- **`onreadystatechange`**: вызывается при изменении состояния запроса.

- **`ontimeout`**: вызывается, если запрос прерывается из-за тайм-аута.

- **`upload`**: можно использовать для отслеживания статуса при загрузке данных.

#### Процесс выполнения ajax-запроса
В общем случае процесс выполнения ajax-запроса с помощью `XMLHttpRequest` выглядит следующим образом:

1. Создается объект `XMLHttpRequest`

    ```js
    const request = new XMLHttpRequest();
    ```

2. Устанавливается обработчик событий загрузки (например, через свойство `onload`), который будет вызываться после завершения HTTP-запроса

    ```js
    request.onload = (event) => { console.log("request finished");}
    ```

3. Запускается HTTP-запрос с помощью метода **`open()`**. Методу передается метод HTTP, который будет использоваться для запроса (например, GET или POST), URL-адрес, к которому должен быть отправлен запрос, и при необходимости другие необязательные аргументы

    ```js
    request.open("GET", "http://localhost/hello");
    ```

4. При необходимости производится дополнительная конфигурация HTTP-запроса. Например, с помощью метода `setRequestHeader()` можно определить заголовки, которые будут отправляться вместе с запросом. Однако важно выполнить эту настройку после предыдущего шага, то есть после вызова метода `open()`, но перед следующим шагом, то есть перед вызовом метода `send()`

    ```js
    request.setRequestHeader("Accept", "text/plain"); // установка заголовка на прием данных
    ```

5. Непосредственно отправляется HTTP-запрос с помощью вызова метода **`send()`**. При желании в этот метод можно передать данные для отправки на сервер

    ```js
    request.send()
    ```

Вначале рассмотрим простейший пример, как выполнять запрос к серверу с помощью `XMLHttpRequest`.

##### Определение ресурса на севере
Поскольку Ajax предполагает взаимодействие клиента и сервера, то для работы с Ajax нам потребуется некоторый сетевой ресурс, к которому мы будем обращаться. Для эмуляции сетевого ресурса используем локальный веб-сервер. Веб-сервер может быть любым. В данном случае воспользуемся самым простым вариантом — Node.js, так как эта технология двольно проста, доступна для всех основных операционных систем и также также позволяет использовать javascript для создания приложений. Но естественно перед созданием приложения необходимо [установить Node.js](https://metanit.com/web/nodejs/1.1.php). В данном случае не потребуется никаких знаний node.js, весь используемый код подробно описывается. Но опять же вместо node.js это может быть любая другая технология сервера — php, asp.net, python и т.д. либо какой-то определенный веб-сервер типа Apache или IIS.

Итак, создадим на жестком диске папку для файлов веб-сервера. Например, в моем случае это папка *C:\app*. Далее в этой папке определим файл сервера. Пусть он будет называться *server.js* и будет иметь следующий код:
```js
const http = require("http");
const fs = require("fs");

http.createServer(function(request, response){

    if(request.url == "/hello"){
        response.end("Hello world");
    }
    else{
        fs.readFile("index.html", (error, data) => response.end(data));
    }
}).listen(3000, ()=>console.log("Сервер запущен по адресу http://localhost:3000"));
```

Это самый примитивный сервер, который достаточен для нашей задачи. Вкратце пробежимся по коду. Сначала подключаются пакеты с функциональностью, которую мы собираемся использовать:
```js
const http = require("http");   // для обработки входящих запросов
const fs = require("fs");       // для чтения с жесткого диска файла index.html
```

Для создания сервера применяется функция **`http.createServer()`**. В эту функцию передается функция-обработчик, которая вызывается каждый раз, когда к серверу приходит запрос. Эта функция имеет два параметра: `request` (содержит данные запроса) и `response` (управляет отправкой ответа).

В функции-обработчике с помощью свойства `request.url` мы можем узнать, к какому ресурсу на сервере пришел запрос. Так, в данном случае, если пришел запрос по пути "/hello" (условно к ресурсу "/hello"), то оправляем в ответ с помощью метода `response.end()` текст "Hello world":
```js
if(request.url == "/hello"){
    response.end("Hello world");
}
```

Если запрос пришел к какому-то другому ресурсу, то отправляем файл *index.html*, который мы дальше определим:
```js
else{
    fs.readFile("index.html", (error, data) => response.end(data));
}
```

Для считывания файлов применяется встроенная функция **`fs.readFile()`**. Первый параметр функции — адрес файла (в данном случае предполагается, что файл *index.html* находится в одной папке с файлом сервера *server.js*). Второй параметр — функция, которая вызывается после считывания файла и получет его содержимое через свой второй параметр `data`. Затем считанное содежимое также может быть отпавлено с помощью функции `response.end(data)`.

В конце с помощью функции **`listen()`** запускаем веб-сервер на 3000 порту. То есть сервер будет запускаться по адресу http://localhost:3000/.

##### Выполнение ajax-запроса
Теперь в папке сервера определим простенький файл *index.html*

![веб-сервер node.js для тестирования XMLHttpRequest в javascript](../img/xmlhttprequest1.png)

Определим в этом файле следующее содежимое:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Example</title>
</head>
<body>
<script>
const xhr = new XMLHttpRequest();
// GET-запрос к ресурсу /hello
xhr.open("GET", "/hello");

// обработчик получения ответа сервера
xhr.onload = () => {
    if (xhr.status == 200) {                // если код ответа 200
        console.log(xhr.responseText);      // выводим полученный ответ на консоль браузера
    } else {                                // иначе выводим текст статуса
        console.log("Server response: ", xhr.statusText);
    }
};
xhr.send();     // выполняем запрос
</script>
</body>
</html>
```

Здесь в метод **`xhr.open()`** в качестве типа запроса передается тип "GET", а в качестве адреса ресурса — "/hello".

```js
xhr.open("GET", "/hello");
```

Для отслеживания завершения запроса устанавливаем обработчик для события `load` с помощью свойства `xhr.onload`:
```js
xhr.onload = () => {
    if (xhr.status == 200) {                // если код ответа 200
        console.log(xhr.responseText);      // выводим полученный ответ на консоль браузера
    } else {                                // иначе выводим текст статуса
        console.log("Server response: ", xhr.statusText);
    }
};
```

В данном случае в качестве обработчика события выступает лямбда-выражение. И когда запрос завершится, сработает данный обработчик. Если запрос был успешно обрабатан, то по умолчанию сервер посылает статусный код 200. Как мы помним из кода сервера, при обращении по адресу "/hello" сервер посылает клиенту строку. И чтобы получить данную строку, обращаемся к свойству `xhr.responseText`. Если же в процессе обращения к серверу возникла какая-то ошибка или статусный код не 200, то с помощью свойства `xhr.statusText` выводит текст статуса ответа.

И в конце собственно выполняем запрос:
```js
xhr.send();     // выполняем запрос
```

Таким образом, при загрузке данной веб-страницы будет выполняться ajax-запрос к серверу.

Теперь в консоли перейдем к папке сервера с помощью команды **`cd`** и запустим сервер с помощью команды **`node server.js`**
```
C:\app>node server.js
Сервер запущен по адресу http://localhost:3000
```

После запуска сервера мы можем перейти в браузере по адресу http://localhost:3000, нам отобразится страница, в javascript-коде которой произойдет обращение к ресурсу "/hello":

![XMLHttpRequest в javascript](../img/xmlhttprequest3.png)

В итоге при обращении к ресурсу "/hello" сервер отправит отправит строку "Hello world", которую мы сможем получить на веб-странице.

В примере выше применялся относительный путь, но также можно было бы использовать абсолютный путь с указанием протокола, адреса сервера и порта:
```js
xhr.open("GET", "http://localhost:3000/hello");
```

Вместо события load мы также могли бы обрабатывать событие **`readystatechange`** объекта `XMLHttpRequest`, которое возникает каждый раз, когда изменяется значение свойства **`readyState`**:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Example</title>
</head>
<body>
<script>
const xhr = new XMLHttpRequest();
// GET-запрос к ресурсу /hello
xhr.open("GET", "/hello");

// обработчик получения ответа сервера
xhr.onreadystatechange = () => {
    if (xhr.readyState == 4) {                  // если запрос завершен
        if (xhr.status == 200) {                // если код ответа 200
            console.log(xhr.responseText);      // выводим полученный ответ на консоль браузера
        } else {                                // иначе выводим текст статуса
            console.log("Server response: ", xhr.statusText);
        }
    }
};
xhr.send();     // выполняем запрос
</script>
</body>
</html>
```

Здесь в обработчике события сначала проверяет состояние запроса — если код состояния равен 4, то обрабатывает ответ от сервера. Остальная логика та же, что и предыдущем случае.

### Загрузка HTML с помощью XMLHttpRequest
Нередко в коде страницы требуется получить с сервера некоторый код HTML. Например, страница может представлять одностраничный сайт, который через ajax запрос загружает необходимый html-код и вставляет на страницу. Поэтому рассмотрим, как через AJAX загрузить код html.

В качестве сервера, как и в прошлой статье, будем использовать Node.js как наиболее простой вариант, но естественно при желании можно использовать любую другую технологию серверного уровня или какой-нибудь веб-сервер.[^13.4]

Итак, определим для проекта на жестком диске папку, в которой создадим три файла:

- *index.html*: главная страница приложения

- *home.html*: страница с кодом html, который мы будем загружать через AJAX

- *server.js*: файл приложения сервера, который будет использовать Node.js

#### Определение сервера
Файл *server.js* будет представлять код сервера Node.js. Определим в нем следующий код:
```js
const http = require("http");
const fs = require("fs");

http.createServer((request, response)=>{
    // получаем путь после слеша, слеш - первый символ в пути
    let filePath = request.url.substring(1);
    // если пустой путь, отправляем главную страницу index.html
    if(!filePath) filePath = "index.html";
    // в качестве типа ответа устанавливаем html
    response.setHeader("Content-Type", "text/html; charset=utf-8;");
    fs.readFile(filePath, (error, data)=>{
        if(error){                              // если ошибка
            response.statusCode = 404;
            response.end("<h1>Resourse not found!</h1>");
        }
        else{
            response.end(data);
        }
    });
}).listen(3000, ()=>console.log("Сервер запущен по адресу http://localhost:3000"));
```

Вкратце пробежимся по коду. Сначала подключаются пакеты с функциональностью, которую мы собираемся использовать:
```js
const http = require("http");   // для обработки входящих запросов
const fs = require("fs");       // для чтения файлов с жесткого диска
```

Для создания сервера применяется функция **`http.createServer()`**. В эту функцию передается функция-обработчик, которая вызывается каждый раз, когда к серверу приходит запрос. Эта функция имеет два параметра: `request` (содержит данные запроса) и `response` (управляет отправкой ответа).

В функции-обработчике с помощью свойства `request.url` мы можем получить путь к ресурсу, к которому пришел запрос. Нам надо обрабатывать запросы к страницам "index.html" и "home.html" (а в перспективе к любым другим страницам html). Путь всегда начинается со слеша "/". Например, запрос к странице "home.html" будет представлять путь "/home.html". Соответственно, чтобы получить из запрошенного пути путь к файлам на жестком диске, нам надо убрать начальный слеш:
```js
let filePath = request.url.substring(1);
```

Однако если запрос обращен к корню сайта, то путь состоит только из одного слеша — "/". Соответственно, если мы удалим этот слеш, то получим пустую строку. Поэтому если запрос идет к корню веб-приложения, то будем считать что запрос идет к главной странице — *index.html*:
```js
if(!filePath) filePath = "index.html";
```

И поскольку в нашем случае ответ сервера будет представлять код html, то с помощью метода `setHeader()` устанавливаем для заголовка "Content-Type" значение "text/html":
```js
response.setHeader("Content-Type", "text/html; charset=utf-8;");
```

То есть ответ сервера будет представлять html.

Далее с помощью функции **`fs.readFile`** считываем файл, к которому идет запрос. Первый параметр функции — адрес файла (в данном случае предполагается, что файл находится в одной папке с файлом сервера *server.js*). Второй параметр — функция, которая вызывается после считывания файла и получет его содержимое через свой второй параметр `data`. Вполне возможно, что запрошенного файла не окажется, и в этом случае отправляем ошибку 404:
```js
fs.readFile(filePath, (error, data)=>{
    if(error){                              // если ошибка
        response.statusCode = 404;
        response.end("<h1>Resourse not found!</h1>");
    }
```

Если ошибки нет, файл найден и успешно считан, то отправляем параметр `data`, который содержит данные файла:
```js
else{
    response.end(data);
}
```

В конце с помощью функции **`listen()`** запускаем веб-сервер на 3000 порту. То есть сервер будет запускаться по адресу http://localhost:3000/.

#### Определение кода html для загрузки
Файл *home.html* будет содержать простенький код, который будет загружаться веб-страницей. Пусть это будет следующий код:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Home Page</title>
</head>
<body>
    <h1>Home Page</h1>
    <p>Home Page Text</p>
</body>
</html>
```

#### Определение главной страницы и загрузка данных
Теперь определим код главной страницы *index.html*, которая будет загружать страницу *home.html*:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Example</title>
</head>
<body>
    <script>
        const xhr = new XMLHttpRequest();
        xhr.onload = () => {                        // обработчик получения ответа сервера
            if (xhr.status == 200) {                // если код ответа 200
                const html = xhr.responseText;      // получаем ответ
                console.log(html);      // выводим полученный ответ на консоль браузера
            } else {                                // иначе выводим текст статуса
                console.log("Server response: ", xhr.statusText);
            }
        };
        xhr.open("GET", "/home.html");                  // GET-запрос к ресурсу /home.html
        xhr.setRequestHeader("Accept", "text/html");    // принимаем только html
        xhr.send();     // выполняем запрос
    </script>
</body>
</html>
```

В обработчике загрузке `xhr.onload` получаем текст ответа через `xhr.responseText` и выводим ответ на консоль.

Теперь в консоли перейдем к папке сервера с помощью команды **`cd`** и запустим сервер с помощью команды **`node server.js`**
```
C:\app>node server.js
Сервер запущен по адресу http://localhost:3000
```

После запуска сервера мы можем перейти в браузере по адресу http://localhost:3000, нам отобразится страница, в javascript-коде которой произойдет обращение к странице "home.html". Код javascript получит эту страницу и выведет ее содержимое на консоль:

![Получение кода html в ajax-запросе с помощью XMLHttpRequest в javascript](../img/xmlhttprequest6.png)

#### Управление html-содержимым
В примере выше мы получали содержимое страницы как обычный текст. Однако так как этот текст фактически содержит разметку HTML, то мы можем загрузить его на веб-страницу. Так, изменим код страницы *index.html* следующим образом:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Example</title>
</head>
<body>
    <div id="content"></div>
    <script>
        const contentDiv = document.getElementById("content");  // элемент для загрузки html
        const xhr = new XMLHttpRequest();

        xhr.onload = () => {
            if (xhr.status == 200) {
                contentDiv.innerHTML = xhr.responseText;    // выводим полученный ответ в contentDiv
            } else {                                        // иначе выводим текст статуса
                console.log("Server response: ", xhr.statusText);
            }
        };
        xhr.open("GET", "/home.html");                      // GET-запрос к ресурсу /home.html
        xhr.setRequestHeader("Accept", "text/html");        // принимаем только html
        xhr.send();                                         // выполняем запрос
    </script>
</body>
</html>
```

В данном случае загружаем полученный код страницы "home.html" в элемент c `id=content`

![Загрузка кода html на веб-страницу в ajax-запросе с помощью XMLHttpRequest в javascript](../img/xmlhttprequest7.png)

Однако проблема в данном случае состоит в том, что код страницы "home.html" кроме собственно некоторого содержимого также содержит элементы `head`, `title`, метаописания страницы с помощью тегов `<meta>`. Эти элементы нет смысла загружать на другую веб-страницу. Либо мы хотим загрузить какой-то определенный элемент со страницы "home.html", а не весь ее код. В этом случае мы можем получить ответ через свойство **`responseXML`** и затем манипулировать ответом как стандартным документом html. Например, изменим код javascript следующим образом:
```js
const contentDiv = document.getElementById("content");

const xhr = new XMLHttpRequest();
xhr.onload = () => {                            // обработчик получения ответа сервера
    if (xhr.status == 200) {
        // загружаем только содержимое элемента body
        contentDiv.innerHTML = xhr.responseXML.body.innerHTML;
    } else {
        console.log("Server response: ", xhr.statusText);
    }
};
xhr.open("GET", "/home.html");                  // GET-запрос к ресурсу /home.html
xhr.responseType = "document";                  // устанавливаем тип ответа
xhr.setRequestHeader("Accept", "text/html");    // принимаем только html
xhr.send();     // выполняем запрос
```

Здесь следует отметить два момента. Прежде всего устанавливаем для ответа тип "document":
```js
xhr.responseType = "document";
```

Это позволит нам получить ответ как объект типа **`Document`**, аналогичный тому, что представляет свойство `document` на веб-странице.

Чтобы получить ответ в виде html/xml используем свойство **`responseXML`**. И далее, поскольку это свойство представляет объект **`Document`**, используем свойство `body` для обращения к непосредственному содержимому страницы:
```js
contentDiv.innerHTML = xhr.responseXML.body.innerHTML;
```

В результате в `contentDiv` будет загружено содержимое элемента `body` страницы "home.html".

Подобным образом можно обращаться к другим свойствам объекта `Document`. Например, получим заголовок:
```js
document.title = xhr.responseXML.title;
```

Или загрузим на страницу только текст из заголовка `<ht1>`:
```js
contentDiv.innerHTML =  xhr.responseXML.querySelector("h1").textContent;
```

#### Динамическая загрузка компонентов
Возможность загружать html-код и вставлять его на страницу позволяет нам пойти дальше и разделить функционал приложения на несколько компонентов и при необходимости подгружать их. Например, пусть в проекте у нас есть следующие файлы:

- *server.js*: файл приложения сервера на Node.js

- *index.html*: главная страница приложения

- *home.html*: файл компонента home

- *about.html*: файл компонента about

- *contact.html*: файл компонента contact

Файл приложения сервера на Node.js — *server.js* — остается тем же, что был определен выше в данной статье.

Пусть файл *home.html* содержит какой-нибудь простейший код типа следующего:
```html
<h1>Home Page</h1>
<p>Home Page Text</p>
```

Файл *about.html* пусть выглядит аналогичным образом:
```html
<h1>About Page</h1>
<p>About Page Text</p>
```

И код файла *contact.html*:
```html
<h1>Contact Page</h1>
<p>Contact Page Text</p>
```

Эти файлы представляют компоненты, которые будут загружаться на главной странице.

На главной странице *index.html* определим следующий код:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Example</title>
</head>
<body>
<nav><a href="home">Home</a> | <a href="about">About</a> | <a href="contact">Contact</a></nav>
<div id="content"></div>
<script>
const contentDiv = document.getElementById("content");

function loadContent(fileName){
    const xhr = new XMLHttpRequest();
    xhr.onload = () => {
        if (xhr.status == 200) {
            contentDiv.innerHTML = xhr.responseText;    // xhr.responseXML.body.innerHTML;
            document.title = fileName;
        }
    };
    xhr.open("GET", fileName + ".html");                // GET-запрос по адресу ссылки
    xhr.setRequestHeader("Accept", "text/html");        // принимаем только html
    xhr.send();                                         // выполняем запрос
}

// устанавливаем обработчик нажатия для кнопок
const links = document.getElementsByTagName("a");
for (let i = 0; i < links.length; i++) {
    links[i].addEventListener("click", (e)=>{
        loadContent(links[i].getAttribute("href"));
        e.preventDefault();
    });
}
// по умолчанию загружаем компонент home
loadContent("home");
</script>
</body>
</html>
```

Здесь для навигации по компонентам на страницу помещаем ряд ссылок:
```html
<nav><a href="home">Home</a> | <a href="about">About</a> | <a href="contact">Contact</a></nav>
```

Адрес каждой такой ссылки совпадает с названием страницы соответствующего компонента без расширения ".html".

Каждый из компонентов будет загружаться на странице в элемент с `id="content"`, который получаем в коде JavaScript в константу `contentDiv`:
```js
const contentDiv = document.getElementById("content");
```

Также в коде JavaScript для каждой ссылки устанавливаем обработчки, в котором вызываем функцию `loadContent` и в которую передаем значение атрибута `href` ссылки — то есть адрес компонента
```js
const links = document.getElementsByTagName("a");
for (let i = 0; i < links.length; i++) {
    links[i].addEventListener("click", (e)=>{
        loadContent(links[i].getAttribute("href"));
        e.preventDefault();
    });
}
```

В функции `loadContent` используем адрес ссылки для отправки ajax-запроса, а ответ (полученный html) загружаем в элемент `contentDiv`
```js
contentDiv.innerHTML = xhr.responseText; // xhr.responseXML.body.innerHTML;
```

При загрузке страницы сразу загружаем код компонента `home`, как компонента по умолчанию:
```js
loadContent("home");
```

Таким образом, на главной странице мы сможем обращаться к конкретным компонентам, переходя по ссылкам:

![Динамическая загрузка компонентов на веб-страницу в ajax-запросе с помощью XMLHttpRequest в javascript](../img/xmlhttprequest8.png)

### Загрузка XML с помощью XMLHttpRequest

Формат XML представляет популярный формат хранения и передачи данных. Рассмотрим, как загружать xml-документ на веб-странице с помощью ajax-запроса.

В качестве сервера, как и в прошлой статье, будем использовать Node.js как наиболее простой вариант, но естественно при желании можно использовать любую другую технологию серверного уровня или какой-нибудь веб-сервер.[^13.5]

Итак, определим для проекта на жестком диске папку, в которой создадим три файла:

- *index.html*: главная страница приложения

- *users.xml*: xml-файл с данными

- *app.js*: файл приложения сервера, который будет использовать Node.js

#### Определение данных
Файл *users.xml* будет представлять загружаемые данные и пусть будет иметь следующее содержимое:
```xml
<?xml version="1.0" encoding="UTF-8" ?>
<users>
    <user name="Tom" age="39">
        <contacts>
            <email>tom@smail.com</email>
            <phone>+1234567890</phone>
        </contacts>
    </user>
    <user name="Bob" age="43">
        <contacts>
            <email>bob@tmail.com</email>
            <phone>+1334567181</phone>
        </contacts>
    </user>
    <user name="Sam" age="28">
        <contacts>
            <email>sam@xmail.com</email>
            <phone>+1434567782</phone>
        </contacts>
    </user>
</users>
```

Здесь элемент `users` представляет набор пользователей, каждый из которых представлен элементом `user`. Для каждого такого элемента определены два атрибута: `name` (имя пользователя) и `age` (возраст пользователя). И также элемент user имеет вложенный элемент `contacts`, который представляет контактные данные пользователя в виде вложенных элементов `phone` и `email`.

## Глоссарий
AJAX (*Asynchronous JavaScript And XML*)
: технология для отправки запросов к серверу из клиентского кода JavaScript без перезагрузки страницы. Изначально AJAX предполагал асинхронное взаимодействие клиента и сервера посредством данных в формате XML. Хотя сейчас XML во многом вытеснил формат JSON.

MIME (*Multipurpose Internet Mail Extensions*) — это интернет-стандарт, позволяющий передавать по электронной почте (SMTP) и в веб-протоколах (HTTP) данные, отличные от простого ASCII-текста: изображения, видео, звук, документы, а также многосоставные (multipart) письма и символы национальных алфавитов. Он описывает структуру, кодировку и тип вложений.

## Источники информации
[^13.1]: [AJAX-запросы и XMLHttpRequest](https://metanit.com/web/javascript/13.1.php)
[^13.4]: [Загрузка HTML с помощью XMLHttpRequest](https://metanit.com/web/javascript/13.4.php)
[^13.5]: [Загрузка XML с помощью XMLHttpRequest](https://metanit.com/web/javascript/13.5.php)
