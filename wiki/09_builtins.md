## Встроенные объекты и коллекции

- [Встроенные объекты и коллекции](#встроенные-объекты-и-коллекции)
  - [Объект Date. Работа с датами](#объект-date-работа-с-датами)
    - [Определение дат](#определение-дат)
    - [Получение даты и времени](#получение-даты-и-времени)
    - [Установка даты и времени](#установка-даты-и-времени)
  - [Объект Math. Математические операции](#объект-math-математические-операции)
    - [abs()](#abs)
    - [min() и max()](#min-и-max)
    - [ceil()](#ceil)
    - [floor()](#floor)
    - [round()](#round)
    - [random()](#random)
    - [pow()](#pow)
    - [sqrt()](#sqrt)
    - [log()](#log)
    - [Тригонометрические функции](#тригонометрические-функции)
    - [Константы](#константы)
  - [Объект Number](#объект-number)
    - [Преобразование в другую систему счисления](#преобразование-в-другую-систему-счисления)
    - [Из числа в строку, метод toString](#из-числа-в-строку-метод-tostring)
  - [Символы](#символы)
    - [Символы как идентификаторы свойств объектов](#символы-как-идентификаторы-свойств-объектов)
  - [Proxy](#proxy)
    - [Переопределение функциональности объекта](#переопределение-функциональности-объекта)
      - [Метод get и получение свойств объекта](#метод-get-и-получение-свойств-объекта)
      - [Установка свойства и метод set](#установка-свойства-и-метод-set)
  - [Коллекции](#коллекции)
    - [Множества Set](#множества-set)
      - [Размер набора](#размер-набора)
      - [Добавление](#добавление)
      - [Удаление](#удаление)
      - [Проверка наличия элемента](#проверка-наличия-элемента)
      - [Перебор множества](#перебор-множества)
      - [Получение итератора](#получение-итератора)
      - [Удаление из массива повторяющихся элементов](#удаление-из-массива-повторяющихся-элементов)
    - [Ассоциативные массивы Map](#ассоциативные-массивы-map)
      - [Размер словаря](#размер-словаря)
      - [Добавление и изменение элементов](#добавление-и-изменение-элементов)
      - [Получение элементов](#получение-элементов)
      - [Удаление элементов](#удаление-элементов)
      - [Перебор элементов](#перебор-элементов)
    - [Слабоссылаемые множества](#слабоссылаемые-множества)
      - [Перебор WeakSet](#перебор-weakset)
      - [Слабые ссылки](#слабые-ссылки)
    - [Слабоссылочные словари](#слабоссылочные-словари)
      - [Слабые ссылки](#слабые-ссылки-1)
  - [Источники информации](#источники-информации)

### Объект Date. Работа с датами
Объект **`Date`** позволяет работать с датами и временем в JavaScript.

#### Определение дат
Существуют различные способы создания объекта `Date`:

- С помошью пустого конструктора **`Date`** без параметров. В этом случае созданный объект хранит текущие дату и время

    ```js
    const currentDate = new Date();
    console.log(currentDate);   // Thu Oct 26 2023 13:17:53 GMT+0100
    ```

- В конструктор `Date` передается количества миллисекунд, которые прошли с начала эпохи Unix, то есть с 1 января 1970 года 00:00:00 GMT:

    ```js
    const myDate = new Date(1359270000000);
    console.log(myDate); // Sun Jan 27 2013 11:00:00 GMT+0400 (Москва, стандартное время)
    ```

    <details>
    <summary><em>Об эпохе Unix</em></summary>

    Эпоха Unix связана с началом отсчёта времени в Unix-подобных системах как количество секунд, прошедших с полуночи 1 января 1970 года. Эта дата стала точкой отсчёта для Unix-времени (или Unix-timestamp) и была выбрана, потому что это была ближайшая подходящая дата после создания первой версии операционной системы Unix в начале 1970-х годов.

    **Исторический контекст**: Изначально операционная система Unix была разработана в исследовательском центре Bell Labs в 1970-х годах. Выбор этой даты способствовал созданию единого стандарта времени для разных операционных систем, облегчая синхронизацию и обработку данных. "Unix Epoch" — момент времени — 1 января 1970 года, 00:00:00 UTC — называется «эпохой Unix» и является точкой, от которой ведется отсчет всех последующих секунд в Unix-времени.

    </details>

- В конструктор `Date` передаются день, месяц и год:

    ```js
    const date1 = new Date("27 March 2008");
    console.log(date1); // Thu Mar 27 2008 00:00:00 GMT+0300 (Москва, стандартное время)
    // или так
    const date2 = new Date("3/27/2008");
    console.log(date2); // Thu Mar 27 2008 00:00:00 GMT+0300 (Москва, стандартное время)
    // или так
    const date3 = new Date("3 27 2008");
    console.log(date3); // Thu Mar 27 2008 00:00:00 GMT+0300 (Москва, стандартное время)
    ```

    Если мы используем полное название месяца, то оно пишется в по-английски, если используем сокращенный вариант, тогда используется формат "месяц/день/год" или "месяц день год".

- Четвертый способ состоит в передаче в конструктор `Date` всех параметров даты и времени:

    ```js
    const myDate = new Date(2012,11,25,18,30,20,10);
    console.log(myDate); // Tue Dec 25 2012 18:30:20 GMT+0400 (Москва, стандартное время)
    ```

    В данном случае используются по порядку следующие параметры: `new Date(год, месяц, число, час, минуты, секунды, миллисекунды)`. При этом надо учитывать, что отсчет месяцев начинается с нуля, то есть январь — `0`, а декабрь — `11`.

#### Получение даты и времени
Для получения различных компонентов даты применяется ряд методов:

- `getDate()`: возвращает день месяца

- `getDay()`: возвращает день недели (отсчет начинается с `0` — воскресенье, и последний день — `6` — суббота)

- `getMonth()`: возвращает номер месяца (отсчет начинается с нуля, то есть месяц с номер `0` — январь)

- `getFullYear()`: возвращает год

- `toDateString()`: возвращает полную дату в виде строки

- `getHours()`: возвращает час (от 0 до 23)

- `getMinutes()`: возвращает минуты (от 0 до 59)

- `getSeconds()`: возвращает секунды (от 0 до 59)

- `getMilliseconds()`: возвращает миллисекунды (от 0 до 999)

- `toTimeString()`: возвращает полное время в виде строки

Получим текущую дату:
```js
const today = new Date();
console.log(today.getDate());       // 26
console.log(today.getDay());        // 4
console.log(today.getMonth());      // 9
console.log(today.getFullYear());   // 2023
```

Преобразуем данные в более читабельную форму:
```js
const days = ["Воскресенье", "Понедельник", "Вторник", "Среда", "Четверг", "Пятница", "Суббота"];
const months = ["Январь", "Февраль", "Март", "Апрель", "Май", "Июнь",
            "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь"];

const today = new Date();
console.log(`Сегодня: ${today.getDate()} ${months[today.getMonth()]} ${today.getFullYear()}, ${days[today.getDay()]}`);
// Сегодня: 26 Октябрь 2023, Четверг
```

Для перевода из числовых значений в более привычные названия для дней недели и месяцев используются массивы. Получив индекс дня недели (`today.getDay()`) и индекс месяца (`today.getMonth()`) можно получить нужный элемент из массива.

Теперь получим текущее время:
```js
var welcome;
const myDate = new Date();
const hour = myDate.getHours();
const minute = myDate.getMinutes();
const second = myDate.getSeconds();

console.log(`Текущее время: ${hour}:${minute}:${second}`); // Текущее время: 13:38:26
```

#### Установка даты и времени
Кроме задания параметров даты в конструкторе для установки мы также можем использовать дополнительные методы объекта `Date`:

- **`setDate()`**: установка дня в дате

- **`setMonth()`**: уставовка месяца (отсчет начинается с нуля, то есть месяц с номер `0` — январь)

- **`setFullYear()`**: устанавливает год

- **`setHours()`**: установка часа

- **`setMinutes()`**: установка минут

- **`setSeconds()`**: установка секунд

- **`setMilliseconds()`**: установка миллисекунд

Установим дату:
```js
const myDate = new Date();
myDate.setDate(14);
myDate.setMonth(10);    // ноябрь
myDate.setFullYear(2023);
console.log(myDate); // Tue Nov 14 2023 13:41:20 GMT+0300 (Москва, стандартное время)
```

При установке значений мы можем передать величину, большую, чем максимальное допустимое значение. Например, установить для часа число 54:
```js
myDate.setHours(54);
```

В этом случае значение часа будет равно 54 - 24 * 2 = 6, а оставшиеся часы будут составлять два дня (24 * 2), что прибавит к дате два дня. То же самое действует и в отношении дней, минут, секунд, миллисекунд и месяцев.[^5.1]

### Объект Math. Математические операции
Объект **`Math`** предоставляет ряд математических функций, которые можно использовать при вычислениях. Рассмотрим основные математические функции.[^5.2]

#### abs()
Функция `abs()` возвращает абсолютное значение числа:
```js
const x = -25;
console.log(Math.abs(x)); // 25
const y = 34;
console.log(Math.abs(y)); // 34
```

#### min() и max()
Функции `min()` и `max()` возвращают соответственно минимальное и максимальное значение из набора чисел:
```js
const max = Math.max(19, 45); // 45
const min = Math.min(33, 24); // 24
```

Эти функции необязательно должны принимать два числа, в них можно передавать и большее количество чисел:
```js
const max = Math.max(1, 2, 3, -9, 46, -23); // 46
```

#### ceil()
Функция `ceil()` округляет число до следующего наибольшего целого числа:
```js
const x = Math.ceil(9.2); // 10
const y = Math.ceil(-5.9); // -5
```

Выражение `Math.ceil(9.2)` возвращает число 10, так как число 10 следующее наибольшее целое число после 9.2. И также выражение `Math.ceil(-5.9)` возвращает -5, потому что число -5 следующее наибольшее целое после -5.9

#### floor()
Функция `floor()` округляет число до следующего наименьшего целого числа:
```js
const x = Math.floor(9.2); // 9
const y = Math.floor(-5.9); // -6
```

#### round()
Функция `round()` округляет число до следующего наименьшего целого числа, если его десятичная часть меньше 0.5. Если же десятичная часть равна или больше 0.5, то округление идет до ближайшего наибольшего целого числа:
```js
const x = Math.round(5.5); // 6
const y = Math.round(5.4); // 5
const z = Math.round(-5.4); // -5
const n = Math.round(-5.5); // -5
const m = Math.round(-5.6); // -6
console.log(x);
console.log(y);
console.log(z);
console.log(n);
```

#### random()
Функция `random()` возвращает случайное число с плавающей точкой их диапазона от 0 до 1:
```js
const x = Math.random();
```

#### pow()
Функция `pow()` возвращает число в определенной степени. Например, возведем число 2 в степень 3:
```js
const x = Math.pow(2, 3); // 8
```

#### sqrt()
Функция `sqrt()` возвращает квадратный корень числа:
```js
const x = Math.sqrt(121); // 11
const y = Math.sqrt(9); // 3
const z = Math.sqrt(20); // 4.47213595499958
```

#### log()
Функция `log()` возвращает натуральный логарифм числа:
```js
const x = Math.log(1); // 0
const z = Math.log(10); // 2.302585092994046
```

Для вычисления логарифма по произвольному основанию в JavaScript используется формула смены основания:

$$ \log_b{(x)} = \frac{\log_a{(x)}}{\log_a{(b)}} $$

В JavaScript это реализуется как `Math.log(x) / Math.log(base)`, где `Math.log()` вычисляет натуральный логарифм (по основанию $e$).

Например, чтобы вычислить логарифм 100 по основанию 10:
```js
const x = 100;
const base = 10;
const result = Math.log(x) / Math.log(base);
console.log(result); // Выведет: 2
```

Другие полезные методы
- `Math.log()`: Возвращает натуральный логарифм (по основанию $e$).
- `Math.log10()`: Возвращает логарифм по основанию 10 (доступен в некоторых реализациях, таких как Java, но не является частью стандартного объекта `Math` в JavaScript).
- `Math.log2()`: Возвращает логарифм по основанию 2 (также доступен в некоторых реализациях, но не является частью стандартного объекта `Math` в JavaScript). 

#### Тригонометрические функции
Целый ряд функций представляют тригонометрические функции: `sin()` (вычисляет синус угла), `cos()` (вычисляет косинус угла), `tan()` (вычисляет тангенс угла).

```js
const x = Math.sin(90); // 0.8939966636005579
const y = Math.cos(0); // 1
const z = Math.tan(45); // 1.6197751905438615
```

Функция `asin()` вычисляет арксинус числа, `acos` — арккосинус, а `atan()` — арктангенс числа:
```js
const x = Math.asin(0.9); // 1.1197695149986342
const y = Math.acos(1); // 1
const z = Math.atan(1); // 0.7853981633974483
```

#### Константы
Кроме методов объект `Math` также определяет набор встроенных констант, которые можно использовать в различных вычислениях:

- `Math.PI` (число PI): `3.141592653589793`

- `Math.SQRT2` (квадратный корень из двух): `1.4142135623730951`

- `Math.SQRT1_2` (половина от квадратного корня из двух): `0.7071067811865476`

- `Math.E` (число e или число Эйлера): `2.718281828459045`

- `Math.LN2` (натуральный логарифм числа 2): `0.6931471805599453`

- `Math.LN10` (натуральный логарифм числа 10): `2.302585092994046`

- `Math.LOG2E` (двоичный логарифм числа e): `1.4426950408889634`

- `Math.LOG10E` (десятичный логарифм числа e): `0.4342944819032518`

Используем константы в вычислениях:
```js
const x = Math.log(Math.E); // 1
const z = Math.tan(Math.PI/4); // 0.9999999999999999
```

### Объект Number
Объект `Number` представляет числа. Чтобы создать число, надо передать в конструктор `Number` число или строку, представляющую число:
```js
const x = new Number(34);
const y = new Number('34');
console.log(x+y); // 68
```

Определения `x` и `y` в данном случае будут практически аналогичны.[^5.4]

Однако создавать объект `Number` можно и просто присвоив переменной определенное число:
```js
const z = 34;
```

Объект `Number` предоставляет ряд свойств и методов. Некоторые его свойства:

- `Number.MAX_VALUE`: наибольшее возможное целое число. Приблизительно равно 1.79E+308. Числа, которые больше этого значения, рассматриваются как `Infinity`;

- `Number.MIN_VALUE`: наименьшее возможное положительное целое число. Приблизительно равно 5e-324 (где-то около нуля);

- `Number.NaN`: специальное значение, которое указывает, что объект не является числом;

- `Number.NEGATIVE_INFINITY`: значение, которое обозначает отрицательную бесконечность и которое возникает при переполнении. Например, если мы складываем два отрицательных числа, которые по модулю равны `Number.MAX_VALUE`. Например:

    ```js
    const x = -1 * Number.MAX_VALUE
    const y = -1 * Number.MAX_VALUE
    const z = x + y;
    if(z===Number.NEGATIVE_INFINITY)
        console.log("отрицательная бесконечность");
    else
        console.log(z);
    ```

- `Number.POSITIVE_INFINITY`: положительная бесконечность. Также, как и отрицательная бесконечность, возникает при переполнении, только теперь в положительную сторону:

```js
const x = Number.MAX_VALUE
const y = Number.MAX_VALUE
const z = x * y;
if(z===Number.POSITIVE_INFINITY)
    console.log("положительная бесконечность");
else
    console.log(z);
```

Некоторые основные методы:

- `isNaN()`: определяет, является ли объект числом. Если объект не является числом, то возвращается значение `true`:

```js
const a = Number.isNaN(Number.NaN); // true
const b = Number.isNaN(true); // false - new Number(true) = 1
const c = Number.isNaN(null);  // false - new Number(null) = 0
const d = Number.isNaN(25);  // false
const e = Number.isNaN("54"); // false
```

Но следующее выражение вернет `false`, хотя значение не является числом:
```js
const f = Number.isNaN("hello"); // false
```

Чтобы избежать подобных ситуаций, лучше применять глобальную функцию **`isNaN`**:
```js
const f = isNaN("hello"); // true
```

- `parseFloat()`: преобразует строку в число с плавающей точкой. Например:

```js
const a = Number.parseFloat("34.90"); // 34.9
console.log(a);
const b = Number.parseFloat("hello"); // NaN
console.log(b);
const c = Number.parseFloat("34hello"); // 34
console.log(c);
```

- `parseInt()`: преобразует строку в целое число. Например:

```js
const a = Number.parseInt("34.90"); // 34
console.log(a);
const b = Number.parseInt("hello"); // NaN
console.log(b);
const c = Number.parseInt("25hello"); // 25
console.log(c);
```

- `toFixed()`: оставляет в числе с плавающей точкой определенное количество знаков в дробной части. Например:

```js
const a =  10 / 1.44;
console.log("До метода toFixed(): ", a, "<br/>");
a = a.toFixed(2); // оставляем два знака после запятой
console.log("После метода toFixed(): ", a, "<br/>");
```

Вывод браузера:
```
До метода toFixed(): 6.944444444444445
После метода toFixed(): 6.94
```

#### Преобразование в другую систему счисления
Выше мы рассматривали перевод строк в числа в десятичной системе. Но мы можем с помощью второго параметра явно указать, что хотим преобразовать строку в число в определенной системе. Например, преобразование в число в двоичной системе:
```js
const num1 = "110";
const num2 = parseInt(num1, 2);
console.log(num2); // 6
```

Здесь в функцию `parseInt` в качестве второго параметра передается число 2, что указаывает, что первый параметр будет рассматриваться как число в двоичной системе. Результатом будет 6, так как 110 в двоичной системе — это число 6 в десятичной.

#### Из числа в строку, метод toString
Для преобразования числа в строку у него можно вызвать специальный метод `toString()`:
```js
const num = 10;
console.log(num.toString()); // 10
```

Однако в данном случае нет смысла вызывать у числа num метод `toString()`, так как число можно вывести на консоль без всяких преобразований. Тем не менее метод `toString()` может быть полезен — в качестве параметра он принимает основание системы счисления числа и может быть использован для вывода числа в определенной системе счисления:
```js
const num1 = 0b0110;
// выводим число в двоичной системе
console.log(num1.toString(2)); // 110

const num2 = 0xFF;
// выводим число в шестнадцатеричной системе
console.log(num2.toString(16)); // ff
```

### Символы
Символ или тип **`Symbol`** представляет некоторое уникальное значение.

Для определения символа применяется конструктор типа **`Symbol`**. Например, создадим простейший символ:
```js
const tom = Symbol("Tom");
console.log(tom);   // Symbol(Tom)
```

Причем каждый символ **уникален**. Так, попробуем создать два одинаковых символа:
```js
const tom = Symbol("Tom");
console.log(tom);   // Symbol(Tom)

const tomas = Symbol("Tom");
console.log(tomas); // Symbol(Tom)

console.log(tom == tomas);      // false
console.log(tom === tomas);     // false
```

Несмотря на то, что оба создаваемых выше в примее символа инициализированы одним и тем же значением, но оба оператора — равенства и эквивалентности при сравнению этих символа возвращают `false`. То есть символы всегда уникальны.[^5.5]

#### Символы как идентификаторы свойств объектов
Основной областью применения символов являются определение идентификаторов свойств объектов. То есть, если вкратце, символы позволяют избежать ситуаций, когда несколько свойств объекта имеют одинаковые названия. Возможно, данная ситуация может показаться искусственной: ну как мы можем определить в объекте два одинакоых свойства? Однако если свойства добавляются динамически в довольно большой программе или даже где-то во внешнем коде, который мы не можем контролировать, то задача по контролю за идентификаторами свойств усложняется.

Для примера возьмем следующую задачу: в комании работают три программиста, один из которых старший разработчик, а остальные два — младшие разработчики. Но при этом два из разработчиков имеют одинаковые имена. Скажем, один Том является старшим разработчиком, а Сэм и другой Том — младшие разработчики. Например, мы могли бы представить подобную компанию так:
```js
const company = {
    "Tom": "senior",
    "Sam": "junior",
    "Tom": "junior"
}
for(developer in company) {
    console.log(`${developer} - ${company[developer]}`);
}
```

Однако консольный вывод покажет, что в нашей компании только два разработчика, поскольку названия двух из них совпадают:
```
Tom - junior
Sam - junior
```

Теперь применим символы:
```js
const company = {
    [Symbol("Tom")]: "senior",
    [Symbol("Sam")]: "junior",
    [Symbol("Tom")]: "junior"
}
const developers = Object.getOwnPropertySymbols(company);
for(developer of developers) {
    console.log(`${developer.toString()} - ${company[developer]}`);
}
```

Для получения всех символов из объекта применяется функция **`Object.getOwnPropertySymbols()`**, в которую передается объект. Возвращает эта функция набор символов, которые мы можем перебрать в цикле. Для получения текстового представления символов можно применять метод `toString()` символа. А для получения значения, как и в общем случае, применяется синтаксис массивов: `company[developer]`. В итоге мы получим следующий консольный вывод:
```
Symbol(Tom) - senior
Symbol(Sam) - junior
Symbol(Tom) - junior
```

Также можно динамически добавлять свойства с символьными идентификаторами в объект:
```js
const company = { };
company[Symbol("Tom")]= "senior";
company[Symbol("Sam")]= "junior";
company[Symbol("Tom")]= "junior";
```

### Proxy
**Прокси** (**`Proxy`**) представляет объект, который позволяет перехватывать выполнение операций по отношению к некоторому другому объекту и может переопределять его поведение.[^5.9]

Для создания объекта `Proxy` применяется конструктор **`Proxy()`**:
```js
const proxy = new Proxy(target, handler);
```

Конструктор `Proxy` принимает два параметра:

- `target` — цель создания прокси, это может быть любой объект, к которому применяется `Proxy`;

- `handler` — другой объект, который определяет, какие именно операции объекта `target` будут перехватываться и переопределяться и как именно.

Рассмотрим простейший пример:
```js
// объект, к которому применяется прокси
const target = {name: "Tom"};
// объект, который определяет, как будет переопределяться target
const handler = {};
// объект прокси
const proxy = new Proxy(target, handler);

console.log(proxy.name);    // Tom
```

Итак, в примере выше `target` — это объект, к которому будет применяться проксирование. В данном случае этот объект имеет свойство `name`.

```js
const target = {name: "Tom"};
```

Далее создается пустой обработчик `handler`:
```js
const handler = {};
```

В принципе этот объект должен определять, как будет переопределяться объект `target`. Но пока оставим его пустым.

Затем создаем объект `Proxy`, передавая в его конструктор объекты `target` и `handler`.

```js
const proxy = new Proxy(target, handler);
```

Проксирование объекта (в данном случае объекта `target`) означает, что через прокси мы можем обращаться к функциональности этого объекта. И в данном случае через объект `proxy` мы можем обратиться к свойству `name` проксированного объекта `target`:
```js
console.log(proxy.name);    // Tom
```

И поскольку мы использовали пустой `handler`, который ничего не переопределяет, то по сути прокси ведет себя как оригинальный объект `target`.

#### Переопределение функциональности объекта
Выше мы выполнили проксирование объекта, но пока никак не переопределяли его поведение. Ключевым в данном случае является определение обработчика **`handler`**, который может перехватывать обращения к свойствам проксированного объекта. Этот обработчик может определять два метода: **`get`** и **`set`**.

##### Метод get и получение свойств объекта
Метод **`get`** перехватывает обращения к свойству при получении его значения и возвращает для этого свойства некоторое значение:
```js
const handler = {
  get: function(target, prop, receiver) {
    return некоторое_значение;
  }
};
```

Метод **`get`** имеет три параметра:

- `target`: сам проксированный объект. Благодаря этому параметру мы можем обратиться к функциональности оригинального объекта;

- `prop`: название свойства, к которому идет обращение;

- `receiver`: объект `Proxy`, через который выполняется проксирование;

Возьмем следующий пример:
```js
const target = {name: "Tom"};
const handler = {
  get: function(target, prop, receiver) {
    return "Tomas Smith";
  }
};
const proxy = new Proxy(target, handler);
console.log(proxy.name);    // Tomas Smith
```

Здесь в обработчике `handler` в методе `get` возвращается строка "Tomas Smith":
```js
get: function(target, prop, receiver) {
    return "Tomas Smith";
}
```

Это приведет к тому, что при обращение к любому свойству прокси-объекта будет возвращаться данная строка:
```js
console.log(proxy.name);    // Tomas Smith
```

Так, мы выполнили перехват обращения к свойству и простейшее переопределение. При этом мы можем обащаться и к оригинальному объекту, который проксируется:
```js
const target = {name: "Tom"};
const handler = {
  get: function(target, prop) {
    return "Name: " + target.name;
  }
};
const proxy = new Proxy(target, handler);
console.log(proxy.name);    // Name: Tom
```

Здесь обработчик возвращает строку `"Name: " + target.name`, где `target.name` представляет обращение к свойству `name` оригинального объекта. Естественно логика возвращение значения свойства может более сложной.

Но возьмем более сложный объект — с двумя свойствами:
```js
const target = {name: "Tom", age: 37};
const handler = {
  get: function(target, prop) {
    return target[prop];
  }
};
const proxy = new Proxy(target, handler);
console.log(proxy.name);    // Tom
console.log(proxy.age);     // 37
```

Здесь целевой объект имеет два свойства: `name` и `age`. В обработчике мы перехватываем обращение к ним, но никак его не переопределяем, а просто возвращаем значения свойств оригинального объекта:
```js
return target[prop];
```

Для обращения к свойствам целевого объекта применяется синтаксис массивов.

Но также мы можем проверить, к какому именно свойству идет обращение, и выполнить некоторое переопределение:
```js
const target = {name: "Tom", age: 37};
const handler = {
  get: function(target, prop) {
    if(prop==="name")
        return target.name.toUpperCase();
    else
        return target[prop];
  }
};
const proxy = new Proxy(target, handler);
console.log(proxy.name);    // TOM
console.log(proxy.age);     // 37
```

В данном случае, если обращение идет к свойству `name`, то есть к свойству, которое хранит строку, то вызываем у этой строки метод `toUpperCase()` и переводим ее в верхний регистр.

##### Установка свойства и метод set
Метод **`set`** перехватывает обращения к свойству при установке его значения:
```js
const handler = {
  set: function(target, property, value, receiver) {

  }
};
```

Метод **`set`** имеет четыре параметра:

- `target`: оригинальный объект, к которому идет проксирование

- `property`: название свойства, к которому идет обращение

- `value`: устанавливаемое значение

- `receiver`: объект `Proxy`, через который выполняется проксирование

Рассмотрим на примере:
```js
const target = {name: "Tom", age: 37};
const handler = {
  set: function(target, prop, value) {
        console.log(value);
        target[prop] = value;
  }
};
const proxy = new Proxy(target, handler);
proxy.name = "Tomas";
console.log(proxy.name);    // Tomas
proxy.age = 22;
console.log(proxy.age);     // 22
```

В данном примере в методе `set` сначала логируем передаваеемое свойству значение, затем устанавливаем свойство:
```js
target[prop] = value;
```

Немного изменим пример:
```js
const target = {name: "Tom", age: 37};
const handler = {
  set: function(target, prop, value) {
    if(prop==="age" && value < 1)
        console.log("Некорректный возраст");
    else
        return target[prop] = value;
  }
};
const proxy = new Proxy(target, handler);
proxy.name = "Tomas";
console.log(proxy.name);    // Tomas
proxy.age = -199;           // Некорректный возраст
console.log(proxy.age);     // 37
proxy.age = 22;
console.log(proxy.age);     // 22
```

Здесь в методе `set` обработчика проверяем, если идет установка свойства `age` и значение меньше 1, то просто выводим сообщение о некорректности данных
```js
if(prop==="age" && value < 1)
    console.log("Некорректный возраст");
```

Иначе передаем значение свойству оригинального объекта:
```js
else
    return target[prop] = value;
```

### Коллекции

#### Множества Set
Множества (sets) представляют структуру данных, которая может хранить только уникальные значения. В JavaScript функционал множества опредляет объект **`Set`**. Для создания множества применяется конструктор этого объекта:
```js
const mySet = new Set();
```

Также можно передать в конструктор массив значений, которыми будет инициализировано множество:
```js
const arr = [1, 1, 2, 3, 4, 5, 2, 4];
const numbers = new Set(arr);
console.log(numbers);           // Set(5) {1, 2, 3, 4, 5}
```

В данном случае в множество передаются данные из массива. Однако поскольку множество может хранить только уникальные значения, то при его создании повторяющиеся значения, которые есть в массиве, удаляются.

Для упрощения создания набора мы можем сразу передать массив в конструктор `Set`:
```js
const numbers = new Set([1, 2, 3, 4, 5]);
console.log(numbers);       // Set(5) {1, 2, 3, 4, 5}
```

##### Размер набора
Для проверки количества элементов можно использовать свойство **`size`**.

```js
const numbers = new Set([1, 1, 2, 3, 4, 5, 2, 4]);
console.log(numbers.size);      // 5
```

##### Добавление
Для добавления применяется метод **`add()`**. Его результатом является измененное множество:
```js
const numbers = new Set();
numbers.add(1);
numbers.add(3);
numbers.add(5);
numbers.add(3);     // не добавляется
numbers.add(1);     // не добавляется
console.log(numbers);       // Set(3) {1, 3, 5}
```

При этом, поскольку множество хранит только уникальные значения, то добавление элементов, которые уже в нем есть, не имеет смысла.

Так как метод `add` возвращает ссылку на это же множество, то мы можем вызывать методы по цепочке:
```js
const numbers = new Set();
numbers.add(1).add(3).add(5);
console.log(numbers);       // Set(3) {1, 3, 5}
```

##### Удаление
Для удаления элементов применяется метод **`delete()`**:
```js
const numbers = new Set([1, 3, 5]);
numbers.delete(3);
console.log(numbers);       // Set(2) {1, 5}
```

Причем данный метод возвращает булевое значение: `true` — если элемент удален и `false` — если удаление не произошло (например, когда удаляемого элемента нет в множестве):
```js
const numbers = new Set([1, 3, 5]);

let isDeleted = numbers.delete(3);
console.log(isDeleted);         // true
isDeleted = numbers.delete(54);
console.log(isDeleted);         // false
```

Если необходимо удалить вообще все элементы из множества, то применяется метод **`clear()`**:
```js
let numbers = new Set();
const numbers = new Set([1, 3, 5]);
numbers.clear();
console.log(numbers);           // Set(0) {}
```

##### Проверка наличия элемента
Если нужно проверить, если ли элемент в множестве, то используется метод **`has()`**. Если элемент есть, то метод возвращает `true`, иначе возвращает `false`:
```js
const numbers = new Set([1, 3, 5]);
console.log(numbers.has(3));    // true
console.log(numbers.has(32));   // false
```

##### Перебор множества
Для перебора элементов множества применяется метод **`forEach()`**:
```js
const numbers = new Set([1, 2, 3, 5]);

numbers.forEach(function(value1, value2, set){
    console.log(value1);
})
```

Для совместимости с массивами, которые тоже имеют метод `forEach`, в данный метод передается функция обратного вызова, которая принимает три параметра. Непосредственно для множества первый и второй параметры представляют текущий перебираемый элемент, а третий параметр — перебираемое множество. В данном случае применяется только первый параметр.

Также для перебора множества можно использовать цикл `for...of`:
```js
const numbers = new Set([1, 2, 3, 5]);

for(n of numbers){
    console.log(n);
}
```

##### Получение итератора
Также у объекта **`Set`** есть ряд методов, которые возвращают итератор, а точнее объект **`SetIterator`**. Это методы `values()`, `keys()`, `entries()`:
```js
const numbers = new Set([1, 2, 3, 5]);

console.log(numbers.values());  // SetIterator {1, 2, 3, 5}
console.log(numbers.keys());    // SetIterator {1, 2, 3, 5}
console.log(numbers.entries()); // SetIterator {1 => 1, 2 => 2, 3 => 3, 5 => 5}
```

Соответственно возвращаемый итератор мы можем использовать для получения объектов множества:
```js
const people = new Set(["Tom", "Bob", "Sam"]);

const iterator = people.values();

console.log(iterator.next());   // {value: "Tom", done: false}
console.log(iterator.next());   // {value: "Bob", done: false}
console.log(iterator.next());   // {value: "Sam", done: false}
console.log(iterator.next());   // {value: undefined, done: true}
```

##### Удаление из массива повторяющихся элементов
Ограничения объекта `Set` — хранения уникальных значений позволяет эффективно его применять в ряде операций. Например, удаление из массива повторяющихся элементов:
```js
const peopleArray = ["Tom", "Bob", "Sam", "Alice", "Sam", "Kate", "Tom"];
const peopleSet = new Set(peopleArray);
const newPeopleArray = Array.from(peopleSet);

console.log(newPeopleArray);    // ["Tom", "Bob", "Sam", "Alice", "Kate"]
```

Здесь для создания нового массива с неповторяющимися элементами применяется функция **`Array.from()`**, которая в качестве аргумента получает объект `Set`.[^14.3]

#### Ассоциативные массивы Map
Объект **`Map`** или словарь представляет структуру данных, где каждый элемент имеет ключ и значение. Ключи в рамках словаря являются уникальными, то есть с одним ключом может быть сопоставлен только один элемент. Для создания словаря применяется конструктор объекта **`Map`**:
```js
const myMap = new Map();
```

Также можно инициализировать словарь начальными значениями. Для этого в конструктор передается массив, элементы которого представляют массивы из двух элементов — первый элемент будет выступать в качестве ключа, а второй — в качестве значения:
```js
const myMap = new Map([[1, "a"], [2, "b"], [3, "c"]]);
console.log(myMap);     // Map(3){1 => "a", 2 => "b", 3 => "c"}
```

В данном случае числа 1, 2, 3 являются ключами, а строки "a", "b", "c" — значениями.

При этом ключи и значения необзательно должны быть одного типа. Тип ключей и значений может совпадать:
```js
const dict = new Map([["red", "красный"], ["green", "зеленый"], ["blue", "синий"]]);
console.log(dict);  // Map(3) {"red" =>"красный", "green"=> "зеленый", "blue"=>"синий"}
```

##### Размер словаря
С помощью свойства **`size`** можно проверить количество элементов в `Map`:
```js
const dict = new Map([["red", "красный"], ["green", "зеленый"], ["blue", "синий"]]);
console.log(dict.size);     // 3
```

##### Добавление и изменение элементов
Для установки значения применяется метод **`set()`**:
```js
const dict = new Map([["red", "красный"], ["green", "зеленый"], ["blue", "синий"]]);
dict.set("yello", "желтый");        // добавление элемента
dict.set("red", "червонный");       // изменение элемента
console.log(dict);      // Map(4) {"red" => "червонный", "green" => "зеленый", "blue" => "синий", "yello" => "желтый"}
```

Первый параметр метода `set()` представляет ключ, а второй параметр — значение элемента. Если по такому ключу нет элементов, то добавляется новый элемент. Если ключ уже есть, то уже имеющийся элемент изменяет свое значение.

##### Получение элементов
Для получения элемента по ключу применяется метод **`get()`**, в который передается ключ элемента:
```js
const dict = new Map([["red", "красный"], ["green", "зеленый"], ["blue", "синий"]]);
console.log(dict.get("red"));  // красный
console.log(dict.get("violet"));  // undefined
```

Если `map` не содержит элемента по заданному ключу, то метод возвращает `undefined`.

Чтобы избежать возвращения `undefined` мы можем проверить наличие элемента по ключу с помощью метода **`has()`**. Если элемент по ключу имеется, то метод возвращает `true`, иначе возвращается `false`:
```js
const dict = new Map([["red", "красный"], ["green", "зеленый"], ["blue", "синий"]]);
console.log(dict.has("red"));  // true
console.log(dict.has("violet"));  //  false

if(dict.has("red")) console.log(dict.get("red"));   // красный
```

##### Удаление элементов
Для удаления одного элемента по ключу применяется метод **`delete()`**:
```js
const dict = new Map([["red", "красный"], ["green", "зеленый"], ["blue", "синий"]]);
dict.delete("red");
console.log(dict);  // Map(2){"green" => "зеленый", "blue" => "синий"}
```

Для удаления всех элементов используется метод **`clear()`**:
```js
const dict = new Map([["red", "красный"], ["green", "зеленый"], ["blue", "синий"]]);
dict.clear();
console.log(dict);  // Map(0){}
```

##### Перебор элементов
Для перебора элементов используется метод **`forEach`**:
```js
const dict = new Map([["red", "красный"], ["green", "зеленый"], ["blue", "синий"]]);
dict.forEach(function(value, key, map){
    console.log(key, ":", value);
})
```

Метод `forEach` в качестве параметра получает функцию обратного вызова, которая имеет три параметра. Первый и второй параметры - это соответственно значение и ключ текущего перебираемого элемента, а третий параметр — перебираемый объект `Map`.

Консольный вывод данного примера:
```
red : красный
green : зеленый
blue : синий
```

Также для перебора объекта `Map` можно использовать циклы, например, цикл `for...of`:
```js
const dict = new Map([["red", "красный"], ["green", "зеленый"], ["blue", "синий"]]);

for(item of dict){
    console.log(item[0], ":", item[1]);
}
```

Каждый элемент из `Map` помещается в переменную `item`, которая в свою очередь представляет массив. Первый элемент этого массива — ключ, а второй элемент — значение элемента.[^14.4]

Также объект Map имеет два дополнительных метода: **`keys()`** позволяет перебрать только ключи и **`values()`** позволяет перебирать значения элементов. Оба метода возвращают итераторы, поэтому для перебора ключей и значений по отдельности также можно использовать цикл `for...of`:
```js
const dict = new Map([["red", "красный"], ["green", "зеленый"], ["blue", "синий"]]);

for(item of dict.keys()){
    console.log(item);
}
// Консольный вывод:
// red
// green
// blue
for(item of dict.values()){
    console.log(item);
}
// Консольный вывод:
// красный
// зеленый
// синий
```

#### Слабоссылаемые множества
Объект **`WeakSet`** во многом похож на обычное множество. Он также может хранить только уникальные значения, но каждый его элемент должен представлять объект.[^14.5]

Для создания объекта `WeakSet` используется его конструктор, в который можно передать начальные значения:
```js
// пустой WeakSet
const weakSet1 = new WeakSet();
// инициализация начальными значениями
const weakSet2 = new WeakSet([{name:"Tom", age: 37}, {name:"Alice", age: 34}]);
```

Для инициализации как в случае с объектом `Set` в конструктор передается массив, но данный массив содержит именно объекты, а не скалярные значения, типа чисел или строк.

Для добавления данных в `WeakSet` применяется метод **`add()`**:
```js
const weakSet = new WeakSet();
weakSet.add({lang: "JavaScript"});
weakSet.add({lang: "TypeScript"});
// weakSet.add(34); // так нельзя - 34 - число, а не объект
console.log(weakSet);   // {{lang: "JavaScript"}, {lang: "TypeScript"}}
```

Причем опять же добавить мы можем только объект, а не скалярные значения типа чисел или строк.

Для удаления применяется метод **`delete()`**, в который передается ссылка на удаляемый объект:
```js
const weakSet = new WeakSet();
const js = {lang: "JavaScript"};
const ts = {lang: "TypeScript"};
weakSet.add(js);
weakSet.add(ts);

weakSet.delete(js);

console.log(weakSet);   // {{lang: "TypeScript"}}
```

Если надо проверить, имеется ли объект в `WeakSet`, то можно использовать метод **`has()`**, который возвращает `true` при наличии объекта:
```js
const js = {lang: "JavaScript"};
const ts = {lang: "TypeScript"};
const java = {lang: "Java"};
const weakSet = new WeakSet([js, ts]);
console.log(weakSet.has(ts));       // true
console.log(weakSet.has(java));     //  false
```

##### Перебор WeakSet
Стоит отметить, что `WeakSet` не поддерживает перебор ни с помощью метода `forEach`, которого у `WeakSet` нет, ни с помощью цикла `for`. Например. если мы попробуем перебрать `WeakSet` через цикл `for..of`:
```js
const weakSet = new WeakSet([
    {lang: "JavaScript"},
    {lang: "TypeScript"},
    {lang: "Java"}
]);


for(item of weakSet){
    console.log(item);
}
```

То мы получим ошибку
```
Uncaught TypeError: weakSet is not iterable
```

##### Слабые ссылки
Объекты передаются в `WeakSet` по ссылке. И отличительной особенностью `WeakSet` является то, что когда объект перестает существовать в силу различных причин, он удаляется из `WeakSet`. Так, рассмотрим следующий пример:
```js
let js = {lang: "JavaScript"};
let ts = {lang: "TypeScript"};
const weakSet = new WeakSet([js, ts]);

js = null;

console.log(weakSet);   // {{lang: "JavaScript"}, {lang: "TypeScript"}}
console.log("Некоторая работа");
const timerId = setTimeout(function(){
    console.log(weakSet);   // {{lang: "TypeScript"}}
    clearTimeout(timerId);
}, 20000);
```

В данном случае сначала объект `WeakSet` хранит ссылки на два объекта: `js` и `ts`. Далее мы устанавливаем значение для переменной `js` в `null`.

Это приведет к тому, что спустя некоторое время начальное значение этой переменной будет удалено сборщиком мусора JavaScript.

```js
js = null;
```

Причем если сразу после этого мы посмотрим на содержимое `weakSet`, то увидим, что объект `js` в нем еще присутствует. Однако спустя некоторое время ссылка будет удалена из `weakSet`. Для эмуляции прошествия времени здесь используется функция `setTimeout`, которая выводит на консоль содержимое `weakSet` через 9000 секунд (конкретный период времени, через который сборщик мусора удалит значение, может отличаться)

Теперь сравним с тем, что произойдет, если вместо `WeakSet` использовать **`Set`**:
```js
let js = {lang: "JavaScript"};
let ts = {lang: "TypeScript"};
const set = new Set([js, ts]);

js = null;

console.log(set);   // Set(2) {{lang: "JavaScript"}, {lang: "TypeScript"}}
console.log("Некоторая работа");
const timerId = setTimeout(function(){
    console.log(set);   // Set(2){{lang: "JavaScript"}, {lang: "TypeScript"}}
    clearTimeout(timerId);
}, 20000);
```

В случае с `Set` даже спустя некоторое время мы увидим, что в объекте `Set` до сих пор присутствует объект, для которого было установлено значение `null`.

#### Слабоссылочные словари
`WeakMap` представляет развитие коллекции `Map`. Особенностью `WeakMap` является то, что все ее элементы должны представлять объекты. При этом ключи должны представлять объекты.[^14.6]

Создание `WeakMap`:
```js
// пустой WeakMap
const weakMap1 = new WeakMap();

// WeakMap с инициализацией данными
let key1 = {key:1};
let key2 = {key:2};
let value1 = {name: "Tom"};
let value2 = {name: "Sam"};

const weakMap2 = new WeakMap([[key1, value1], [key2, value2]]);
// или так
// const weakMap2 = new WeakMap([[{key:1}, {name: "Tom"}], [{key:2}, {name: "Sam"}]]);
```

Стоит отметить, что объект `WeakMap` не поддерживает перебор.

Для добавления новых объектов или изменения старых применяется метод **`set()`**:
```js
let key1 = {key:1};
let key2 = {key:2};
let value1 = {name: "Tom"};
let value2 = {name: "Sam"};

const weakMap2 = new WeakMap([[key1, value1]]);
weakMap2.set(key2, value2);
weakMap2.set(key1, {name: "Kate"});
console.log(weakMap2.get(key1));    //{name: "Kate"}
console.log(weakMap2.get(key2));    //{name: "Sam"}
```

Для получения объектов по ключу из WeakMap применяется метод **`get()`**:
```js
let key1 = {key:1};
let key2 = {key:2};
let value1 = {name: "Tom"};
let value2 = {name: "Sam"};

const weakMap2 = new WeakMap([[key1, value1], [key2, value2]]);
console.log(weakMap2.get(key1));    // {name: "Tom"}
```

Чтобы проверить наличие элемента по определенному ключу, применяется метод **`has()`**, который возвращает `true` при наличии элемента:
```js
let key1 = {key:1},
    key2 = {key:2};
let value1 = {name: "Tom"},
    value2 = {name: "Sam"};

const weakMap2 = new WeakMap([[key1, value1]]);
console.log(weakMap2.has(key1));    // true
console.log(weakMap2.has(key2));    // false
```

Для удаления элемента по ключу применяется метод **`delete()`**:
```js
let key1 = {key:1},
    key2 = {key:2};
let value1 = {name: "Tom"},
    value2 = {name: "Sam"};

const weakMap2 = new WeakMap([[key1, value1], [key2, value2]]);
console.log(weakMap2.has(key1));    // true
weakMap2.delete(key1);
console.log(weakMap2.has(key1));    // false
```

##### Слабые ссылки
Объекты передаются в `WeakMap` по ссылке. И отличительной особенностью `WeakMap` является то, что когда объект перестает существовать в силу различных причин, он удаляется из `WeakMap`. Рассмотрим следующий пример:
```js
let jsCode = {code: "js"},
    tsCode = {code: "ts"};
let js = {lang: "JavaScript"},
    ts = {lang: "TypeScript"};
const weakMap = new WeakMap([[jsCode, js], [tsCode, ts]]);

jsCode = null;

console.log(weakMap);   // WeakMap {{code: "js"} => {lang: "JavaScript"}, {code: "ts"} => {lang: "TypeScript"}}
console.log("Некоторая работа");
const timerId = setTimeout(function(){
    console.log(weakMap);   // WeakMap {{code: "ts"} => {lang: "TypeScript"}}
    clearTimeout(timerId);
}, 30000);
```

В данном случае сначала объект `WeakMap` хранит ссылки на два элемента с ключами `jsCode` и `tsCode`. Далее для переменной `jsCode` устанавливается значение `null`.

```js
jsCode = null;
```

Это приведет к тому, что спустя некоторое время начальное значение этой переменной будет удалено сборщиком мусора JavaScript.

Причем если сразу после этого мы посмотрим на содержимое `weakMap`, то увидим, что объект с ключом `jsCode` в нем еще присутствует. Однако спустя некоторое время ссылка будет удалена из `weakSet`. Для эмуляции прошествия времени здесь используется функция `setTimeout`, которая выводит на консоль содержимое `weakSet` через 10000 секунд (конкретный период времени, через который сборщик мусора удалит значение, может отличаться).

Теперь сравним с тем, что произойдет, если вместо `WeakMap` использовать `Map`:
```js
let jsCode = {code: "js"},
    tsCode = {code: "ts"};
let js = {lang: "JavaScript"},
    ts = {lang: "TypeScript"};
const map = new Map([[jsCode, js], [tsCode, ts]]);

jsCode = null;

console.log(map);   // Map(2) {{code: "js"} => {lang: "JavaScript"}, {code: "ts"} => {lang: "TypeScript"}}
console.log("Некоторая работа");
const timerId = setTimeout(function(){
    console.log(map);   // Map(2) {{code: "js"} => {lang: "JavaScript"}, {code: "ts"} => {lang: "TypeScript"}}
    clearTimeout(timerId);
}, 30000);
```

В случае с `Map` даже спустя некоторое время мы увидим, что в объекте `Map` до сих пор присутствует объект, для которого было установлено значение `null`.

### Источники информации
[^5.1]: [Объект Date. Работа с датами](https://metanit.com/web/javascript/5.1.php)
[^5.2]: [Объект Math. Математические операции](https://metanit.com/web/javascript/5.2.php)
[^5.4]: [Объект Number](https://metanit.com/web/javascript/5.4.php)
[^5.5]: [Символы](https://metanit.com/web/javascript/5.5.php)
[^5.9]: [Proxy](https://metanit.com/web/javascript/5.9.php)
[^14.3]: [Множества Set](https://metanit.com/web/javascript/14.3.php)
[^14.4]: [Map](https://metanit.com/web/javascript/14.4.php)
[^14.5]: [WeakSet](https://metanit.com/web/javascript/14.5.php)
[^14.6]: [WeakMap](https://metanit.com/web/javascript/14.6.php)
