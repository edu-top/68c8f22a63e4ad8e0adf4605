## Встроенные объекты и коллекции

- [Встроенные объекты и коллекции](#встроенные-объекты-и-коллекции)
  - [Объект Date. Работа с датами](#объект-date-работа-с-датами)
    - [Определение дат](#определение-дат)
    - [Получение даты и времени](#получение-даты-и-времени)
    - [Установка даты и времени](#установка-даты-и-времени)
  - [Объект Math. Математические операции](#объект-math-математические-операции)
    - [abs()](#abs)
    - [min() и max()](#min-и-max)
    - [ceil()](#ceil)
    - [floor()](#floor)
    - [round()](#round)
    - [random()](#random)
    - [pow()](#pow)
    - [sqrt()](#sqrt)
    - [log()](#log)
    - [Тригонометрические функции](#тригонометрические-функции)
    - [Константы](#константы)
  - [Объект Number](#объект-number)
    - [Преобразование в другую систему счисления](#преобразование-в-другую-систему-счисления)
    - [Из числа в строку, метод toString](#из-числа-в-строку-метод-tostring)
  - [Объект String](#объект-string)
    - [Длина строки](#длина-строки)
    - [Повторение строки](#повторение-строки)
    - [Поиск в строке](#поиск-в-строке)
      - [indexOf/lastIndexOf](#indexoflastindexof)
      - [includes](#includes)
    - [Выбор подстроки](#выбор-подстроки)
      - [Substring](#substring)
      - [slice](#slice)
      - [substr](#substr)
    - [Управление регистром символов](#управление-регистром-символов)
    - [Получение символа по индексу](#получение-символа-по-индексу)
    - [Удаление пробелов](#удаление-пробелов)
    - [Объединение строк](#объединение-строк)
    - [Замена подстроки](#замена-подстроки)
    - [Разделение строки](#разделение-строки)
    - [Проверка начала и окончания строки](#проверка-начала-и-окончания-строки)
    - [Заполнение строки](#заполнение-строки)
    - [Шаблоны строк](#шаблоны-строк)
      - [html-код в шаблонах](#html-код-в-шаблонах)
      - [Вложенные шаблоны](#вложенные-шаблоны)
      - [Тег-функции и передача шаблона строки в функцию](#тег-функции-и-передача-шаблона-строки-в-функцию)
  - [Символы](#символы)
    - [Символы как идентификаторы свойств объектов](#символы-как-идентификаторы-свойств-объектов)
  - [Proxy](#proxy)
    - [Переопределение функциональности объекта](#переопределение-функциональности-объекта)
      - [Метод get и получение свойств объекта](#метод-get-и-получение-свойств-объекта)
      - [Установка свойства и метод set](#установка-свойства-и-метод-set)
  - [Коллекции](#коллекции)
    - [Множества Set](#множества-set)
      - [Размер набора](#размер-набора)
      - [Добавление](#добавление)
      - [Удаление](#удаление)
      - [Проверка наличия элемента](#проверка-наличия-элемента)
      - [Перебор множества](#перебор-множества)
      - [Получение итератора](#получение-итератора)
      - [Удаление из массива повторяющихся элементов](#удаление-из-массива-повторяющихся-элементов)
    - [Ассоциативные массивы Map](#ассоциативные-массивы-map)
      - [Размер словаря](#размер-словаря)
      - [Добавление и изменение элементов](#добавление-и-изменение-элементов)
      - [Получение элементов](#получение-элементов)
      - [Удаление элементов](#удаление-элементов)
      - [Перебор элементов](#перебор-элементов)
    - [Слабоссылаемые множества](#слабоссылаемые-множества)
      - [Перебор WeakSet](#перебор-weakset)
      - [Слабые ссылки](#слабые-ссылки)
    - [Слабоссылочные словари](#слабоссылочные-словари)
      - [Слабые ссылки](#слабые-ссылки-1)
  - [Источники информации](#источники-информации)

### Объект Date. Работа с датами
Объект **`Date`** позволяет работать с датами и временем в JavaScript.

#### Определение дат
Существуют различные способы создания объекта `Date`:

- С помошью пустого конструктора **`Date`** без параметров. В этом случае созданный объект хранит текущие дату и время

    ```js
    const currentDate = new Date();
    console.log(currentDate);   // Thu Oct 26 2023 13:17:53 GMT+0100
    ```

- В конструктор `Date` передается количества миллисекунд, которые прошли с начала эпохи Unix, то есть с 1 января 1970 года 00:00:00 GMT:

    ```js
    const myDate = new Date(1359270000000);
    console.log(myDate); // Sun Jan 27 2013 11:00:00 GMT+0400 (Москва, стандартное время)
    ```

    <details>
    <summary><em>Об эпохе Unix</em></summary>

    Эпоха Unix связана с началом отсчёта времени в Unix-подобных системах как количество секунд, прошедших с полуночи 1 января 1970 года. Эта дата стала точкой отсчёта для Unix-времени (или Unix-timestamp) и была выбрана, потому что это была ближайшая подходящая дата после создания первой версии операционной системы Unix в начале 1970-х годов.

    **Исторический контекст**: Изначально операционная система Unix была разработана в исследовательском центре Bell Labs в 1970-х годах. Выбор этой даты способствовал созданию единого стандарта времени для разных операционных систем, облегчая синхронизацию и обработку данных. "Unix Epoch" — момент времени — 1 января 1970 года, 00:00:00 UTC — называется «эпохой Unix» и является точкой, от которой ведется отсчет всех последующих секунд в Unix-времени.

    </details>

- В конструктор `Date` передаются день, месяц и год:

    ```js
    const date1 = new Date("27 March 2008");
    console.log(date1); // Thu Mar 27 2008 00:00:00 GMT+0300 (Москва, стандартное время)
    // или так
    const date2 = new Date("3/27/2008");
    console.log(date2); // Thu Mar 27 2008 00:00:00 GMT+0300 (Москва, стандартное время)
    // или так
    const date3 = new Date("3 27 2008");
    console.log(date3); // Thu Mar 27 2008 00:00:00 GMT+0300 (Москва, стандартное время)
    ```

    Если мы используем полное название месяца, то оно пишется в по-английски, если используем сокращенный вариант, тогда используется формат "месяц/день/год" или "месяц день год".

- Четвертый способ состоит в передаче в конструктор `Date` всех параметров даты и времени:

    ```js
    const myDate = new Date(2012,11,25,18,30,20,10);
    console.log(myDate); // Tue Dec 25 2012 18:30:20 GMT+0400 (Москва, стандартное время)
    ```

    В данном случае используются по порядку следующие параметры: `new Date(год, месяц, число, час, минуты, секунды, миллисекунды)`. При этом надо учитывать, что отсчет месяцев начинается с нуля, то есть январь — `0`, а декабрь — `11`.

#### Получение даты и времени
Для получения различных компонентов даты применяется ряд методов:

- `getDate()`: возвращает день месяца

- `getDay()`: возвращает день недели (отсчет начинается с `0` — воскресенье, и последний день — `6` — суббота)

- `getMonth()`: возвращает номер месяца (отсчет начинается с нуля, то есть месяц с номер `0` — январь)

- `getFullYear()`: возвращает год

- `toDateString()`: возвращает полную дату в виде строки

- `getHours()`: возвращает час (от 0 до 23)

- `getMinutes()`: возвращает минуты (от 0 до 59)

- `getSeconds()`: возвращает секунды (от 0 до 59)

- `getMilliseconds()`: возвращает миллисекунды (от 0 до 999)

- `toTimeString()`: возвращает полное время в виде строки

Получим текущую дату:
```js
const today = new Date();
console.log(today.getDate());       // 26
console.log(today.getDay());        // 4
console.log(today.getMonth());      // 9
console.log(today.getFullYear());   // 2023
```

Преобразуем данные в более читабельную форму:
```js
const days = ["Воскресенье", "Понедельник", "Вторник", "Среда", "Четверг", "Пятница", "Суббота"];
const months = ["Январь", "Февраль", "Март", "Апрель", "Май", "Июнь",
            "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь"];

const today = new Date();
console.log(`Сегодня: ${today.getDate()} ${months[today.getMonth()]} ${today.getFullYear()}, ${days[today.getDay()]}`);
// Сегодня: 26 Октябрь 2023, Четверг
```

Для перевода из числовых значений в более привычные названия для дней недели и месяцев используются массивы. Получив индекс дня недели (`today.getDay()`) и индекс месяца (`today.getMonth()`) можно получить нужный элемент из массива.

Теперь получим текущее время:
```js
var welcome;
const myDate = new Date();
const hour = myDate.getHours();
const minute = myDate.getMinutes();
const second = myDate.getSeconds();

console.log(`Текущее время: ${hour}:${minute}:${second}`); // Текущее время: 13:38:26
```

#### Установка даты и времени
Кроме задания параметров даты в конструкторе для установки мы также можем использовать дополнительные методы объекта `Date`:

- **`setDate()`**: установка дня в дате

- **`setMonth()`**: уставовка месяца (отсчет начинается с нуля, то есть месяц с номер `0` — январь)

- **`setFullYear()`**: устанавливает год

- **`setHours()`**: установка часа

- **`setMinutes()`**: установка минут

- **`setSeconds()`**: установка секунд

- **`setMilliseconds()`**: установка миллисекунд

Установим дату:
```js
const myDate = new Date();
myDate.setDate(14);
myDate.setMonth(10);    // ноябрь
myDate.setFullYear(2023);
console.log(myDate); // Tue Nov 14 2023 13:41:20 GMT+0300 (Москва, стандартное время)
```

При установке значений мы можем передать величину, большую, чем максимальное допустимое значение. Например, установить для часа число 54:
```js
myDate.setHours(54);
```

В этом случае значение часа будет равно 54 - 24 * 2 = 6, а оставшиеся часы будут составлять два дня (24 * 2), что прибавит к дате два дня. То же самое действует и в отношении дней, минут, секунд, миллисекунд и месяцев.[^5.1]

### Объект Math. Математические операции
Объект **`Math`** предоставляет ряд математических функций, которые можно использовать при вычислениях. Рассмотрим основные математические функции.[^5.2]

#### abs()
Функция `abs()` возвращает абсолютное значение числа:
```js
const x = -25;
console.log(Math.abs(x)); // 25
const y = 34;
console.log(Math.abs(y)); // 34
```

#### min() и max()
Функции `min()` и `max()` возвращают соответственно минимальное и максимальное значение из набора чисел:
```js
const max = Math.max(19, 45); // 45
const min = Math.min(33, 24); // 24
```

Эти функции необязательно должны принимать два числа, в них можно передавать и большее количество чисел:
```js
const max = Math.max(1, 2, 3, -9, 46, -23); // 46
```

#### ceil()
Функция `ceil()` округляет число до следующего наибольшего целого числа:
```js
const x = Math.ceil(9.2); // 10
const y = Math.ceil(-5.9); // -5
```

Выражение `Math.ceil(9.2)` возвращает число 10, так как число 10 следующее наибольшее целое число после 9.2. И также выражение `Math.ceil(-5.9)` возвращает -5, потому что число -5 следующее наибольшее целое после -5.9

#### floor()
Функция `floor()` округляет число до следующего наименьшего целого числа:
```js
const x = Math.floor(9.2); // 9
const y = Math.floor(-5.9); // -6
```

#### round()
Функция `round()` округляет число до следующего наименьшего целого числа, если его десятичная часть меньше 0.5. Если же десятичная часть равна или больше 0.5, то округление идет до ближайшего наибольшего целого числа:
```js
const x = Math.round(5.5); // 6
const y = Math.round(5.4); // 5
const z = Math.round(-5.4); // -5
const n = Math.round(-5.5); // -5
const m = Math.round(-5.6); // -6
console.log(x);
console.log(y);
console.log(z);
console.log(n);
```

#### random()
Функция `random()` возвращает случайное число с плавающей точкой их диапазона от 0 до 1:
```js
const x = Math.random();
```

#### pow()
Функция `pow()` возвращает число в определенной степени. Например, возведем число 2 в степень 3:
```js
const x = Math.pow(2, 3); // 8
```

#### sqrt()
Функция `sqrt()` возвращает квадратный корень числа:
```js
const x = Math.sqrt(121); // 11
const y = Math.sqrt(9); // 3
const z = Math.sqrt(20); // 4.47213595499958
```

#### log()
Функция `log()` возвращает натуральный логарифм числа:
```js
const x = Math.log(1); // 0
const z = Math.log(10); // 2.302585092994046
```

Для вычисления логарифма по произвольному основанию в JavaScript используется формула смены основания:

$$ \log_b{(x)} = \frac{\log_a{(x)}}{\log_a{(b)}} $$

В JavaScript это реализуется как `Math.log(x) / Math.log(base)`, где `Math.log()` вычисляет натуральный логарифм (по основанию $e$).

Например, чтобы вычислить логарифм 100 по основанию 10:
```js
const x = 100;
const base = 10;
const result = Math.log(x) / Math.log(base);
console.log(result); // Выведет: 2
```

Другие полезные методы
- `Math.log()`: Возвращает натуральный логарифм (по основанию $e$).
- `Math.log10()`: Возвращает логарифм по основанию 10 (доступен в некоторых реализациях, таких как Java, но не является частью стандартного объекта `Math` в JavaScript).
- `Math.log2()`: Возвращает логарифм по основанию 2 (также доступен в некоторых реализациях, но не является частью стандартного объекта `Math` в JavaScript). 

#### Тригонометрические функции
Целый ряд функций представляют тригонометрические функции: `sin()` (вычисляет синус угла), `cos()` (вычисляет косинус угла), `tan()` (вычисляет тангенс угла).

```js
const x = Math.sin(90); // 0.8939966636005579
const y = Math.cos(0); // 1
const z = Math.tan(45); // 1.6197751905438615
```

Функция `asin()` вычисляет арксинус числа, `acos` — арккосинус, а `atan()` — арктангенс числа:
```js
const x = Math.asin(0.9); // 1.1197695149986342
const y = Math.acos(1); // 1
const z = Math.atan(1); // 0.7853981633974483
```

#### Константы
Кроме методов объект `Math` также определяет набор встроенных констант, которые можно использовать в различных вычислениях:

- `Math.PI` (число PI): `3.141592653589793`

- `Math.SQRT2` (квадратный корень из двух): `1.4142135623730951`

- `Math.SQRT1_2` (половина от квадратного корня из двух): `0.7071067811865476`

- `Math.E` (число e или число Эйлера): `2.718281828459045`

- `Math.LN2` (натуральный логарифм числа 2): `0.6931471805599453`

- `Math.LN10` (натуральный логарифм числа 10): `2.302585092994046`

- `Math.LOG2E` (двоичный логарифм числа e): `1.4426950408889634`

- `Math.LOG10E` (десятичный логарифм числа e): `0.4342944819032518`

Используем константы в вычислениях:
```js
const x = Math.log(Math.E); // 1
const z = Math.tan(Math.PI/4); // 0.9999999999999999
```

### Объект Number
Объект `Number` представляет числа. Чтобы создать число, надо передать в конструктор `Number` число или строку, представляющую число:
```js
const x = new Number(34);
const y = new Number('34');
console.log(x+y); // 68
```

Определения `x` и `y` в данном случае будут практически аналогичны.[^5.4]

Однако создавать объект `Number` можно и просто присвоив переменной определенное число:
```js
const z = 34;
```

Объект `Number` предоставляет ряд свойств и методов. Некоторые его свойства:

- `Number.MAX_VALUE`: наибольшее возможное целое число. Приблизительно равно 1.79E+308. Числа, которые больше этого значения, рассматриваются как `Infinity`;

- `Number.MIN_VALUE`: наименьшее возможное положительное целое число. Приблизительно равно 5e-324 (где-то около нуля);

- `Number.NaN`: специальное значение, которое указывает, что объект не является числом;

- `Number.NEGATIVE_INFINITY`: значение, которое обозначает отрицательную бесконечность и которое возникает при переполнении. Например, если мы складываем два отрицательных числа, которые по модулю равны `Number.MAX_VALUE`. Например:

    ```js
    const x = -1 * Number.MAX_VALUE
    const y = -1 * Number.MAX_VALUE
    const z = x + y;
    if(z===Number.NEGATIVE_INFINITY)
        console.log("отрицательная бесконечность");
    else
        console.log(z);
    ```

- `Number.POSITIVE_INFINITY`: положительная бесконечность. Также, как и отрицательная бесконечность, возникает при переполнении, только теперь в положительную сторону:

```js
const x = Number.MAX_VALUE
const y = Number.MAX_VALUE
const z = x * y;
if(z===Number.POSITIVE_INFINITY)
    console.log("положительная бесконечность");
else
    console.log(z);
```

Некоторые основные методы:

- `isNaN()`: определяет, является ли объект числом. Если объект не является числом, то возвращается значение `true`:

```js
const a = Number.isNaN(Number.NaN); // true
const b = Number.isNaN(true); // false - new Number(true) = 1
const c = Number.isNaN(null);  // false - new Number(null) = 0
const d = Number.isNaN(25);  // false
const e = Number.isNaN("54"); // false
```

Но следующее выражение вернет `false`, хотя значение не является числом:
```js
const f = Number.isNaN("hello"); // false
```

Чтобы избежать подобных ситуаций, лучше применять глобальную функцию **`isNaN`**:
```js
const f = isNaN("hello"); // true
```

- `parseFloat()`: преобразует строку в число с плавающей точкой. Например:

```js
const a = Number.parseFloat("34.90"); // 34.9
console.log(a);
const b = Number.parseFloat("hello"); // NaN
console.log(b);
const c = Number.parseFloat("34hello"); // 34
console.log(c);
```

- `parseInt()`: преобразует строку в целое число. Например:

```js
const a = Number.parseInt("34.90"); // 34
console.log(a);
const b = Number.parseInt("hello"); // NaN
console.log(b);
const c = Number.parseInt("25hello"); // 25
console.log(c);
```

- `toFixed()`: оставляет в числе с плавающей точкой определенное количество знаков в дробной части. Например:

```js
const a =  10 / 1.44;
console.log("До метода toFixed(): ", a, "<br/>");
a = a.toFixed(2); // оставляем два знака после запятой
console.log("После метода toFixed(): ", a, "<br/>");
```

Вывод браузера:
```
До метода toFixed(): 6.944444444444445
После метода toFixed(): 6.94
```

#### Преобразование в другую систему счисления
Выше мы рассматривали перевод строк в числа в десятичной системе. Но мы можем с помощью второго параметра явно указать, что хотим преобразовать строку в число в определенной системе. Например, преобразование в число в двоичной системе:
```js
const num1 = "110";
const num2 = parseInt(num1, 2);
console.log(num2); // 6
```

Здесь в функцию `parseInt` в качестве второго параметра передается число 2, что указаывает, что первый параметр будет рассматриваться как число в двоичной системе. Результатом будет 6, так как 110 в двоичной системе — это число 6 в десятичной.

#### Из числа в строку, метод toString
Для преобразования числа в строку у него можно вызвать специальный метод `toString()`:
```js
const num = 10;
console.log(num.toString()); // 10
```

Однако в данном случае нет смысла вызывать у числа num метод `toString()`, так как число можно вывести на консоль без всяких преобразований. Тем не менее метод `toString()` может быть полезен — в качестве параметра он принимает основание системы счисления числа и может быть использован для вывода числа в определенной системе счисления:
```js
const num1 = 0b0110;
// выводим число в двоичной системе
console.log(num1.toString(2)); // 110

const num2 = 0xFF;
// выводим число в шестнадцатеричной системе
console.log(num2.toString(16)); // ff
```

### Объект String
Для создания строк мы можем как напрямую присваивать переменной или константе строку:
```js
const message = "Hello";
```

Для работы со строками предназначен объект **`String`**, поэтому также можно использовать конструктор `String`:
```js
const message = new String("Hello");
```

Но как правило, используется первый более краткий способ. В первом случае JavaScript при необходимости автоматически преобразует переменную примитивного типа в объект `String`.

С помощью индексов можно обращаться к отдельным символам строки, как к элементам массива (как и в массивах индексация начинается с нуля):
```js
const message = "Hello";
console.log(message[0]);    // H
console.log(message[4]);    // o
```

Объект `String` имеет большой набор свойств и методов, с помощью которых мы можем манипулировать строками.[^6.1]

#### Длина строки
Свойство **`length`** указывает на длину строки:
```js
const message = "Hello";
console.log(message.length);        //  5 символов
```

#### Повторение строки
Метод **`repeat()`** позволяет создать строку путем многократного повторения другой строки. Количество повторов передается в качестве аргумента:
```js
const message = "hello ";
console.log(message.repeat(3)); // hello hello hello
```

#### Поиск в строке

##### indexOf/lastIndexOf
Для поиска в строке некоторой подстроки используются методы **`indexOf()`** (индекс первого вхождения подстроки) и **`lastIndexOf()`** (индекс последнего вхождения подстроки). Эти методы принимают два параметра:
```js
indexOf(str, index)
lastIndexOf(str, index)
```

- подстроку, которую надо найти

- индекс, с которого идет поиск (необязательный параметр)

Оба этих метода возвращают индекс символа, с которого в строке начинается подстрока. Если подстрока не найдена, то возвращается число -1.

```js
const hello = "привет мир. пока мир";
const key = "мир";
const firstPos = hello.indexOf(key);
const lastPos = hello.lastIndexOf(key);
console.log("Первое вхождение: ", firstPos);    // 7
console.log("Последнее вхождение: ", lastPos);  // 17
```

Применим поиск относительно индекса, например, начиная с индекса 10:
```js
const hello = "привет мир. пока мир";
const key = "мир";
const firstPos = hello.indexOf(key, 10);    // поиск с 10-го индекса
console.log("Первое вхождение: ", firstPos);    // 17
```

Следует учитывать, что поиск регистрозависимый:
```js
const hello = "привет мир. пока мир";
const key = "Мир";
const firstPos = hello.indexOf(key);
console.log(firstPos);  // -1
```

##### includes
Еще один метод — **`includes()`** — возвращает `true`, если строка содержит определенную подстроку.

```js
const hello = "привет мир. пока мир";

console.log(hello.includes("мир")); // true
console.log(hello.includes("миг")); // false
```

С помощью второго дополнительного параметра можно определить индекс, с которого будет начинаться поиск подстроки:
```js
const hello = "привет мир. пока мир";

console.log(hello.includes("мир", 5));  // true
console.log(hello.includes("привет", 6));   // false
```

#### Выбор подстроки
Для того, чтобы вырезать из строки подстроку, применяются методы **`substring()`** и **`slice()`**.

##### Substring
Метод **`substring()`** принимает два параметра:
```js
substring(startIndex, endIndex)
```

- индекс символа в строке, начиная с которого надо проводить обрезку строки. Обязательный параметр

- индекс, до которого надо обрезать строку. Необязательный параметра — если он не указан, то обрезается вся остальная часть строки

```js
const hello = "привет мир. пока мир";
const world = hello.substring(7, 10); // с 7-го по 10-й индекс
console.log(world); // мир
const bye = hello.substring(12);    // c 12 индекса до конца строки
console.log(bye); // пока мир
```

##### slice
Метод **`slice`** также позволяет получить из строки какую-то ее часть. Она принимает два параметра:
```js
slice(startIndex, endIndex)
```

- начальный индекс подстроки в строке. Обязательный параметр

- конечный индекс подстроки в строке. Необязательный параметра — если он не указан, то обрезается вся остальная часть строки

```js
const hello = "привет мир. пока мир";
const world = hello.slice(7, 10); // с 7-го по 10-й индекс
console.log(world); // мир
const bye = hello.slice(12);    // c 12 индекса до конца строки
console.log(bye); // пока мир
```

Можно заметить, что этот метод похож на метод `substring()`, тем не менее между ними есть небольшие различие. Прежде всего, в `slice()` начальный индекс должен быть меньше чем конечный. В `substring()`, если начальный индекс больше конечного, то они меняются местами (то есть `substring(5, 1)` будет равноценно `substring(1, 5)`):
```js
const hello = "привет мир. пока мир";
const world1 = hello.slice(6, 0); // не работает
console.log(world1); //     пустая строка
const world2 = hello.substring(6, 0); // аналогично hello.substring(0, 6)
console.log(world2); // привет
```

Другое отличие, что `slice` позволяет использовать отрицательные индексы. Отрицательный индекс указывает на индекс символа относительно конца строки. `substring()` же отрицательные индексы не поддерживает:
```js
const hello = "привет мир. пока мир";
const bye1 = hello.slice(-8, -4); // с 8-го индекса с конца до 4 индекса с конца
console.log(bye1); // пока
const bye2 = hello.substring(-8, -4); // не работает
console.log(bye2); //
```

##### substr
Следует отметить, что еще есть метод **`substr()`**. Этот метод не является частью стандарта и в целом не рекомендуется к использованию, однако он все еще может поддерживаться браузерами, и его до сих пор можно встретить в различных программах. Он принимает два параметра:
```js
substr(startIndex, count)
```

- начальный индекс подстроки в строке. Обязательный параметр

- количество выбираемых символов. Необязательный параметра — если он не указан, то выбирается вся остальная часть строки

Применение:
```js
const hello = "привет мир. пока мир";
const world = hello.substr(7, 3); // с 7-го индекса 3 символа
console.log(world); // мир
const bye = hello.substr(12); // с 12-го индекса до конца
console.log(bye); // пока мир
```

#### Управление регистром символов
Для изменения регистра символов имеются методы **`toLowerCase()`** (для перевода в нижний регистр) и **`toUpperCase()`** (для перевода в верхний регистр).

```js
const hello = "Привет Том";
console.log(hello.toLowerCase()); // привет том
console.log(hello.toUpperCase()); // ПРИВЕТ ТОМ
```

#### Получение символа по индексу
Чтобы получить определенный символ в строке по индексу, можно применять синтаксис массивов. Но также JavaScript предоставляет методы **`charAt()`** и **`charCodeAt()`**. Оба этих метода в качестве параметра принимают индекс символа:
```js
const hello = "Привет Том";
console.log(hello.charAt(2));       // и
console.log(hello.charCodeAt(2));   // 1080
```

Но если в качестве результата метод `charAt()` возвращает сам символ, то метод `charCodeAt()` возвращает числовой код этого символа.

#### Удаление пробелов
Для удаления начальных и концевых пробелов в стоке используется метод **`trim()`**:
```js
let hello = "   Привет Том  ";
const beforeLength = hello.length;
hello = hello.trim();
const afterLength = hello.length;
console.log("Длина строки до: ", beforeLength);     // 15
console.log("Длина строки после: ", afterLength);   // 10
```

Дополнительно есть ряд методов, которые удаляют пробелы с определенной стороны строки:

- **`trimStart()`**: удаляет пробел с начала строки (в зависимости от того, является ли письмо правостронним или левостронним, это может быть правый или левый край строки);

- **`trimEnd()`**: удаляет пробел с конца строки (в зависимости от того, является ли письмо правостронним или левостронним, это может быть правый или левый край строки);

- **`trimLeft()`**: удаляет пробел с левой части строки;

- **`trimRight()`**: удаляет пробел с правой части строки.

#### Объединение строк
Метод **`concat()`** объединяет две строки:
```js
let hello = "Привет ";
const world = "мир";
hello = hello.concat(world);
console.log(hello); // Привет мир
```

#### Замена подстроки
Метод **`replace()`** заменяет первое вхождение одной подстроки на другую:
```js
let hello = "Добрый день";
hello = hello.replace("день", "вечер");
console.log(hello); // Добрый вечер
```

Первый параметр метода указывает, какую подстроку надо заменить, а второй параметр — на какую подстроку надо заменить.

В то же время у этого метода есть одна особенность — он заменяет только первое вхождение подстроки:
```js
let menu = "Завтрак: каша, чай. Обед: суп, чай. Ужин: салат, чай.";
menu = menu.replace("чай", "кофе");
console.log(menu);  // Завтрак: каша, кофе. Обед: суп, чай. Ужин: салат, чай.
```

Однако еще один метод — **`replaceAll()`** позволяет заменить все вхождения подстроки:
```js
let menu = "Завтрак: каша, чай. Обед: суп, чай. Ужин: салат, чай.";
menu = menu.replaceAll("чай", "кофе");
console.log(menu);  // Завтрак: каша, кофе. Обед: суп, кофе. Ужин: салат, кофе.
```

#### Разделение строки
Метод **`split()`** разбивает строку на массив подстрок по определенному разделителю. В качестве разделителя используется строка, которая передается в метод:
```js
const message = "Сегодня была прекрасная погода";
const messageParts = message.split(" ");
console.log(messageParts);  // ["Сегодня", "была", "прекрасная", "погода"]
```

В данном случае строка разделяется по проблему, то есть в итоге в массиве `messageParts` окажется четыре элемента.

#### Проверка начала и окончания строки
Метод **`startsWith()`** возвращает `true`, если строка начинается с определенной подстроки. А метод **`endsWith()`** возвращает `true`, если строка оканчивается на определенную подстроку.

```js
const hello = "let me speak from my heart";
console.log(hello.startsWith("let"));       // true
console.log(hello.startsWith("Let"));       // false
console.log(hello.startsWith("lets"));      // false

console.log(hello.endsWith("heart"));       // true
console.log(hello.startsWith("bart"));      // false
```

При этом играет роль регистр символов, и из примера выше мы видим, что "let" не эквивалентно "Let".

Дополнительный второй параметр позволяет указать индекс (для `startsWith` — индекс с начала, а для `endsWith` — индекс с конца строки), относительно которого будет производиться сравнение:
```js
const hello = "let me speak from my heart";
console.log(hello.startsWith("me", 4));     // true, "me" - 4 индекс с начала строки

console.log(hello.startsWith("my", hello.length-8));    // true, "my" - 8 индекс с конца
```

#### Заполнение строки
Методы **`padStart()`** и **`padEnd()`** растянуть строку на определенное количество символов и заполнить строку слева и справа соответственно.

```js
let hello = "hello".padStart(8);  // "   hello"
console.log(hello);
hello = "hello".padEnd(8);        // "hello   "
console.log(hello);
```

Вызов `"hello".padStart(8)` будет рястягивать строку "hello" на 8 символов. То есть изначально в строке "hello" 5 символов, значит, к ней будет добавлено 3 символа. При чем они будут добавлено в начале строки. По умолчанию добавляемые символы представляют пробелы. Аналогично вызов `"hello".padEnd(8)` растянет строку на 8 символов, но оставшие символы в виде пробелов будут добавлены в конец строки.

По умолчанию эти методы используют пробелы для заполнения, но в качестве второго параметра мы можем передать методам значение, которым надо дополнить строку:
```js
let hello = "hello".padStart(17, "JavaScript, ");  // "JavaScript, hello"
hello = "hello".padEnd(12, " JS");      // "hello JS"
```

Если добавляемое количество символов больше добавляемой строки, то добавляемая строка повторяется:
```js
let hello = "123".padStart(6, "0");  // "000123"
hello = "123".padEnd(6, "0");       // "123000"
```

#### Шаблоны строк
Шаблоны строк (template strings / template literals) позволяют вставлять в строку различные значения. Подобный прием еще называют интерполяцией. Для этого строки заключаются в косые кавычки, а вставляемое значение предваряется символом **`$`** и заключается в фигурные скобки:
```js
const name = "Tom";
const hello = `Hello ${name}`;
console.log(hello);     // Hello Tom
```

Здесь на место `${name}` будет вставляться значение константы name. Таким образом, из шаблона ``Hello ${name}`` мы получим строку `Hello Tom`.[^6.5]

Подобным образом в строку можно вставлять сразу несколько значений:
```js
const name = "Tom";
const age = 37;
const userInfo = `${name} is ${age} years old`;
console.log(userInfo);      // Tom is 37 years old
```

Также вместо скалярных значений могут добавляться свойства сложных объектов:
```js
const tom ={
    name: "Tom",
    age: 22
}
const tomInfo = `${tom.name} is ${tom.age} years old`;
console.log(tomInfo);       // Tom is 22 years old
```

Любо можно вставлять более сложные вычисляемые выражения:
```js
function sum(x, y){
    return x + y;
}
const a = 5;
const b = 4;

const result = `${a} + ${b} = ${sum(a, b)}`;
console.log(result);    // 5 + 4 = 9


const expression = `${a} * ${b} = ${ a * b}`;
console.log(expression);    // 5 * 4 = 20
```

В первом случае в шаблоне вызывается функция `sum()`, параметрам которой передаются значения констант `a` и `b`: `${sum(a, b)}`. В итоге в это место будет вставлена сумма `a` и `b`.

Во втором случае в шаблоне выполняется операция умножения констант: `${ a * b}`.

##### html-код в шаблонах
Шаблоны также могут хранить html-код, который будет динамически формироваться.

```js
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM Vault</title>
</head>
<body>
<script>
const tom = {name: "Tom", age: 37};
const markup = `<div>
    <p><b>Name</b>: ${tom.name}</p>
    <p><b>Age</b>: ${tom.age}</p>
</div>`;

document.body.innerHTML = markup;
</script>
</body>
</html>
```

![String templates in JavaScript](../img/templates_1_cp.png)

##### Вложенные шаблоны
Рассмотрим другой пример — создадим из элементов массива список html:
```js
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM Vault</title>
</head>
<body>
<script>
const people = [{name: "Tom", age: 37}, {name:"Sam", age: 41}, {name: "Bob", age: 21}];
const markup = `<ul>
    ${people.map(person => `<li>${person.name}</li>`)}
</ul>`;

document.body.innerHTML = markup;
</script>
</body>
</html>
```

![Шаблоны строк в JavaScript](../img/templates_2_cp.png)

В данном случае мы имеем дело с вложенным шаблоном. То есть вначале определяется общий внешний шаблон:
```js
const markup = `<ul>
    ${.............}
</ul>`;
```

А в динамически формируемом выражении применяется еще один шаблон:
```js
${people.map(person => `<li>${person.name}</li>`)}
```

В данном случае у массива `people` вызывается функция `map()`, которое определяет некоторое действие для каждого элемента массива. Это действие передается в `map()` в виде функции. Здесь для упрощения в качестве такой функции применяется лямбда-выражение. Оно получает каждый элемент массива через параметр `person` и для него формирует шаблон строки ``<li>${person.name}</li>``.

##### Тег-функции и передача шаблона строки в функцию
JavaScript позволяет передать в функцию шаблон строки, причем не просто как строку, но и все ее динамчески вычисляемые фрагменты в виде отдельных параметров. Для этого применяются тег-функции (tag function). Подобная возможность может применяться, например, для предобработки шаблонов и их значений. Рассмотрим следующий пример:
```js
const person = "Tom";

function check (parts, name){
    console.log(parts);
    return parts[0] + name + parts[1];
}
const checkedTemplate = check`Person: ${person}.`;
console.log(checkedTemplate);
```

Здесь определена tag-функция `check()`, которая имеет два параметра: `parts` и `name`
```js
function check (parts, name){
    console.log(parts);
    return parts[0] + name + parts[1];
}
```

Параметр `parts` — это массив частей шаблона, разделенных вставляемыми динамическими фрагментами. Второй параметр — `name` — это динамически вычисляемый фрагмент шаблона. То есть в данном случае мы предполагаем, что шаблон строки, который передается в функцию `check()`, будет иметь только один динамически вычисляемый фрагмент. Соответственно в массиве `parts` будет два элемента: статическая часть шаблона, которая идет до вычисляемого фрагмента, и часть шаблона, которая идет после.

Чтобы было более ясно, о чем идет речь, в функции выводим на консоль эти элементы массива `parts`.

Функция возвращает `return parts[0] + name + parts[1]`, то есть по сути мы просто возвращаем ранее сформированный шаблон, ничего не меняя.

Обратите внимание, как мы передаем этой функции шаблон:
```js
const checkedTemplate = check`Person: ${person}.`;
```

Шаблон просто указывается после названия функции. Или иначе говоря, tag-функция указывается как префикс перед шаблоном.

Результат работы программы:
```
Array(2)
	0: "Person: "
	1: "."
	length: 2
	raw: (2) ['Person: ', '.']
	[[Prototype]]: Array(0)
Person: Tom.
```

Из консольного вывода мы видим, что элементами массива parts являются подстроки "Person: " и ".". А в качестве значения параметра name передается строка "Tom". Стоит отметить, что даже если после динамически вычисляемого фрагмента больше не было бы никаких символов (например, ``Person: ${person}``), то массив `parts` все равно имел бы два элемента, только вторым элементом тогда была бы пустая строка.

Но в примере выше мы просто возвращали то же содержимое, которое было сформировано на основе шаблона. Однако мы можем выполнить некоторую обработку:
```js
const tom = "Tom";
const admin = "Admin";

function check (parts, name){
    if(name === "Admin") return "Пользователь не определен";
    else return parts[0] + name + parts[1];
}
let checkedTemplate1 = check`Пользователь: ${tom}`;
let checkedTemplate2 = check`Пользователь: ${admin}`;

console.log(checkedTemplate1);
console.log(checkedTemplate2);
```

В данном случае, если в шаблон передается значение "Admin", то возвращаем один результат, иначе возвращаем, то, что было бы сформированно на основе шаблона.

```
Пользователь: Tom
Пользователь не определен
```
Подобным образом можно обрабатывать шаблоны с большим количеством вычисляемых фрагментов:
```js
const tom = {name: "Tom", age: 37};
const bob = {name: "Bob", age: 11};

function check (parts, name, age){
    if(age > 18) return `${parts[0]}${name}. Доступ открыт`;
    else return `Для пользователя ${name} доступ закрыт. Возраст ${age} недействителен`;
}
let checkedTemplate1 = check`Пользователь: ${tom.name} ${tom.age}`;
let checkedTemplate2 = check`Пользователь: ${bob.name} ${bob.age}`;

console.log(checkedTemplate1);
console.log(checkedTemplate2);
```

В данном случае шаблон содержит два динамческих фрагмента. Соответственно в массива `part` будет три элемента.

В функции `check()` в зависимости от значения второго динамического фрамегмента (условного возраста пользователя) возвращаем то или иное значение.

Консольный вывод:
```
Пользователь:  Tom. Доступ открыт
Для пользователя Bob доступ закрыт. Возраст 11 недействителен
```

### Символы
Символ или тип **`Symbol`** представляет некоторое уникальное значение.

Для определения символа применяется конструктор типа **`Symbol`**. Например, создадим простейший символ:
```js
const tom = Symbol("Tom");
console.log(tom);   // Symbol(Tom)
```

Причем каждый символ **уникален**. Так, попробуем создать два одинаковых символа:
```js
const tom = Symbol("Tom");
console.log(tom);   // Symbol(Tom)

const tomas = Symbol("Tom");
console.log(tomas); // Symbol(Tom)

console.log(tom == tomas);      // false
console.log(tom === tomas);     // false
```

Несмотря на то, что оба создаваемых выше в примее символа инициализированы одним и тем же значением, но оба оператора — равенства и эквивалентности при сравнению этих символа возвращают `false`. То есть символы всегда уникальны.[^5.5]

#### Символы как идентификаторы свойств объектов
Основной областью применения символов являются определение идентификаторов свойств объектов. То есть, если вкратце, символы позволяют избежать ситуаций, когда несколько свойств объекта имеют одинаковые названия. Возможно, данная ситуация может показаться искусственной: ну как мы можем определить в объекте два одинакоых свойства? Однако если свойства добавляются динамически в довольно большой программе или даже где-то во внешнем коде, который мы не можем контролировать, то задача по контролю за идентификаторами свойств усложняется.

Для примера возьмем следующую задачу: в комании работают три программиста, один из которых старший разработчик, а остальные два — младшие разработчики. Но при этом два из разработчиков имеют одинаковые имена. Скажем, один Том является старшим разработчиком, а Сэм и другой Том — младшие разработчики. Например, мы могли бы представить подобную компанию так:
```js
const company = {
    "Tom": "senior",
    "Sam": "junior",
    "Tom": "junior"
}
for(developer in company) {
    console.log(`${developer} - ${company[developer]}`);
}
```

Однако консольный вывод покажет, что в нашей компании только два разработчика, поскольку названия двух из них совпадают:
```
Tom - junior
Sam - junior
```

Теперь применим символы:
```js
const company = {
    [Symbol("Tom")]: "senior",
    [Symbol("Sam")]: "junior",
    [Symbol("Tom")]: "junior"
}
const developers = Object.getOwnPropertySymbols(company);
for(developer of developers) {
    console.log(`${developer.toString()} - ${company[developer]}`);
}
```

Для получения всех символов из объекта применяется функция **`Object.getOwnPropertySymbols()`**, в которую передается объект. Возвращает эта функция набор символов, которые мы можем перебрать в цикле. Для получения текстового представления символов можно применять метод `toString()` символа. А для получения значения, как и в общем случае, применяется синтаксис массивов: `company[developer]`. В итоге мы получим следующий консольный вывод:
```
Symbol(Tom) - senior
Symbol(Sam) - junior
Symbol(Tom) - junior
```

Также можно динамически добавлять свойства с символьными идентификаторами в объект:
```js
const company = { };
company[Symbol("Tom")]= "senior";
company[Symbol("Sam")]= "junior";
company[Symbol("Tom")]= "junior";
```

### Proxy
**Прокси** (**`Proxy`**) представляет объект, который позволяет перехватывать выполнение операций по отношению к некоторому другому объекту и может переопределять его поведение.[^5.9]

Для создания объекта `Proxy` применяется конструктор **`Proxy()`**:
```js
const proxy = new Proxy(target, handler);
```

Конструктор `Proxy` принимает два параметра:

- `target` — цель создания прокси, это может быть любой объект, к которому применяется `Proxy`;

- `handler` — другой объект, который определяет, какие именно операции объекта `target` будут перехватываться и переопределяться и как именно.

Рассмотрим простейший пример:
```js
// объект, к которому применяется прокси
const target = {name: "Tom"};
// объект, который определяет, как будет переопределяться target
const handler = {};
// объект прокси
const proxy = new Proxy(target, handler);

console.log(proxy.name);    // Tom
```

Итак, в примере выше `target` — это объект, к которому будет применяться проксирование. В данном случае этот объект имеет свойство `name`.

```js
const target = {name: "Tom"};
```

Далее создается пустой обработчик `handler`:
```js
const handler = {};
```

В принципе этот объект должен определять, как будет переопределяться объект `target`. Но пока оставим его пустым.

Затем создаем объект `Proxy`, передавая в его конструктор объекты `target` и `handler`.

```js
const proxy = new Proxy(target, handler);
```

Проксирование объекта (в данном случае объекта `target`) означает, что через прокси мы можем обращаться к функциональности этого объекта. И в данном случае через объект `proxy` мы можем обратиться к свойству `name` проксированного объекта `target`:
```js
console.log(proxy.name);    // Tom
```

И поскольку мы использовали пустой `handler`, который ничего не переопределяет, то по сути прокси ведет себя как оригинальный объект `target`.

#### Переопределение функциональности объекта
Выше мы выполнили проксирование объекта, но пока никак не переопределяли его поведение. Ключевым в данном случае является определение обработчика **`handler`**, который может перехватывать обращения к свойствам проксированного объекта. Этот обработчик может определять два метода: **`get`** и **`set`**.

##### Метод get и получение свойств объекта
Метод **`get`** перехватывает обращения к свойству при получении его значения и возвращает для этого свойства некоторое значение:
```js
const handler = {
  get: function(target, prop, receiver) {
    return некоторое_значение;
  }
};
```

Метод **`get`** имеет три параметра:

- `target`: сам проксированный объект. Благодаря этому параметру мы можем обратиться к функциональности оригинального объекта;

- `prop`: название свойства, к которому идет обращение;

- `receiver`: объект `Proxy`, через который выполняется проксирование;

Возьмем следующий пример:
```js
const target = {name: "Tom"};
const handler = {
  get: function(target, prop, receiver) {
    return "Tomas Smith";
  }
};
const proxy = new Proxy(target, handler);
console.log(proxy.name);    // Tomas Smith
```

Здесь в обработчике `handler` в методе `get` возвращается строка "Tomas Smith":
```js
get: function(target, prop, receiver) {
    return "Tomas Smith";
}
```

Это приведет к тому, что при обращение к любому свойству прокси-объекта будет возвращаться данная строка:
```js
console.log(proxy.name);    // Tomas Smith
```

Так, мы выполнили перехват обращения к свойству и простейшее переопределение. При этом мы можем обащаться и к оригинальному объекту, который проксируется:
```js
const target = {name: "Tom"};
const handler = {
  get: function(target, prop) {
    return "Name: " + target.name;
  }
};
const proxy = new Proxy(target, handler);
console.log(proxy.name);    // Name: Tom
```

Здесь обработчик возвращает строку `"Name: " + target.name`, где `target.name` представляет обращение к свойству `name` оригинального объекта. Естественно логика возвращение значения свойства может более сложной.

Но возьмем более сложный объект — с двумя свойствами:
```js
const target = {name: "Tom", age: 37};
const handler = {
  get: function(target, prop) {
    return target[prop];
  }
};
const proxy = new Proxy(target, handler);
console.log(proxy.name);    // Tom
console.log(proxy.age);     // 37
```

Здесь целевой объект имеет два свойства: `name` и `age`. В обработчике мы перехватываем обращение к ним, но никак его не переопределяем, а просто возвращаем значения свойств оригинального объекта:
```js
return target[prop];
```

Для обращения к свойствам целевого объекта применяется синтаксис массивов.

Но также мы можем проверить, к какому именно свойству идет обращение, и выполнить некоторое переопределение:
```js
const target = {name: "Tom", age: 37};
const handler = {
  get: function(target, prop) {
    if(prop==="name")
        return target.name.toUpperCase();
    else
        return target[prop];
  }
};
const proxy = new Proxy(target, handler);
console.log(proxy.name);    // TOM
console.log(proxy.age);     // 37
```

В данном случае, если обращение идет к свойству `name`, то есть к свойству, которое хранит строку, то вызываем у этой строки метод `toUpperCase()` и переводим ее в верхний регистр.

##### Установка свойства и метод set
Метод **`set`** перехватывает обращения к свойству при установке его значения:
```js
const handler = {
  set: function(target, property, value, receiver) {

  }
};
```

Метод **`set`** имеет четыре параметра:

- `target`: оригинальный объект, к которому идет проксирование

- `property`: название свойства, к которому идет обращение

- `value`: устанавливаемое значение

- `receiver`: объект `Proxy`, через который выполняется проксирование

Рассмотрим на примере:
```js
const target = {name: "Tom", age: 37};
const handler = {
  set: function(target, prop, value) {
        console.log(value);
        target[prop] = value;
  }
};
const proxy = new Proxy(target, handler);
proxy.name = "Tomas";
console.log(proxy.name);    // Tomas
proxy.age = 22;
console.log(proxy.age);     // 22
```

В данном примере в методе `set` сначала логируем передаваеемое свойству значение, затем устанавливаем свойство:
```js
target[prop] = value;
```

Немного изменим пример:
```js
const target = {name: "Tom", age: 37};
const handler = {
  set: function(target, prop, value) {
    if(prop==="age" && value < 1)
        console.log("Некорректный возраст");
    else
        return target[prop] = value;
  }
};
const proxy = new Proxy(target, handler);
proxy.name = "Tomas";
console.log(proxy.name);    // Tomas
proxy.age = -199;           // Некорректный возраст
console.log(proxy.age);     // 37
proxy.age = 22;
console.log(proxy.age);     // 22
```

Здесь в методе `set` обработчика проверяем, если идет установка свойства `age` и значение меньше 1, то просто выводим сообщение о некорректности данных
```js
if(prop==="age" && value < 1)
    console.log("Некорректный возраст");
```

Иначе передаем значение свойству оригинального объекта:
```js
else
    return target[prop] = value;
```

### Коллекции

#### Множества Set
Множества (sets) представляют структуру данных, которая может хранить только уникальные значения. В JavaScript функционал множества опредляет объект **`Set`**. Для создания множества применяется конструктор этого объекта:
```js
const mySet = new Set();
```

Также можно передать в конструктор массив значений, которыми будет инициализировано множество:
```js
const arr = [1, 1, 2, 3, 4, 5, 2, 4];
const numbers = new Set(arr);
console.log(numbers);           // Set(5) {1, 2, 3, 4, 5}
```

В данном случае в множество передаются данные из массива. Однако поскольку множество может хранить только уникальные значения, то при его создании повторяющиеся значения, которые есть в массиве, удаляются.

Для упрощения создания набора мы можем сразу передать массив в конструктор `Set`:
```js
const numbers = new Set([1, 2, 3, 4, 5]);
console.log(numbers);       // Set(5) {1, 2, 3, 4, 5}
```

##### Размер набора
Для проверки количества элементов можно использовать свойство **`size`**.

```js
const numbers = new Set([1, 1, 2, 3, 4, 5, 2, 4]);
console.log(numbers.size);      // 5
```

##### Добавление
Для добавления применяется метод **`add()`**. Его результатом является измененное множество:
```js
const numbers = new Set();
numbers.add(1);
numbers.add(3);
numbers.add(5);
numbers.add(3);     // не добавляется
numbers.add(1);     // не добавляется
console.log(numbers);       // Set(3) {1, 3, 5}
```

При этом, поскольку множество хранит только уникальные значения, то добавление элементов, которые уже в нем есть, не имеет смысла.

Так как метод `add` возвращает ссылку на это же множество, то мы можем вызывать методы по цепочке:
```js
const numbers = new Set();
numbers.add(1).add(3).add(5);
console.log(numbers);       // Set(3) {1, 3, 5}
```

##### Удаление
Для удаления элементов применяется метод **`delete()`**:
```js
const numbers = new Set([1, 3, 5]);
numbers.delete(3);
console.log(numbers);       // Set(2) {1, 5}
```

Причем данный метод возвращает булевое значение: `true` — если элемент удален и `false` — если удаление не произошло (например, когда удаляемого элемента нет в множестве):
```js
const numbers = new Set([1, 3, 5]);

let isDeleted = numbers.delete(3);
console.log(isDeleted);         // true
isDeleted = numbers.delete(54);
console.log(isDeleted);         // false
```

Если необходимо удалить вообще все элементы из множества, то применяется метод **`clear()`**:
```js
let numbers = new Set();
const numbers = new Set([1, 3, 5]);
numbers.clear();
console.log(numbers);           // Set(0) {}
```

##### Проверка наличия элемента
Если нужно проверить, если ли элемент в множестве, то используется метод **`has()`**. Если элемент есть, то метод возвращает `true`, иначе возвращает `false`:
```js
const numbers = new Set([1, 3, 5]);
console.log(numbers.has(3));    // true
console.log(numbers.has(32));   // false
```

##### Перебор множества
Для перебора элементов множества применяется метод **`forEach()`**:
```js
const numbers = new Set([1, 2, 3, 5]);

numbers.forEach(function(value1, value2, set){
    console.log(value1);
})
```

Для совместимости с массивами, которые тоже имеют метод `forEach`, в данный метод передается функция обратного вызова, которая принимает три параметра. Непосредственно для множества первый и второй параметры представляют текущий перебираемый элемент, а третий параметр — перебираемое множество. В данном случае применяется только первый параметр.

Также для перебора множества можно использовать цикл `for...of`:
```js
const numbers = new Set([1, 2, 3, 5]);

for(n of numbers){
    console.log(n);
}
```

##### Получение итератора
Также у объекта **`Set`** есть ряд методов, которые возвращают итератор, а точнее объект **`SetIterator`**. Это методы `values()`, `keys()`, `entries()`:
```js
const numbers = new Set([1, 2, 3, 5]);

console.log(numbers.values());  // SetIterator {1, 2, 3, 5}
console.log(numbers.keys());    // SetIterator {1, 2, 3, 5}
console.log(numbers.entries()); // SetIterator {1 => 1, 2 => 2, 3 => 3, 5 => 5}
```

Соответственно возвращаемый итератор мы можем использовать для получения объектов множества:
```js
const people = new Set(["Tom", "Bob", "Sam"]);

const iterator = people.values();

console.log(iterator.next());   // {value: "Tom", done: false}
console.log(iterator.next());   // {value: "Bob", done: false}
console.log(iterator.next());   // {value: "Sam", done: false}
console.log(iterator.next());   // {value: undefined, done: true}
```

##### Удаление из массива повторяющихся элементов
Ограничения объекта `Set` — хранения уникальных значений позволяет эффективно его применять в ряде операций. Например, удаление из массива повторяющихся элементов:
```js
const peopleArray = ["Tom", "Bob", "Sam", "Alice", "Sam", "Kate", "Tom"];
const peopleSet = new Set(peopleArray);
const newPeopleArray = Array.from(peopleSet);

console.log(newPeopleArray);    // ["Tom", "Bob", "Sam", "Alice", "Kate"]
```

Здесь для создания нового массива с неповторяющимися элементами применяется функция **`Array.from()`**, которая в качестве аргумента получает объект `Set`.[^14.3]

#### Ассоциативные массивы Map
Объект **`Map`** или словарь представляет структуру данных, где каждый элемент имеет ключ и значение. Ключи в рамках словаря являются уникальными, то есть с одним ключом может быть сопоставлен только один элемент. Для создания словаря применяется конструктор объекта **`Map`**:
```js
const myMap = new Map();
```

Также можно инициализировать словарь начальными значениями. Для этого в конструктор передается массив, элементы которого представляют массивы из двух элементов — первый элемент будет выступать в качестве ключа, а второй — в качестве значения:
```js
const myMap = new Map([[1, "a"], [2, "b"], [3, "c"]]);
console.log(myMap);     // Map(3){1 => "a", 2 => "b", 3 => "c"}
```

В данном случае числа 1, 2, 3 являются ключами, а строки "a", "b", "c" — значениями.

При этом ключи и значения необзательно должны быть одного типа. Тип ключей и значений может совпадать:
```js
const dict = new Map([["red", "красный"], ["green", "зеленый"], ["blue", "синий"]]);
console.log(dict);  // Map(3) {"red" =>"красный", "green"=> "зеленый", "blue"=>"синий"}
```

##### Размер словаря
С помощью свойства **`size`** можно проверить количество элементов в `Map`:
```js
const dict = new Map([["red", "красный"], ["green", "зеленый"], ["blue", "синий"]]);
console.log(dict.size);     // 3
```

##### Добавление и изменение элементов
Для установки значения применяется метод **`set()`**:
```js
const dict = new Map([["red", "красный"], ["green", "зеленый"], ["blue", "синий"]]);
dict.set("yello", "желтый");        // добавление элемента
dict.set("red", "червонный");       // изменение элемента
console.log(dict);      // Map(4) {"red" => "червонный", "green" => "зеленый", "blue" => "синий", "yello" => "желтый"}
```

Первый параметр метода `set()` представляет ключ, а второй параметр — значение элемента. Если по такому ключу нет элементов, то добавляется новый элемент. Если ключ уже есть, то уже имеющийся элемент изменяет свое значение.

##### Получение элементов
Для получения элемента по ключу применяется метод **`get()`**, в который передается ключ элемента:
```js
const dict = new Map([["red", "красный"], ["green", "зеленый"], ["blue", "синий"]]);
console.log(dict.get("red"));  // красный
console.log(dict.get("violet"));  // undefined
```

Если `map` не содержит элемента по заданному ключу, то метод возвращает `undefined`.

Чтобы избежать возвращения `undefined` мы можем проверить наличие элемента по ключу с помощью метода **`has()`**. Если элемент по ключу имеется, то метод возвращает `true`, иначе возвращается `false`:
```js
const dict = new Map([["red", "красный"], ["green", "зеленый"], ["blue", "синий"]]);
console.log(dict.has("red"));  // true
console.log(dict.has("violet"));  //  false

if(dict.has("red")) console.log(dict.get("red"));   // красный
```

##### Удаление элементов
Для удаления одного элемента по ключу применяется метод **`delete()`**:
```js
const dict = new Map([["red", "красный"], ["green", "зеленый"], ["blue", "синий"]]);
dict.delete("red");
console.log(dict);  // Map(2){"green" => "зеленый", "blue" => "синий"}
```

Для удаления всех элементов используется метод **`clear()`**:
```js
const dict = new Map([["red", "красный"], ["green", "зеленый"], ["blue", "синий"]]);
dict.clear();
console.log(dict);  // Map(0){}
```

##### Перебор элементов
Для перебора элементов используется метод **`forEach`**:
```js
const dict = new Map([["red", "красный"], ["green", "зеленый"], ["blue", "синий"]]);
dict.forEach(function(value, key, map){
    console.log(key, ":", value);
})
```

Метод `forEach` в качестве параметра получает функцию обратного вызова, которая имеет три параметра. Первый и второй параметры - это соответственно значение и ключ текущего перебираемого элемента, а третий параметр — перебираемый объект `Map`.

Консольный вывод данного примера:
```
red : красный
green : зеленый
blue : синий
```

Также для перебора объекта `Map` можно использовать циклы, например, цикл `for...of`:
```js
const dict = new Map([["red", "красный"], ["green", "зеленый"], ["blue", "синий"]]);

for(item of dict){
    console.log(item[0], ":", item[1]);
}
```

Каждый элемент из `Map` помещается в переменную `item`, которая в свою очередь представляет массив. Первый элемент этого массива — ключ, а второй элемент — значение элемента.[^14.4]

Также объект Map имеет два дополнительных метода: **`keys()`** позволяет перебрать только ключи и **`values()`** позволяет перебирать значения элементов. Оба метода возвращают итераторы, поэтому для перебора ключей и значений по отдельности также можно использовать цикл `for...of`:
```js
const dict = new Map([["red", "красный"], ["green", "зеленый"], ["blue", "синий"]]);

for(item of dict.keys()){
    console.log(item);
}
// Консольный вывод:
// red
// green
// blue
for(item of dict.values()){
    console.log(item);
}
// Консольный вывод:
// красный
// зеленый
// синий
```

#### Слабоссылаемые множества
Объект **`WeakSet`** во многом похож на обычное множество. Он также может хранить только уникальные значения, но каждый его элемент должен представлять объект.[^14.5]

Для создания объекта `WeakSet` используется его конструктор, в который можно передать начальные значения:
```js
// пустой WeakSet
const weakSet1 = new WeakSet();
// инициализация начальными значениями
const weakSet2 = new WeakSet([{name:"Tom", age: 37}, {name:"Alice", age: 34}]);
```

Для инициализации как в случае с объектом `Set` в конструктор передается массив, но данный массив содержит именно объекты, а не скалярные значения, типа чисел или строк.

Для добавления данных в `WeakSet` применяется метод **`add()`**:
```js
const weakSet = new WeakSet();
weakSet.add({lang: "JavaScript"});
weakSet.add({lang: "TypeScript"});
// weakSet.add(34); // так нельзя - 34 - число, а не объект
console.log(weakSet);   // {{lang: "JavaScript"}, {lang: "TypeScript"}}
```

Причем опять же добавить мы можем только объект, а не скалярные значения типа чисел или строк.

Для удаления применяется метод **`delete()`**, в который передается ссылка на удаляемый объект:
```js
const weakSet = new WeakSet();
const js = {lang: "JavaScript"};
const ts = {lang: "TypeScript"};
weakSet.add(js);
weakSet.add(ts);

weakSet.delete(js);

console.log(weakSet);   // {{lang: "TypeScript"}}
```

Если надо проверить, имеется ли объект в `WeakSet`, то можно использовать метод **`has()`**, который возвращает `true` при наличии объекта:
```js
const js = {lang: "JavaScript"};
const ts = {lang: "TypeScript"};
const java = {lang: "Java"};
const weakSet = new WeakSet([js, ts]);
console.log(weakSet.has(ts));       // true
console.log(weakSet.has(java));     //  false
```

##### Перебор WeakSet
Стоит отметить, что `WeakSet` не поддерживает перебор ни с помощью метода `forEach`, которого у `WeakSet` нет, ни с помощью цикла `for`. Например. если мы попробуем перебрать `WeakSet` через цикл `for..of`:
```js
const weakSet = new WeakSet([
    {lang: "JavaScript"},
    {lang: "TypeScript"},
    {lang: "Java"}
]);


for(item of weakSet){
    console.log(item);
}
```

То мы получим ошибку
```
Uncaught TypeError: weakSet is not iterable
```

##### Слабые ссылки
Объекты передаются в `WeakSet` по ссылке. И отличительной особенностью `WeakSet` является то, что когда объект перестает существовать в силу различных причин, он удаляется из `WeakSet`. Так, рассмотрим следующий пример:
```js
let js = {lang: "JavaScript"};
let ts = {lang: "TypeScript"};
const weakSet = new WeakSet([js, ts]);

js = null;

console.log(weakSet);   // {{lang: "JavaScript"}, {lang: "TypeScript"}}
console.log("Некоторая работа");
const timerId = setTimeout(function(){
    console.log(weakSet);   // {{lang: "TypeScript"}}
    clearTimeout(timerId);
}, 20000);
```

В данном случае сначала объект `WeakSet` хранит ссылки на два объекта: `js` и `ts`. Далее мы устанавливаем значение для переменной `js` в `null`.

Это приведет к тому, что спустя некоторое время начальное значение этой переменной будет удалено сборщиком мусора JavaScript.

```js
js = null;
```

Причем если сразу после этого мы посмотрим на содержимое `weakSet`, то увидим, что объект `js` в нем еще присутствует. Однако спустя некоторое время ссылка будет удалена из `weakSet`. Для эмуляции прошествия времени здесь используется функция `setTimeout`, которая выводит на консоль содержимое `weakSet` через 9000 секунд (конкретный период времени, через который сборщик мусора удалит значение, может отличаться)

Теперь сравним с тем, что произойдет, если вместо `WeakSet` использовать **`Set`**:
```js
let js = {lang: "JavaScript"};
let ts = {lang: "TypeScript"};
const set = new Set([js, ts]);

js = null;

console.log(set);   // Set(2) {{lang: "JavaScript"}, {lang: "TypeScript"}}
console.log("Некоторая работа");
const timerId = setTimeout(function(){
    console.log(set);   // Set(2){{lang: "JavaScript"}, {lang: "TypeScript"}}
    clearTimeout(timerId);
}, 20000);
```

В случае с `Set` даже спустя некоторое время мы увидим, что в объекте `Set` до сих пор присутствует объект, для которого было установлено значение `null`.

#### Слабоссылочные словари
`WeakMap` представляет развитие коллекции `Map`. Особенностью `WeakMap` является то, что все ее элементы должны представлять объекты. При этом ключи должны представлять объекты.[^14.6]

Создание `WeakMap`:
```js
// пустой WeakMap
const weakMap1 = new WeakMap();

// WeakMap с инициализацией данными
let key1 = {key:1};
let key2 = {key:2};
let value1 = {name: "Tom"};
let value2 = {name: "Sam"};

const weakMap2 = new WeakMap([[key1, value1], [key2, value2]]);
// или так
// const weakMap2 = new WeakMap([[{key:1}, {name: "Tom"}], [{key:2}, {name: "Sam"}]]);
```

Стоит отметить, что объект `WeakMap` не поддерживает перебор.

Для добавления новых объектов или изменения старых применяется метод **`set()`**:
```js
let key1 = {key:1};
let key2 = {key:2};
let value1 = {name: "Tom"};
let value2 = {name: "Sam"};

const weakMap2 = new WeakMap([[key1, value1]]);
weakMap2.set(key2, value2);
weakMap2.set(key1, {name: "Kate"});
console.log(weakMap2.get(key1));    //{name: "Kate"}
console.log(weakMap2.get(key2));    //{name: "Sam"}
```

Для получения объектов по ключу из WeakMap применяется метод **`get()`**:
```js
let key1 = {key:1};
let key2 = {key:2};
let value1 = {name: "Tom"};
let value2 = {name: "Sam"};

const weakMap2 = new WeakMap([[key1, value1], [key2, value2]]);
console.log(weakMap2.get(key1));    // {name: "Tom"}
```

Чтобы проверить наличие элемента по определенному ключу, применяется метод **`has()`**, который возвращает `true` при наличии элемента:
```js
let key1 = {key:1},
    key2 = {key:2};
let value1 = {name: "Tom"},
    value2 = {name: "Sam"};

const weakMap2 = new WeakMap([[key1, value1]]);
console.log(weakMap2.has(key1));    // true
console.log(weakMap2.has(key2));    // false
```

Для удаления элемента по ключу применяется метод **`delete()`**:
```js
let key1 = {key:1},
    key2 = {key:2};
let value1 = {name: "Tom"},
    value2 = {name: "Sam"};

const weakMap2 = new WeakMap([[key1, value1], [key2, value2]]);
console.log(weakMap2.has(key1));    // true
weakMap2.delete(key1);
console.log(weakMap2.has(key1));    // false
```

##### Слабые ссылки
Объекты передаются в `WeakMap` по ссылке. И отличительной особенностью `WeakMap` является то, что когда объект перестает существовать в силу различных причин, он удаляется из `WeakMap`. Рассмотрим следующий пример:
```js
let jsCode = {code: "js"},
    tsCode = {code: "ts"};
let js = {lang: "JavaScript"},
    ts = {lang: "TypeScript"};
const weakMap = new WeakMap([[jsCode, js], [tsCode, ts]]);

jsCode = null;

console.log(weakMap);   // WeakMap {{code: "js"} => {lang: "JavaScript"}, {code: "ts"} => {lang: "TypeScript"}}
console.log("Некоторая работа");
const timerId = setTimeout(function(){
    console.log(weakMap);   // WeakMap {{code: "ts"} => {lang: "TypeScript"}}
    clearTimeout(timerId);
}, 30000);
```

В данном случае сначала объект `WeakMap` хранит ссылки на два элемента с ключами `jsCode` и `tsCode`. Далее для переменной `jsCode` устанавливается значение `null`.

```js
jsCode = null;
```

Это приведет к тому, что спустя некоторое время начальное значение этой переменной будет удалено сборщиком мусора JavaScript.

Причем если сразу после этого мы посмотрим на содержимое `weakMap`, то увидим, что объект с ключом `jsCode` в нем еще присутствует. Однако спустя некоторое время ссылка будет удалена из `weakSet`. Для эмуляции прошествия времени здесь используется функция `setTimeout`, которая выводит на консоль содержимое `weakSet` через 10000 секунд (конкретный период времени, через который сборщик мусора удалит значение, может отличаться).

Теперь сравним с тем, что произойдет, если вместо `WeakMap` использовать `Map`:
```js
let jsCode = {code: "js"},
    tsCode = {code: "ts"};
let js = {lang: "JavaScript"},
    ts = {lang: "TypeScript"};
const map = new Map([[jsCode, js], [tsCode, ts]]);

jsCode = null;

console.log(map);   // Map(2) {{code: "js"} => {lang: "JavaScript"}, {code: "ts"} => {lang: "TypeScript"}}
console.log("Некоторая работа");
const timerId = setTimeout(function(){
    console.log(map);   // Map(2) {{code: "js"} => {lang: "JavaScript"}, {code: "ts"} => {lang: "TypeScript"}}
    clearTimeout(timerId);
}, 30000);
```

В случае с `Map` даже спустя некоторое время мы увидим, что в объекте `Map` до сих пор присутствует объект, для которого было установлено значение `null`.

### Источники информации
[^5.1]: [Объект Date. Работа с датами](https://metanit.com/web/javascript/5.1.php)
[^5.2]: [Объект Math. Математические операции](https://metanit.com/web/javascript/5.2.php)
[^5.4]: [Объект Number](https://metanit.com/web/javascript/5.4.php)
[^5.5]: [Символы](https://metanit.com/web/javascript/5.5.php)
[^5.9]: [Proxy](https://metanit.com/web/javascript/5.9.php)
[^14.3]: [Множества Set](https://metanit.com/web/javascript/14.3.php)
[^14.4]: [Map](https://metanit.com/web/javascript/14.4.php)
[^14.5]: [WeakSet](https://metanit.com/web/javascript/14.5.php)
[^14.6]: [WeakMap](https://metanit.com/web/javascript/14.6.php)
[^6.1]: [Строки](https://metanit.com/web/javascript/6.1.php)
[^6.5]: [Шаблоны строк](https://metanit.com/web/javascript/6.5.php)
