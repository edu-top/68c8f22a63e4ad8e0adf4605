## События

- [События](#события)
  - [Введение в обработку событий](#введение-в-обработку-событий)
    - [Базовые события](#базовые-события)
  - [Обработчики событий](#обработчики-событий)
    - [Встроенные обработчики](#встроенные-обработчики)
    - [Свойства обработчиков событий](#свойства-обработчиков-событий)
    - [Слушатели событий](#слушатели-событий)
  - [Передача данных в обработчик события. Объект Event](#передача-данных-в-обработчик-события-объект-event)
    - [Объект Event](#объект-event)
    - [Остановка выполнения события](#остановка-выполнения-события)
    - [Получение текущего объекта](#получение-текущего-объекта)
  - [Распространение событий](#распространение-событий)
    - [Восходящие события](#восходящие-события)
      - [Всплытие](#всплытие)
      - [Прекращение всплытия](#прекращение-всплытия)
    - [event.target](#eventtarget)
    - [Нисходящие события](#нисходящие-события)
      - [Погружение](#погружение)
    - [Итого](#итого)
  - [Программный вызов событий](#программный-вызов-событий)
    - [Конструктор Event](#конструктор-event)
    - [Метод dispatchEvent](#метод-dispatchevent)
    - [MouseEvent, KeyboardEvent и другие](#mouseevent-keyboardevent-и-другие)
  - [Определение своих событий](#определение-своих-событий)
    - [Пример всплытия](#пример-всплытия)
    - [CustomEvent](#customevent)
    - [event.preventDefault()](#eventpreventdefault)
    - [Вложенные события обрабатываются синхронно](#вложенные-события-обрабатываются-синхронно)
    - [Итого](#итого-1)
  - [Источники информации](#источники-информации)

### Введение в обработку событий
Для взаимодействия с пользователем в JavaScript определен механизм событий. Например, когда пользователь нажимает кнопку, то возникает событие нажатия кнопки. Аналогично когда пользователь вводит в текстовое поле текст, возникает событие этого текстового поля. В коде JavaScript мы можем определить возникновение события и как-то его обработать.

Вкратце общий механизм выглядит следующим образом. Сначала собственно происходит событие, например, пользователь нажал на кнопку. Объект, который сгенерировал событие, еще называется эмиттером/эмитентом события. После того как произошло событие, оно помещается в очередь событий (*event queue*), что гарантирует, что события, которые были сгенерированы первыми, также будут обработаны в первую очередь. Цикл событий (*event loop*) постоянно проверяет, есть ли новое событие в очереди событий, и если оно есть, соответствующее событие пересылается обработчикам событий (*event handler*). В JavaScript эти обработчики событий представляют собой простые функции, которые позволяют отреагировать на возникшее событие. Подобный подход еще называют событийным программированием (*event-driven programming*).[^9.1]

![Событийный цикл в языке JavaScript](../img/event_loop.png)

Если для события не определено обработчиков, то для него выполняется действие, которое определено браузером по умолчанию.

В JavaScript есть следующие типы событий:

- События мыши (перемещение курсора, нажатие мыши и т.д.)

- События клавиатуры (нажатие или отпускание клавиши клавиатуры)

- События жизненного цикла элементов (например, событие загрузки веб-станицы)

- События элементов форм (нажатие кнопки на форме, выбор элемента в выпадающем списке и т.д.)

- События, возникающие при изменении элементов DOM

- События, возникающие при касании на сенсорных экранах

- События, возникающие при возникновении ошибок

Стоит отметить, что применение событий не ограничены только графическим интерфейсом, однако графический интерфейс — наиболее показательная сфера применения событий.

Рассмотрим простейшую обработку событий. Например, на веб-странице у нас есть следующий элемент `div`:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <div id="rect" onclick="console.log('Clicked!')" style="width:50px;height:50px;background-color:blue;"></div>
</body>
</html>
```

Здесь определен обычный блок `div`, который имеет атрибут **`onclick`**, который задает **обработчик события** нажатия на блок `div`. То есть, чтобы обработать какое-либо событие, нам надо определить для него обработчик. Обработчик представляет собой код на языке JavaScript. В данном случае обработчик просто выводит строку на консоль:
```js
console.log('Clicked!')
```

И при нажатии на блок мы сможем увидеть в консоли браузера соответствующее сообщение:

![Обработка событий в языке JavaScript](../img/events.png)

#### Базовые события
Вкратце перечислю основные события, которые мы можем использовать в JavaScript.

*События мыши*:

Событие | Описание | Объект события
-- | -- | --
`click` | возникает при нажатии указателем мыши на элемент | `MouseEvent`
`dblclick` | возникает при двойном нажатии указателем мыши на элемент | `MouseEvent`
`contextmenu` | возникает при открытии контекстного меню (правой кнопкой мыши) | `MouseEvent`
`mousedown` | возникает при нахождении указателя мыши на элементе, когда кнопка мыши находится в нажатом состоянии | `MouseEvent`
`mouseup` | возникает при нахождении указателя мыши на элементе во время отпускания кнопки мыши | `MouseEvent`
`mousemove` | возникает при прохождении указателя мыши над элементом | `MouseEvent`
`mouseover` | возникает при вхождении указателя мыши в границы элемента | `MouseEvent`
`mouseout` | возникает, когда указатель мыши выходит за пределы элемента | `MouseEvent`
`mouseenter` | возникает при вхождении указателя мыши в границы элемента | `MouseEvent`
`mouseleave` | возникает, когда указатель мыши выходит за пределы элемента | `MouseEvent`

*События клавиатуры*:

Событие | Описание | Объект события
-- | -- | --
`keydown` | возникает при нажатии клавиши клавиатуры и длится, пока нажата клавиша | `KeyboardEvent`
`keyup` | возникает при отпускании клавиши клавиатуры | `KeyboardEvent`
`keypress` | возникает при нажатии клавиши клавиатуры, но после события `keydown` и до события `keyup`. | `KeyboardEvent`

*События элементов форм*:

Событие | Описание | Объект события
-- | -- | --
`input` | возникает при изменении текста в элементах `<input>` и `textarea` или в элемент с атрибутом `contenteditable` | `Event`
`change` | возникает при изменении значения в списках, флажках (`checkbox`) или радиокнопках | `Event`
`submit` | возникает при отправке формы | `Event`
`reset` | возникает при сбросе формы (через кнопку `reset`) | `Event`

*События фокусировки*:

Событие | Описание | Объект события
-- | -- | --
`focus` | возникает при получении фокуса | `FocusEvent`
`blur` | возникает при потере фокуса | `FocusEvent`
`focusin` | возникает при получении фокуса (в отличие от события `focus`, это событие поднимающееся. Про поднимающиеся и опускающиеся события далее) | `FocusEvent`
`focusout` | возникает при потере фокуса (это событие поднимающееся в отличие от события `blur`) | `FocusEvent`

Общие события интерфейса:

Событие | Описание | Объект события
-- | -- | --
`load` | возникает при загрузке веб-страницы | `UIEvent`
`unload` | возникает при выгрузке веб-страницы (например, когда запрошена страница по новому адресу) | `UIEvent`
`abort` | возникает при отмене загрузки ресурса | `UIEvent`
`Error` | возникает при генерации ошибки при загрузке страницы (например, ошибка в коде JavaScript) | `UIEvent`
`select` | возникает при выделении текст на странице | `UIEvent`
`resize` | возникает при изменении размеров окна браузера | `UIEvent`
`scroll` | возникает при прокрутке | `UIEvent`
`beforeunload` | возникает непосредственно перед выгрузкой страницы | `BeforeUnloadEvent`
`DOMContentLoaded` | возникает при полной загрузке дерева DOM | `Event`
`cut` | возникает при вырезании текста из поля ввода (например, с помощью <kbd>Ctrl</kbd>+<kbd>X</kbd>) | `ClipboardEvent`
`copy` | возникает при копировании текста из поля ввода (например, с помощью <kbd>Ctrl</kbd>+<kbd>C</kbd>) | `ClipboardEvent`
`paste` | возникает при вставке текста в поле ввода (например, с помощью <kbd>Ctrl</kbd>+<kbd>V</kbd>) | `ClipboardEvent`
`select` | возникает при выделении текста в поле ввода | `ClipboardEvent`

*События мобильных устройств и других устройств с сенсорным экраном*:

Событие | Описание | Объект события
-- | -- | --
`orientationchange` | возникает при изменении ориентации устройства | `Event`
`deviceorientation` | возникает, когда появляются новые данные об ориентации устройства | `DeviceOrientationEvent`
`devicemotion` | возникает с регулярными интервалами и указывает на силу ускорения, действующую на конечное устройство | `DeviceMotionEvent`
`touchstart` | возникает при касании дисплея | `TouchEvent`
`touchend` | возникает, когда палец убран с дисплея (касание завершилось) | `TouchEvent`
`touchmove` | возникает при движении пальцем по сенсорному дисплею | `TouchEvent`
`touchcancel` | возникает при прерывании отслеживания касаний | `TouchEvent`

### Обработчики событий
Если в коде JavaScript возникает событие, то его обрабатывает связанный с этим событием обработчик. Рассмотрим, как определять обработчики событий.[^9.2]

#### Встроенные обработчики
Самый простой способ определения обработчиков событий — их установка в коде html. Это так называемые встроенные обработчики или inline-обработчики, которые определяются в коде элемента с помощью атрибутов. Подобные атрибуты начинаются с префикса **`on`**. Например, у многих html-элементов есть атрибут **`on`**`click`, который определяет обработчик нажатия элемента. Посмотрим на примере кнопки:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <button onclick="console.log('Clicked!')">Click Me</div>
</body>
</html>
```

С помощью атрибута `onclick="console.log('Clicked!')"` к кнопке прикрепляется обработчик ее нажатия. Этот обработчик состоит из одной инструкции JavaScript — `console.log("Clicked!")`, которая выводит сообщение на консоль. Таким образом, при нажатии на кнопку сработает событие нажатия, и будет выполняться обработчик из атрибута `onclick`:

![Обработка событий в языке JavaScript](../img/events2.png)

Можно даже определить несколько инструкций подобным образом:
```html
<button onclick="console.log('Hello');console.log('Clicked!')">Click Me</div>
```

Но, очевидно, что это не самый удобный способ. Но также можно вынести все инструкции в отдельную функцию JavaScript. А атрибуту `onclick` передать вызов этой функции:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <button onclick="btn_click()">Click Me</div>
    <script>
    let clicks = 0;     // счетчик нажатий
    function btn_click(){
        console.log("Clicked", ++clicks);
    }
    </script>
</body>
</html>
```

Теперь по нажатию кнопки будет вызываться функция `btn_click`, которая определена в коде JavaScript.

Хотя этот подход прекрасно работает, но он имеет кучу недостатков:

- Код html смешивается с кодом JavaScript, в связи с чем становится труднее разрабатывать, отлаживать и поддерживать приложение

- Обработчики событий можно задать только для уже созданных на веб-странице элементов. Динамически создаваемые элементы в этом случае лишаются возможности обработки событий

- К элементу для одного события может быть прикреплен только один обработчик

- Нельзя удалить обработчик без изменения кода

#### Свойства обработчиков событий
Проблемы, которые возникают при использовании встроенных обработчиков, были призваны решить свойства обработчиков. Подобно тому, как у html-элементов есть атрибуты для обработчиков, так и в коде javascript у элементов DOM мы можем получить свойства обработчиков, которые соответствуют атрибутам:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <button id="btn">Click Me</div>
    <script>
    let clicks = 0;     // счетчик нажатий
    function btn_click(){
        console.log("Clicked", ++clicks);
    }
    // устанавливаем обработчик нажатия для элемента с id="btn"
    document.getElementById("btn").onclick = btn_click;
    </script>
</body>
</html>
```

В итоге нам достаточно взять свойство **`onclick`** и присвоить ему функцию, используемую в качестве обработчика. За счет этого код html отделяется от кода javascript.

#### Слушатели событий
Несмотря на то, что свойства обработчиков решают ряд проблем, которые связаны с использованием атрибутов, в то же время это также не оптимальный подход. Еще один способ установки обработчиков событий представляет использование слушателей.

Для работы со слушателями событий в JavaScript есть объект **`EventTarget`**, который определяет методы **`addEventListener()`** (для добавления слушателя) и **`removeEventListener()`** для удаления слушателя. И поскольку html-элементы DOM тоже являются объектами `EventTarget`, то они также имеют эти методы. Фактически слушатели представляют те же функции обработчиков.

Метод `addEventListener()` принимает два параметра: название события без префикса `on` и функцию обработчика этого события. Например:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>METANIT.COM</title>
</head>
<body>
    <button id="btn">Click Me</div>
    <script>
    let clicks = 0;     // счетчик нажатий
    function btn_click(){
        console.log("Clicked", ++clicks);
    }
    const btn = document.getElementById("btn");
    // прикрепляем обработчик события "click"
    btn.addEventListener("click", btn_click);
    </script>
</body>
</html>
```

То есть в данном случае опять же обрабатывается событие `click`. Удаление слушателя аналогично добавлению:
```js
rect.removeEventListener("click", btn_click);
```

Преимуществом использования слушателей является и то, что мы можем установить для одного события несколько функций:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <button id="btn">Click Me</div>
    <script>
    let clicks = 0;     // счетчик нажатий
    function btn_click(){
        console.log("Clicked", ++clicks);
    }
    const btn = document.getElementById("btn");

    // прикрепляем первый обработчик события "click" в виде функции btn_click
    btn.addEventListener("click", btn_click);

    // прикрепляем второй обработчик события "click" в виде анонимной функции
    btn.addEventListener("click", function(){
        console.log("Button clicked!")
    });

    // прикрепляем третий обработчик события "click" в виде стрелочной функции
    btn.addEventListener("click", ()=>console.log("Element clicked!"));

    </script>
</body>
</html>
```

### Передача данных в обработчик события. Объект Event
Иногда возникает необходимость передать в обработчик некоторые данные. Если обработчики событий устанавливаются с помощью атрибутов элементов, то это сделать довольно просто. Например, передадим в обработчик нажатия кнопки текст, которые будет использоваться в обработчике:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <button id="btn" onclick="btn_click('Button Clicked')">Click Me</button>
    <script>
    // в обработчик передается текст
    function btn_click(text){
        console.log(text);  // выводим этот текст
    }
    </script>
</body>
</html>
```

Итак, здесь в обработчик кнопки передается некоторый текст:
```html
<button id="btn" onclick="btn_click('Button Clicked')">
```

В функции обработчика получаем этот текст и некоторым образом его используем, например, выводим на консоль:
```js
function btn_click(text){
    console.log(text);  // выводим этот текст
}
```

В данном случае в функцию обработчика передавалась строка, но в реальности, это может быть любой объект. Например, через значение **`this`** можно передать текущий объект, на котором возникает событие:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <button id="btn" onclick="btn_click(this)">Click Me</button>
    <script>
    let clicks = 0;     // счетчик нажатий
    // в обработчик передается ссылка на элемент кнопки
    function btn_click(btn){
        // изменяем текст кнопки
        btn.textContent = `Clicked ${++clicks}`;
    }
    </script>
</body>
</html>
```

Ключевое слово `this` указывает на текущий объект ссылки, на которую производится нажатие. И в коде обработчика мы можем получить этот объект и обратиться к его свойствам, например, к свойству textContent и таким образом изменить текст кнопки.

Стоит отметить, что в некоторых случаях нам может потребоваться возвращать из обработчика значение `false`. Например, рассмотрим следующую программу:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <a id="link" href="https://example.com" onclick="return a_click(this)">example</a>
    <script>
    // в обработчик передается ссылка
    function a_click(anchor){
        // получаем адрес ссылки
        console.log(anchor.href);
        return false;   // запрещаем переадресацию
    }
    </script>
</body>
</html>
```

Здесь в атрибуте `onclick` ссылки — элемента `<a>` не просто вызывается обработчик события, а возвращается его результат:
```html
<a id="link" href="https://metanit.com" onclick="return a_click(this)">
```

Причем функция обработчика возвращает **`false`**:
```js
function a_click(anchor){
    console.log(anchor.href);
    return false;   // запрещаем переадресацию
}
```

Дело в том, что для некоторых обработчиков можно подтвердить или остановить обработку события. Например, нажатие на ссылку должно привести к переадресации. Но возвращая из обработчика **`false`**, мы можем остановить стандартный путь обработки события, и переадресации не будет. Если же возвращать значение `true`, то событие обрабатывается в стандартном порядке.

Если же мы вовсе уберем возвращении результата, то событие будет обрабатываться, как будто возвращается значение `true`:
```html
<a id="link" href="https://metanit.com" onclick="a_click(this)">Metanit.com</a>
<script>
function a_click(anchor){
    console.log(anchor.href);
}
</script>
```

#### Объект Event
При обработке события браузер автоматически передает в функцию обработчика в качестве параметра объект **`Event`**, который инкапсулирует всю информацию о событии. И с помощью его свойств мы можем получить эту информацию:

- **`bubbles`**: возвращает `true`, если событие является восходящим. Например, если событие возникло на вложенном элементе, то оно может быть обработано на родительском элементе.

- **`cancelable`**: возвращает `true`, если можно отменить стандартную обработку события

- **`currentTarget`**: определяет элемент, к которому прикреплен обработчик события

- **`defaultPrevented`**: возвращает `true`, если был вызван у объекта `Event` метод `preventDefault()`

- **`eventPhase`**: хранит число, которое представляет стадию обработки события. Возможные значения:

  - `0` (`Event.NONE`)

  - `1` (`Event.CAPTURING_PHASE`)

  - `2` (`Event.AT_TARGET`)

  - `3` (`Event.BUBBLING_PHASE`)

- **`target`**: указывает на элемент, на котором было вызвано событие

- **`timeStamp`**: хранит время возникновения события

- **`type`**: указывает на имя события

- **`isTrusted`**: указывает, событие было сгенерировано элементами веб-страницы или кодом JavaScript

Например:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <button onclick="btn_click(event)">Click Me</button>
    <script>
    function btn_click(e){
        console.log(e);
    }
    </script>
</body>
</html>
```

При вызове функции-обработчика информация о событии доступна через объект `event`. Этот объект не определяется разработчиком, это просто аргумент функции обработчика, который хранит всю информацию о событии:
```html
<button onclick="btn_click(event)">
```

В коде JavaScript этот объект можно получить через параметр функции:
```js
function btn_click(e){
    console.log(e);
}
```

В данном случае просто выводим объект на консоль. Но естественно также можно было бы получить отдельную конкретную информацию о событии:
```js
function btn_click(e){
    console.log("Type:", e.type);       // Type: click
    console.log("Target:", e.target);   // Target: <button onclick=​"btn_click(event)​">​Click Me​</button>​
    console.log("Timestamp:", e.timeStamp);
}
```

Подобным образом мы можем получить объект события, если обработчик события прикрепляется через свойства элементов или через метод **`addEventListener()`**. Например, прикрепеление обработчика через свойство элемента:
```html
<button id="btn">Click Me</button>
<script>
function btn_click(e){
    console.log("Type:", e.type);
    console.log("Target:", e.target);
    console.log("Timestamp:", e.timeStamp);
}
// устанавливаем обработчик нажатия для элемента с id="btn"
document.getElementById("btn").onclick = btn_click;
</script>
```

Или прикрепеление обработчика с помощью метода `addEventListener`:
```html
<button id="btn">Click Me</button>
<script>
function btn_click(e){
    console.log("Type:", e.type);
    console.log("Target:", e.target);
    console.log("Timestamp:", e.timeStamp);
}
const btn = document.getElementById("btn");
// прикрепляем обработчик события "click"
btn.addEventListener("click", btn_click);
</script>
```

#### Остановка выполнения события
С помощью метода **`preventDefault()`** объекта `Event` мы можем остановить дальнейшее выполнение события. В ряде случаев этот метод не играет большой роли. Однако в некоторых ситуаций он может быть полезен. Например, при нажатии на ссылку мы можем с помощью дополнительной обработки определить, надо ли переходить по ссылке или надо запретить переход. Или другой пример: пользователь отправляет данные формы, но в ходе обработки в обработчике события мы определили, что поля формы заполнены неправильно, и в этом случае мы также можем запретить отправку.

Например, остановим переход по ссылке:
```html
<a id="link" href="https://metanit.com">Metanit.com</a>
<script>
function linkHandler(e){
    console.log("Link has been clicked");
    e.preventDefault();     // останавливаем переход по ссылке
}
const link = document.getElementById("link");
link.addEventListener("click", linkHandler);
</script>
```

Здесь по нажатию на ссылку будет срабатывать метод `linkHandler`. И, поскольку в этом методе с помощью вызова `e.preventDefault()` предупреждаем переход по ссылке, то перехода не будет. Данный подход, к примеру, часто используется при ajax-запросах, когда надо обработать нажатие на ссылку, но при этом не выполнять перехода на другой ресурс, а сделать к нему запрос из кода javascript без перезагрузки страницы.

#### Получение текущего объекта
Для получения текущего объекта, для которого обрабатыватся событие, внутри обработчика события мы можем использовать ключевое слово **`this`**:
```html
<button id="btn">Click Me</button>
<script>
const btn = document.getElementById("btn");
function btn_click(){
    console.log(this);  //  <button id="btn">Click Me</button>
}
btn.addEventListener("click", btn_click);
</script>
```

Здесь при обработке события `click` на кнопке объект `this` в функции `btn_click` будет представлять эту кнопку. Фактически в данном случае значения `this` и `event.target` были бы эквивалентны[^9.3]
```js
function btn_click(e){
    console.log(this===e.target); // true
}
```

### Распространение событий
Давайте начнём с примера.

Этот обработчик для `<div>` сработает, если вы кликните по любому из вложенных тегов, будь то `<em>` или `<code>`:
```html
<div onclick="alert('Обработчик!')">
  <em>Если вы кликните на <code>EM</code>, сработает обработчик на <code>DIV</code></em>
</div>
```

![Event propagation](../img/bubbling_01.png)

Вам не кажется это странным? Почему же сработал обработчик на `<div>`, если клик произошёл на `<em>`?[^bubbling-and-capturing]

Когда мы нажимаем на какой-либо элемент на станице и генерируется событие нажатия, то это событие может распространяться от элемента к элементу. Например, если мы нажимаем на блок `div`, то также мы нажимаем и на элемент `body`, в котором блок `div` находится. То есть происходит распространение события.[^9.4]

Есть несколько форм распространения событий:

- **Восходящие**: событие распространяется вверх по дереву DOM от дочерних узлов к родительским

- **Нисходящие**: событие распространяется вниз по дереву DOM от родительских узлов к дочерним, пока не достигнет того элемента, на котором это событие и возникло

#### Восходящие события
Рассмотрим восходящие (`bubbling`) события, которые распространяются в верх по дереву DOM. Допустим, у нас есть следующая веб-страница:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
    <style>
    #blueRect{
        width:100px;
        height:100px;
        background-color:blue;
    }
    #redRect{
        width:50px;
        height:50px;
        background-color:red;
    }
    </style>
</head>
<body>
    <div id="blueRect">
        <div id="redRect"></div>
    </div>
    <script>
    const redRect = document.getElementById("redRect");
    redRect.addEventListener("click", () => console.log("Событие на redRect"));

    const blueRect = document.getElementById("blueRect");
    blueRect.addEventListener("click", ()=>console.log("Событие на blueRect"));

    document.body.addEventListener("click", () => console.log("Событие на body"));
    </script>
</body>
</html>
```

Если мы нажмем на вложенный (красный) `div`, то событие пойдет к родительскому элементу `div` и далее к элементу `body`:

![Восходящие события в JavaScript](../img/bubbling.png)

##### Всплытие
Принцип всплытия очень простой.

**Когда на элементе происходит событие, обработчики сначала срабатывают на нём, потом на его родителе, затем выше и так далее, вверх по цепочке предков.**

Например, есть 3 вложенных элемента `FORM` > `DIV` > `P` с обработчиком на каждом:
```html
<style>
  body * {
    margin: 10px;
    border: 1px solid blue;
  }
</style>

<form onclick="alert('form')">FORM
  <div onclick="alert('div')">DIV
    <p onclick="alert('p')">P</p>
  </div>
</form>
```

![Event propagation](../img/bubbling_02.png)

Клик по внутреннему `<p>` вызовет обработчик `onclick`:

1. Сначала на самом `<p>`.
2. Потом на внешнем `<div>`.
3. Затем на внешнем `<form>`.
4. И так далее вверх по цепочке до самого `document`.

![Event order bubbling](../img/event-order-bubbling.svg)

Поэтому если кликнуть на `<p>`, то мы увидим три оповещения: `p` → `div` → `form`.

Этот процесс называется «всплытием», потому что события «всплывают» от внутреннего элемента вверх через родителей подобно тому, как всплывает пузырёк воздуха в воде.

!!! warning *Почти* все события всплывают.

    Ключевое слово в этой фразе – «почти».

    Например, событие `focus` не всплывает. В дальнейшем мы увидим и другие примеры. Однако, стоит понимать, что это скорее исключение, чем правило, всё-таки большинство событий всплывают.

##### Прекращение всплытия
Надо сказать, что подобное поведение не всегда является желательным. И в этом случае мы можем остановить распространение событие с помощью метода **`stopPropagation()`** объекта `Event`:
```js
const redRect = document.getElementById("redRect");
redRect.addEventListener("click", function(e){
    console.log("Событие на redRect");
    e.stopPropagation();
});
```

И в результате нажатия событие будет обработано только обработчиком для `redRect`.

Всплытие идёт с «целевого» элемента прямо наверх. По умолчанию событие будет всплывать до элемента `<html>`, а затем до объекта `document`, а иногда даже до `window`, вызывая все обработчики на своём пути.

Но любой промежуточный обработчик может решить, что событие полностью обработано, и остановить всплытие.

Для этого нужно вызвать метод `event.stopPropagation()`.

Например, здесь при клике на кнопку `<button>` обработчик `body.onclick` не сработает:
```html
<body onclick="alert(`сюда всплытие не дойдёт`)">
  <button onclick="event.stopPropagation()">Кликни меня</button>
</body>
```

![Event propagation](../img/bubbling_03.png)

Правда, у `stopPropagation()` есть одна проблема — он приостанавливает дальнейшее выполнение **текущего** обработчика. Однако если для одного и того же события элемента прикреплены несколько обработчиков событий, то остальные обработчики продолжать выполняться. И чтобы оставить также выполнение всех остальных обработчиков подобных образом можно вызывать метод **`stopImmediatePropagation`**
```js
const redRect = document.getElementById("redRect");
function handler1(e){
    console.log("handler1: Событие на redRect");
    e.stopImmediatePropagation();   // останавливаем также выполнение handler2
}
function handler2(e){
    console.log("handler2: Событие на redRect");
}
redRect.addEventListener("click", handler1);
redRect.addEventListener("click", handler2);
```

!!! info event.stopImmediatePropagation()

    Если у элемента есть несколько обработчиков на одно событие, то даже при прекращении всплытия все они будут выполнены.

    То есть, `event.stopPropagation()` препятствует продвижению события дальше, но на текущем элементе все обработчики будут вызваны.

    Для того, чтобы полностью остановить обработку, существует метод event.`stopImmediatePropagation()`. Он не только предотвращает всплытие, но и останавливает обработку событий на текущем элементе.

!!! warning Не прекращайте всплытие без необходимости!

Всплытие – это удобно. Не прекращайте его без явной нужды, очевидной и архитектурно прозрачной.

Зачастую прекращение всплытия через `event.stopPropagation()` имеет свои подводные камни, которые со временем могут стать проблемами.

Например:

1. Мы делаем вложенное меню. Каждое подменю обрабатывает клики на своих элементах и делает для них `stopPropagation`, чтобы не срабатывало внешнее меню.
2. Позже мы решили отслеживать все клики в окне для какой-то своей функциональности, к примеру, для статистики – где вообще у нас кликают люди. Некоторые системы аналитики так делают. Обычно используют `document.addEventListener('click'…)`, чтобы отлавливать все клики.
3. Наша аналитика не будет работать над областью, где клики прекращаются `stopPropagation`. Увы, получилась «мёртвая зона».

Зачастую нет никакой необходимости прекращать всплытие. Задача, которая, казалось бы, требует этого, может быть решена иначе. Например, с помощью создания своего уникального события, о том, как это делать, мы поговорим позже. Также мы можем записывать какую-то служебную информацию в объект `event` в одном обработчике, а читать в другом, таким образом мы можем сообщить обработчикам на родительских элементах информацию о том, что событие уже было как-то обработано.

#### event.target
Всегда можно узнать, на каком конкретно элементе произошло событие.

**Самый глубокий элемент, который вызывает событие, называется <dfn title="целевой элемент">целевым элементом</dfn>, и он доступен через `event.target`.**

Отличия от `this` (=`event.currentTarget`):

- `event.target` – это «целевой» элемент, на котором произошло событие, в процессе всплытия он неизменен.
- `this` – это «текущий» элемент, до которого дошло всплытие, на нём сейчас выполняется обработчик.

Например, если стоит только один обработчик `form.onclick`, то он «поймает» все клики внутри формы. Где бы ни был клик внутри – он всплывёт до элемента `<form>`, на котором сработает обработчик.

При этом внутри обработчика `form.onclick`:

- `this` (=`event.currentTarget`) всегда будет элемент `<form>`, так как обработчик сработал на ней.
- `event.target` будет содержать ссылку на конкретный элемент внутри формы, на котором произошёл клик.

Возможна и ситуация, когда `event.target` и `this` – один и тот же элемент, например, если клик был непосредственно на самом элементе `<form>`, а не на его подэлементе.

#### Нисходящие события
События также могут быть нисходящими (*capturing*). Для их использования в метод **`addEventListener()`** в качестве третьего необязательного параметра передается логическое значение `true` или `false`. Значение **`true`** указывает, что событие нисходящим. По умолчанию все события восходящие.

Возьмем ту же веб-станицу, только изменим ее код javascript:
```js
const redRect = document.getElementById("redRect");
redRect.addEventListener("click", function(){
    console.log("Событие на redRect");
}, true);

const blueRect = document.getElementById("blueRect");
blueRect.addEventListener("click", function(){
    console.log("Событие на blueRect");
}, true);

document.body.addEventListener("click", function(){
    console.log("Событие на body");
}, true);
```

Теперь события будут распространяться в обратном порядке:

![Нисходящие события в JavaScript](../img/capturing.png)

##### Погружение
Существует ещё одна фаза из жизненного цикла события – «погружение» (иногда её называют «перехват»). Она очень редко используется в реальном коде, однако тоже может быть полезной.

Стандарт **DOM Events** описывает 3 фазы прохода события:

1. Фаза погружения (capturing phase) – событие сначала идёт сверху вниз.
2. Фаза цели (target phase) – событие достигло целевого(исходного) элемента.
3. Фаза всплытия (bubbling stage) – событие начинает всплывать.

Картинка из спецификации демонстрирует, как это работает при клике по ячейке `<td>`, расположенной внутри таблицы:

![Event flow](../img/eventflow.svg)

То есть при клике на `<td>` событие путешествует по цепочке родителей сначала вниз к элементу (погружается), затем оно достигает целевой элемент (фаза цели), а потом идёт наверх (всплытие), вызывая по пути обработчики.

**Ранее мы говорили только о всплытии, потому что другие стадии, как правило, не используются и проходят незаметно для нас.**

Обработчики, добавленные через `on<event>`-свойство или через HTML-атрибуты, или через `addEventListener(event, handler)` с двумя аргументами, ничего не знают о фазе погружения, а работают только на 2-ой и 3-ей фазах.

Чтобы поймать событие на стадии погружения, нужно использовать третий аргумент `capture` вот так:
```js
elem.addEventListener(..., {capture: true})
// или просто "true", как сокращение для {capture: true}
elem.addEventListener(..., true)
```

Существуют два варианта значений опции `capture`:

- Если аргумент `false` (по умолчанию), то событие будет поймано при всплытии.
- Если аргумент `true`, то событие будет перехвачено при погружении.

Обратите внимание, что хоть и формально существует 3 фазы, 2-ую фазу («фазу цели»: событие достигло элемента) нельзя обработать отдельно, при её достижении вызываются все обработчики: и на всплытие, и на погружение.

Давайте посмотрим и всплытие и погружение в действии:
```html
<style>
  body * {
    margin: 10px;
    border: 1px solid blue;
  }
</style>

<form>FORM
  <div>DIV
    <p>P</p>
  </div>
</form>

<script>
  for(let elem of document.querySelectorAll('*')) {
    elem.addEventListener("click", e => alert(`Погружение: ${elem.tagName}`), true);
    elem.addEventListener("click", e => alert(`Всплытие: ${elem.tagName}`));
  }
</script>
```

![Event propagation](../img/bubbling_04.png)

Здесь обработчики навешиваются на *каждый* элемент в документе, чтобы увидеть в каком порядке они вызываются по мере прохода события.

Если вы кликните по `<p>`, то последовательность следующая:

1. `HTML` → `BODY` → `FORM` → `DIV` (фаза погружения, первый обработчик)
2. `P` (фаза цели, срабатывают обработчики, установленные и на погружение и на всплытие, так что выведется два раза)
3. `DIV` → `FORM` → `BODY` → `HTML` (фаза всплытия, второй обработчик)

Существует свойство `event.eventPhase`, содержащее номер фазы, на которой событие было поймано. Но оно используется редко, мы обычно и так знаем об этом в обработчике.

!!! info Чтобы убрать обработчик `removeEventListener`, нужна та же фаза

    Если мы добавили обработчик вот так `addEventListener(..., true)`, то мы должны передать то же значение аргумента capture в `removeEventListener(..., true)`, когда снимаем обработчик.

!!! info На каждой фазе разные обработчики на одном элементе срабатывают в порядке назначения

    Если у нас несколько обработчиков одного события, назначенных `addEventListener` на один элемент, в рамках одной фазы, то их порядок срабатывания – тот же, в котором они установлены:
    ```js
    elem.addEventListener("click", e => alert(1)); // всегда сработает перед следующим
    elem.addEventListener("click", e => alert(2));
    ```

#### Итого
При наступлении события – самый глубоко вложенный элемент, на котором оно произошло, помечается как «целевой» (`event.target`).

- Затем событие сначала двигается вниз от корня документа к `event.target`, по пути вызывая обработчики, поставленные через `addEventListener(...., true)`, где `true` – это сокращение для `{capture: true}`.
- Далее обработчики вызываются на целевом элементе.
- Далее событие двигается от `event.target` вверх к корню документа, по пути вызывая обработчики, поставленные через `on<event>` и `addEventListener` без третьего аргумента или с третьим аргументом равным `false`.

Каждый обработчик имеет доступ к свойствам события `event`:

- `event.target` – самый глубокий элемент, на котором произошло событие.
- `event.currentTarget` (=`this`) – элемент, на котором в данный момент сработал обработчик (тот, на котором «висит» конкретный обработчик)
- `event.eventPhase` – на какой фазе он сработал (погружение=1, фаза цели=2, всплытие=3).

Любой обработчик может остановить событие вызовом `event.stopPropagation()`, но делать это не рекомендуется, так как в дальнейшем это событие может понадобиться, иногда для самых неожиданных вещей.

В современной разработке стадия погружения используется очень редко, обычно события обрабатываются во время всплытия. И в этом есть логика.

В реальном мире, когда происходит чрезвычайная ситуация, местные службы реагируют первыми. Они знают лучше всех местность, в которой это произошло, и другие детали. Вышестоящие инстанции подключаются уже после этого и при необходимости.

Тоже самое справедливо для обработчиков событий. Код, который «навесил» обработчик на конкретный элемент, знает максимум деталей об элементе и его предназначении. Например, обработчик на определённом `<td>` скорее всего подходит только для этого конкретного `<td>`, он знает все о нём, поэтому он должен отработать первым. Далее имеет смысл передать обработку события родителю – он тоже понимает, что происходит, но уже менее детально, далее – выше, и так далее, до самого объекта `document`, обработчик на котором реализовывает самую общую функциональность уровня документа.

Всплытие и погружение являются основой для «делегирования событий» – очень мощного приёма обработки событий. Его мы изучим в следующей главе.[^bubbling-and-capturing]

### Программный вызов событий
События могут возникать не только в следствие действий пользователя на веб-странице. События также можно генерировать программно.

Чтобы программно вызвать событие, у элемента на веб-странице можно вызвать метод `dispatchEvent()`, в который передается экземпляр объекта `Event` (либо его производные типа `MouseEvent` или `KeybordEvent`).

```js
const event = new Event(имя_события, config);   //  определяем объект события
element.dispatchEvent(event);   //   вызываем событие для элемента element
```

Первый аргумент, передаваемый конструктору `Event`, представляет собой строку — тип события. Дополнительно в качестве второго параметра можно передать объект конфигурации. В частности, с помощью объекта конфигурации можно определить следующие свойства:

- `cancelable`: можно ли событие отменить (если `true`, то отменяемое событие, `false` — неотменяемое)

- `bubbles`: должно ли событие быть восходящим (если `true`, то восходящее)


Например, программно нажмем на ссылку:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <a id="link" href="https://example.com">example</a>
    <script>
    const link = document.getElementById("link");   // получаем ссылку
    const event = new MouseEvent("click");
    link.dispatchEvent(event);
    </script>
</body>
</html>
```

Нажатие на ссылку представляет событие мыши "click", поэтому определяем объект события типа `MouseEvent`:
```js
const event = new MouseEvent("click");
```

Затем вызываем событие для элемента `link`:
```js
link.dispatchEvent(event);
```

В итоге произойдет переход по ссылке уже при загрузке страницы.

И как в общем случае, это событие также можно обработать:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <a id="link" href="https://example.com">example</a>
    <script>
    const link = document.getElementById("link");

    link.addEventListener("click", (e)=>{
        console.log("Link has been clicked");
        e.preventDefault();     // предупреждаем переход
    });

    const event = new MouseEvent("click", {cancelable:true});
    link.dispatchEvent(event);
    </script>
</body>
</html>
```

Чтобы выполнение события можно было остановить, в конструктор `MouseEvent` в качестве второго параметра передаем конфигурационных объект с одним свойством: `cancelable:true` указывает, что можно остановить обработку события. Благодаря этому в обработчике события "click" можно вызвать метод `e.preventDefault()`.[^9.7]

#### Конструктор Event
Встроенные классы для событий формируют иерархию аналогично классам для DOM-элементов. Её корнем является встроенный класс `Event`.

Событие встроенного класса `Event` можно создать так:
```js
let event = new Event(type[, options]);
```

Где:

- `type` – тип события, строка, например "click" или же любой придуманный нами – "my-event".
- `options` – объект с тремя необязательными свойствами:
  - `bubbles: true/false` – если `true`, тогда событие всплывает.
  - `cancelable: true/false` – если `true`, тогда можно отменить действие по умолчанию. Позже мы разберём, что это значит для пользовательских событий.
  - `composed: true/false` – если `true`, тогда событие будет всплывать наружу за пределы Shadow DOM. Позже мы разберём это в разделе Веб-компоненты.

По умолчанию все три свойства установлены в `false`: `{bubbles: false, cancelable: false, composed: false}`.[^dispatch-events]

#### Метод dispatchEvent
После того, как объект события создан, мы должны запустить его на элементе, вызвав метод `elem.dispatchEvent(event)`.

Затем обработчики отреагируют на него, как будто это обычное браузерное событие. Если при создании указан флаг `bubbles`, то оно будет всплывать.

В примере ниже событие `click` инициируется JavaScript-кодом так, как будто кликнули по кнопке:
```html
<button id="elem" onclick="alert('Клик!');">Автоклик</button>

<script>
  let event = new Event("click");
  elem.dispatchEvent(event);
</script>
```

!!! info event.isTrusted

    Можно легко отличить «настоящее» событие от сгенерированного кодом.

    Свойство `event.isTrusted` принимает значение `true` для событий, порождаемых реальными действиями пользователя, и `false` для генерируемых кодом.

#### MouseEvent, KeyboardEvent и другие
Для некоторых конкретных типов событий есть свои специфические конструкторы. Вот небольшой список конструкторов для различных событий пользовательского интерфейса, которые можно найти в спецификации [UI Event](https://www.w3.org/TR/uievents):

- `UIEvent`
- `FocusEvent`
- `MouseEvent`
- `WheelEvent`
- `KeyboardEvent`
…

Стоит использовать их вместо new `Event`, если мы хотим создавать такие события. К примеру, `new MouseEvent("click")`.

Специфический конструктор позволяет указать стандартные свойства для данного типа события.

Например, `clientX/clientY` для события мыши:
```js
let event = new MouseEvent("click", {
  bubbles: true,
  cancelable: true,
  clientX: 100,
  clientY: 100
});

alert(event.clientX); // 100
```
Обратите внимание: этого нельзя было бы сделать с обычным конструктором `Event`.

Давайте проверим:
```js
let event = new Event("click", {
  bubbles: true, // только свойства bubbles и cancelable
  cancelable: true, // работают в конструкторе Event
  clientX: 100,
  clientY: 100
});

alert(event.clientX); // undefined, неизвестное свойство проигнорировано!
```

Впрочем, использование конкретного конструктора не является обязательным, можно обойтись `Event`, а свойства записать в объект отдельно, после создания, вот так: `event.clientX=100`. Здесь это скорее вопрос удобства и желания следовать правилам. События, которые генерирует браузер, всегда имеют правильный тип.

Полный список свойств по типам событий вы найдёте в спецификации, например, [MouseEvent](https://www.w3.org/TR/uievents/#mouseevent).[^dispatch-events]

### Определение своих событий
Возможность программной генерации событий открывает нам путь к созданию кастомных событий — мы можем определять и вызывать произвольные события.[^9.8]

Можно не только назначать обработчики, но и генерировать события из JavaScript-кода.

Пользовательские события могут быть использованы при создании графических компонентов. Например, корневой элемент нашего меню, реализованного при помощи JavaScript, может генерировать события, относящиеся к этому меню: `open` (меню раскрыто), `select` (выбран пункт меню) и т.п. А другой код может слушать эти события и узнавать, что происходит с меню.

Можно генерировать не только совершенно новые, придуманные нами события, но и встроенные, такие как `click`, `mousedown` и другие. Это бывает полезно для автоматического тестирования.[^dispatch-events]

Например, у нас есть функция-конструктор `Account`, которая принимает количество денег и создает условный денежный счет:
```js
function Account(money) {
    _money = money;
    this.pay=function(sum){
        if(_money >= sum){
            _money -= sum;
            console.log(_money);
        }
    }
}
```

В переменной `_money` хранится текущее количество денег на счете. С помощью функции pay условно тратим определенную сумму, если баланс позволяет. Но, допустим, нам надо как-то извещать систему, что произошло списание со счета. С одно стороны, мы могли бы это делать непосредственно в методе `pay` — вызывать в методе `console.log()` и выводить на консоль какой-то текст. Но на момент написания этого кода мы можем быть не уверены, какой именно текст надо выводить на консоль. А может быть потребуется и не на консоль, а в окне браузере. Или посылать извещение на определенный сетевой ресурс. А может наша функция-конструктор будет использоваться в Node.js, где может потребоваться какая-то другая обработка. Да и использовать нашу функцию-конструктор могут совсем другие разработчики, у которых может быть собственно понимание того, что надо делать при списании средств. В любом случае мы сталкиваемся с многовариантностью, но во всех этих ситуация главное, что нам надо сделать — уведомить систему, что произошло списание средств. И охватить все эти ситуации нам поможет определение собственных событий.

Для определения кастомных событий мы можем применять конструктор **`Event`**, в который передается название события. Так, рассмотрим следующую программу:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <button id="btn">Pay</button>
    <script>
    const button = document.getElementById("btn");
    const myAcc = new Account(100); // условный денежный счет
    // устанавливаем обработчик события payment для всего документа
    document.addEventListener("payment", ()=>console.log("Payment succeeded!"));

    // по нажатию на кнопку выполняем метод pay
    button.addEventListener("click", ()=>myAcc.pay(50));
    // конструктор объекта счета
    function Account(money) {
        _money = money;
        this.pay=function(sum){
            if(_money >= sum){
                _money -= sum;
                console.log(_money);

                const event = new Event("payment"); // определяем объект события
                document.dispatchEvent(event);      // генерируем событие для всего документа
            }
        }
    }
    </script>
</body>
</html>
```

Основные моменты. В методе `pay` создаем объект `Event`, которое будет представлять событие "payment" (не важно, что такого события изначально не существует, мы сами его создаем). Затем генерируем это событие:
```js
const event = new Event("payment"); // определяем объект события
document.dispatchEvent(event);      // генерируем событие для всего документа
```

Стоит отметить, что событие генерируется для всего документа: **`document`**.`dispatchEvent(event)`, но это может быть любой конкретный элемент веб-страницы.

Чтобы обработать это событие, подписываемся на него:
```js
document.addEventListener("payment", ()=>console.log("Payment succeeded!"));
```

Опять же подписка на событие производится для всего документа. Обработчик события просто выводит строку на консоль.

По нажатию на кнопку вызываем метод pay объекта myAcc и тем самым генерируем событие "payment" (если на счете достаточно средств).

Для тестирования понажимаем на кнопку:

![Создание своих событий в JavaScript](../img/customevent1.png)

Также, как и в общем случае, мы можем получить объект подобное события в обработчике:
```js
// получаем через параметр e объект события
document.addEventListener("payment", (e)=>{
    console.log(e.type);                //  payment
    console.log("Payment succeeded!");
});
```

#### Пример всплытия
Мы можем создать всплывающее событие с именем `"hello"` и поймать его на `document`.

Всё, что нужно сделать – это установить флаг `bubbles` в `true`:
```html
<h1 id="elem">Привет из кода!</h1>

<script>
  // ловим на document...
  document.addEventListener("hello", function(event) { // (1)
    alert("Привет от " + event.target.tagName); // Привет от H1
  });

  // ...запуск события на элементе!
  let event = new Event("hello", {bubbles: true}); // (2)
  elem.dispatchEvent(event);

  // обработчик на document сработает и выведет сообщение.

</script>
```

Обратите внимание:

1. Мы должны использовать `addEventListener` для наших собственных событий, т.к. `on<event>`-свойства существуют только для встроенных событий, то есть `document.onhello` не сработает.
2. Мы обязаны передать флаг `bubbles:true`, иначе наше событие не будет всплывать.

Механизм всплытия идентичен как для встроенного события (`click`), так и для пользовательского события (`hello`). Также одинакова работа фаз всплытия и погружения.[^dispatch-events]

#### CustomEvent
Однако тип `Event` хотя и может использоваться, но не очень подходит для определения кастомных событий. Например, что, если мы хотим передать в обработчик события какую-то дополнительную информацию — сумму списания, текущий баланс или что-то еще?

Для генерации событий совершенно новых типов, таких как "hello", следует использовать конструктор `new CustomEvent`. Технически `CustomEvent` абсолютно идентичен `Event` за исключением одной небольшой детали.

У второго аргумента-объекта есть дополнительное свойство `detail`, в котором можно указывать информацию для передачи в событие.

Например:
```html
<h1 id="elem">Привет для Васи!</h1>

<script>
  // дополнительная информация приходит в обработчик вместе с событием
  elem.addEventListener("hello", function(event) {
    alert(event.detail.name);
  });

  elem.dispatchEvent(new CustomEvent("hello", {
    detail: { name: "Вася" }
  }));
</script>
```

Таким образом, для подобных случаев лучше использовать тип **`CustomEvent`**. Так, изменим код JavaScript следующим образом:
```js
const button = document.getElementById("btn");
document.addEventListener("payment", (e)=>{
    console.log("Payment succeeded!");
    console.log("Payment Sum:", e.detail.paymentSum);   // получаем данные события
    console.log("Current balance:", e.detail.balance);
});

const myAcc = new Account(100);
// по нажатию на кнопку выполняем метод pay
button.addEventListener("click", ()=>myAcc.pay(50));

function Account(money) {
    _money = money;
    this.pay=function(sum){
        if(_money >= sum){
            _money -= sum;
            // определяем объект события
            const event = new CustomEvent("payment", {
                detail:{                //  передаем в CustomEvent данные о событии
                    paymentSum: sum,
                    balance: _money
                }
            });
            document.dispatchEvent(event);      // генерируем событие для всего документа
        }
    }
}
```


В `CustomEvent` в качестве второго параметра передается конфигурационный объект, который имеет свойство **`detail`**. Это свойство в свою очередь представляет объект с произвольным набором свойств. В данном случае мы определяем в нем свойства `paymentSum` и `balance` и передаем этим свойствам интересующие нас значения:
```js
const event = new CustomEvent("payment", {
    detail:{
        paymentSum: sum,
        balance: _money
    }
});
```

Свойство `detail` может содержать любые данные. Надо сказать, что никто не мешает и в обычное `new Event` записать любые свойства. Но `CustomEvent` предоставляет специальное поле `detail` во избежание конфликтов с другими свойствами события.

Кроме того, класс события описывает, что это за событие, и если оно не браузерное, а пользовательское, то лучше использовать `CustomEvent`, чтобы явно об этом сказать.

Далее передаем объект `CustomEvent` (как и `Event`) в `dispatchEvent` и тем самым генерируем событие:
```js
document.dispatchEvent(event);
```

При обработке события мы можем получить переданные данные через свойство `detail`:
```js
document.addEventListener("payment", (e)=>{
    console.log("Payment succeeded!");
    console.log("Payment Sum:", e.detail.paymentSum);   // получаем данные события
    console.log("Current balance:", e.detail.balance);
});
```

Пример консольного вывода при первом нажатии кнопки:
```
Payment succeeded!
Payment Sum: 50
Current balance: 50
```

Подобным образом можно определять и другие события. Например, определим еще одно событие на случай, если средств недостаточно для совершения платежа:
```js
const button = document.getElementById("btn");
document.addEventListener("payment_success", (e)=>{
    console.log("Payment succeeded!");
    console.log("Payment Sum:", e.detail.paymentSum);
    console.log("Current balance:", e.detail.balance);
});
document.addEventListener("payment_fail", (e)=>{
    console.error("Payment failed");
    console.error("Current balance:", e.detail.balance, "Requested Sum: ", e.detail.paymentSum);
});
const myAcc = new Account(100);
button.addEventListener("click", ()=>myAcc.pay(50));

function Account(money) {
    _money = money;
    this.pay=function(sum){
        const data = {
            paymentSum: sum,
            balance: _money
        };
        if(_money >= sum){
            _money -= sum;

            const event = new CustomEvent("payment_success", {
                detail: data
            });
            document.dispatchEvent(event);
        }
        else{
            const event = new CustomEvent("payment_fail", {
                detail: data
            });
            document.dispatchEvent(event);
        }
    }
}
```

Теперь, если средстd достаточно на счете генерируется событие "payment_success", а если недостаточно — то "payment_fail". И для каждого из этих событий определяем свой обработчик.

консольный вывод программы (при трех нажатиях на кнопку):
```
Payment succeeded!
Payment Sum: 50
Current balance: 100
Payment succeeded!
Payment Sum: 50
Current balance: 50
Payment failed
Current balance: 0 Requested Sum:  50
```

#### event.preventDefault()
Для многих браузерных событий есть «действия по умолчанию», такие как переход по ссылке, выделение и т.п.

Для новых, пользовательских событий браузерных действий, конечно, нет, но код, который генерирует такое событие, может предусматривать какие-то свои действия после события.

Вызов `event.preventDefault()` является возможностью для обработчика события сообщить в сгенерировавший событие код, что эти действия надо отменить.

Тогда вызов `elem.dispatchEvent(event)` возвратит `false`. И код, сгенерировавший событие, узнает, что продолжать не нужно.

Посмотрим практический пример – прячущегося кролика (могло бы быть скрывающееся меню или что-то ещё).

Ниже вы можете видеть кролика `#rabbit` и функцию `hide()`, которая при вызове генерирует на нём событие `"hide"`, уведомляя всех интересующихся, что кролик собирается спрятаться.

Любой обработчик может узнать об этом, подписавшись на событие `hide` через `rabbit.addEventListener('hide',...)` и, при желании, отменить действие по умолчанию через `event.preventDefault()`. Тогда кролик не исчезнет:
```html
<pre id="rabbit">
  |\   /|
   \|_|/
   /. .\
  =\_Y_/=
   {>o<}
</pre>
<button onclick="hide()">Hide()</button>

<script>
  // hide() будет вызван при щелчке на кнопке
  function hide() {
    let event = new CustomEvent("hide", {
      cancelable: true // без этого флага preventDefault не сработает
    });
    if (!rabbit.dispatchEvent(event)) {
      alert('Действие отменено обработчиком');
    } else {
      rabbit.hidden = true;
    }
  }

  rabbit.addEventListener('hide', function(event) {
    if (confirm("Вызвать preventDefault?")) {
      event.preventDefault();
    }
  });
</script>
```

![Dispatch event](../img/dispatch-events_01.png)

Обратите внимание: событие должно содержать флаг `cancelable: true`. Иначе, вызов `event.preventDefault()` будет проигнорирован.

#### Вложенные события обрабатываются синхронно
Обычно события обрабатываются асинхронно. То есть, если браузер обрабатывает `onclick` и в процессе этого произойдёт новое событие, то оно ждёт, пока закончится обработка `onclick`.

Исключением является ситуация, когда событие инициировано из обработчика другого события.

Тогда управление сначала переходит в обработчик вложенного события и уже после этого возвращается назад.

В примере ниже событие `menu-open` обрабатывается синхронно во время обработки `onclick`:
```html
<button id="menu">Меню (нажми меня)</button>

<script>
  menu.onclick = function() {
    alert(1);

    // alert("вложенное событие")
    menu.dispatchEvent(new CustomEvent("menu-open", {
      bubbles: true
    }));

    alert(2);
  };

  document.addEventListener('menu-open', () => alert('вложенное событие'))
</script>
```

![Dispatch event](../img/dispatch-events_02.png)

Порядок вывода: 1 → вложенное событие → 2.

Обратите внимание, что вложенное событие `menu-open` успевает всплыть и запустить обработчик на `document`. Обработка вложенного события полностью завершается до того, как управление возвращается во внешний код (`onclick`).

Это справедливо не только для `dispatchEvent`, но и для других ситуаций. JavaScript в обработчике события может вызвать другие методы, которые приведут к другим событиям – они тоже обрабатываются синхронно.

Если нам это не подходит, то мы можем либо поместить `dispatchEvent` (или любой другой код, инициирующий события) в конец обработчика `onclick`, либо, если это неудобно, можно обернуть генерацию события в `setTimeout` с нулевой задержкой:
```html
<button id="menu">Меню (нажми меня)</button>

<script>
  menu.onclick = function() {
    alert(1);

    // alert(2)
    setTimeout(() => menu.dispatchEvent(new CustomEvent("menu-open", {
      bubbles: true
    })));

    alert(2);
  };

  document.addEventListener('menu-open', () => alert('вложенное событие'))
</script>
```

Теперь `dispatchEvent` запускается асинхронно после исполнения текущего кода, включая `menu.onclick`, поэтому обработчики полностью независимы.

Новый порядок вывода: 1 → 2 → вложенное событие.

#### Итого
Чтобы сгенерировать событие из кода, вначале надо создать объект события.

Базовый конструктор `Event(name, options)` принимает обязательное имя события и `options` – объект с двумя свойствами:

- `bubbles: true` чтобы событие всплывало.
- `cancelable: true` если мы хотим, чтобы `event.preventDefault()` работал.

Особые конструкторы встроенных событий `MouseEvent`, `KeyboardEvent` и другие принимают специфичные для каждого конкретного типа событий свойства. Например, `clientX` для событий мыши.

Для пользовательских событий стоит применять конструктор `CustomEvent`. У него есть дополнительная опция `detail`, с помощью которой можно передавать информацию в объекте события. После чего все обработчики смогут получить к ней доступ через `event.detail`.

Несмотря на техническую возможность генерировать встроенные браузерные события типа `click` или `keydown`, пользоваться ей стоит с большой осторожностью.

Весьма часто, когда разработчик хочет сгенерировать встроенное событие – это вызвано «кривой» архитектурой кода.

Как правило, генерация встроенных событий полезна в следующих случаях:

- Либо как явный и грубый хак, чтобы заставить работать сторонние библиотеки, в которых не предусмотрены другие средства взаимодействия.
- Либо для автоматического тестирования, чтобы скриптом «нажать на кнопку» и посмотреть, произошло ли нужное действие.

Пользовательские события со своими именами часто создают для улучшения архитектуры, чтобы сообщить о том, что происходит внутри наших меню, слайдеров, каруселей и т.д.[^dispatch-events]

### Источники информации
[^9.1]: [Введение в обработку событий](https://metanit.com/web/javascript/9.1.php)
[^9.2]: [Обработчики событий](https://metanit.com/web/javascript/9.2.php)
[^9.3]: [Передача данных в обработчик события. Объект Event](https://metanit.com/web/javascript/9.3.php)
[^9.4]: [Распространение событий](https://metanit.com/web/javascript/9.4.php)
[^9.7]: [Программный вызов событий](https://metanit.com/web/javascript/9.7.php)
[^9.8]: [Определение своих событий](https://metanit.com/web/javascript/9.8.php)
[^dispatch-events]: [Генерация пользовательских событий](https://learn.javascript.ru/dispatch-events)
[^bubbling-and-capturing]: [Всплытие и погружение](https://learn.javascript.ru/bubbling-and-capturing)
