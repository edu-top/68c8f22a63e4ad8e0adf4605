## События

- [События](#события)
  - [Введение в обработку событий](#введение-в-обработку-событий)
    - [Базовые события](#базовые-события)
  - [Обработчики событий](#обработчики-событий)
    - [Встроенные обработчики](#встроенные-обработчики)
    - [Свойства обработчиков событий](#свойства-обработчиков-событий)
    - [Слушатели событий](#слушатели-событий)
  - [Программный вызов событий](#программный-вызов-событий)
    - [Конструктор Event](#конструктор-event)
    - [Метод dispatchEvent](#метод-dispatchevent)
    - [MouseEvent, KeyboardEvent и другие](#mouseevent-keyboardevent-и-другие)
  - [Определение своих событий](#определение-своих-событий)
    - [Пример всплытия](#пример-всплытия)
    - [CustomEvent](#customevent)
    - [event.preventDefault()](#eventpreventdefault)
    - [Вложенные события обрабатываются синхронно](#вложенные-события-обрабатываются-синхронно)
    - [Итого](#итого)
  - [Источники информации](#источники-информации)

### Введение в обработку событий
Для взаимодействия с пользователем в JavaScript определен механизм событий. Например, когда пользователь нажимает кнопку, то возникает событие нажатия кнопки. Аналогично когда пользователь вводит в текстовое поле текст, возникает событие этого текстового поля. В коде JavaScript мы можем определить возникновение события и как-то его обработать.

Вкратце общий механизм выглядит следующим образом. Сначала собственно происходит событие, например, пользователь нажал на кнопку. Объект, который сгенерировал событие, еще называется эмиттером/эмитентом события. После того как произошло событие, оно помещается в очередь событий (*event queue*), что гарантирует, что события, которые были сгенерированы первыми, также будут обработаны в первую очередь. Цикл событий (*event loop*) постоянно проверяет, есть ли новое событие в очереди событий, и если оно есть, соответствующее событие пересылается обработчикам событий (*event handler*). В JavaScript эти обработчики событий представляют собой простые функции, которые позволяют отреагировать на возникшее событие. Подобный подход еще называют событийным программированием (*event-driven programming*).[^9.1]

![Событийный цикл в языке JavaScript](../img/event_loop.png)

Если для события не определено обработчиков, то для него выполняется действие, которое определено браузером по умолчанию.

В JavaScript есть следующие типы событий:

- События мыши (перемещение курсора, нажатие мыши и т.д.)

- События клавиатуры (нажатие или отпускание клавиши клавиатуры)

- События жизненного цикла элементов (например, событие загрузки веб-станицы)

- События элементов форм (нажатие кнопки на форме, выбор элемента в выпадающем списке и т.д.)

- События, возникающие при изменении элементов DOM

- События, возникающие при касании на сенсорных экранах

- События, возникающие при возникновении ошибок

Стоит отметить, что применение событий не ограничены только графическим интерфейсом, однако графический интерфейс — наиболее показательная сфера применения событий.

Рассмотрим простейшую обработку событий. Например, на веб-странице у нас есть следующий элемент `div`:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <div id="rect" onclick="console.log('Clicked!')" style="width:50px;height:50px;background-color:blue;"></div>
</body>
</html>
```

Здесь определен обычный блок `div`, который имеет атрибут **`onclick`**, который задает **обработчик события** нажатия на блок `div`. То есть, чтобы обработать какое-либо событие, нам надо определить для него обработчик. Обработчик представляет собой код на языке JavaScript. В данном случае обработчик просто выводит строку на консоль:
```js
console.log('Clicked!')
```

И при нажатии на блок мы сможем увидеть в консоли браузера соответствующее сообщение:

![Обработка событий в языке JavaScript](../img/events.png)

#### Базовые события
Вкратце перечислю основные события, которые мы можем использовать в JavaScript.

*События мыши*:

Событие | Описание | Объект события
-- | -- | --
`click` | возникает при нажатии указателем мыши на элемент | `MouseEvent`
`dblclick` | возникает при двойном нажатии указателем мыши на элемент | `MouseEvent`
`contextmenu` | возникает при открытии контекстного меню (правой кнопкой мыши) | `MouseEvent`
`mousedown` | возникает при нахождении указателя мыши на элементе, когда кнопка мыши находится в нажатом состоянии | `MouseEvent`
`mouseup` | возникает при нахождении указателя мыши на элементе во время отпускания кнопки мыши | `MouseEvent`
`mousemove` | возникает при прохождении указателя мыши над элементом | `MouseEvent`
`mouseover` | возникает при вхождении указателя мыши в границы элемента | `MouseEvent`
`mouseout` | возникает, когда указатель мыши выходит за пределы элемента | `MouseEvent`
`mouseenter` | возникает при вхождении указателя мыши в границы элемента | `MouseEvent`
`mouseleave` | возникает, когда указатель мыши выходит за пределы элемента | `MouseEvent`

*События клавиатуры*:

Событие | Описание | Объект события
-- | -- | --
`keydown` | возникает при нажатии клавиши клавиатуры и длится, пока нажата клавиша | `KeyboardEvent`
`keyup` | возникает при отпускании клавиши клавиатуры | `KeyboardEvent`
`keypress` | возникает при нажатии клавиши клавиатуры, но после события `keydown` и до события `keyup`. | `KeyboardEvent`

*События элементов форм*:

Событие | Описание | Объект события
-- | -- | --
`input` | возникает при изменении текста в элементах `<input>` и `textarea` или в элемент с атрибутом `contenteditable` | `Event`
`change` | возникает при изменении значения в списках, флажках (`checkbox`) или радиокнопках | `Event`
`submit` | возникает при отправке формы | `Event`
`reset` | возникает при сбросе формы (через кнопку `reset`) | `Event`

*События фокусировки*:

Событие | Описание | Объект события
-- | -- | --
`focus` | возникает при получении фокуса | `FocusEvent`
`blur` | возникает при потере фокуса | `FocusEvent`
`focusin` | возникает при получении фокуса (в отличие от события `focus`, это событие поднимающееся. Про поднимающиеся и опускающиеся события далее) | `FocusEvent`
`focusout` | возникает при потере фокуса (это событие поднимающееся в отличие от события `blur`) | `FocusEvent`

Общие события интерфейса:

Событие | Описание | Объект события
-- | -- | --
`load` | возникает при загрузке веб-страницы | `UIEvent`
`unload` | возникает при выгрузке веб-страницы (например, когда запрошена страница по новому адресу) | `UIEvent`
`abort` | возникает при отмене загрузки ресурса | `UIEvent`
`Error` | возникает при генерации ошибки при загрузке страницы (например, ошибка в коде JavaScript) | `UIEvent`
`select` | возникает при выделении текст на странице | `UIEvent`
`resize` | возникает при изменении размеров окна браузера | `UIEvent`
`scroll` | возникает при прокрутке | `UIEvent`
`beforeunload` | возникает непосредственно перед выгрузкой страницы | `BeforeUnloadEvent`
`DOMContentLoaded` | возникает при полной загрузке дерева DOM | `Event`
`cut` | возникает при вырезании текста из поля ввода (например, с помощью <kbd>Ctrl</kbd>+<kbd>X</kbd>) | `ClipboardEvent`
`copy` | возникает при копировании текста из поля ввода (например, с помощью <kbd>Ctrl</kbd>+<kbd>C</kbd>) | `ClipboardEvent`
`paste` | возникает при вставке текста в поле ввода (например, с помощью <kbd>Ctrl</kbd>+<kbd>V</kbd>) | `ClipboardEvent`
`select` | возникает при выделении текста в поле ввода | `ClipboardEvent`

*События мобильных устройств и других устройств с сенсорным экраном*:

Событие | Описание | Объект события
-- | -- | --
`orientationchange` | возникает при изменении ориентации устройства | `Event`
`deviceorientation` | возникает, когда появляются новые данные об ориентации устройства | `DeviceOrientationEvent`
`devicemotion` | возникает с регулярными интервалами и указывает на силу ускорения, действующую на конечное устройство | `DeviceMotionEvent`
`touchstart` | возникает при касании дисплея | `TouchEvent`
`touchend` | возникает, когда палец убран с дисплея (касание завершилось) | `TouchEvent`
`touchmove` | возникает при движении пальцем по сенсорному дисплею | `TouchEvent`
`touchcancel` | возникает при прерывании отслеживания касаний | `TouchEvent`

### Обработчики событий
Если в коде JavaScript возникает событие, то его обрабатывает связанный с этим событием обработчик. Рассмотрим, как определять обработчики событий.[^9.2]

#### Встроенные обработчики
Самый простой способ определения обработчиков событий — их установка в коде html. Это так называемые встроенные обработчики или inline-обработчики, которые определяются в коде элемента с помощью атрибутов. Подобные атрибуты начинаются с префикса **`on`**. Например, у многих html-элементов есть атрибут **`on`**`click`, который определяет обработчик нажатия элемента. Посмотрим на примере кнопки:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <button onclick="console.log('Clicked!')">Click Me</div>
</body>
</html>
```

С помощью атрибута `onclick="console.log('Clicked!')"` к кнопке прикрепляется обработчик ее нажатия. Этот обработчик состоит из одной инструкции JavaScript — `console.log("Clicked!")`, которая выводит сообщение на консоль. Таким образом, при нажатии на кнопку сработает событие нажатия, и будет выполняться обработчик из атрибута `onclick`:

![Обработка событий в языке JavaScript](../img/events2.png)

Можно даже определить несколько инструкций подобным образом:
```html
<button onclick="console.log('Hello');console.log('Clicked!')">Click Me</div>
```

Но, очевидно, что это не самый удобный способ. Но также можно вынести все инструкции в отдельную функцию JavaScript. А атрибуту `onclick` передать вызов этой функции:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <button onclick="btn_click()">Click Me</div>
    <script>
    let clicks = 0;     // счетчик нажатий
    function btn_click(){
        console.log("Clicked", ++clicks);
    }
    </script>
</body>
</html>
```

Теперь по нажатию кнопки будет вызываться функция `btn_click`, которая определена в коде JavaScript.

Хотя этот подход прекрасно работает, но он имеет кучу недостатков:

- Код html смешивается с кодом JavaScript, в связи с чем становится труднее разрабатывать, отлаживать и поддерживать приложение

- Обработчики событий можно задать только для уже созданных на веб-странице элементов. Динамически создаваемые элементы в этом случае лишаются возможности обработки событий

- К элементу для одного события может быть прикреплен только один обработчик

- Нельзя удалить обработчик без изменения кода

#### Свойства обработчиков событий
Проблемы, которые возникают при использовании встроенных обработчиков, были призваны решить свойства обработчиков. Подобно тому, как у html-элементов есть атрибуты для обработчиков, так и в коде javascript у элементов DOM мы можем получить свойства обработчиков, которые соответствуют атрибутам:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <button id="btn">Click Me</div>
    <script>
    let clicks = 0;     // счетчик нажатий
    function btn_click(){
        console.log("Clicked", ++clicks);
    }
    // устанавливаем обработчик нажатия для элемента с id="btn"
    document.getElementById("btn").onclick = btn_click;
    </script>
</body>
</html>
```

В итоге нам достаточно взять свойство **`onclick`** и присвоить ему функцию, используемую в качестве обработчика. За счет этого код html отделяется от кода javascript.

#### Слушатели событий
Несмотря на то, что свойства обработчиков решают ряд проблем, которые связаны с использованием атрибутов, в то же время это также не оптимальный подход. Еще один способ установки обработчиков событий представляет использование слушателей.

Для работы со слушателями событий в JavaScript есть объект **`EventTarget`**, который определяет методы **`addEventListener()`** (для добавления слушателя) и **`removeEventListener()`** для удаления слушателя. И поскольку html-элементы DOM тоже являются объектами `EventTarget`, то они также имеют эти методы. Фактически слушатели представляют те же функции обработчиков.

Метод `addEventListener()` принимает два параметра: название события без префикса `on` и функцию обработчика этого события. Например:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>METANIT.COM</title>
</head>
<body>
    <button id="btn">Click Me</div>
    <script>
    let clicks = 0;     // счетчик нажатий
    function btn_click(){
        console.log("Clicked", ++clicks);
    }
    const btn = document.getElementById("btn");
    // прикрепляем обработчик события "click"
    btn.addEventListener("click", btn_click);
    </script>
</body>
</html>
```

То есть в данном случае опять же обрабатывается событие `click`. Удаление слушателя аналогично добавлению:
```js
rect.removeEventListener("click", btn_click);
```

Преимуществом использования слушателей является и то, что мы можем установить для одного события несколько функций:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <button id="btn">Click Me</div>
    <script>
    let clicks = 0;     // счетчик нажатий
    function btn_click(){
        console.log("Clicked", ++clicks);
    }
    const btn = document.getElementById("btn");

    // прикрепляем первый обработчик события "click" в виде функции btn_click
    btn.addEventListener("click", btn_click);

    // прикрепляем второй обработчик события "click" в виде анонимной функции
    btn.addEventListener("click", function(){
        console.log("Button clicked!")
    });

    // прикрепляем третий обработчик события "click" в виде стрелочной функции
    btn.addEventListener("click", ()=>console.log("Element clicked!"));

    </script>
</body>
</html>
```

### Программный вызов событий
События могут возникать не только в следствие действий пользователя на веб-странице. События также можно генерировать программно.

Чтобы программно вызвать событие, у элемента на веб-странице можно вызвать метод `dispatchEvent()`, в который передается экземпляр объекта `Event` (либо его производные типа `MouseEvent` или `KeybordEvent`).

```js
const event = new Event(имя_события, config);   //  определяем объект события
element.dispatchEvent(event);   //   вызываем событие для элемента element
```

Первый аргумент, передаваемый конструктору `Event`, представляет собой строку — тип события. Дополнительно в качестве второго параметра можно передать объект конфигурации. В частности, с помощью объекта конфигурации можно определить следующие свойства:

- `cancelable`: можно ли событие отменить (если `true`, то отменяемое событие, `false` — неотменяемое)

- `bubbles`: должно ли событие быть восходящим (если `true`, то восходящее)


Например, программно нажмем на ссылку:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <a id="link" href="https://example.com">example</a>
    <script>
    const link = document.getElementById("link");   // получаем ссылку
    const event = new MouseEvent("click");
    link.dispatchEvent(event);
    </script>
</body>
</html>
```

Нажатие на ссылку представляет событие мыши "click", поэтому определяем объект события типа `MouseEvent`:
```js
const event = new MouseEvent("click");
```

Затем вызываем событие для элемента `link`:
```js
link.dispatchEvent(event);
```

В итоге произойдет переход по ссылке уже при загрузке страницы.

И как в общем случае, это событие также можно обработать:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <a id="link" href="https://example.com">example</a>
    <script>
    const link = document.getElementById("link");

    link.addEventListener("click", (e)=>{
        console.log("Link has been clicked");
        e.preventDefault();     // предупреждаем переход
    });

    const event = new MouseEvent("click", {cancelable:true});
    link.dispatchEvent(event);
    </script>
</body>
</html>
```

Чтобы выполнение события можно было остановить, в конструктор `MouseEvent` в качестве второго параметра передаем конфигурационных объект с одним свойством: `cancelable:true` указывает, что можно остановить обработку события. Благодаря этому в обработчике события "click" можно вызвать метод `e.preventDefault()`.[^9.7]

#### Конструктор Event
Встроенные классы для событий формируют иерархию аналогично классам для DOM-элементов. Её корнем является встроенный класс `Event`.

Событие встроенного класса `Event` можно создать так:
```js
let event = new Event(type[, options]);
```

Где:

- `type` – тип события, строка, например "click" или же любой придуманный нами – "my-event".
- `options` – объект с тремя необязательными свойствами:
  - `bubbles: true/false` – если `true`, тогда событие всплывает.
  - `cancelable: true/false` – если `true`, тогда можно отменить действие по умолчанию. Позже мы разберём, что это значит для пользовательских событий.
- `composed: true/false` – если `true`, тогда событие будет всплывать наружу за пределы Shadow DOM. Позже мы разберём это в разделе Веб-компоненты.

По умолчанию все три свойства установлены в `false`: `{bubbles: false, cancelable: false, composed: false}`.[^dispatch-events]

#### Метод dispatchEvent
После того, как объект события создан, мы должны запустить его на элементе, вызвав метод `elem.dispatchEvent(event)`.

Затем обработчики отреагируют на него, как будто это обычное браузерное событие. Если при создании указан флаг `bubbles`, то оно будет всплывать.

В примере ниже событие `click` инициируется JavaScript-кодом так, как будто кликнули по кнопке:
```html
<button id="elem" onclick="alert('Клик!');">Автоклик</button>

<script>
  let event = new Event("click");
  elem.dispatchEvent(event);
</script>
```

!!! info event.isTrusted

    Можно легко отличить «настоящее» событие от сгенерированного кодом.

    Свойство `event.isTrusted` принимает значение `true` для событий, порождаемых реальными действиями пользователя, и `false` для генерируемых кодом.

#### MouseEvent, KeyboardEvent и другие
Для некоторых конкретных типов событий есть свои специфические конструкторы. Вот небольшой список конструкторов для различных событий пользовательского интерфейса, которые можно найти в спецификации [UI Event](https://www.w3.org/TR/uievents):

- `UIEvent`
- `FocusEvent`
- `MouseEvent`
- `WheelEvent`
- `KeyboardEvent`
…

Стоит использовать их вместо new `Event`, если мы хотим создавать такие события. К примеру, `new MouseEvent("click")`.

Специфический конструктор позволяет указать стандартные свойства для данного типа события.

Например, `clientX/clientY` для события мыши:
```js
let event = new MouseEvent("click", {
  bubbles: true,
  cancelable: true,
  clientX: 100,
  clientY: 100
});

alert(event.clientX); // 100
```
Обратите внимание: этого нельзя было бы сделать с обычным конструктором `Event`.

Давайте проверим:
```js
let event = new Event("click", {
  bubbles: true, // только свойства bubbles и cancelable
  cancelable: true, // работают в конструкторе Event
  clientX: 100,
  clientY: 100
});

alert(event.clientX); // undefined, неизвестное свойство проигнорировано!
```

Впрочем, использование конкретного конструктора не является обязательным, можно обойтись `Event`, а свойства записать в объект отдельно, после создания, вот так: `event.clientX=100`. Здесь это скорее вопрос удобства и желания следовать правилам. События, которые генерирует браузер, всегда имеют правильный тип.

Полный список свойств по типам событий вы найдёте в спецификации, например, [MouseEvent](https://www.w3.org/TR/uievents/#mouseevent).[^dispatch-events]

### Определение своих событий
Возможность программной генерации событий открывает нам путь к созданию кастомных событий — мы можем определять и вызывать произвольные события.[^9.8]

Можно не только назначать обработчики, но и генерировать события из JavaScript-кода.

Пользовательские события могут быть использованы при создании графических компонентов. Например, корневой элемент нашего меню, реализованного при помощи JavaScript, может генерировать события, относящиеся к этому меню: `open` (меню раскрыто), `select` (выбран пункт меню) и т.п. А другой код может слушать эти события и узнавать, что происходит с меню.

Можно генерировать не только совершенно новые, придуманные нами события, но и встроенные, такие как `click`, `mousedown` и другие. Это бывает полезно для автоматического тестирования.[^dispatch-events]

Например, у нас есть функция-конструктор `Account`, которая принимает количество денег и создает условный денежный счет:
```js
function Account(money) {
    _money = money;
    this.pay=function(sum){
        if(_money >= sum){
            _money -= sum;
            console.log(_money);
        }
    }
}
```

В переменной `_money` хранится текущее количество денег на счете. С помощью функции pay условно тратим определенную сумму, если баланс позволяет. Но, допустим, нам надо как-то извещать систему, что произошло списание со счета. С одно стороны, мы могли бы это делать непосредственно в методе `pay` — вызывать в методе `console.log()` и выводить на консоль какой-то текст. Но на момент написания этого кода мы можем быть не уверены, какой именно текст надо выводить на консоль. А может быть потребуется и не на консоль, а в окне браузере. Или посылать извещение на определенный сетевой ресурс. А может наша функция-конструктор будет использоваться в Node.js, где может потребоваться какая-то другая обработка. Да и использовать нашу функцию-конструктор могут совсем другие разработчики, у которых может быть собственно понимание того, что надо делать при списании средств. В любом случае мы сталкиваемся с многовариантностью, но во всех этих ситуация главное, что нам надо сделать — уведомить систему, что произошло списание средств. И охватить все эти ситуации нам поможет определение собственных событий.

Для определения кастомных событий мы можем применять конструктор **`Event`**, в который передается название события. Так, рассмотрим следующую программу:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <button id="btn">Pay</button>
    <script>
    const button = document.getElementById("btn");
    const myAcc = new Account(100); // условный денежный счет
    // устанавливаем обработчик события payment для всего документа
    document.addEventListener("payment", ()=>console.log("Payment succeeded!"));

    // по нажатию на кнопку выполняем метод pay
    button.addEventListener("click", ()=>myAcc.pay(50));
    // конструктор объекта счета
    function Account(money) {
        _money = money;
        this.pay=function(sum){
            if(_money >= sum){
                _money -= sum;
                console.log(_money);

                const event = new Event("payment"); // определяем объект события
                document.dispatchEvent(event);      // генерируем событие для всего документа
            }
        }
    }
    </script>
</body>
</html>
```

Основные моменты. В методе `pay` создаем объект `Event`, которое будет представлять событие "payment" (не важно, что такого события изначально не существует, мы сами его создаем). Затем генерируем это событие:
```js
const event = new Event("payment"); // определяем объект события
document.dispatchEvent(event);      // генерируем событие для всего документа
```

Стоит отметить, что событие генерируется для всего документа: **`document`**.`dispatchEvent(event)`, но это может быть любой конкретный элемент веб-страницы.

Чтобы обработать это событие, подписываемся на него:
```js
document.addEventListener("payment", ()=>console.log("Payment succeeded!"));
```

Опять же подписка на событие производится для всего документа. Обработчик события просто выводит строку на консоль.

По нажатию на кнопку вызываем метод pay объекта myAcc и тем самым генерируем событие "payment" (если на счете достаточно средств).

Для тестирования понажимаем на кнопку:

![Создание своих событий в JavaScript](../img/customevent1.png)

Также, как и в общем случае, мы можем получить объект подобное события в обработчике:
```js
// получаем через параметр e объект события
document.addEventListener("payment", (e)=>{
    console.log(e.type);                //  payment
    console.log("Payment succeeded!");
});
```

#### Пример всплытия
Мы можем создать всплывающее событие с именем `"hello"` и поймать его на `document`.

Всё, что нужно сделать – это установить флаг `bubbles` в `true`:
```html
<h1 id="elem">Привет из кода!</h1>

<script>
  // ловим на document...
  document.addEventListener("hello", function(event) { // (1)
    alert("Привет от " + event.target.tagName); // Привет от H1
  });

  // ...запуск события на элементе!
  let event = new Event("hello", {bubbles: true}); // (2)
  elem.dispatchEvent(event);

  // обработчик на document сработает и выведет сообщение.

</script>
```

Обратите внимание:

1. Мы должны использовать `addEventListener` для наших собственных событий, т.к. `on<event>`-свойства существуют только для встроенных событий, то есть `document.onhello` не сработает.
2. Мы обязаны передать флаг `bubbles:true`, иначе наше событие не будет всплывать.

Механизм всплытия идентичен как для встроенного события (`click`), так и для пользовательского события (`hello`). Также одинакова работа фаз всплытия и погружения.[^dispatch-events]

#### CustomEvent
Однако тип `Event` хотя и может использоваться, но не очень подходит для определения кастомных событий. Например, что, если мы хотим передать в обработчик события какую-то дополнительную информацию — сумму списания, текущий баланс или что-то еще?

Для генерации событий совершенно новых типов, таких как "hello", следует использовать конструктор `new CustomEvent`. Технически `CustomEvent` абсолютно идентичен `Event` за исключением одной небольшой детали.

У второго аргумента-объекта есть дополнительное свойство `detail`, в котором можно указывать информацию для передачи в событие.

Например:
```html
<h1 id="elem">Привет для Васи!</h1>

<script>
  // дополнительная информация приходит в обработчик вместе с событием
  elem.addEventListener("hello", function(event) {
    alert(event.detail.name);
  });

  elem.dispatchEvent(new CustomEvent("hello", {
    detail: { name: "Вася" }
  }));
</script>
```

Таким образом, для подобных случаев лучше использовать тип **`CustomEvent`**. Так, изменим код JavaScript следующим образом:
```js
const button = document.getElementById("btn");
document.addEventListener("payment", (e)=>{
    console.log("Payment succeeded!");
    console.log("Payment Sum:", e.detail.paymentSum);   // получаем данные события
    console.log("Current balance:", e.detail.balance);
});

const myAcc = new Account(100);
// по нажатию на кнопку выполняем метод pay
button.addEventListener("click", ()=>myAcc.pay(50));

function Account(money) {
    _money = money;
    this.pay=function(sum){
        if(_money >= sum){
            _money -= sum;
            // определяем объект события
            const event = new CustomEvent("payment", {
                detail:{                //  передаем в CustomEvent данные о событии
                    paymentSum: sum,
                    balance: _money
                }
            });
            document.dispatchEvent(event);      // генерируем событие для всего документа
        }
    }
}
```


В `CustomEvent` в качестве второго параметра передается конфигурационный объект, который имеет свойство **`detail`**. Это свойство в свою очередь представляет объект с произвольным набором свойств. В данном случае мы определяем в нем свойства `paymentSum` и `balance` и передаем этим свойствам интересующие нас значения:
```js
const event = new CustomEvent("payment", {
    detail:{
        paymentSum: sum,
        balance: _money
    }
});
```

Свойство `detail` может содержать любые данные. Надо сказать, что никто не мешает и в обычное `new Event` записать любые свойства. Но `CustomEvent` предоставляет специальное поле `detail` во избежание конфликтов с другими свойствами события.

Кроме того, класс события описывает, что это за событие, и если оно не браузерное, а пользовательское, то лучше использовать `CustomEvent`, чтобы явно об этом сказать.

Далее передаем объект `CustomEvent` (как и `Event`) в `dispatchEvent` и тем самым генерируем событие:
```js
document.dispatchEvent(event);
```

При обработке события мы можем получить переданные данные через свойство `detail`:
```js
document.addEventListener("payment", (e)=>{
    console.log("Payment succeeded!");
    console.log("Payment Sum:", e.detail.paymentSum);   // получаем данные события
    console.log("Current balance:", e.detail.balance);
});
```

Пример консольного вывода при первом нажатии кнопки:
```
Payment succeeded!
Payment Sum: 50
Current balance: 50
```

Подобным образом можно определять и другие события. Например, определим еще одно событие на случай, если средств недостаточно для совершения платежа:
```js
const button = document.getElementById("btn");
document.addEventListener("payment_success", (e)=>{
    console.log("Payment succeeded!");
    console.log("Payment Sum:", e.detail.paymentSum);
    console.log("Current balance:", e.detail.balance);
});
document.addEventListener("payment_fail", (e)=>{
    console.error("Payment failed");
    console.error("Current balance:", e.detail.balance, "Requested Sum: ", e.detail.paymentSum);
});
const myAcc = new Account(100);
button.addEventListener("click", ()=>myAcc.pay(50));

function Account(money) {
    _money = money;
    this.pay=function(sum){
        const data = {
            paymentSum: sum,
            balance: _money
        };
        if(_money >= sum){
            _money -= sum;

            const event = new CustomEvent("payment_success", {
                detail: data
            });
            document.dispatchEvent(event);
        }
        else{
            const event = new CustomEvent("payment_fail", {
                detail: data
            });
            document.dispatchEvent(event);
        }
    }
}
```

Теперь, если средстd достаточно на счете генерируется событие "payment_success", а если недостаточно — то "payment_fail". И для каждого из этих событий определяем свой обработчик.

консольный вывод программы (при трех нажатиях на кнопку):
```
Payment succeeded!
Payment Sum: 50
Current balance: 100
Payment succeeded!
Payment Sum: 50
Current balance: 50
Payment failed
Current balance: 0 Requested Sum:  50
```

#### event.preventDefault()
Для многих браузерных событий есть «действия по умолчанию», такие как переход по ссылке, выделение и т.п.

Для новых, пользовательских событий браузерных действий, конечно, нет, но код, который генерирует такое событие, может предусматривать какие-то свои действия после события.

Вызов `event.preventDefault()` является возможностью для обработчика события сообщить в сгенерировавший событие код, что эти действия надо отменить.

Тогда вызов `elem.dispatchEvent(event)` возвратит `false`. И код, сгенерировавший событие, узнает, что продолжать не нужно.

Посмотрим практический пример – прячущегося кролика (могло бы быть скрывающееся меню или что-то ещё).

Ниже вы можете видеть кролика `#rabbit` и функцию `hide()`, которая при вызове генерирует на нём событие `"hide"`, уведомляя всех интересующихся, что кролик собирается спрятаться.

Любой обработчик может узнать об этом, подписавшись на событие `hide` через `rabbit.addEventListener('hide',...)` и, при желании, отменить действие по умолчанию через `event.preventDefault()`. Тогда кролик не исчезнет:
```html
<pre id="rabbit">
  |\   /|
   \|_|/
   /. .\
  =\_Y_/=
   {>o<}
</pre>
<button onclick="hide()">Hide()</button>

<script>
  // hide() будет вызван при щелчке на кнопке
  function hide() {
    let event = new CustomEvent("hide", {
      cancelable: true // без этого флага preventDefault не сработает
    });
    if (!rabbit.dispatchEvent(event)) {
      alert('Действие отменено обработчиком');
    } else {
      rabbit.hidden = true;
    }
  }

  rabbit.addEventListener('hide', function(event) {
    if (confirm("Вызвать preventDefault?")) {
      event.preventDefault();
    }
  });
</script>
```

![Dispatch event](../img/dispatch-events_01.png)

Обратите внимание: событие должно содержать флаг `cancelable: true`. Иначе, вызов `event.preventDefault()` будет проигнорирован.

#### Вложенные события обрабатываются синхронно
Обычно события обрабатываются асинхронно. То есть, если браузер обрабатывает `onclick` и в процессе этого произойдёт новое событие, то оно ждёт, пока закончится обработка `onclick`.

Исключением является ситуация, когда событие инициировано из обработчика другого события.

Тогда управление сначала переходит в обработчик вложенного события и уже после этого возвращается назад.

В примере ниже событие `menu-open` обрабатывается синхронно во время обработки `onclick`:
```html
<button id="menu">Меню (нажми меня)</button>

<script>
  menu.onclick = function() {
    alert(1);

    // alert("вложенное событие")
    menu.dispatchEvent(new CustomEvent("menu-open", {
      bubbles: true
    }));

    alert(2);
  };

  document.addEventListener('menu-open', () => alert('вложенное событие'))
</script>
```

![Dispatch event](../img/dispatch-events_02.png)

Порядок вывода: 1 → вложенное событие → 2.

Обратите внимание, что вложенное событие `menu-open` успевает всплыть и запустить обработчик на `document`. Обработка вложенного события полностью завершается до того, как управление возвращается во внешний код (`onclick`).

Это справедливо не только для `dispatchEvent`, но и для других ситуаций. JavaScript в обработчике события может вызвать другие методы, которые приведут к другим событиям – они тоже обрабатываются синхронно.

Если нам это не подходит, то мы можем либо поместить `dispatchEvent` (или любой другой код, инициирующий события) в конец обработчика `onclick`, либо, если это неудобно, можно обернуть генерацию события в `setTimeout` с нулевой задержкой:
```html
<button id="menu">Меню (нажми меня)</button>

<script>
  menu.onclick = function() {
    alert(1);

    // alert(2)
    setTimeout(() => menu.dispatchEvent(new CustomEvent("menu-open", {
      bubbles: true
    })));

    alert(2);
  };

  document.addEventListener('menu-open', () => alert('вложенное событие'))
</script>
```

Теперь `dispatchEvent` запускается асинхронно после исполнения текущего кода, включая `menu.onclick`, поэтому обработчики полностью независимы.

Новый порядок вывода: 1 → 2 → вложенное событие.

#### Итого
Чтобы сгенерировать событие из кода, вначале надо создать объект события.

Базовый конструктор `Event(name, options)` принимает обязательное имя события и `options` – объект с двумя свойствами:

- `bubbles: true` чтобы событие всплывало.
- `cancelable: true` если мы хотим, чтобы `event.preventDefault()` работал.

Особые конструкторы встроенных событий `MouseEvent`, `KeyboardEvent` и другие принимают специфичные для каждого конкретного типа событий свойства. Например, `clientX` для событий мыши.

Для пользовательских событий стоит применять конструктор `CustomEvent`. У него есть дополнительная опция `detail`, с помощью которой можно передавать информацию в объекте события. После чего все обработчики смогут получить к ней доступ через `event.detail`.

Несмотря на техническую возможность генерировать встроенные браузерные события типа `click` или `keydown`, пользоваться ей стоит с большой осторожностью.

Весьма часто, когда разработчик хочет сгенерировать встроенное событие – это вызвано «кривой» архитектурой кода.

Как правило, генерация встроенных событий полезна в следующих случаях:

- Либо как явный и грубый хак, чтобы заставить работать сторонние библиотеки, в которых не предусмотрены другие средства взаимодействия.
- Либо для автоматического тестирования, чтобы скриптом «нажать на кнопку» и посмотреть, произошло ли нужное действие.

Пользовательские события со своими именами часто создают для улучшения архитектуры, чтобы сообщить о том, что происходит внутри наших меню, слайдеров, каруселей и т.д.[^dispatch-events]

### Источники информации
[^9.1]: [Введение в обработку событий](https://metanit.com/web/javascript/9.1.php)
[^9.2]: [Обработчики событий](https://metanit.com/web/javascript/9.2.php)
[^9.7]: [Программный вызов событий](https://metanit.com/web/javascript/9.7.php)
[^9.8]: [Определение своих событий](https://metanit.com/web/javascript/9.8.php)
[^dispatch-events]: [Генерация пользовательских событий](https://learn.javascript.ru/dispatch-events)
