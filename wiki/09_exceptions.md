## Обработка исключений и отладка

- [Обработка исключений и отладка](#обработка-исключений-и-отладка)
  - [Обработка ошибок](#обработка-ошибок)
    - [Конструкция try..catch..finally](#конструкция-trycatchfinally)
      - [Получение ошибки в блоке catch](#получение-ошибки-в-блоке-catch)
      - [Блок finally](#блок-finally)
    - [Генерация ошибок и оператор throw](#генерация-ошибок-и-оператор-throw)
      - [throw в try..catch..finally](#throw-в-trycatchfinally)
    - [Типы ошибок](#типы-ошибок)
      - [Типы ошибок](#типы-ошибок-1)
      - [Применение типов ошибок](#применение-типов-ошибок)
      - [Обработка нескольких типов ошибок](#обработка-нескольких-типов-ошибок)
      - [Создание своих типов ошибок](#создание-своих-типов-ошибок)
    - [Обработка ошибок и стек вызова функций](#обработка-ошибок-и-стек-вызова-функций)
    - [Проброс ошибки вверх по стеку вызова функций](#проброс-ошибки-вверх-по-стеку-вызова-функций)
    - [Изоморфная обработка ошибок](#изоморфная-обработка-ошибок)
  - [Отладка и отладчик](#отладка-и-отладчик)
    - [Установка точек прерывания](#установка-точек-прерывания)
  - [Источники информации](#источники-информации)

### Обработка ошибок

#### Конструкция try..catch..finally
В процессе работы программы могут возникать различные ошибки, которые нарушают привычный ход программы и даже заставляют ее прервать выполнение. Язык JavaScript имеет инструменты для обработки таких ситуаций.[^16.1]

Простейшая ситуация — вызов функции, которой не существует:
```js
callSomeFunc();

console.log("Остальные инструкции");
```

Здесь вызывается функция `callSomeFunc()`, которая нигде не определена. Соответственно при вызове этой функции мы столкнемся с ошибкой:
```
Uncaught ReferenceError: callSomeFunc is not defined
```

Все остальные инструкции, которые идут после строки, на которой возникла ошибка, не выполняется. Программа заканчивает свою работу.

Ситуация может показаться искуственной, поскольку мы знаем, что функция `callSomeFunc` нигде не определена. Однако когда мы имеем дело с большой программой, различные куски которой определяли разные разработчики, становится сложнее контролировать код. И таких ситуаций может быть много. Какие-то мы можем сами отследить и предупредить, а какие-то нет.

Для обработки подобных ситуаций JavaScript предоставляет конструкцию **`try...catch...finally`**, которая имеет следующее формальное определение:
```js
try {
  инструкции блока try
}
catch (error) {
  инструкции блока catch
}
finally {
  инструкции блока finally
}
```

После оператора **`try`** определяется блок кода. В этот блок помещаются инструкции, при выполнении которых может возникнуть потенциальная ошибка.

Затем идет оператор **`catch`**. После этого оператора в круглых скобках указывается название объекта, который будет содержать информацию об ошибке. И далее идет блок `catch`. Этот блок выполняется только при возникновении ошибки в блоке `try`.

После блока `catch` идет оператор **`finally`** со своим блоком инструкций. Этот блок выполняется в конце после блока `try` и `catch` вне зависимости, возникла ошибка или нет.

Стоит отметить, что только блок **`try`** является обязательным. А один из остальных блоков — **`catch`** или **`finally`** — мы можем опустить. Однако один из этих блоков (не важно `catch` или `finally`) обязательно должен присутствовать. То есть мы можем использовать следующие варианты этой конструкции:

- `try...catch`

- `try...finally`

- `try...catch...finally`

Например, обработаем с помощью этой конструкцию предыдущую ситуацию с несуществующей функцией:
```js
try{
    callSomeFunc();
    console.log("Конец блока try");
}
catch{
    console.log("Возникла ошибка!");
}
console.log("Остальные инструкции");
```

Итак, сначала выполняется блок **`try`**. Однако при выполнении первой же инструкции — вызова функции `callSomeFunc()` возникает ошибка. Это приведет к тому, что все последующие инструкции в блоке **`try`** НЕ будут выполняться. А управление перейдет к блоку `catch`. В этом блоке выводится сообщение, что возникла ошибка. После выполнения блока **`catch`** выполняются остальные инструкции программы. Таким образом, программа не прерывает свою работу при возникновении ошибки и продолжает свою работу. И в данном случае консольный вывод будет следующим:
```
Возникла ошибка!
Остальные инструкции
```

Рассмотим другой пример:
```js
function callSomeFunc(){console.log("Функция callSomeFunc");}
try{
    callSomeFunc();
    console.log("Конец блока try");
}
catch(error){
    console.log("Возникла ошибка!");
}

console.log("Остальные инструкции");
```

Теперь функция `callSomeFunc()` определена в прогамме, поэтому при вызове функции ошибки не произойдет, и блок **`try`** доработает до конца. А блок **`catch`** при отсутствии ошибки не будет выполняться. И консольный вывод будет следующим:
```
Функция callSomeFunc
Конец блока try
Остальные инструкции
```

##### Получение ошибки в блоке catch
В качестве в качестве параметра в блок `catch` передается объект с информацией об ошибке:
```js
try{
    callSomeFunc();
    console.log("Конец блока try");
}
catch(error){
    console.log("Возникла ошибка!");
    console.log(error);
}
```

В этом случае мы получим консольный вывод на подобие следующего:
```
Возникла ошибка!
ReferenceError: callSomeFunc is not defined
    at index.html:35
```

##### Блок finally
Конструкция **`try`** также может содержать блок **`finally`**. Мы можем использовать этот блок вместе с блоком **`catch`** или вместо него. Блок **`finally`** выполняется вне зависимости, произошла ошибка или нет. Например:
```js
try{
    callSomeFunc();
    console.log("Конец блока try");
}
catch{
    console.log("Произошла ошибка");
}
finally{
    console.log("Блок finally")
}

console.log("Остальные инструкции");
```

Консольный вывод программы:
```
Произошла ошибка
Блок finally
Остальные инструкции
```

Если мы уберем блок **`catch`** и оставим только блок **`finally`**, то ошибка не будет обработана, и программа завершится ошибкой. Однако блок **`finally`** все равно выполнится:
```js
try{
    callSomeFunc();
    console.log("Конец блока try");
}
finally{
    console.log("Блок finally")
}

console.log("Остальные инструкции");
```

Консольный вывод программы:
```
Блок finally
Uncaught ReferenceError: callSomeFunc is not defined
```

#### Генерация ошибок и оператор throw
Интерпретатор JavaScript генерирует ошибки для ряда ситуаций, например, при вызове несуществующей функции, при повторном присвоении константе значения и т.д. Но при необходимости мы сами можем генерировать ошибки и определить условия, когда будет генерироваться ошибка.[^16.2]

Например, рассмотрим следующую ситуацию:
```js
class Person{

    constructor(name, age){
        this.name = name;
        this.age = age;
    }
    print(){ console.log(`Name: ${this.name}  Age: ${this.age}`); }
}
const tom = new Person("Tom", -123);
tom.print();    // Name: Tom  Age: -123
```

Класс `Person` описывает человека. В конструкторе класс получает значения для свойств `name` (имя) и `age` (возраст). Исходя из здравого смысла мы понимаем, что возраст не может быть отрицательным. Тем не менее пока, исходя из логики класса, ничего не мешает при создании объекта `Person` передать ему для возраста отрицательное значение. С точки зрения интерпретатора JavaScript ошибки нет, однако с точки логики и здравого смысла — это ошибка. Как исправить эту ситуацию? Есть различные способы, и один из них заключается в генерации исключения.

Для генерации исключения применяется оператор **`throw`**, после которого указывается информация об ошибке:
```js
throw информация_об_ошибке;
```

Информация об ошибке может представлять любой объект.

Так, сгенерируем исключение при передаче в конструктор `Person` отрицательного значения для свойства `age`:
```js
class Person{

    constructor(name, age){
        if(age < 0) throw "Возраст должен быть положительным";
        this.name = name;
        this.age = age;
    }
    print(){ console.log(`Name: ${this.name}  Age: ${this.age}`);}
}
const tom = new Person("Tom", -123);    // Uncaught Возраст должен быть положительным
tom.print();
```

В итоге при вызове конструктора `Person` будет сгенерировано исключение и программа завершится ошибкой. А на консоли браузера мы увидим информацию об ошибке, которая указана после оператора `throw`:
```
Uncaught Возраст должен быть положительным
```

Как и в общем случае мы можем обработать эту ошибку с помощью блока **`try...catch`**:
```js
class Person{

    constructor(name, age){
        if(age < 0) throw "Возраст должен быть положительным";
        this.name = name;
        this.age = age;
    }
    print(){ console.log(`Name: ${this.name}  Age: ${this.age}`);}
}

try{
    const tom = new Person("Tom", -123);    // Uncaught Возраст должен быть положительным
    tom.print();
}
catch(error){
    console.log("Произошла ошибка");
    console.log(error);     // Возраст должен быть положительным
}
```

##### throw в try..catch..finally
Оператор **`throw`** может вызываться в различных контекстах, например, в том же блоке **`try`**:
```js
try{
    throw "Непредвиденная ошибка!";
}
catch(error){
    console.log(error); // Непредвиденная ошибка!
}
```

Это может быть полезно по ряду причин. Во-первых, мы можем тут же обработать ошибку. Во-вторых, мы можем определить с помощью блока `finally` некоторые завершающие действия, которые будут выполняться, даже если сгенерирована ошибка. Например:
```js
// класс условной базы данных
class Database{
    constructor(){
        this.data = ["Tom", "Sam", "Bob"];
    }
    // получение данных
    getItem(index){
        this.open();
        if(index > 0 && index < this.data.length)
            return this.data[index];
        else
            throw "Некорректный индекс";
        this.close();   // при генерации исключения эта строка не будет выполняться
    }
    // открытие БД
    open(){ console.log("Подключение к базе данных установлено"); }
    // закрытие БД
    close(){ console.log("Подключение к базе данных закрыто"); }
}

const db = new Database();
try {
    db.getItem(5);      // возвращаем полученный элемент
} catch(err) {
    console.error(err); // если произошла ошибка обрабатываем ее
}
```

Здесь определен класс `Database` — класс условной базы данных. Все данные хранятся в массиве `data`. Для взаимодействия с базой данных определены три метода. Методы `open` и `close` условно открывают и закрывают подключение к базе данных. Метод `getItem` получает по индексу элемент из массива `data`. Если же индекс некорректный, то генерируется ошибка. При этом до получения элемента по индексу метод `getItem` должен открыть подключение методом `open`, а после получения — закрыть методом `close`. Однако в примере выше при генерации ошибки закрытия подключения не произойдет:
```js
else
    throw "Некорректный индекс";
this.close();   // при генерации исключения эта строка не будет выполняться
```

В итоге при передаче в метод `getItem` некорректного индекса консольный вывод программы будет следующим:
```
Подключение к базе данных установлено
Некорректный индекс
```

Однако что делать, если нам все-таки надо вызвать метод `close`? Мы можем поместить его вызов в блок **`finally`**:
```js
class Database{
    constructor(){
        this.data = ["Tom", "Sam", "Bob"];
    }
    // получение данных
    getItem(index){
        this.open();
        try{
             if(index > 0 && index < this.data.length)
                return this.data[index];
            else
                throw "Некорректный индекс";
        }
        finally{    // даже если сгенерирована ошибка, то этот блок выполняется
            this.close();   // при генерации исключения эта строка также будет выполняться
        }
    }
    // открытие БД
    open(){ console.log("Подключение к базе данных установлено"); }
    // закрытие БД
    close(){ console.log("Подключение к базе данных закрыто"); }
}

const db = new Database();
try {
    db.getItem(5);   // возвращаем полученный элемент
} catch(err) {
    console.error(err); // если произошла ошибка обрабатываем ее
}
```

И теперь консольный вызов будет иным:
```
Подключение к базе данных установлено
Подключение к базе данных закрыто
Некорректный индекс
```

#### Типы ошибок
В блоке **`catch`** мы можем получить информацию об ошибке, которая представляет объект. Все ошибки, которые генерируются интерпретатором JavaScript, предоставляют объект типа **`Error`**, который имеет ряд свойств:

- **`message`**: сообщение об ошибке

- **`name`**: тип ошибки

Стоит отметить, что отдельные браузеры поддерживают еще ряд свойств, но их поведение в зависимости от браузера может отличаться:

- **`fileName`**: название файла с кодом JavaScript, где произошла ошибка

- **`lineNumber`**: строка в файле, где произошла ошибка

- **`columnNumber`**: столбец в строке, где произошла ошибка

- **`stack`**: стек ошибки

Получим данные ошибки, например, при вызове несуществующей функции:
```js
try{
    callSomeFunc();
}
catch(error){
    console.log("Тип ошибки:", error.name);
    console.log("Ошибка:", error.message);
}
```

Консольный вывод:
```
Тип ошибки: ReferenceError
Ошибка: callSomeFunc is not defined
```

##### Типы ошибок
Выше мы рассмотрели, что генерируемая интерпретатором ошибка представляет тип Error, однако при вызове несуществующей функции генерируется ошибка типа **`ReferenceError`**. Дело в том, что тип `Error` представляет общий тип ошибок. В то же время есть конкретные типы ошибок для определенных ситуаций:

- **`EvalError`**: представляет ошибку, которая генерируется при выполнении глобальной функции `eval()`

- **`RangeError`**: ошибка генерируется, если параметр или переменная, представляют число, которое находится вне некоторого допустимого диапазона

- **`ReferenceError`**: ошибка генерируется при обращении к несуществующей ссылке

- **`SyntaxError`**: представляет ошибку синтаксиса

- **`TypeError`**: ошибка генерируется, если значение переменной или параметра представляют некорректный тип или при попытке изменить значение, которое нельзя изменять

- **`URIError`**: ошибка генерируется при передаче функциям `encodeURI()` и `decodeURI()` некорректных значений

- **`AggregateError`**: предоставляет ошибку, которая объединяет несколько возникших ошибок

Например, при попытке присвоить константе второй раз значение, генерируется ошибка `TypeError`:
```js
try{
    const num = 9;
    num = 7;
}
catch(error){
    console.log(error.name);        // TypeError
    console.log(error.message);     // Assignment to constant variable.
}
```

##### Применение типов ошибок
При генерации ошибок мы можем использовать встроенные типы ошибок. Например:
```js
class Person{

    constructor(name, age){
        if(age < 0) throw new Error("Возраст должен быть положительным");
        this.name = name;
        this.age = age;
    }
    print(){ console.log(`Name: ${this.name}  Age: ${this.age}`);}
}

try{
    const tom = new Person("Tom", -45);
    tom.print();
}
catch(error){
    console.log(error.message); // Возраст должен быть положительным
}
```

Здесь конструктор класса `Person` принимает значения для имени и возаста человека. Если передан отрицательный возраст, то генерируем ошибку в виде объекта `Error`. В качестве параметра в конструктор `Error` передается сообщение об ошибке:
```js
if(age < 0) throw new Error("Возраст должен быть положительным");
```

В итоге при обработке исключения в блоке `catch` мы сможем получить переданное сообщение об ошибке.

Все остальные типы ошибок в качестве первого параметра в конструкторе также принимают сообщение об ошибке. Так, сгенерируем несколько типов ошибок:
```js
class Person{

    constructor(pName, pAge){

        const age = parseInt(pAge);
        if(isNaN(age))  throw new TypeError("Возраст должен представлять число");
        if(age < 0 || age > 120) throw new RangeError("Возраст должен быть больше 0 и меньше 120");
        this.name = pName;
        this.age = age;
    }
    print(){ console.log(`Name: ${this.name}  Age: ${this.age}`);}
}
```

Поскольку для возраста можно передать не только число, но и вообще какое угодно значение, то вначале мы пытаемся преобразовать это значение в число с помощью функции `parseInt()`:
```js
const age = parseInt(pAge);
if(isNaN(age))  throw new TypeError("Возраст должен представлять число");
```

Далее с помощью функции `isNaN(age)` проверяем, является полученное число числом. Если `age` — НЕ число, то данная функция возвращает `true`. Поэтому генерируется ошибка типа `TypeError`.

Затем проверяем, что полученное число входит в допустимый диапазон. Если же не входит, генерируем ошибку типа `RangeError`:
```js
if(age < 0 || age > 120) throw new RangeError("Возраст должен быть больше 0 и меньше 120");
```

Проверим генерацию исключений:
```js
try{
    const tom = new Person("Tom", -45);
}
catch(error){
    console.log(error.message); // Возраст должен быть больше 0 и меньше 120
}

try{
    const bob = new Person("Bob", "bla bla");
}
catch(error){
    console.log(error.message); // Возраст должен представлять число
}

try{
    const sam = new Person("Sam", 23);
    sam.print();    // Name: Sam  Age: 23
}
catch(error){
    console.log(error.message);
}
```

Консольный вывод:
```
Возраст должен быть больше 0 и меньше 120
Возраст должен представлять число
Name: Sam  Age: 23
```

##### Обработка нескольких типов ошибок
При выполнении одного и то же кода могут генерироваться ошибки разных типов. И иногда бывает необходимо разграничить обработку разных типов. В этом случае мы можем проверять тип возникшей ошибки. Например, пример выше с классом `Person`:
```js
class Person{

    constructor(pName, pAge){

        const age = parseInt(pAge);
        if(isNaN(age))  throw new TypeError("Возраст должен представлять число");
        if(age < 0 || age > 120) throw new RangeError("Возраст должен быть больше 0 и меньше 120");
        this.name = pName;
        this.age = age;
    }
    print(){ console.log(`Name: ${this.name}  Age: ${this.age}`);}
}

try{
    const tom = new Person("Tom", -45);
    const bob = new Person("Bob", "bla bla");
}
catch(error){
    if (error instanceof TypeError) {
        console.log("Некорректный тип данных.");
    } else if (error instanceof RangeError) {
        console.log("Недопустимое значение");
    }
    console.log(error.message);
}
```

##### Создание своих типов ошибок
Мы не ограничены встроенными только встроенными типами ошибок и при необходимости можем создавать свои типы ошибок, предназначенные для каких-то конкретных ситуаций. Например:
```js
class PersonError extends Error {
  constructor(value, ...params) {
    // остальные параметры передаем в конструктор базового класса
    super(...params)
    this.name = "PersonError"
    this.argument = value;
  }
}

class Person{

    constructor(pName, pAge){

        const age = parseInt(pAge);
        if(isNaN(age))  throw new PersonError(pAge, "Возраст должен представлять число");
        if(age < 0 || age > 120) throw new PersonError(pAge, "Возраст должен быть больше 0 и меньше 120");
        this.name = pName;
        this.age = age;
    }
    print(){ console.log(`Name: ${this.name}  Age: ${this.age}`);}
}

try{
    //const tom = new Person("Tom", -45);
    const bob = new Person("Bob", "bla bla");
}
catch(error){
    if (error instanceof PersonError) {
        console.log("Ошибка типа Person. Некорректное значение:", error.argument);
    }
    console.log(error.message);
}
```

Консольный вывод
```
Ошибка типа Person. Некорректное значение: bla bla
Возраст должен представлять число
```

Для представления ошибки класса `Person` здесь определен тип `PersonError`, который наследуется от класса `Error`:
```js
class PersonError extends Error {
  constructor(value, ...params) {
    // остальные параметры передаем в конструктор базового класса
    super(...params)
    this.name = "PersonError"
    this.argument = value;
  }
}
```

В конструкторе мы определяем дополнительное свойство — `argument`. Оно будет хранить значение, которое вызвало ошибку. С помощью параметра `value` конструктора получаем это значение. Кроме того, переопределяем имя типа с помощью свойства `this.name`.[^16.3]

В классе `Person` используем этот тип, передавая в конструктор `PersonError` соответствующие значения:
```js
if(isNaN(age))  throw new PersonError(pAge, "Возраст должен представлять число");
if(age < 0 || age > 120) throw new PersonError(pAge, "Возраст должен быть больше 0 и меньше 120");
```

Затем при обработке исключения мы можем проверить тип, и если он представляет класс `PersonError`, то обратиться к его свойству `argument`:
```js
catch(error){
    if (error instanceof PersonError) {
        console.log("Ошибка типа Person. Некорректное значение:", error.argument);
    }
    console.log(error.message);
}
```

#### Обработка ошибок и стек вызова функций
Если внутри функции возникает ошибка, которая не обрабатывается, то интерпретатор JavaScript выходит из этой функции во внешний код в поиске обработчика ошибки. Например:
```js
function A(){
    console.log("func A starts");
    callSomeFunc();
    console.log("func A ends");
}
console.log("program ends");
```

Здесь функция A вызывает не определенную функцию `callSomeFunc()`. Поэтому при выполнении программы при вызове функции `A` прерывается. Интерпретатор выходит во внешний код в поиске обработчика ошибки. Но во внешнем коде вокруг вызова функции `A` также не определена конструкция `try..catch`, поэтому выполнение всей программы аварийно завершится. Консольный вывод:
```
func A starts
Uncaught ReferenceError: callSomeFunc is not defined
    at A (index.html:11:2)
    at index.html:30:6
```

То же самое касается вложенных вызовов функций. Если во вложенной функции произошла ошибка, и она не обработана, то интепретатор также выходит во внешний контекст — внешнюю функцию. Если в ней ошибка также не обрабатывается, то интепретатор опять выходит во внешний контект, пока не найдет обработчик ошибки. Если ошибка не обработана ни в одной функции, ни в глобальном коде, то программа завершается. Например:
```js
function A(){
    console.log("func A starts");
    callSomeFunc();
    console.log("func A ends");
}
function B(){
    console.log("func B starts");
    A();
    console.log("func B ends");
}
function C(){
    console.log("func C starts");
    B();
    console.log("func C ends");
}
C();
console.log("program ends");
```

Здесь вызывается функция `C`, которая вызывает функцию `В`, которая вызывает функцию `А`, а та — несуществующую функцию `callSomeFunc`. В итоге в функции `А` возникнет ошибка. Поскольку функция `А` не обработала ошибку, интерпретатор последовательно ищет обработчик ошибки в функции `В`, затем в функции `С` и в конце в глобальном контексте. Но так как нигде ошибка не обрабатывается, то после возникновения ошибки, выполнение программы завершится:
```
func C starts
func B starts
func A starts
Uncaught ReferenceError: callSomeFunc is not defined
    at A (index.html:11:2)
    at B (index.html:16:2)
    at C (index.html:27:2)
    at index.html:31:1
```

Теперь определим в одной из функций обработчик ошибки, например, в функции `С`:
```js
function A(){
    console.log("func A starts");
    callSomeFunc();
    console.log("func A ends");
}
function B(){
    console.log("func B starts");
    A();
    console.log("func B ends");
}
function C(){
    console.log("func C starts");
    try{
        B();
    }
    catch{
        console.log("Error occured");
    }
    console.log("func C ends");
}

C();
console.log("program ends");
```

Опять же при возникновении ошибки интерпретатор сначала ищет обработчик в функции `А`. Поскольку в ошибка не обрабатывается, интерпретатор смотрит в окружающем коде в функции `В`, в ней обработчика тоже нет. Тогда поиск идет в функции `С` — в ней ошибка обрабатывается, и программа продолжает свою работу:
```
func C starts
func B starts
func A starts
Error occured
func C ends
program ends
```

При этом поскольку функции `А` и `В` не обработали ошибку, то они дальше не выполняются.

#### Проброс ошибки вверх по стеку вызова функций
Иногда ошибки обрабатываются где-то во вложенных вызовах других функций. Например, возьмем следующую ситуацию:
```js
// класс условной базы данных
class Database{
    constructor(){
        this.data = ["Tom", "Sam", "Bob"];
    }
    // получение данных
    getItem(index){
        if(index > 0 && index < this.data.length)
            return this.data[index];
        else    // если некорректный индекс - генерируем ошибку
            throw new RangeError("Invalid index");
    }
    // открытие бд
    open(){
        console.log("Database has opened");
    }
    // закрытие бд
    close(){
        console.log("Database has closed");
    }
}
// функция-обертка для получения объекта из базы данных по индексу
function get(index) {

    const db = new Database();
    db.open();  // условно открываем бд
    try {
        return db.getItem(index);   // возвращаем полученный элемент
    } catch(err) {
        console.error(err); // если произошла ошибка обрабатываем ее
    }
    db.close(); // условно закрываем бд
}
// вывод результата
function printResult(){
    const item = get(5);    // пытаемся получить элемент с индексом 5
    console.log("Got from database:",item); // выводим полученный элемент на консоль
}
printResult();
```

Здесь определен условный класс базы данных Database. Для взаимодействия с данными в нем определены три функции. Функции условного открытия и закрытия базы данных — функции `open` и `close` соответственно и функция `getItem`, которая возвращает элемент по определенному индексу из массива data. Однако если переданный индекс некорректен — меньше 0 или больше допустимого индекса, то генерируем ошибку `RangeError`.

Стоит отметить отметить, что это не единственный подход к реализации подобного функционала. Частно применяется другой подход, когда, если некорректный индекс/id, то функция возвращает `null`, что в определенных ситуациях может быть более предпочтительным. Но в данном случае для демонстрации остановимся на генерации исключения, если передан некорректный индекс.

Условимся, что, чтобы взаимодействовать с базой данных, нам надо ее вначале условно "открыть" методом `open`, а после завершения работы с ней "закрыть" с помощью метода `close` — довольно распространенный подход при работе с базами данных. Но чтобы абстрагироваться от всех этих деталей определяем дополнительную функцию `get`, которая принимает id и обращается к базе данных для получения элемента по id. И поскольку при обращении к методу `getItem` может произойти ошибка, то обрабатываем ее в конструкции `try..catch`
```js
try {
    return db.getItem(index);   // возвращаем полученный элемент
} catch(err) {
    console.error(err); // если произошла ошибка обрабатываем ее
}
```

Далее эту функцию вызываем из другой функции `printResult`, которая отображает полученный результат:
```js
function printResult(){
    const item = get(5);    // пытаемся получить элемент с индексом 5
    console.log("Got from database:",item); // выводим полученный элемент на консоль
}
```

Если мы посмотрим на вывод программы:
```
Database has opened
RangeError: Invalid index
    at Database.getItem (index.html:19:19)
    at get (index.html:36:19)
    at printResult (index.html:44:18)
    at index.html:47:1
get @ index.html:38
printResult @ index.html:44
(anonymous) @ index.html:47


Database has closed
Got from database: undefined
```

то увидим, что при передаче некорректного индекса, с одной стороны, ошибка обрабатывается, но с другой стороны, в функции `printResult` мы получаем неопределенный результат (значение `undefined`) и вообще не в курсе, что произошло — это можно узнать только по консольному выводу во время выполнения. Но функция `get` необязательно должна выводить ошибку на консоль, ошибка может обрабатываться каким-то другим образом. Соответственно возникает необходимость донести информацию об ошибке до более верхних уровней стека вызова функций (до функции `printResult`).

Для этого изменим код, выполнив проброс ошибки вверх по стеку вызова функций:
```js
class Database{
    constructor(){
        this.data = ["Tom", "Sam", "Bob"];
    }
    getItem(index){
        if(index > 0 && index < this.data.length)
            return this.data[index];
        else
            throw new RangeError("Invalid index");
    }
    open(){
        console.log("Database has opened");
    }
    close(){
        console.log("Database has closed");
    }
}
function get(index) {

    const db = new Database();
    db.open();
    try {
        return db.getItem(index);
    } catch(err) {
        console.error(err);
        throw new Error(err.message);   // снова генерируем ту же ошибку
    }
    finally{
        db.close();
    }
}
function printResult(){
    try{
        const item = get(5);
        console.log("Got from database:",item);
    }
    catch(err){
        console.log(err);   // обрабатываем ошибку из функции get
    }
}
printResult();
```

Теперь в функции `get` после обработки ошибки повторно генерируем ошибку с помощью оператора `throw`:
```js
try {
    return db.getItem(index);
} catch(err) {
    console.error(err);
    throw new Error(err.message);
}
finally{
    db.close();
}
```

Также стоит отметить, что вызов `db.close()`, который условно закрывает базу данных, помещается в блок **`finally`**. **Это гарантирует, что даже при генерации ошибки эта операция все равно будет выполнена.**[^16.4]

Таким образом, если при вызове `db.getItem` произошла ошибка, то при вызове функции get тоже произойдет ошибка, соотвественно в функции `printResult` мы можем обработать эту ошибку:
```js
function printResult(){
    try{
        const item = get(5);
        console.log("Got from database:",item);
    }
    catch(err){
        console.log(err);
    }
}
```

#### Изоморфная обработка ошибок
Изоморфная разработка в JavaScript предполагает переход к универсальной системе управлению исключениями, которая способна единообразно перехватывать, логировать и обрабатывать ошибки вне зависимости от выполняемых функций (если эти функции следуют некоторому общему протоколу) и предполагает стандартизацию формата ошибок. Ее цель — снизить дублирование кода, улучшить сопровождение и обеспечить предсказуемое поведение при возникновении сбоев. Дело в том, что обработка ошибок с помощью конструкции `try...catch` может показаться громоздкой, особенно когда приходится писать вложенные блоки `try..catch`. С блоками `try...catch` связан ряд проблем. Например, соответствующие блоки захватывают создаваемые в этих блоках значения, соответственно приходится выносить значения во внешние переменные. А глубокая вложенность функций, которые также могут генерировать исключения, усложняют и код, и понимание того, что он делает.

Рассмотрим простейший пример:
```js
// определение обертки для обработки ошибок
function tryCatch (fn){
  try{
    return [fn(), null];
  }
  catch(err){
    return [null, err];
  }
}

// использование
const sqrt = (x) => {
  if(x < 0) throw new Error(`Number ${x} is invalid`);
  return Math.sqrt(x);
}

// пример получения ошибки
const [res1, err1] = tryCatch(()=>sqrt(-4));

if(err1) console.error(err1);
else console.log("sqrt(-4):", res1);

// пример получения результата
const [res2, err2] = tryCatch(()=>sqrt(4));

if(err2) console.error(err2);
else console.log("sqrt(4):", res2);
```

Этот код демонстрирует обёртку над функцией для безопасного выполнения с возвратом массива `[результат, ошибка]` вместо ручного использования `try/catch`.

Вначале определяется функция `tryCatch`:
```js
function tryCatch (fn){
  try{
    return [fn(), null];
  }
  catch(err){
    return [null, err];
  }
}
```

`tryCatch` через параметр `fn` принимает другую функцию и вызывает ее внутри блока `try/catch`. В качестве результата возвращается массив с двумя элементами.

Если функция `fn` выполняется без ошибок, то возвращается массив `[результат, null]`.

Если происходит ошибка — возвращается `[null, ошибка]`.

Это делает вызовы функций более чистыми, особенно при работе с возможными исключениями.

Далее для примера определена обычная функция sqrt, которая вычисляет квадратный корень переданного в нее числа с помощью встроенной функции `Math.sqrt()` и которая генерирует ошибку при отрицательных значениях (так как нельзя вычислить квадратный корень для отрицательных чисел).

```js
const sqrt = (x) => {
  if (x < 0) throw new Error(`Number ${x} is invalid`);
  return Math.sqrt(x);
};
```

Далее идут примеры вызова. В первом случае вызывается `sqrt(-4)`, что вызывает исключение:
```js
const [res1, err1] = tryCatch(()=>sqrt(-4));
```

Здесь `tryCatch` ловит исключение и возвращает массив `[null, Error("Number -4 is invalid")]`.

Во втором случае вызов `sqrt(4)` возвращает 2, соответственно ошибки нет
```js
const [res2, err2] = tryCatch(()=>sqrt(4));
```

Фактически возвращается массив `[2, null]`.

В итоге мы получим следующий вывод в консоли браузера:
```
Error: Number -4 is invalid
sqrt(4): 2
```

Возьмем другой пример — создание объекта класса:
```js
class Person{

    constructor(name, age){
        if(age < 0) throw `Недопустимый возраст ${age}. Минимальное значение: 1`;
        if(name.length < 2) throw `Недопустимое имя ${name}: минимальная длина имени - 2 символа`;
        this.name = name;
        this.age = age;
    }
    print(){ console.log(`Name: ${this.name}  Age: ${this.age}`);}
}
```

В данном случае класс `Person` генерирует исключение, если в конструктор передан недопустимый возраст — меньше 0 или если длина переданного имени меньше 2 символов. Используем вышеопределенную функцию `tryCatch` для обработки исключений:
```js
function tryCatch (fn){
  try{
    return [fn(), null];
  }
  catch(err){
    return [null, err];
  }
}

class Person{

    constructor(name, age){
        if(age < 0) throw `Недопустимый возраст ${age}. Минимальное значение: 1`;
        if(name.length < 2) throw `Недопустимое имя ${name}: минимальная длина имени - 2 символа`;
        this.name = name;
        this.age = age;
    }
    print(){ console.log(`Name: ${this.name}  Age: ${this.age}`);}
}

// для примера пытаемся создать пару объектов
const [tom, err1] = tryCatch(() => new Person("Tom", -123));
if(err1) console.error(err1);
else tom.print();

const [bob, err2] = tryCatch(() => new Person("Bob", 46));
if(err2) console.error(err2);
else bob.print();
```

Здесь для примера пытаемся создать два объекта `Person`, передавая в вызов `tryCatch` соответствующий вызов конструктора. И опять же мы получаем массив, где первый элемент — результат, а второй — информация об ошибке. Поскольку в первом случае в конструктор `Person` передаются заведомо некорректные данные, то мы получим ошибку, а во втором случае — объект `Person`:
```
Недопустимый возраст -123. Минимальное значение: 1
Name: Bob  Age: 46
```

Стоит отметить, что выше представлена только одна из возможных реализаций. Некоторые особенности могут отличаться. Например, функция-обертка может дополнительно обрабатывать ошибку. Так, стандартный тип для ошибок в JavaScript — это тип **`Error`**. Однако в коде разработчики не всегда генерируют ошибки этого типа. Например, в коде выше в конструкторе класса `Person` ошибка по сути представляет простую строку:
```js
if(age < 0)
  throw `Недопустимый возраст ${age}. Минимальное значение: 1`;  // ошибка представляет строку
```

И функция-обертка может проверять тип и при необходимости обертывать ошибку в тип `Error`:
```js
function tryCatch (fn){
  try{
    return [fn(), null];
  }
  catch(err){
    // проверяем, представляет ли ошибка err объект Error
    const error = err instanceof Error ? err : new Error(String(err))
    return [null, error];
  }
}
```

Также сама функция-обертка может отличаться. Так, мы могли бы определить следующую функцию:
```js
const tryWrap = (fn) => (...args) => {
  try{
    return [fn(...args), null];
  }
  catch(err){
    return [null, err];
  }
}
```

`tryWrap` определена как стрелочная функция, которая через параметр `fn` принимает другую функцию и возвращает новую функцию. Возвращаемая функция вызывает функцию `fn` с переданными аргументами (`...args`), но делает это внутри блока `try/catch`. Обратите внимание, что через параметр `args` можно передать произвольное количество аргументов. В остальном логика та же самая, что и у выше определнной функции `tryCatch`: если функция `fn` выполняется без ошибок, то возвращается массив `[результат, null]`. Если происходит ошибка, то возвращается массив `[null, ошибка]`.

Пример использования:
```js
// на примере функции sqrt
const [res1, err1] = tryWrap(sqrt)(-4);
const [res2, err2] = tryWrap(sqrt)(4);

// на примере конструктора класса Person
const [tom, tomErr] = tryWrap((name, age)=>new Person(name, age))("Tom", -123);
const [bob, bobErr] = tryWrap((name, age)=>new Person(name, age))("Bob", 46);
```

Можно в принципе не определять функцию-обертку, если используемые функции изначально поддерживают требуемые контракт — возвращают информацию о результате функции и ошибке в требуемом формате. Например:
```js
// функция возвращает данные в формате "[результат, ошибка]""
const sqrt = (x) => {
  if(x < 0) return [null, new Error(`Number ${x} is invalid`)];
  return [Math.sqrt(x), null];
}

const [res1, err1] = sqrt(-4);
if(err1) console.error(err1);
else console.log("sqrt(-4):", res1);


const [res2, err2] = sqrt(4);
if(err2) console.error(err2);
else console.log("sqrt(4):", res2);
```

аким образом мы получили унифицированный способ для обработки ошибок, и нам не надо писать `try/catch` каждый раз при вызове отдельной функции, которая может сгенерировать ошибку. Особенно данный подход упрощает написание кода в функциональном стиле. Для асинхронных операций этот подход можно адаптировать в виде `async/await`-совместимого варианта.

В итоге счет изоморфной обработки ошибок упрощается код, улучшается его отладка и мониторинг благодаря централизованной обработке ошибок, упрощается повторное использование код и повышается надёжности приложения за счёт предсказуемой реакции на сбои.[^16.5]

### Отладка и отладчик

В общем случае отладка представляет процесс поиска ошибок и багов в программе. Для выполнения отладки применяется специальный инструмент — отладчик. Но кроме поиска багов и ошибок отладка и отладчик предоставляют прекрасный способ понять поток и выполнение программы, происходящие в ней действия, как эти действия выполняются в программе и в конечном счете обогатить навыки и понимание разработки.

Что касательно отладчиков для программ на языке JavaScript, то мы можем использоваться отладчиками, встроенными в веб-браузеры. Многие распространенные веб-браузеры предоставляют возможность отладки. В данном же случае для отладки мы будем использовать встроенный отладчик в Chrome DevTools, так как Google Chrome представляет наиболее распространенный браузер. Однако работа с отладчиками в других браузерах будет во многом похожей.

Рассмотрим следующую программу:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>ECMAScript</title>
</head>
<body>
    <script>
const numbers = [5, 3, 6, 2, 5, 1];

for(let i=0; i < numbers.length-1; i++){

    for(let j=i+1; j < numbers.length; j++){

        if(numbers[i] > numbers[j]){

            const temp = numbers[j];
            numbers[j] = numbers[i];
            numbers[i] = temp;
        }
    }
}

console.log("numbers:", numbers);
    </script>
</body>
</html>
```

Здесь в коде JavaScript определена простейшая сортировка массива чисел. Сначала в цикле по i проходим по всем элементам массива вплоть до последнего (не включая), и сравниваем текущий элемент по `i` со всеми последующими элементами в цикле по `j`. Если один из последующих элементов (`numbers[j]`) меньше текущего элемента (`numbers[i]`), то меняем их местами. После того, как мы сравнивали текущий элемент `numbers[i]` со всеми последующими (`numbers[j]`) и поместили в `numbers[i]` наименьший элемент, увеличиваем значение `i` и переходим к сравнению следующего элемента со всеми последующими.

И чтобы детально посмотреть, как программа сортируем массив, воспользуемся отладкой. Для этого загрузим страницу с кодом JavaScript в Google Chrome и перейдем к инструментам разработчика (можно сделать с помощью комбинации клавиш <kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>I</kbd>). Далее в панели инструментов разработчика откроем вкладку **Sources**.

![Отладка кода JavaScript в Chrome DevTools](../img/debug0.png)

А в левом древовидном меню найдем файл, где у нас расположен код JavaScript (в данном случае это веб-страница *index.html*). И этот файл будет открыт в центральной части.

#### Установка точек прерывания
Чтобы иметь возможность инспектировать программу в определенной строке кода, надо на эту строку установить **точку прерывания** (breakpoint). В Chrome DevTools для этого достаточно нажать на номер нужной строки. После установки точки прерывания строка кода будет отмечена синий меткой:

![Установка точки прерывания в коде JavaScript в Chrome DevTools](../img/debug2.png)

Так, на снимке экрана видно, что у нас точка прерывания установлена в файле *index.html* на 17-й строке:

```js
const temp = numbers[j];
```

В качестве альтернативы можно нажать на номер строки кода и в появившемся контекстном меню выбрать пункт "Add breakpoint" для установки на указанную строку точки прерывания.

![Установка точки прерывания в Chrome DevTools](../img/debug3.png)

Чтобы удалить точку прерывания, достаточно нажать на синюю метку на номере строки.

Если мы обновим страницу в браузере, то при выполнении кода JavaScript программа остановится на установленной точке прерывания:

![Выполнение программы JavaScript и точки прерывания в коде в Chrome DevTools](../img/debug4.png)

И в этой точке мы можем исследовать состояние программы на текущий момент.

При остановке на точке прерывания мы можем увидеть часть информации непосредственно в после с исходным кодом файла, например, навести на нужную нам переменную, и нам отобразится ее значение. Но для более подробной информации предназначена правая колонка, где можно посмотреть текущие значения глобальных и локальных переменных, значения параметров, стек вызова функций и прочую информацию:

![Проверка состояния переменных JavaScript при отладке в Chrome DevTools](../img/debug5.png)

Например, из вышеприведенного скриншота видно, что при первом выполнении 17-й строки значение переменной `i` равно 0, а значение переменной `j` равно 1.

С помощью кнопок над правой колонкой можно управлять ходом отладки:

![Управление ходом отладки JavaScript в Chrome DevTools](../img/debug6.png)

Подобным образом мы можем установить множество точек прерывания и детально исследовать выполнение программы.

Кроме обычных точек прерывания Chrome DevTools позволяет устанавливать и другие типы точек прерывания. Так, условные точки прерывания позволяют остановить выполнение программы, если соблюдается некоторое условие. Точки прерывания DOM позволяют остановить выполнение при динамическом изменении содержимого веб-страницы. Точки прерывания обработчиков событий позволяют остановить выполнение, если сработало определенное событие веб-страницы. Точки прерывания XHR позволяют остановить программу при выполнении Ajax-запроса. И таким образом, мы можем детально исследовать различные аспекты работы программы.[^2.11]

### Источники информации
[^16.1]: [Обработка ошибок](https://metanit.com/web/javascript/16.1.php)
[^16.2]: [Генерация ошибок и оператор throw](https://metanit.com/web/javascript/16.2.php)
[^16.3]: [Типы ошибок](https://metanit.com/web/javascript/16.3.php)
[^16.4]: [Обработка ошибок и стек вызова функций](https://metanit.com/web/javascript/16.4.php)
[^16.5]: [Изоморфная обработка ошибок](https://metanit.com/web/javascript/16.5.php)
[^2.11]: [Отладка и отладчик](https://metanit.com/web/javascript/2.11.php)
