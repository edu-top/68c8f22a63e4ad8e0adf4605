## Разветвляющиеся алгоритмы. Условные выражения, конструкции и операторы

- [Разветвляющиеся алгоритмы. Условные выражения, конструкции и операторы](#разветвляющиеся-алгоритмы-условные-выражения-конструкции-и-операторы)
  - [Условные выражения](#условные-выражения)
      - [Логические операции с произвольными значениями](#логические-операции-с-произвольными-значениями)
      - [Условные конструкции](#условные-конструкции)
  - [Управляющие конструкции](#управляющие-конструкции)
    - [Конструкция if..else](#конструкция-ifelse)
      - [Проверка наличия значения](#проверка-наличия-значения)
      - [Выражение else](#выражение-else)
      - [Альтернативные условия и else if](#альтернативные-условия-и-else-if)
    - [True или false](#true-или-false)
    - [Конструкция switch..case](#конструкция-switchcase)
      - [Оператор break](#оператор-break)
      - [Объединение условий](#объединение-условий)
      - [Условие по умолчанию — default](#условие-по-умолчанию--default)
  - [Условные операторы](#условные-операторы)
    - [Тернарная операция](#тернарная-операция)
    - [Оператор ??](#оператор-)
    - [Оператор ??=](#оператор--1)
  - [Расширенный алгоритм работы логических операторов](#расширенный-алгоритм-работы-логических-операторов)
    - [Оператор «ИЛИ» (`||`)](#оператор-или-)
    - [Оператор «И» (`&&`)](#оператор-и-)
    - [Оператор нулевого слияния (`??`)](#оператор-нулевого-слияния-)
  - [Задачи](#задачи)
  - [Источники информации](#источники-информации)


### Условные выражения
Условные выражения работают с условиями — выражениями, которые возвращают значение типа `Boolean` — `true` (условие не верно) или `false` (условие не верно).

##### Логические операции с произвольными значениями
В предыдущем разделе упоминалось, что логические операции **обычно** в качестве операндов принимают значения `Boolean` — **`true`** или **`false`**, а результатом операций также **обычно** являются значения `Boolean`. Но это обычно, в реальности же операндами и результатами этих операций могут быть произвольные значения. Иногда JavaScript может автоматически преобразовать определенные значения в тип `Boolean`:

Исходное значение | Целевое значение
-- | --
`null` | `false`
`undefined` | `false`
`0` (в том числе значение `NaN`) | `false`
`1`, `3.14`, `-5.23` (любое ненулевое значение) | `true`
`""` (пустая строка) | `false`
`"abc"`, `'0'` (любая непустая строка) | `true`
`{ name: "Tom", age: '25' }`, `{}` (любой объект) | `true`

И если какие-то операнды не представляют значение `Boolean`, то в этом случае логические операции действуют в соответствии с некоторыми плавилами.

Если как минимум один операнд операции **`&&`** не является значением типа `Boolean`, то выполняются следующие действия:

- если первый операнд возвращает `false` (например, число 0, пустая строка, `null`, `undefined`), то операция возвращает первый операнд;

- в остальных случаях возвращается второй операнд.

```js
let isAlive;        // undefined
let name = "Tom";

const result = isAlive && name;
console.log(result);
```

Здесь первый операнд операции **`&&`** — переменная `isAlive` равна `undefined` (так как переменная не инициализирована), что при преобразовании к `Boolean` даст `false`, поэтому операция возвратит значение переменной `isAlive`.

Еще несколько примеров:
```js
console.log(false && "Tom");  // false
console.log("Tom" && null);   // null
console.log(true && "Tom");   // Tom
```

Если один или оба операнда операции **`||`** не являются значениями `Boolean`, то операция выполняет следующие действия:

- если первый операнд оценивается как `true` (то есть не равен 0, пустой строке, `null` или `undefined`), то возвращается первый операнд;

- во всех остальных случаях возвращается второй операнд.

Примеры:
```js
console.log(false || "Tom");  // Tom
console.log("Tom" || null);   // Tom
console.log(true || "Tom");   // true
```

Если операнд операции отрицания **`!`** не является значением `Boolean`, то выполняются следующие действия:

- если операнд — пустая строка, то возвращается **`true`**, если строка не пустая — то **`false`**;

- если операнд — число 0, то возвращается **`true`**, для всех других чисел возвращается **`false`**;

- если операнд — объект, возвращается **`false`**;

- если операнд — значения `null`, `NaN` и `undefined`, возвращается **`true`**.

Примеры:
```js
let isAlive;            // undefined
console.log(!isAlive);  // true
console.log(!null);     // true
console.log(!0);        // true
console.log(!10);       // false
console.log(!"");       // true (пустая строка)
console.log(!"Tom");    // false
```

##### Условные конструкции
Выше рассматривалось, что логические операции могут принимать значения произвольных типов, а не только `Boolean`. Казалось бы в этом нет особого смысла. Тем не менее подобные конструкции могут быть очень удобны, когда нам надо проверить условие и в зависимости от проверки выполнить то или иное действие. Например:
```js
const age = 22;
age <= 17 && console.log("Вам меньше 18 лет. Доступ запрещен.");
age > 17 && console.log("Вам больше 17 лет. Доступ разрешен.");
```

Здесь в зависимости от значения константы `age` (которая представляет условный возраст) выводим на консоль ту или иную строку (условно в зависимости от возраста разрешаем или запрещаем доступ). Напомним, что `&&` возвращает второй операнд, если первый равен `true`. Сначала выполняется первая операцию `&&`
```js
age <= 17 && console.log("Вам меньше 18 лет. Доступ запрещен.");
```

Здесь сначала проверяется первый операнд — выражение `age <= 17`. Если оно истинно (то есть если `age` меньше 18), то выполняем метод `console.log()`. Однако поскольку условие из первого операнда НЕ верно (так как `age` больше 17), поэтому не будет выполнять второй операнд, и операция возвратит `false`.

Аналогично работает вторая операция **`&&`** за тем исключением, что она проверяет истинность выражения `age > 17` (то есть `age` должно быть больше 17)
```js
age > 17 && console.log("Вам больше 17 лет. Доступ разрешен.");
```

Здесь же условие из первого операнда верно, поэтому будет выполняться второй операнд. В итоге на консоль браузера будет выведена строка
```
Вам больше 17 лет. Доступ разрешен.
```

Аналогично для построения условных конструкций можно использовать операцию **`||`**, но она возвращает второй операнд, если первый операнд равен `false`. То есть получается наоброт: операция **`&&`** возвращает второй операнд, если условие первого операнда верно, а **`||`** — если условие не верно. И мы могли бы переписать предыдущий пример с помощью операции `||` следующим образом:
```js
const age = 12;
age <= 17 || console.log("Вам больше 17 лет. Доступ разрешен.");
age > 17 || console.log("Вам меньше 18 лет. Доступ запрещен.");
```

### Управляющие конструкции
Реализация разветвляющихся алгоритмов осуществляется при помощи базовой алгоритмической структуры "ветвление". Она встречается, если действия алгоритма зависят от некоторого условия.

Алгоритм реализован через алгоритмическую конструкцию «ветвление», если от входных данных зависит, какие команды будут выполняться. Условие, которое выражает эту зависимость, фактически является вопросом, на который можно ответить либо «да», либо «нет».

Существуют полная и неполная формы ветвления.

В полной форме если условие выполняется, то алгоритм переходит к выполнению первой серии команд, а если не выполняется — то ко второй.

В неполной форме алгоритм выполняет серию команд только если условие истинно. В противном случае ничего не происходит.

Алгоритм, основанный на конструкции «ветвление» называется разветвляющимся алгоритмом. Примером такого алгоритма может служить алгоритм нахождения корней квадратного уравнения, блок-схема которого приведена на рисунке 2.[^базовые-алгоритмические-структуры]

![Ветвление](../img/ea5d55a4-b598-437f-8466-bed779d81bb2.png)

Условные управляющие конструкции позволяют выполнить те или иные действия в зависимости от определенных условий.

#### Конструкция if..else
Конструкция **`if..else`** проверяет некоторое условие и если это условие верно, то выполняет некоторые действия. Простейшая форма конструкции **`if..else`**:
```js
if(условие){
    некоторые действия
}
```

После ключевого слова **`if`** в круглых скобках идет условие, а после условия — блок кода с некоторыми действиями. Если это условие истинно, то затем выполняются действия, которые помещены в блоке кода

Например:
```js
const income = 100;
if(income > 50) {
    console.log("доход больше 50");
}
```

Здесь в конструкции `if` используется следующее условие: `income > 50`. Если это условие возвращает `true`, то есть если константа `income` имеет значение больше 50, то браузер отображает сообщение. Если же значение `income` меньше 50, то никакого сообщения не отображается.

Если блок кода содержит одну инструкцию, как в случае выше, то конструкцию можно упростить, убрав фигурные скобки и поместив действия сразу после условия:
```js
const income = 100;
if(income > 50) console.log("доход больше 50");
```

или перенести действия на следующую строку
```js
const income = 100;
if(income > 50)
    console.log("доход больше 50");
```

Причем условия могут быть сложными:
```js
const income = 100;
const age = 19;
if(income > 50 && age > 18){

    console.log("доход больше 50");
    console.log("возраст больше 18");
}
```

##### Проверка наличия значения
Конструкция `if` позволяет проверить наличие значения. Например:
```js
let myVar = 89;
if(myVar){

    console.log(`Переменная myVar имеет значение: ${myVar}`);
}
```

Если переменная `myVar` имеет значение, как в данном случае, то в условной конструкции она возвратит значение `true`.

Противоположный вариант:
```js
let myVar;
if(myVar){
    console.log(`Переменная myVar имеет значение: ${myVar}`);
}
```

Здесь переменная `myVar` не имеет значения. (В реальности она равна `undefined`). Поэтому условие в конструкии `if` возвратит `false`, и действия в блоке конструкции `if` не будут выполняться.

Но нередко для проверки значения переменной используют альтернативный вариант — проверяют на значение `undefined` и `null`:
```js
if (myVar !== undefined && myVar !== null) {
    console.log(`Переменная myVar имеет значение: ${myVar}`);
}
```

##### Выражение else
Выше мы рассмотрели, как определить действия, которые выполняются, если условие после **`if`** истинно. Но что, если мы хотим также выполнять еще один набор инструкций, если условие ложно? В этом случае можно использовать блок **`else`**. Данный блок содержит инструкции, которые выполняются, если условие после **`if`** ложно, то есть равно **`false`**:
```js
if(условие){
    действия, если условие истинно
}
else{
    действия, если условие ложно
}
```

То есть если условие после `if` истинно, выполняется блок `if`. Если условие ложно, выполняется блок `else`. Например:
```js
const income = 45;
if(income > 50){

    console.log("Доход больше 50");
}
else{
    console.log("Доход меньше или равен 50");
}
```

Здесь константа `income` равна 45, поэтому условие после оператора `if` возвратит **`false`**, и управление перейдет к блоку `else`.

Также если блок `else` содержит одну инструкцию, то можно сократить конструкцию:
```js
const income = 45;
if(income > 50) console.log("Доход больше 50");
else console.log("Доход меньше или равен 50");
```

##### Альтернативные условия и else if
С помощью конструкции **`else if`** мы можем добавить альтернативное условие к блоку `if`. Например, выше в условие значение `income` может быть больше определенном значению может быть меньше, а может быть равно ему. Отразим это в коде:
```js
const income = 50;
if(income > 50) {
    console.log("Доход больше 50");
}
else if(income === 50){
    console.log("Доход равен 50");
}
else{
    console.log("Доход меньше 50");
}
```

В данном случае выполнится блок `else if`. При необходимости мы можем использовать несколько блоков `else if` с разными условиями:
```js
const income = 500;
if(income < 200){

    console.log("Доход ниже среднего");
}
else if(income>=200 && income<300){

    console.log("Чуть ниже среднего");
}
else if(income>=300 && income<400){

    console.log("Средний доход");
}
else{
    console.log("Доход выше среднего");
}
```

При этом блок `else` применять необязательно:
```js
const income = 500;
if(income < 200){

    console.log("Доход ниже среднего");
}
else if(income>=200 && income<300){

    console.log("Чуть ниже среднего");
}
else if(income>=300 && income<400){

    console.log("Средний доход");
}
```

#### True или false
В javascript любая переменная может применяться в условных выражениях, но не любая переменная представляет тип `boolean`. И в этой связи возникает вопрос, что возвратит та или иная переменная — `true` или `false`? Много зависит от типа данных, который представляет переменная:

- `undefined`

    Возвращает `false`

- `null`

    Возвращает `false`

- `Boolean`

    Если константа/переменная равна `false`, то возвращается `false`. Соответствено если константа/переменная равна `true`, то возвращается `true`

- `Number`

    Возвращает `false`, если число равно 0 или `NaN` (`Not a Number`), в остальных случаях возвращается `true`

    Например, следующая переменная будет возращать false:

    ```js
    let x = NaN;
    if(x){  // false

    }
    ```

    `NaN` (не число) — это специальное значение типа `Number`, которое возвращают функции преобразования в числовой тип (`parseInt()`, `parseFloat()`, `Number()`, `+/-{n}`, `{n}*1`), если строковый аргумент не может быть преобразован в число.

    С помощью специальной функции `isNaN()` можно проверить, представляет ли строка число. Если строка не является числом, то функция возвращает `true`, если это число — то `false`:
    ```js
    const num1 = "javascript";
    const num2 = "22";
    let result = isNaN(num1);
    console.log(result); // true - num1 не является числом

    result = isNaN(num2);
    console.log(result); //  false - num2 - это число
    ```

- `String`

    Возвращает `false`, если константа/переменная равна пустой строке, то есть ее длина равна `0`, в остальных случаях возвращается `true`.

    ```js
    const emptyText = "";   // false - так как пустая строка
    const someText = "javascript";  // true - строка не пустая
    ```

- `Object`

    Всегда возвращает `true`
    ```js
    const user = {name:"Tom"};  // true
    const car = {}; // true
    ```

#### Конструкция switch..case
Конструкция **`switch..case`** является альтернативой использованию конструкции `if..else` и также позволяет обработать сразу несколько условий:
```js
const income = 200;
switch(income){

    case 100 :
        console.log("Доход равен 100");
        break;
    case 200 :
        console.log("Доход равен 200");
        break;
    case 500 :
        console.log("Доход равен 500");
        break;
}
```

После ключевого слова `switch` в скобках идет сравниваемое выражение. Значение этого выражения последовательно сравнивается со значениями, помещенными после оператора `сase`. И если совпадение будет найдено, то будет выполняться определенный блок `сase`.

В конце каждого блока `сase` ставится оператор **`break`**, чтобы избежать выполнения других блоков. В данном случае константа `income` равна 200, поэтому будет выполняться блок
```js
case 200 :
    console.log("Доход равен 200");
    break;
```

##### Оператор break
Оператор **`break`** служит для того, чтобы избежать выполнения других условий. Например, мы могли бы написать:
```js
let income = 200;
switch(income){

    case 100 :
        console.log("Доход равен 100");
        income +=100;
        break;
    case 200 :
        console.log("Доход равен 200");
        income +=100;
        break;
    case 500 :
        console.log("Доход равен 500");
        income +=100;
        // break;   // здесь смысла в break нет, так как последний блок
}
```

Здесь опять `income` равно 200 и опять будет выполняться блок
```js
case 200 :
    console.log("Доход равен 200");
    income +=100;
    break;
```

Благодаря оператору `break` после выполнения блока произойдет выход из конструкции `switch`, и никакие другие блоки case не будут выполняться.

Но теперь уберем оператор **`break`**:
```js
let income = 200;
switch(income){

    case 100 :
        console.log("Доход равен 100");
        income +=100;
    case 200 :
        console.log("Доход равен 200");
        income +=100;
    case 500 :
        console.log("Доход равен 500");
        income +=100;
}
console.log("Финальный доход равен", income);
```

Результат выполнения:
```
Доход равен 200
Доход равен 500
Финальный доход равен 400
```

Здесь изначально переменная income опять равна 200, соответственно будет выполняться блок
```js
case 200 :
    console.log("Доход равен 200");
    income +=100;
```

Значение `income` увеличивается на 100, однако в конце блока нет оператора **`break`**, поэтому управление перейдет к проверке условия в следующий блок:
```js
case 500 :
    console.log("Доход равен 500");
    income +=100;
```

И не важно, что `income` не равно 500 (а лишь 300 на данный момент), этот блок также будет выполняться.

##### Объединение условий
Однако при необходимости можно сразу обработать несколько условий:
```js
const income = 200;
switch(income){

    case 100 :
    case 200 :
        console.log("Доход равен 100 или 200");
        break;
    case 500 :
        console.log("Доход равен 500");
        break;
}
```

В данном случае для условия, когда income равно 100 и 200, выполняются одни и те же действия.

##### Условие по умолчанию — default
Если мы хотим также обработать ситуацию, когда совпадения не будет найдено, то можно добавить необязательный блок **`default`**:
```js
const income = 700;
switch(income){

    case 100 :
        console.log("Доход равен 100");
        break;
    case 200 :
        console.log("Доход равен 200");
        break;
    case 500 :
        console.log("Доход равен 500");
        break;
    default:
        console.log("Доход неизвестной величины");
        break;
}
```

### Условные операторы
Условные операторы позволяют проверить некоторое условие и в зависимости от результата проверки выполнить определенные действия. Здесь мы рассмотрим оператор **`? :`** или так называемый тернарный оператор и операцию **`??`**.

#### Тернарная операция
Тернарная операция состоит из трех операндов и имеет следующее определение:
```js
[первый операнд - условие] ? [второй операнд] : [третий операнд]
```

В зависимости от условия в первом операнде тернарная операция возвращает второй или третий операнд. Если условие в первом операнде равно `true`, то возвращается второй операнд; если условие равно `false`, то третий. Например:
```js
const a = 1;
const b = 2;
const result = a < b ? a: b;
console.log(result); // 1
```

Здесь первый операнд представляет следующее условие `a < b`. Если значение константы `a` меньше значения константы `b`, то возвращается второй операнд — `a`, то есть константа `result` будет равна `a`.

Если значение константы `a` больше или равно значению константы `b`, то возвращается третий операнд — `b`, поэтому константа `result` будет равна значению `b`.

В качестве операндов также могут выступать выражения:
```js
const a = 1;
const b = 2;
const result = a < b ? a + b : a - b;
console.log(result); // 3
```

В этом примере кода первый операнд представляет то же самое условие, что и в предыдущем примере, однако второй и третий операнды представляют арифметические операции. Если значение константы `a` меньше значения константы `b`, то возвращается второй операнд — `a + b`. Соответственно константа `result` будет равна сумме `a` и `b`.

Если значение константы `a` больше или равно значению константы `b`, то возвращается третий операнд — `a - b`. Соответственно константа `result` будет равна разности `a` и `b`.

#### Оператор ??
Оператор **`??`** (nullish coalescing operator) позволяет проверить значение на `null` и `undefined`. Он принимает два операнда:
```js
левый_операнд ?? правый_операнд
```

Оператор возвращает значение левого операнда, если оно НЕ равно `null` и `undefined`. Иначе возвращается значение правого операнда. Например:
```js
const result = "hello" ?? "world";
console.log(result);    // hello

console.log(0 ?? 5);    // 0

console.log("" ?? "javascript");    // "" - пустая строка

console.log(false ?? true); // false

console.log(null ?? "not null");    // not null

console.log(undefined ?? "defined");    // defined

console.log(null ?? null);  // null
console.log(undefined ?? undefined);    // undefined
```

#### Оператор ??=
Оператор `??` имеет модификацию в виде оператора **`??=`**, который также позволяет проверить значение на `null` и `undefined`. Он принимает два операнда:
```js
левый_операнд ??= правый_операнд
```

Если левый операнд равен `null` и `undefined`, то ему присваивается значение правого операнда. Иначе левый операнд сохраняет свое значение. Например:
```js
const message = "Hello JavaScript";
let text = "Hello work!"
text ??= message;
console.log(text);  // Hello work!
```

Здесь переменная `text` не равна `null` или `undefined`, поэтому она сохраняет свое значение. Обратный пример:
```js
const message = "Hello JavaScript";
let text = null;
text ??= message;
console.log(text);  // Hello JavaScript
```

Здесь переменная `text` равна `null`, поэтому при посредстве оператора `??=` она получает значение переменной `message`.

### Расширенный алгоритм работы логических операторов
Как описывалось выше, несмотря на своё название, логические операторы могут применяться к значениям любых типов. Полученные результаты также могут иметь различный тип. Этой особенностью можно пользоваться для замены условных конструкции, чтобы выполнять код на основе истинности или ложности выражений. Оператор `&&` выполняет действие, если первое условие истинно, а `||` выполняет действие, если хотя бы одно из условий истинно.

#### Оператор «ИЛИ» (`||`)
Традиционно в программировании ИЛИ предназначено только для манипулирования булевыми значениями: в случае, если какой-либо из аргументов `true`, он вернёт `true`, в противоположной ситуации возвращается `false`. В JavaScript этот оператор работает несколько иным образом: ИЛИ `||` находит первое истинное значение. Расширенный алгоритм работы предполагает, что оператор `||` выполняет следующие действия:

- вычисляет операнды слева направо;
- каждый операнд конвертирует в логическое значение, при этом если результат `true`, то останавливается и возвращает исходное значение этого операнда;
- если все операнды являются ложными (`false`), возвращает последний из них, при этом
значение возвращается в исходном виде, без преобразования.

Другими словами, цепочка ИЛИ `||` возвращает первое истинное значение или последнее, если такое значение не найдено.

Например:
```js
alert( 1 || 0 ); // 1 (1 - истинное значение)
alert( true || 'какая-то строка' ); // true

alert( null || 1 ); // 1 (первое истинное значение)
alert( null || 0 || 1 ); // 1 (первое истинное значение)
alert( undefined || null || 0 ); // 0 (поскольку все ложно, возвращается последнее значение)
```

Это делает возможным более интересное применение оператора по сравнению с «чистым, традиционным, только булевым ИЛИ».

1. **Получение первого истинного значения из списка переменных или выражений.**

    Например, у нас есть переменные `firstName`, `lastName` и `nickName`, все они необязательные (т.е. они могут быть неопределенными или иметь ложные значения).

    Давайте воспользуемся оператором ИЛИ `||`, чтобы выбрать ту переменную, в которой есть данные, и показать её (или «Аноним», если ни в одной переменной данных нет):
    ```js
    let firstName = "";
    let lastName = "";
    let nickName = "Суперкодер";

    alert( firstName || lastName || nickName || "Аноним"); // Суперкодер
    ```

    Если бы все переменные были ложными, в качестве результата мы бы наблюдали "Аноним".

2. **Сокращённое вычисление.**

    Ещё одной отличительной особенностью оператора ИЛИ `||` является так называемое «сокращённое вычисление».

    Это означает, что ИЛИ `||` обрабатывает свои операнды до тех пор, пока не будет достигнуто первое истинностное значение, и затем это значение сразу же возвращается, даже не затрагивая другие операнды.

    Важность этой особенности становится очевидной, если операнд – это не просто значение, а выражение с сопутствующим эффектом, как, например, присваивание переменной или вызов функции.

    В приведенном ниже примере срабатывает только второй `alert`:
    ```js
    true || alert("никогда не сработает");
    false || alert("сработает");
    ```

    В первой строке оператор ИЛИ `||` останавливает выполнение сразу после того, как сталкивается с истинным значением (`true`), поэтому сообщение не показывается.

    Иногда эту возможность используют для выполнения инструкций только в том случае, если условие в левой части является ложным.[^logical-operators]

**Принцип работы**: Возвращает первое "истинноподобное" значение или последнее значение, если все они "ложноподобны".

**Замена `if`**: Если нужно выполнить действие, когда одно из условий истинно, то можно написать:
```js
// версия с if
if (condition1 || condition2) {
  doSomething();
}

// версия с ||
(condition1 || condition2) && doSomething();
```

> Стоит обратить внимание на то, что в этом случае все равно нужен `&&`, чтобы убедиться, что условие `(condition1 || condition2)` истинно перед выполнением `doSomething()`. 

#### Оператор «И» (`&&`)
В традиционном программировании И возвращает `true`, если оба аргумента истинны, а иначе – `false`. Как и в случае с ИЛИ, любое значение допускается в качестве операнда, соответственно, В JavaScript И `&&` находит первое ложное значение. Расширенный алгоритм предполагает, что оператор `&&` выполняет следующие действия:

- вычисляет операнды слева направо;
- каждый операнд преобразует в логическое значение, при этом если результат `false`, останавливается и возвращает исходное значение этого операнда;
- если все операнды были истинными, возвращается последний.

Другими словами, И возвращает первое ложное значение. Или последнее, если ничего не найдено.

Вышеуказанные правила схожи с поведением ИЛИ. Разница в том, что И возвращает первое *ложное* значение, а ИЛИ –  первое *истинное*.

Примеры:
```js
alert( 1 && 2 && null && 3 ); // null
```

Когда все значения верны, возвращается последнее
```js
alert( 1 && 2 && 3 ); // 3
```

!!! note Приоритет оператора `&&` больше, чем у `||`

    Приоритет оператора И `&&` больше, чем ИЛИ `||`, так что он выполняется раньше.

    Таким образом, код `a && b || c && d` по существу такой же, как если бы выражения `&&` были в круглых скобках: `(a && b) || (c && d)`.

Иногда оператор И `&&` используют как «более короткий способ записи if-выражения».

Например:
```js
let x = 1;

(x > 0) && alert( 'x больше нуля!' );
```

Инструкция в правой части `&&` будет выполнена только в том случае, если вычисление дойдет до нее. То есть, только если `(x > 0)` истинно.

Таким образом, мы имеем аналог для следующего кода:
```
let x = 1;

if (x > 0) alert( 'x больше нуля!' );
```

Несмотря на то, что вариант с `&&` кажется более коротким, `if` более нагляден и, как правило, более читабелен. Поэтому в целом рекомендуется использовать каждую конструкцию по назначению: использовать `if`, если нужно `if`, и использовать `&&,` если нужно И.

**Принцип работы**: Возвращает первое "ложноподобное" значение (например, `false`, `0`, `""`) или последнее значение, если все они "истинноподобны".

**Замена `if`**: Если нужно выполнить действие только при истинности обоих условий, то можно написать:
```js
// версия с if
if (condition1 && condition2) {
  doSomething();
}

// версия с &&
condition1 && condition2 && doSomething();
```

#### Оператор нулевого слияния (`??`)
Оператор `??` возвращает первый аргумент, если он не `null`/`undefined`, иначе второй. Таким образом, результат выражения `a ?? b` будет следующим:

- если `a` определено, то `a`,
- если `a` не определено, то `b`.

Оператор нулевого слияния не является чем-то принципиально новым. Это всего лишь удобный синтаксис, как из двух значений получить одно, которое «определено».

Вот как можно переписать выражение `result = a ?? b`, используя уже знакомые нам операторы:
```js
result = (a !== null && a !== undefined) ? a : b;
```

Как правило, оператор `??` нужен для того, чтобы задать значение по умолчанию для потенциально неопределённой переменной.

Например, здесь мы отобразим `user`, если её значение не `null`/`undefined`, в противном случае `Аноним`:
```js
let user;

alert(user ?? "Аноним"); // Аноним (user не существует)
```

А вот пример, когда `user` присвоено значение:
```js
let user = "Иван";

alert(user ?? "Аноним"); // Иван (user существует)
```

Кроме этого, можно записать последовательность из операторов `??`, чтобы получить первое значение из списка, которое не является `null`/`undefined`.

Допустим, у нас есть данные пользователя в переменных `firstName`, `lastName` или `nickName`. Все они могут не существовать, если пользователь решил не вводить соответствующие значение.

Мы хотели бы отобразить имя пользователя, используя одну из этих переменных, или показать «Аноним», если все они `null`/`undefined`.

Для этого воспользуемся оператором `??`:
```js
let firstName = null;
let lastName = null;
let nickName = "Суперкодер";

// показывает первое значение, которое определено:
alert(firstName ?? lastName ?? nickName ?? "Аноним"); // Суперкодер
```

**Принцип работы**: Этот оператор похож на `||`, но он рассматривает как "ложные" только `null` и `undefined`. Это полезно, когда нужно использовать значение по умолчанию, но только если оно явно `null` или `undefined`, а не, например, 0 или "".

**Замена `if`**:
```js
// версия с if
if (value !== null && value !== undefined) {
  result = value;
} else {
  result = defaultValue;
}

// версия с ??
result = value ?? defaultValue;
```

### Задачи

1. Проверить вводимое пользователем число на чётность и положительность.

2. По возрасту пользователя выполнить классификацию и вывести сообщение: "ребёнок" (0-12), "подросток" (13-17), "взрослый" (18-64), "пенсионер" (65+). Для реализации логики использовать условную конструкцию `if..else`.

3. Вывести корни квадратного уравнения по введенным пользователем коэффициентам.

4. По введенному номеру дня недели (1-7) вывести название дня ("Понедельник", ..., "Воскресенье"). Для реализации логики использовать переключатель `switch..case`.

5. Вывести название сезона по введённому номеру месяца (1-12) или его названию ("январь", "февраль", ..., "декабрь"): "зима", "весна", "лето", "осень". Для реализации логики использовать переключатель `switch`.

Каждую задачу оформить в виде отдельного файла-сценария с названием, соответствующим номеру задачи. Подключить все сценарии на главную страницу (*index.html*).

Во всех задачах обрабатывать пользовательский ввод на наличие ошибок, при этом ввод данных и вывод сообщений (в том числе валидационных) осуществлять с помощью встроенных функций.

По завершении все задачи проверяются, проводится код-ревью и общий разбор ошибок.

---

6. Проверить, является ли введённый год високосным.

7. Решить треугольник.

8. Найти площадь, периметр и длину диагонали прямоугольника по введенным пользователем длине и ширине.

9. Реализуйте калькулятор: функция принимает два числа и оператор ('+', '-', '*', '/'), используя switch выполните арифметическую операцию.
10. Реализуйте проверку пароля: если пароль совпадает с заданным, вывести "Доступ разрешён", иначе "Доступ запрещён".
11. Создайте программу, которая выводит сообщение о статусе пользователя: если возраст меньше 18 — "несовершеннолетний", от 18 до 60 — "взрослый", иначе "пенсионер". Используйте комбинацию if и тернарного оператора.
12. Напишите функцию проверки на чётность и положительность числа, используя оператор && и if.

В случае предоставления пользователем невалидных данных выводить соовтетствующее сообщение и осуществлять повторный запрос данных (циклический).

В чем отличие приведения от преобразования типов?

```js
function isLeapYear(year) {
  if ((year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0)) {
    return true;
  } else {
    return false;
  }
}
```

- 2000 — високосный (делится на 400)

- 1900 — не високосный (делится на 100, но не на 400)

- 2012 — високосный (делится на 4, но не на 100)

- 2019 — не високосный (не делится на 4)

- 44 — високосный (год до нашей эры, делится на 4 и не делится на 100)

- 100 — не високосный (делится на 100, но не на 400)

- 0 — високосный (принять как год 1 до н.э. или 1 н.э., часто считается високосным)

Продолжить тему с прямоугольником:
- проверить пользовательский ввод;
- проверка введенного пользователем числа на простоту (решается циклом делений с увеличением делителя на 1)
- осуществление перезапроса ввода в случае предоставления невалидных данных.
- alert("Некорректный ввод: должно быть число"); - экстракция в функцию.
- оформление в виде функции, рефакторинг с охранными условиями (избавление от вложенности);
- дополнение файла (модуля) другими функциями (треугольник, решение квадратного уравнение);
- создание класса `Calc`;
- оформление библиотеки `Calc`, загрузка в репозиторий, подключение библиотеки.

### Источники информации
[^базовые-алгоритмические-структуры]: [Урок 2: Базовые алгоримтические структуры](https://resh.edu.ru/subject/lesson/5457/conspect/166580/)
[^2.10]: [Условные выражения](https://metanit.com/web/javascript/2.10.php)
[^logical-operators]: [Логические операторы](https://learn.javascript.ru/logical-operators)
