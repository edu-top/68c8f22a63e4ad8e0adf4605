## Объектная модель документа

- [Объектная модель документа](#объектная-модель-документа)
  - [Введение в DOM](#введение-в-dom)
    - [Браузерное окружение](#браузерное-окружение)
    - [DOM (Document Object Model)](#dom-document-object-model)
    - [BOM (Browser Object Model)](#bom-browser-object-model)
    - [Стандарты и спецификации](#стандарты-и-спецификации)
  - [DOM-дерево](#dom-дерево)
    - [Пример DOM](#пример-dom)
    - [Автоисправление](#автоисправление)
    - [Виды узлов DOM](#виды-узлов-dom)
    - [Редкие типы узлов XML DOM](#редкие-типы-узлов-xml-dom)
    - [XSLT-стили](#xslt-стили)
    - [Просмотр структуры DOM](#просмотр-структуры-dom)
    - [Взаимодействие с консолью](#взаимодействие-с-консолью)
    - [Итого](#итого)
  - [Узлы. Навигация по объектам DOM](#узлы-навигация-по-объектам-dom)
    - [Объект Node](#объект-node)
      - [Классы DOM-узлов](#классы-dom-узлов)
      - [Свойства узлов](#свойства-узлов)
      - [Свойство «nodeType»](#свойство-nodetype)
      - [Тег: nodeName и tagName](#тег-nodename-и-tagname)
    - [Свойства объекта document](#свойства-объекта-document)
    - [Навигационные свойства](#навигационные-свойства)
      - [Сверху: documentElement и body](#сверху-documentelement-и-body)
      - [Получение родительского элемента](#получение-родительского-элемента)
      - [Получение элементов одного уровня](#получение-элементов-одного-уровня)
      - [Получение потомков](#получение-потомков)
      - [DOM-коллекции](#dom-коллекции)
      - [nodeValue и получение текстового содержимого](#nodevalue-и-получение-текстового-содержимого)
      - [Навигация только по элементам](#навигация-только-по-элементам)
    - [Специфичные навигационные свойства](#специфичные-навигационные-свойства)
    - [Итого](#итого-1)
    - [Задачи](#задачи)
      - [Дочерние элементы в DOM](#дочерние-элементы-в-dom)
      - [Вопрос о соседях](#вопрос-о-соседях)
      - [Выделите ячейки по диагонали](#выделите-ячейки-по-диагонали)
  - [Элементы](#элементы)
    - [Свойства элементов](#свойства-элементов)
    - [Управление текстом элемента](#управление-текстом-элемента)
    - [Управление кодом HTML](#управление-кодом-html)
      - [innerHTML: содержимое элемента](#innerhtml-содержимое-элемента)
      - [innerHTML+= осуществляет перезапись](#innerhtml-осуществляет-перезапись)
      - [outerHTML: HTML элемента целиком](#outerhtml-html-элемента-целиком)
  - [Поиск элементов на веб-странице](#поиск-элементов-на-веб-странице)
    - [Получение элементов по id](#получение-элементов-по-id)
    - [Поиск по определенному тегу](#поиск-по-определенному-тегу)
    - [Получение элементов по классу](#получение-элементов-по-классу)
    - [Поиск элементов по атрибуту name](#поиск-элементов-по-атрибуту-name)
    - [Поиск элементов по селектору CSS](#поиск-элементов-по-селектору-css)
      - [querySelectorAll](#queryselectorall)
      - [querySelector](#queryselector)
      - [Селекторы CSS](#селекторы-css)
    - [Поиск во вложенных элементах](#поиск-во-вложенных-элементах)
    - [matches](#matches)
    - [closest](#closest)
    - [Замечания по поводу использования методов](#замечания-по-поводу-использования-методов)
    - [Живые коллекции](#живые-коллекции)
    - [Итого](#итого-2)
    - [Задачи](#задачи-1)
      - [Поиск элементов](#поиск-элементов)
  - [Создание, добавление, замена и удаление элементов](#создание-добавление-замена-и-удаление-элементов)
    - [Создание элементов](#создание-элементов)
    - [Добавление элементов](#добавление-элементов)
      - [appendChild](#appendchild)
      - [insertBefore](#insertbefore)
    - [Копирование элемента](#копирование-элемента)
    - [Замена элемента](#замена-элемента)
    - [Удаление элемента](#удаление-элемента)
      - [Удаление всех элементов](#удаление-всех-элементов)
  - [Управление атрибутами элементов](#управление-атрибутами-элементов)
    - [Получение атрибута](#получение-атрибута)
    - [Установка атрибутов](#установка-атрибутов)
    - [Удаление атрибута](#удаление-атрибута)
  - [Управление стилем и классами элементов](#управление-стилем-и-классами-элементов)
    - [Свойство style](#свойство-style)
    - [Свойство className](#свойство-classname)
    - [Свойство classList](#свойство-classlist)
  - [Практическая работа. Реализация поведения "подсказка"](#практическая-работа-реализация-поведения-подсказка)
    - [Задание](#задание)
  - [Источники информации](#источники-информации)

### Введение в DOM
*[DOM]: Document Object Model
*[BOM]: Browser Object Model
*[DTD]: Document Type Definition
*[PI]: Processing Instruction
*[CDATA]: Character Data

#### Браузерное окружение
Язык JavaScript изначально был создан для веб-браузеров. Но с тех пор он значительно эволюционировал и превратился в кроссплатформенный язык программирования для решения широкого круга задач.

Сегодня JavaScript может использоваться в браузере, на веб-сервере или в какой-то другой среде, даже в кофеварке. Каждая среда предоставляет свою функциональность, которую спецификация JavaScript называет <dfn title="окружение">окружением</dfn>.

Окружение предоставляет свои объекты и дополнительные функции, в дополнение базовым языковым. Браузеры, например, дают средства для управления веб-страницами. Node.js делает доступными какие-то серверные возможности и так далее.

На картинке ниже в общих чертах показано, что доступно для JavaScript в браузерном окружении:

![Window object](../img/windowObjects.svg)

Как мы видим, имеется корневой объект `window`, который выступает в 2 ролях:

1. Во-первых, это глобальный объект для JavaScript-кода, об этом более подробно говорится в главе **Глобальный объект**.
2. Во-вторых, он также представляет собой окно браузера и располагает методами для управления им.

Например, здесь мы используем `window` как глобальный объект:
```js
function sayHi() {
  alert("Hello");
}

// глобальные функции доступны как методы глобального объекта:
window.sayHi();
```

А здесь мы используем `window` как объект окна браузера, чтобы узнать его высоту:
```js
alert(window.innerHeight); // внутренняя высота окна браузера
```

Существует гораздо больше свойств и методов для управления окном браузера. Мы рассмотрим их позднее.[^browser-environment]

#### DOM (Document Object Model)
Хотя веб-браузером и вообще вебом область действия JavaScript не ограничивается, однако по прежнему одной из ключевых задач JavaScript является взаимодействие с пользователем и манипуляция элементами веб-страницы в браузере. Для JavaScript веб-страница доступна в виде **объектной модели документа** (document object model) или сокращенно **DOM**. <dfn title="DOM">DOM</dfn> описывает структуру веб-станицы в виде древовидного представления и предоставляет разработчику способ получить доступ к отдельным элементам веб-страницы.

<dfn title="Document Object Model">Document Object Model</dfn>, сокращённо DOM – объектная модель документа, которая представляет все содержимое страницы в виде объектов, которые можно менять.

Объект `document` – основная «входная точка». С его помощью мы можем что-то создавать или менять на странице.

Например:
```js
// заменим цвет фона на красный
document.body.style.background = "red";

// а через секунду вернём как было
setTimeout(() => document.body.style.background = "", 1000);
```

Мы использовали в примере только `document.body.style`, но на самом деле возможности по управлению страницей намного шире. Различные свойства и методы описаны в спецификации:

- **DOM Living Standard** на https://dom.spec.whatwg.org

!!! info "DOM – не только для браузеров"

    Спецификация DOM описывает структуру документа и предоставляет объекты для манипуляций со страницей. Существуют и другие, отличные от браузеров, инструменты, использующие DOM.

    Например, серверные скрипты, которые загружают и обрабатывают HTML-страницы, также могут использовать DOM. При этом они могут поддерживать спецификацию не полностью.

!!! info "CSSOM для стилей"

    Правила стилей CSS структурированы иначе чем HTML. Для них есть отдельная спецификация [CSSOM](https://www.w3.org/TR/cssom-1/), которая объясняет, как стили должны представляться в виде объектов, как их читать и писать.

    CSSOM используется вместе с DOM при изменении стилей документа. В реальности CSSOM требуется редко, обычно правила CSS статичны. Мы редко добавляем/удаляем стили из JavaScript, но и это возможно.

#### BOM (Browser Object Model)
Важно не путать понятия **BOM** (Browser Object Model — объектная модель браузера) и **DOM** (объектная модель документа). Если BOM предоставляет доступ к браузеру и его свойствам в целом, то DOM предоставляет доступ к отдельной веб-странице или html-документу и его элементам.

<dfn title="объектная модель браузера">Объектная модель браузера</dfn> (Browser Object Model, BOM) – это дополнительные объекты, предоставляемые браузером (окружением), чтобы работать со всем, кроме документа.

Например:

- Объект [navigator](https://developer.mozilla.org/ru/docs/Web/API/Window/navigator) даёт информацию о самом браузере и операционной системе. Среди множества его свойств самыми известными являются: `navigator.userAgent` – информация о текущем браузере, и `navigator.platform` – информация о платформе (может помочь в понимании того, в какой ОС открыт браузер – Windows/Linux/Mac и так далее).
- Объект [location](https://developer.mozilla.org/ru/docs/Web/API/Window/location) позволяет получить текущий URL и перенаправить браузер по новому адресу.

Вот как мы можем использовать объект `location`:
```js
alert(location.href); // показывает текущий URL
if (confirm("Перейти на Wikipedia?")) {
  location.href = "https://wikipedia.org"; // перенаправляет браузер на другой URL
}
```

Функции `alert`/`confirm`/`prompt` тоже являются частью BOM: они не относятся непосредственно к странице, но представляют собой методы объекта окна браузера для коммуникации с пользователем.

BOM является частью общей [спецификации HTML](https://html.spec.whatwg.org/).  Спецификация HTML по адресу https://html.spec.whatwg.org не только про «язык HTML» (теги, атрибуты), она также покрывает целое множество объектов, методов и специфичных для каждого браузера расширений DOM. Это всё «HTML в широком смысле». Для некоторых вещей есть отдельные спецификации, перечисленные на https://spec.whatwg.org.

#### Стандарты и спецификации
Говоря о стандартах, у нас есть:

- **Спецификация DOM**

    описывает структуру документа, манипуляции с контентом и события, подробнее на https://dom.spec.whatwg.org.

- **Спецификация CSSOM**

    Описывает файлы стилей, правила написания стилей и манипуляций с ними, а также то, как это всё связано со страницей, подробнее на https://www.w3.org/TR/cssom-1/.

- **Спецификация HTML**

    Описывает язык HTML (например, теги) и BOM (объектную модель браузера) – разные функции браузера: `setTimeout`, `alert`, `location` и так далее, подробнее на https://html.spec.whatwg.org. Тут берётся за основу спецификация DOM и расширяется дополнительными свойствами и методами.

Кроме того, некоторые классы описаны отдельно на https://spec.whatwg.org/.

По этим ссылкам содержится очень много информации, которую невозможно изучить полностью и держать в уме.

Когда нужно будет прочитать о каком-то свойстве или методе, справочник на сайте Mozilla https://developer.mozilla.org/ru/ тоже очень хороший ресурс, хотя ничто не сравнится с чтением спецификации: она сложная и объёмная, но сделает знания максимально полными.

Для поиска чего-либо обычно удобно использовать интернет-поиск со словами «WHATWG [термин]» или «MDN [термин]», например https://google.com?q=whatwg+localstorage, https://google.com?q=mdn+localstorage.

А теперь давайте перейдём к изучению DOM, так как страница – это основа всего.[^browser-environment]

### DOM-дерево
Основой HTML-документа являются теги.

В соответствии с объектной моделью документа («Document Object Model», коротко DOM), каждый HTML-тег является объектом. Вложенные теги являются «детьми» родительского элемента. Текст, который находится внутри тега, также является объектом.

Все эти объекты доступны при помощи JavaScript, мы можем использовать их для изменения страницы.

Например, `document.body` – объект для тега `<body>`.

Если запустить этот код, то `<body>` станет красным на 3 секунды:
```js
document.body.style.background = 'red'; // сделать фон красным

setTimeout(() => document.body.style.background = '', 3000); // вернуть назад
```

Это был лишь небольшой пример того, что может DOM. Скоро мы изучим много способов работать с DOM, но сначала нужно познакомиться с его структурой.

#### Пример DOM
Начнём с такого, простого, документа:
```html
<!DOCTYPE HTML>
<html>
<head>
  <title>О лосях</title>
</head>
<body>
  Правда о лосях.
</body>
</html>
```

DOM – это представление HTML-документа в виде дерева тегов. Вот как оно выглядит:

![DOM tree](../img/dom-tree_1.png)

Каждый узел этого дерева – это объект.

Теги являются *узлами-элементами* (или просто элементами). Они образуют структуру дерева: `<html>` – это корневой узел, `<head>` и `<body>` его дочерние узлы и т.д.

Текст внутри элементов образует *текстовые узлы*, обозначенные как `#text`. Текстовый узел содержит в себе только строку текста. У него не может быть потомков, т.е. он находится всегда на самом нижнем уровне.

Например, в теге `<title>` есть текстовый узел `"О лосях"`.

Обратите внимание на специальные символы в текстовых узлах:

- перевод строки: `↵` (в JavaScript он обозначается как `\n`)
- пробел: `␣`

Пробелы и переводы строки – это полноправные символы, как буквы и цифры. Они образуют текстовые узлы и становятся частью дерева DOM. Так, в примере выше в теге `<head>` есть несколько пробелов перед `<title>`, которые образуют текстовый узел `#text` (он содержит в себе только перенос строки и несколько пробелов).

Существует всего два исключения из этого правила:

1. По историческим причинам пробелы и перевод строки перед тегом `<head>` игнорируются
2. Если мы записываем что-либо после закрывающего тега `</body>`, браузер автоматически перемещает эту запись в конец `body`, поскольку спецификация HTML требует, чтобы всё содержимое было внутри `<body>`. Поэтому после закрывающего тега `</body>` не может быть никаких пробелов.

В остальных случаях всё просто – если в документе есть пробелы (или любые другие символы), они становятся текстовыми узлами дерева DOM, и если мы их удалим, то в DOM их тоже не будет.

Здесь пробельных текстовых узлов нет:
```html
<!DOCTYPE HTML>
<html><head><title>О лосях</title></head><body>Правда о лосях.</body></html>
```

![DOM tree](../img/dom-tree_2.png)

!!! info "Пробелы по краям строк и пробельные текстовые узлы скрыты в инструментах разработки"

    Когда мы работаем с деревом DOM, используя инструменты разработчика в браузере (которые мы рассмотрим позже), пробелы в начале/конце текста и пустые текстовые узлы (переносы строк) между тегами обычно не отображаются.

    Таким образом инструменты разработки экономят место на экране.

    В дальнейших иллюстрациях DOM мы также будем для краткости пропускать пробельные текстовые узлы там, где они не имеют значения. Обычно они не влияют на то, как отображается документ.

Например, рассмотрим простейшую страницу:
```html
<!DOCTYPE html>
<html>
<head>
    <title>Page Title</title>
</head>
<body>
    <h2>Page Header</h2>
    <div>
        <h3>Block Header</h3>
        <p>Text</p>
    </div>
</body>
</html>
```

Дерево DOM для этой страницы будет выглядеть следующим образом:

![DOM-tree in JavaScript](../img/domtree.png)

Таким образом, все компоненты упорядочены в DOM иерархическим образом, где каждый компонент представляет отдельный узел. То есть каждый элемент, например, элемент `div`, представляет собой узел. Но также и текст внутри элемента представляет отдельный узел.

#### Автоисправление
Если браузер сталкивается с некорректно написанным HTML-кодом, он автоматически корректирует его при построении DOM.

Например, в начале документа всегда должен быть тег `<html>`. Даже если его нет в документе – он будет в дереве DOM, браузер его создаст. То же самое касается и тега `<body>`.

Например, если HTML-файл состоит из единственного слова "Привет", браузер обернёт его в теги `<html>` и `<body>`, добавит необходимый тег `<head>`, и DOM будет выглядеть так:

![DOM tree](../img/dom-tree_3.png)

При генерации DOM браузер самостоятельно обрабатывает ошибки в документе, закрывает теги и так далее.

Есть такой документ с незакрытыми тегами:
```html
<p>Привет
<li>Мама
<li>и
<li>Папа
```

…Но DOM будет нормальным, потому что браузер сам закроет теги и восстановит отсутствующие детали:

![DOM tree](../img/dom-tree_4.png)

!!! warning "Таблицы всегда содержат `<tbody>`"

    Важный «особый случай» – работа с таблицами. По стандарту DOM у них должен быть `<tbody>`, но в HTML их можно написать (официально) без него. В этом случае браузер добавляет `<tbody>` в DOM самостоятельно.

    Для такого HTML:
    ```html
    <table id="table"><tr><td>1</td></tr></table>
    ```

    DOM-структура будет такой:

    ![DOM tree](../img/dom-tree_5.png)

    Видите? Из пустоты появился `<tbody>`, как будто документ и был таким. Важно знать об этом, иначе при работе с таблицами возможны сюрпризы.

#### Виды узлов DOM
Есть и некоторые другие типы узлов, кроме элементов и текстовых узлов.

Например, узел-комментарий:
```html
<!DOCTYPE HTML>
<html>
<body>
  Правда о лосях.
  <ol>
    <li>Лось -- животное хитрое</li>
    <!-- комментарий -->
    <li>...и коварное!</li>
  </ol>
</body>
</html>
```

![DOM tree](../img/dom-tree_6.png)

Здесь мы видим узел нового типа – *комментарий*, обозначенный как `#comment`, между двумя текстовыми узлами.

Казалось бы – зачем комментарий в DOM? Он никак не влияет на визуальное отображение. Но есть важное правило: если что-то есть в HTML, то оно должно быть в DOM-дереве.

**Все, что есть в HTML, даже комментарии, является частью DOM.**

Даже директива `<!DOCTYPE...>`, которую мы ставим в начале HTML, тоже является DOM-узлом. Она находится в дереве DOM прямо перед `<html>`. Мы не будем рассматривать этот узел, мы даже не рисуем его на наших диаграммах, но он существует.

Даже объект document, представляющий весь документ, формально является DOM-узлом.

Существует [12 типов узлов](https://dom.spec.whatwg.org/#node).

- **`Document`**: корневой узел html-документа, представляет весь документ в целом  (`nodeType = 9`).

- **`Element`**:  HTML-элемент (`<div>`, `<p>`), основной рабочий узел (`nodeType = 1`).

- **`Text`**: текст элемента, текстовое содержимое между тегами (`nodeType = 3`).

- **`Attr`**: атрибут html-элемента (`href="..."`), устаревший тип (`nodeType = 2`).

- **`DocumentType`**: DTD или тип схемы XML-документа (`<!DOCTYPE html>`) (`nodeType = 10`).

- **`DocumentFragment`**: место для временного хранения частей документа, временный контейнер для фрагментов DOM, не входит в дерево (`nodeType = 11`).

- **`EntityReference`**: ссылка на сущность XML-документа (XML-сущность) (`&copy;`) (`nodeType = 5`).

- **`ProcessingInstruction`**: инструкция обработки веб-страницы (`<?xml-stylesheet?>`) (`nodeType = 7`).

- **`Comment`**: элемент комментария, HTML/XML-комментарий (`<!-- -->`) (`nodeType = 8`).

- **`CDATASection`**: секция CDATA в документе XML, неразборный текст XML (`<![CDATA[...]]>`), как `Text` (`nodeType = 4`).

- **`Entity`**: необработанная сущность DTD, объявление сущности DTD (`<!ENTITY>`) (`nodeType = 6`).

- **`Notation`**: нотация, объявленная в DTD (нотация DTD) (`<!NOTATION>`) (`nodeType = 12`).

Несмотря на такое большое количество типов узлов, как правило, применяются первые 4 типа.[^8.1]

- `document` – «входная точка» в DOM;
- узлы-элементы – HTML-теги, основные строительные блоки;
- текстовые узлы – содержат текст;
- комментарии – иногда в них можно включить информацию, которая не будет показана, но доступна в DOM для чтения JS.

*Статус узлов DOM*

| Узел                  | nodeType | HTML5 | XML | Использование сегодня              |
| --------------------- | -------- | ----- | --- | ---------------------------------- |
| `Element`               | 1        | ✅     | ✅   | Основной                           |
| `Attr`                  | 2        | ❌     | ❌   | Устарел (рекомендуется использовать `getAttribute`) |
| `Text`                  | 3        | ✅     | ✅   | Основной                           |
| `CDATASection`          | 4        | ❌     | ✅   | Только XML (?XML only)                           |
| `EntityReference`       | 5        | ❌     | ⚠️  | Редко (legacy XML)                 |
| `Entity`                | 6        | ❌     | ⚠️  | Устарел                            |
| `ProcessingInstruction` | 7        | ⚠️    | ✅   | XSLT стили                         |
| `Comment`               | 8        | ✅     | ✅   | Часто                              |
| `Document`              | 9        | ✅     | ✅   | Основной                           |
| `DocumentType`          | 10       | ✅     | ✅   | Только `DOCTYPE`                     |
| `DocumentFragment`      | 11       | ✅     | ✅   | Часто (batch updates)              |
| `Notation`              | 12       | ❌     | ⚠️  | Устарел                            |

**Вывод**: в веб-разработке активно используются только `Document`, `Element`, `Text`, `DocumentFragment`, `Comment`. Остальные — артефакты XML/DTD 1998 года.

#### Редкие типы узлов XML DOM
**DTD** (Document Type Definition) — это определение типа документа, первое средство валидации структуры XML.

DTD описывает правила построения XML-документа:

- Какие элементы допустимы и в какой последовательности

- Какие атрибуты разрешены у элементов

- Тип содержимого элементов (#PCDATA, другие элементы)

- Вложенность и обязательность

Синтаксис в XML
```xml
<!DOCTYPE root-element [
  <!ELEMENT note (to,from,heading,body)>  <!-- структура -->
  <!ELEMENT to (#PCDATA)>                 <!-- только текст -->
  <!ATTLIST note type CDATA #REQUIRED>    <!-- атрибуты -->
]>
<note type="important">
  <to>Иван</to>
  <from>Петр</from>
</note>
```

В браузере `document.doctype` возвращает объект `DocumentType`:
```js
console.log(document.doctype);
// #documentType html // для HTML5
console.log(document.doctype.name);    // "html"
console.log(document.doctype.publicId); // ""
```

В настоящее время считается устаревшим стандартом (1998), заменен XML Schema (XSD):

- Нет типов данных (только текст/элементы)

- Сложный синтаксис

- HTML5 использует упрощенный `<!DOCTYPE html>`

Таким образом, DTD — исторический артефакт для валидации простых XML. В веб-разработке остался только как `<!DOCTYPE>` для активации standards mode.

`EntityReference` — ссылка на сущность из DTD. Заменяется на значение сущности при парсинге.

```xml
<!DOCTYPE doc [
  <!ENTITY copy "©">
]>
<doc>&copy; текст</doc>  <!-- EntityReference: &copy; -->
```

В DOM: `nodeName = "copy"`, `nodeType = 5`.​

`ProcessingInstruction` — инструкция обработки (PI) для приложений (XML-стили, XSLT).

```xml
<?xml-stylesheet type="text/xsl" href="style.xsl"?>
```

В DOM: `nodeName = "xml-stylesheet"`, `nodeValue = 'type="text/xsl" href="style.xsl"'`, `nodeType = 7`.

`CDATASection` обозначает секцию CDATA — текст, не парсируемый как XML (для HTML в XML).

```xml
<![CDATA[<script>alert("ok")</script>]]>  <!-- Текст как есть -->
```

В DOM: `nodeType = 4`, обычный текстовый узел с особым флагом.

`Entity` — объявление сущности из DTD (необрабатанная).

```xml
<!ENTITY logo SYSTEM "logo.gif">
```

В DOM: `document.doctype.entities.getNamedItem("logo"), nodeType = 6`.

`Notation` — нотация DTD — описание внешних типов данных (старые изображения).

```xml
<!NOTATION GIF PUBLIC "image/gif">
```

В DOM: `document.doctype.notations.getNamedItem("GIF")`, `nodeType = 12`.

Все эти узлы — артефакты XML 1.0 (1998) для DTD. В веб-разработке практически не встречаются, остались только в legacy XML.

#### XSLT-стили
*[XML]: eXtensible Markup Language
*[XSL]: eXtensible Stylesheet Language
*[RSS]: Really Simple Syndication
*[XSLT]: XSL Transformations
*[RDF]: Resource Description Framework
*[OWL]: Web Ontology Language
*[FOAF]: Friend of a Friend
*[SPARQL]: SPARQL Protocol and RDF Query Language
*[JSON]: JavaScript Object Notation

<dfn title="XML">XML</dfn> — eXtensible Markup Language (расширяемый язык разметки). Структурированный формат данных с пользовательскими тегами (1998).
```xml
<user id="1">
  <name>Иван</name>
  <age>30</age>
</user>
```

<dfn title="XSL">XSL</dfn> — eXtensible Stylesheet Language (семейство). Включает:

- XSLT — преобразование XML в HTML/XML

- XPath — запросы к XML

- XSL-FO — форматирование (PDF)

```xml
<?xml-stylesheet type="text/xsl" href="style.xsl"?>
```

<dfn title="XSLT стили">XSLT стили</dfn> — это таблицы преобразований XML (XSL Transformations), которые определяют, как XML-документ преобразуется в другой формат (HTML, другой XML).

**Как работают**
1. XML-документ содержит данные

2. XSLT-стиль содержит правила преобразования (ё<xsl:template>ё)

3. XSLT-процессор (браузер, Saxon) применяет стиль к данным

```xml
<!-- data.xml -->
<users>
  <user id="1"><name>Иван</name></user>
</users>
```

```xml
<!-- style.xsl -->
<xsl:stylesheet version="1.0">
  <xsl:template match="/users">
    <ul>
      <xsl:for-each select="user">
        <li><xsl:value-of select="name"/></li>
      </xsl:for-each>
    </ul>
  </xsl:template>
</xsl:stylesheet>
```

Результат: `<ul><li>Иван</li></ul>`

*Подключение через `ProcessingInstruction`*:
```xml
<!-- В XML-документе -->
<?xml-stylesheet type="text/xsl" href="style.xsl"?>
<users>...</users>
```

Браузер автоматически применяет XSLT и показывает HTML.

| Задача      | Пример                  |
| ----------- | ----------------------- |
| XML → HTML | Данные → веб-страница  |
| XML → XML  | Конвертация форматов    |
| Отчеты      | XML-данные → PDF/Excel |
| RSS → HTML | Ленты новостей          |

Современный статус — устаревшая технология (1999):

- ✅ Server-side: Node.js (xslt4node), Java (Saxon)

- ❌ Client-side: Браузеры не поддерживают (кроме IE)

- ❌ SPA: React/Vue заменили полностью

**Вывод**: XSLT — мощный инструмент для серверных XML-преобразований, но в веб-фронтенде заменен JavaScript-фреймворками.

<dfn title="RSS">RSS</dfn> — RDF Site Summary / Really Simple Syndication. Формат лент новостей на базе XML.

```xml
<rss version="2.0">
  <channel>
    <item>
      <title>Новость</title>
      <link>https://example.com</link>
      <pubDate>2025-12-18</pubDate>
    </item>
  </channel>
</rss>
```

| Технология | Назначение     | Год  | Статус                     |
| ---------- | -------------- | ---- | -------------------------- |
| XML        | Данные/конфиги | 1998 | ✅ JSON заменил             |
| XSL/XSLT   | XML → HTML    | 1999 | ❌ Устарело (JS фреймворки) |
| RSS        | Ленты новостей | 1999 | ✅ Жив (подкасты, блоги)    |

**Вывод**: XML — универсальный формат данных, XSL — устаревшие стили/преобразования, RSS — живой стандарт новостных фидов.

<dfn title="RDF">RDF</dfn> (Resource Description Framework) — Среда описания ресурсов, модель данных для Семантической паутины (Semantic Web).

RDF представляет данные как граф триплетов:
```
субъект → предикат → объект
Иван    → возраст   → 30
```

Всё идентифицируется URI (уникальными ссылками).

*Пример*:
```
@prefix foaf: <http://xmlns.com/foaf/0.1/> .

<ivan> foaf:name "Иван Иванов" .
<ivan> foaf:age 30 .
<ivan> foaf:knows <maria> .
```

Графически:
```
[Иван] ──name───> "Иван Иванов"
       ──age───> 30
       ──knows──> [Мария]
```

*Форматы*:
| Синтаксис | Пример                                   | Использование      |
| --------- | ---------------------------------------- | ------------------ |
| Turtle    | `@prefix foaf: <...>`                    | Читаемый человеком |
| RDF/XML   | `<rdf:Description>`                      | Legacy             |
| JSON-LD   | `{"@id": "ivan"}`                        | Современный веб    |
| RDFa      | `<span property="foaf:name">Иван</span>` | В HTML             |

RSS 1.0 использует RDF для описания лент:
```xml
<rdf:RDF>
  <item rdf:about="http://example.com/post1">
    <title>Новость</title>
  </item>
</rdf:RDF>
```

*Назначение*
| Область               | Пример                                       |
| --------------------- | -------------------------------------------- |
| Семантическая паутина | Linked Data, DBpedia                         |
| Онтологии             | OWL (Web Ontology Language)                  |
| Метаданные            | FOAF (Friend of a Friend)                    |
| SPARQL-запросы        | SELECT ?person WHERE { ?person foaf:age 30 } |

Статус — живой стандарт W3C (1999–наст. время):

- ✅ JSON-LD — в Schema.org, Google Knowledge Graph

- ✅ SPARQL — запросы к RDF

- ❌ RDF/XML — устарел

**Вывод**: RDF — фундамент Семантической паутины, позволяет машинам понимать связи между данными. Сегодня популярен через JSON-LD в SEO и структурированных данных.

#### Просмотр структуры DOM
Чтобы посмотреть структуру DOM в реальном времени, можно попробовать [Live DOM Viewer](https://software.hixie.ch/utilities/js/live-dom-viewer/). Просто введите что-нибудь в поле, и ниже вы увидите, как меняется DOM.

Другой способ исследовать DOM – это использовать инструменты разработчика браузера. Это то, что мы каждый день делаем при разработке.

Для этого откройте страницу [elks.html](https://learn.javascript.ru/article/dom-nodes/elks.html), включите инструменты разработчика и перейдите на вкладку Elements.

Выглядит примерно так:

![Elks](../img/elks.png)

Вы можете увидеть DOM, понажимать на элементы, детально рассмотреть их и так далее.

Обратите внимание, что структура DOM в инструментах разработчика отображается в упрощённом виде. Текстовые узлы показаны как простой текст. И кроме пробелов нет никаких «пустых» текстовых узлов. Ну и отлично, потому что большую часть времени нас будут интересовать узлы-элементы.

Клик по этой ![button glyph](../img/btn-glyph.png) кнопке в левом верхнем углу инспектора позволяет при помощи мыши (или другого устройства ввода) выбрать элемент на веб-странице и «проинспектировать» его (браузер сам найдёт и отметит его во вкладке Elements). Этот способ отлично подходит, когда у нас огромная HTML-страница (и соответствующий ей огромный DOM), и мы хотим увидеть, где находится интересующий нас элемент.

Есть и другой способ сделать это: можно кликнуть на странице по элементу правой кнопкой мыши и в контекстном меню выбрать «Inspect».

![Inspect](../img/inspect.png)

В правой части инструментов разработчика находятся следующие подразделы:

- **Styles** – здесь мы видим CSS, применённый к текущему элементу: правило за правилом, включая встроенные стили (выделены серым). Почти всё можно отредактировать на месте, включая размеры, внешние и внутренние отступы.
- **Computed** – здесь мы видим итоговые CSS-свойства элемента, которые он приобрёл в результате применения всего каскада стилей (в том числе унаследованные свойства и т.д.).
- **Event Listeners** – в этом разделе мы видим обработчики событий, привязанные к DOM-элементам (мы поговорим о них в следующей части учебника).
… и т.д.

Лучший способ изучить инструменты разработчика – это прокликать их. Большинство значений можно менять и тут же смотреть результат.

#### Взаимодействие с консолью
При работе с DOM нам часто требуется применить к нему JavaScript. Например: получить узел и запустить какой-нибудь код для его изменения, чтобы посмотреть результат. Вот несколько подсказок, как перемещаться между вкладками Elements и Console.

Для начала:

1. На вкладке Elements выберите первый элемент `<li>`.
2. Нажмите <kbd>Esc</kbd> – прямо под вкладкой Elements откроется Console.

Последний элемент, выбранный во вкладке Elements, доступен в консоли как `$0`; предыдущий, выбранный до него, как `$1` и т.д.

Теперь мы можем запускать на них команды. Например `$0.style.background = 'red'` сделает выбранный элемент красным, как здесь:

![Dom console](../img/domconsole0.png)

Это мы посмотрели как получить узел из Elements в Console.

Есть и обратный путь: если есть переменная `node`, ссылающаяся на DOM-узел, можно использовать в консоли команду `inspect(node)`, чтобы увидеть этот элемент во вкладке Elements.

Или мы можем просто вывести DOM-узел в консоль и исследовать «на месте», как `document.body` ниже:

![DOM console](../img/domconsole1.png)

Это может быть полезно для отладки. В следующей главе мы рассмотрим доступ и изменение DOM при помощи JavaScript.

Инструменты разработчика браузера отлично помогают в разработке: мы можем исследовать DOM, пробовать с ним что-то делать и смотреть, что идёт не так.

#### Итого
HTML/XML документы представлены в браузере в виде DOM-дерева.

- Теги становятся узлами-элементами и формируют структуру документа.
- Текст становится текстовыми узлами.
- … и т.д. Всё, что записано в HTML, есть и в DOM-дереве, даже комментарии.

Для изменения элементов или проверки DOM-дерева мы можем использовать инструменты разработчика в браузере.

Здесь мы рассмотрели основы, наиболее часто используемые и важные действия для начала разработки. Подробную документацию по инструментам разработки Chrome Developer Tools можно найти на странице https://developers.google.com/web/tools/chrome-devtools. Лучший способ изучить инструменты – походить по разным вкладкам, почитать меню: большинство действий очевидны для пользователя.

У DOM-узлов есть свойства и методы, которые позволяют выбирать любой из элементов, изменять, перемещать их на странице и многое другое. Мы вернёмся к ним в последующих разделах.[^dom-nodes]

### Узлы. Навигация по объектам DOM

#### Объект Node
DOM позволяет нам делать что угодно с элементами и их содержимым, но для начала нужно получить соответствующий DOM-объект.

Каждый отдельный узел, будь то html-элемент, его атрибут или текст, в структуре DOM представлен объектом **`Node`**. Может возникнуть вопрос: как связаны элементы веб-страницы и узлы веб-страницы? И тут надо отметить, что любой элемент веб-страницы является узлом, но не любой узел является элементом (например, атрибуты и текст элементов также являются отдельными узлами).[^8.4]

Теперь давайте более внимательно взглянем на DOM-узлы. Далее мы подробнее разберём, что они собой представляют и изучим их основные свойства.

##### Классы DOM-узлов

*[IDL]: Interface description language

У разных DOM-узлов могут быть разные свойства. Например, у узла, соответствующего тегу `<a>`, есть свойства, связанные со ссылками, а у соответствующего тегу `<input>` – свойства, связанные с полем ввода и т.д. Текстовые узлы отличаются от узлов-элементов. Но у них есть общие свойства и методы, потому что все классы DOM-узлов образуют единую иерархию.

Каждый DOM-узел принадлежит соответствующему встроенному классу.

Корнем иерархии является [EventTarget](https://dom.spec.whatwg.org/#eventtarget), от него наследует [Node](https://dom.spec.whatwg.org/#interface-node) и остальные DOM-узлы.

На рисунке ниже изображены основные классы:

![DOM class hierarchy](../img/_dom-class-hierarchy.svg)

Существуют следующие классы:

- [`EventTarget`](https://dom.spec.whatwg.org/#eventtarget) – это корневой «абстрактный» класс для всего.

    Объекты этого класса никогда не создаются. Он служит основой, благодаря которой все DOM-узлы поддерживают так называемые «события», о которых мы поговорим позже.

- [`Node`](https://dom.spec.whatwg.org/#interface-node) – также является «абстрактным» классом, и служит основой для DOM-узлов.

    Он обеспечивает базовую функциональность: `parentNode`, `nextSibling`, `childNodes` и т.д. (это геттеры). Объекты класса `Node` никогда не создаются. Но есть определённые классы узлов, которые наследуются от него (и следовательно наследуют функционал `Node`).

- [`Document`](https://dom.spec.whatwg.org/#interface-document), по историческим причинам часто наследуется `HTMLDocument` (хотя последняя спецификация этого не навязывает) – это документ в целом.

    Глобальный объект `document` принадлежит именно к этому классу. Он служит точкой входа в DOM.

- [`CharacterData`](https://dom.spec.whatwg.org/#interface-characterdata) – «абстрактный» класс. Вот, кем он наследуется:

  - [`Text`](https://dom.spec.whatwg.org/#interface-text) – класс, соответствующий тексту внутри элементов. Например, `Hello` в `<p>Hello</p>`.

  - [`Comment`](https://dom.spec.whatwg.org/#interface-comment) – класс для комментариев. Они не отображаются, но каждый комментарий становится членом DOM.

- [`Element`](https://dom.spec.whatwg.org/#interface-element) – это базовый класс для DOM-элементов.

    Он обеспечивает навигацию на уровне элементов: `nextElementSibling`, `children`. А также и методы поиска элементов: `getElementsByTagName`, `querySelector`.

    Браузер поддерживает не только HTML, но также XML и SVG. Таким образом, класс `Element` служит основой для более специфичных классов: `SVGElement`, `XmlElement` (они нам здесь не нужны) и `HTMLElement`.

- И наконец, [`HTMLElement`](https://html.spec.whatwg.org/multipage/dom.html#htmlelement) является базовым классом для всех остальных HTML-элементов. Мы будем работать с ним большую часть времени.

    От него наследуются конкретные элементы:

  - [`HTMLInputElement`](https://html.spec.whatwg.org/multipage/forms.html#htmlinputelement) – класс для тега `<input>`,
  - [`HTMLBodyElement`](https://html.spec.whatwg.org/multipage/semantics.html#htmlbodyelement) – класс для тега `<body>`,
  - [`HTMLAnchorElement`](https://html.spec.whatwg.org/multipage/semantics.html#htmlanchorelement) – класс для тега `<a>`,
  - …и т.д.

Также существует множество других тегов со своими собственными классами, которые могут иметь определенные свойства и методы, в то время как некоторые элементы, такие как `<span>`, `<section>` и `<article>`, не имеют каких-либо определенных свойств, поэтому они являются экземплярами класса `HTMLElement`.

Таким образом, полный набор свойств и методов данного узла является результатом цепочки наследования.

Рассмотрим DOM-объект для тега `<input>`. Он принадлежит классу [`HTMLInputElement`](https://html.spec.whatwg.org/multipage/forms.html#htmlinputelement).

Он получает свойства и методы из (в порядке наследования):

- `HTMLInputElement` – этот класс предоставляет специфичные для элементов формы свойства,
- `HTMLElement` – предоставляет общие для HTML-элементов методы (и геттеры/сеттеры),
- `Element` – предоставляет типовые методы элемента,
- `Node` – предоставляет общие свойства DOM-узлов,
- `EventTarget` – обеспечивает поддержку событий (поговорим о них дальше),
- …и, наконец, он наследует от `Object`, поэтому доступны также методы «обычного объекта», такие как `hasOwnProperty`.

Для того, чтобы узнать имя класса DOM-узла, вспомним, что обычно у объекта есть свойство `constructor`. Оно ссылается на конструктор класса, и в свойстве constructor.name` содержится его имя:
```js
alert( document.body.constructor.name ); // HTMLBodyElement
```

…Или мы можем просто привести его к строке:
```js
alert( document.body ); // [object HTMLBodyElement]
```

Проверить наследование можно также при помощи `instanceof`:
```js
alert( document.body instanceof HTMLBodyElement ); // true
alert( document.body instanceof HTMLElement ); // true
alert( document.body instanceof Element ); // true
alert( document.body instanceof Node ); // true
alert( document.body instanceof EventTarget ); // true
```

Как видно, DOM-узлы – это обычные JavaScript объекты. Для наследования они используют классы, основанные на прототипах.

В этом легко убедиться, если вывести в консоли браузера любой элемент через `console.dir(`*`elem`*`)`. Или даже напрямую обратиться к методам, которые хранятся в `HTMLElement.prototype`, `Element.prototype` и т.д.

!!! info "`console.dir(elem)` и `console.log(elem)`"

    Большинство браузеров поддерживают в инструментах разработчика две команды: `console.log` и `console.dir`. Они выводят свои аргументы в консоль. Для JavaScript-объектов эти команды обычно выводят одно и то же.

    Но для DOM-элементов они работают по-разному:

    - `console.log(`*`elem`*`)` выводит элемент в виде DOM-дерева.
    - `console.dir(`*`elem`*`)` выводит элемент в виде DOM-объекта, что удобно для анализа его свойств.

    Попробуйте сами на `document.body`. Вы увидите разницу во всех современных браузерах (кроме Firefox, где `console.log(`*`elem`*`)` и `console.dir(`*`elem`*`)` выводят одно и то же – элемент в виде DOM-объекта).

!!! info "Спецификация IDL"

В спецификации для описания классов DOM используется не JavaScript, а специальный язык [Interface description language](https://ru.wikipedia.org/wiki/%D0%AF%D0%B7%D1%8B%D0%BA_%D0%BE%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D1%8F_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D0%BE%D0%B2) (IDL), с которым достаточно легко разобраться.

В IDL все свойства представлены с указанием их типов. Например, `DOMString`, `boolean` и т.д.

Небольшой отрывок IDL с комментариями:

```js
// Объявление HTMLInputElement
// Двоеточие ":" после HTMLInputElement означает, что он наследует от HTMLElement
interface HTMLInputElement: HTMLElement {
  // далее идут свойства и методы элемента <input>

  // "DOMString" означает, что значение свойства - строка
  attribute DOMString accept;
  attribute DOMString alt;
  attribute DOMString autocomplete;
  attribute DOMString value;

  // boolean - значит, что autofocus хранит логический тип данных (true/false)
  attribute boolean autofocus;
  ...
  // "void" перед методом означает, что данный метод не возвращает значение
  void select();
  ...
}
```

##### Свойства узлов
Объект **`Node`** предоставляет ряд свойств, с помощью которых мы можем получить информацию о данном узле:

- **`childNodes`**: содержит коллекцию дочерних узлов

- **`children`**: содержит коллекцию дочерних узлов, которые являются элементами

- **`firstChild`**: возвращает первый дочерний узел текущего узла

- **`firstElementChild`**: возвращает первый дочерний узел, который является элементом

- **`lastChild`**: возвращает последний дочерний узел текущего узла

- **`lastElementChild`**: возвращает последний дочерний узел, который является элементом

- **`previousSibling`**: возвращает предыдущий узел, который находится на одном уровне с текущим

- **`nextSibling`**: возвращает следующий узел, который находится на одном уровне с текущим

- **`previousElementSibling`**: возвращает предыдущий узел, который является элементом и который находится на одном уровне с текущим

- **`nextElementSibling`**: возвращает следующий узел, который является элементом и который находится на одном уровне с текущим

- **`ownerDocument`**: возвращает корневой узел документа

- **`parentNode`**: возвращает родительский узел для текущего узла

- **`parentElement`**: возвращает родительский узел, который является элементом

- **`nodeName`**: возвращает имя узла

- **`nodeType`**: возвращает тип узла в виде числа

- **`nodeValue`**: возвращает текст текстового узла

Прежде всего мы можем использовать свойства **`nodeName`** и **`nodeType`**, чтобы узнать тип узла:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <div id="article">
        <h1 id="header">Home Page</h1>
        <p>Page Text</p>
    </div>
<script>
const article = document.getElementById("article");
console.log(article.nodeName);  // DIV
console.log(article.nodeType);  // 1
</script>
</body>
</html>
```

Здесь получаем информацию по элементу с `id="header"`. В частности, свойство `nodeName` возвратит имя тега элемента — **`div`**, а свойство `nodeType` — число 1. 

##### Свойство «nodeType»
Свойство `nodeType` предоставляет ещё один, «старомодный» способ узнать «тип» DOM-узла.

Его значением является цифра:

- `elem.nodeType == 1` для узлов-элементов,
- `elem.nodeType == 3` для текстовых узлов,
- `elem.nodeType == 9` для объектов документа,

В [спецификации](https://dom.spec.whatwg.org/#node) можно посмотреть остальные значения.

Например:
```html
<body>
  <script>
  let elem = document.body;

  // давайте разберёмся: какой тип узла находится в elem?
  alert(elem.nodeType); // 1 => элемент

  // и его первый потомок...
  alert(elem.firstChild.nodeType); // 3 => текст

  // для объекта document значение типа -- 9
  alert( document.nodeType ); // 9
  </script>
</body>
```

Каждому типу узлов соответствует определенное число:

| nodeType | Название константы          | Тип узла              | Описание                | nodeName           | nodeValue  |
| -------- | --------------------------- | --------------------- | ----------------------- | ------------------ | ---------- |
| 1        | `ELEMENT_NODE`                | Элемент               | HTML-элемент `<div>`, `<p>` | имя тега           | `null`       |
| 2        | `ATTRIBUTE_NODE`              | Атрибут               | `href="..."` (устарело)   | имя атрибута       | значение   |
| 3        | `TEXT_NODE`                   | Текст                 | Текст между тегами      | `#text`              | содержимое |
| 4        | `CDATA_SECTION_NODE`          | CDATASection          | `<![CDATA[...]]>`         | `#cdata-section`     | содержимое |
| 5        | `ENTITY_REFERENCE_NODE`       | `EntityReference`       | `&copy;`                  | имя сущности       | `null`       |
| 6        | `ENTITY_NODE`                 | `Entity`                | `<!ENTITY logo>`          | имя сущности       | `null`       |
| 7        | `PROCESSING_INSTRUCTION_NODE` | `ProcessingInstruction` | `<?xml-stylesheet?>`      | `target`             | содержимое |
| 8        | `COMMENT_NODE`                | `Comment`               | `<!-- комментарий -->`    | `#comment`           | текст      |
| 9        | `DOCUMENT_NODE`               | `Document`              | Корень документа        | `#document`          | `null`       |
| 10       | `DOCUMENT_TYPE_NODE`          | `DocumentType`          | `<!DOCTYPE html>`         | имя `DOCTYPE`        | `null`       |
| 11       | `DOCUMENT_FRAGMENT_NODE`      | `DocumentFragment`      | Временный контейнер     | `#document-fragment` | `null`       |
| 12       | `NOTATION_NODE`               | `Notation`              | `<!NOTATION GIF>`         | имя нотации        | `null`       |

RDF в контексте DOM не имеет специального `nodeType` — это формат данных (XML/RDFa/JSON-LD), парсится в обычные `Element`/`Text` узлы:
```xml
<!-- RDF/XML → ELEMENT_NODE (1) + TEXT_NODE (3) -->
<rdf:Description rdf:about="ivan">
  <foaf:name>Иван</foaf:name>  <!-- nodeType = 1, 3 -->
</rdf:Description>
```

Таким образом, `nodeType` определяет DOM-структуру, RDF — семантику данных внутри `Element`/`Text` узлов.

В современных скриптах, чтобы узнать тип узла, мы можем использовать метод `instanceof` и другие способы проверить класс, но иногда `nodeType` проще использовать. Мы не можем изменить значение `nodeType`, только прочитать его.

##### Тег: nodeName и tagName
Получив DOM-узел, мы можем узнать имя его тега из свойств `nodeName` и `tagName`:

Например:
```js
alert( document.body.nodeName ); // BODY
alert( document.body.tagName ); // BODY
```

Есть ли какая-то разница между `tagName` и `nodeName`?

Да, она отражена в названиях свойств, но не очевидна.

- Свойство `tagName` есть только у элементов `Element`.
- Свойство `nodeName` определено для любых узлов `Node`:
  - для элементов оно равно `tagName`.
  - для остальных типов узлов (текст, комментарий и т.д.) оно содержит строку с типом узла.

Другими словами, свойство `tagName` есть только у узлов-элементов (поскольку они происходят от класса `Element`), а `nodeName` может что-то сказать о других типах узлов.

Например, сравним `tagName` и `nodeName` на примере объекта `document` и узла-комментария:
```html
<body><!-- комментарий -->

  <script>
    // для комментария
    alert( document.body.firstChild.tagName ); // undefined (не элемент)
    alert( document.body.firstChild.nodeName ); // #comment

    // for document
    alert( document.tagName ); // undefined (не элемент)
    alert( document.nodeName ); // #document
  </script>
</body>
```

Если мы имеем дело только с элементами, то можно использовать `tagName` или `nodeName`, нет разницы.

!!! info "Имена тегов (кроме XHTML) всегда пишутся в верхнем регистре"

    В браузере существуют два режима обработки документа: HTML и XML. HTML-режим обычно используется для веб-страниц. XML-режим включается, если браузер получает XML-документ с заголовком: `Content-Type: application/xml+xhtml`.

    В HTML-режиме значения `tagName`/`nodeName` всегда записаны в верхнем регистре. Будет выведено BODY вне зависимости от того, как записан тег в HTML `<body>` или `<BoDy>`.

    В XML-режиме регистр сохраняется «как есть». В настоящее время XML-режим применяется редко.

#### Свойства объекта document
Все операции с DOM начинаются с объекта `document`. Это главная «точка входа» в DOM. Из него мы можем получить доступ к любому узлу. Объект `document` определен в глобальном объекте `window` и предназначен для работы со структурой DOM в JavaScript. Для получения базовой информации о веб-странице объект `document` предоставляет ряд свойств:

- **`title`**: представляет заголовок документа (который указан в элементе `<title>`)

- **`lastModified`**: содержит дату последнего изменения документа

- **`URL`**: содержит адрес URL текущего документа

- **`domain`**: содержит домен, к которому принадлежит веб-страница документа

- **`documentElement`**: предоставляет доступ к корневому элементу `<html>`

- **`body`**: предоставляет доступ к элементу `<body>` на веб-странице

- **`head`**: предоставляет доступ к элементу `<head>` на веб-странице

- **`cookie`**: содержит коллекцию всех куки для текущего документа

- **`images`**: содержит коллекцию всех объектов изображений (элементов `img`)

- **`links`**: содержит коллекцию ссылок — элементов `<a>` и `<area>`, у которых определен атрибут `href`

- **`anchors`**: предоставляет доступ к коллекции элементов `<a>`, у которых определен атрибут name

- **`forms`**: содержит коллекцию всех форм на веб-странице

Эти свойства не предоставляют доступ ко всем элементам, однако позволяют получить наиболее часто используемые элементы на веб-странице. Например, получим корневой узел документа:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
<script>
console.log(document.documentElement);
</script>
</body>
</html>
```

В результате на консоль будет выведено содержимое текущей веб-страницы, как оно определено в коде выше.

Или выведем базовую информацию о документе:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
<script>
console.log(document.title);
console.log(document.lastModified);
console.log(document.domain);
console.log(document.URL);
</script>
</body>
</html>
```

Консольный вывод:
```
DevPM
12/07/2025 10:56:12

file:///Users/user/Documents/app/index.html
```

Получим все изображения на странице:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <img src="picure1.png" alt="Картинка 1" />
    <img src="picure2.png" alt="Картинка 2" />
    <img src="picure3.png" alt="Картинка 3" />
    <script>
        const images = document.images;
        // изменим первое изображение
        images[0].src="picture_4.jpg";
        images[0].alt="Новая картинка";
        // перебирем все изображения
        for(img of images){
            console.log(`Url: "${img.src}" Alt:"${img.alt}"`);
        }
    </script>
</body>
</html>
```

Подобно тому, как в коде html мы можем установить атрибуты у элемента `img`, так и в коде javascript мы можем через свойства `src` и `alt` получить и установить значения этих атрибутов. Причем в данном случае не важно, существуют или нет файлы изображений. Консольный вывод будет наподобие следующего:
```
Url: "app/picture_4.jpg" Alt:"Новая картинка"
Url: "app/picure2.png" Alt:"Картинка 2"
Url: "app/picure3.png" Alt:"Картинка 3"
```

Рассмотрим получение всех ссылок на странице:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <a href="article1.html">Статья 1</a>
    <a href="article2.html">Статья 2</a>
    <a href="article3.html">Статья 3</a>
    <script>
        const links = document.links;
        // перебираем все ссылки
        for(link of links){
            console.log(`Href: "${link.href}" Text: "${link.innerText}"`);
        }
    </script>
</body>
</html>
```

Опять же, так как у ссылки определен атрибут `href`, то при переборе ссылок мы можем получить его значение.[^8.3]

#### Навигационные свойства
Так выглядят основные ссылки, по которым можно переходить между узлами DOM:

![DOM navigation links](../img/dom-links.svg)

Поговорим об этом подробнее.

##### Сверху: documentElement и body
Самые верхние элементы дерева доступны как свойства объекта `document`:

- `<html>` = `document.documentElement`

    Самый верхний узел документа: `document.documentElement`. В DOM он соответствует тегу `<html>`.

- `<body>` = `document.body`

    Другой часто используемый DOM-узел – узел тега `<body>`: `document.body`.

- `<head>` = `document.head`

    Тег `<head>` доступен как `document.head`.

!!! warning "Есть одна тонкость: document.body может быть равен null"

    Нельзя получить доступ к элементу, которого ещё не существует в момент выполнения скрипта.

    В частности, если скрипт находится в `<head>`, `document.body` в нём недоступен, потому что браузер его ещё не прочитал.

    Поэтому, в примере ниже первый `alert` выведет `null`:
    ```html
    <html>

    <head>
    <script>
        alert( "Из HEAD: " + document.body ); // null, <body> ещё нет
    </script>
    </head>

    <body>

    <script>
        alert( "Из BODY: " + document.body ); // HTMLBodyElement, теперь он есть
    </script>

    </body>
    </html>
    ```

!!! info "В мире DOM `null` означает «не существует»"

    В DOM значение `null` значит «не существует» или «нет такого узла».

##### Получение родительского элемента
Для получения родительского элемента применяются свойства **`parentNode`** и **`parentElement`**. Например:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <div id="article">
        <h1 id="header">Home Page</h1>
        <p>Page Text</p>
    </div>
    <script>
    // выбираем все элемент c id="header"
    const header = document.getElementById("header");
    // получаем родительский элемента
    const headerParent = header?.parentElement;
    // можно так
    // const headerParent = header?.parentNode;
    console.log(headerParent);    // выводим родительский элемент на консоль
    </script>
</body>
</html>
```

Здесь выводим на консоль элемент, в который помещен элемент с `id="header"`.

Стоит отметить, что хотя оба метода в принципе возвращают один и тот же элемент, однако есть исключение — элемент `<html>`. Для него родительским узлом будет объект `document`, а вот родительского элемента у него не будет (будет значение `null`):
```js
const htmlEl = document.getElementsByTagName("html")[0];
const parentElem = htmlEl.parentElement;
const parentNode = htmlEl.parentNode;
console.log(parentElem);    // null
console.log(parentNode);    // объект document
```

##### Получение элементов одного уровня
*Соседи* (*siblings*) – это узлы, у которых один и тот же родитель.

Например, здесь `<head>` и `<body>` соседи:
```html
<html>
  <head>...</head><body>...</body>
</html>
```

- говорят, что `<body>` – «следующий» или «правый» сосед `<head>`
- также можно сказать, что `<head>` «предыдущий» или «левый» сосед `<body>`.

Следующий узел того же родителя (следующий сосед) – в свойстве `nextSibling`, а предыдущий – в `previousSibling`.

Таким образом, свойства **`previousSibling`**/**`previousElementSibling`** и **`nextSibling`**/**`nextElementSibling`** позволяют получить предыдущий и следующий элементы, которые располагаются на одном уровне с текущим. Например:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <div id="article">
        <h1 id="header">Home Page</h1>
        <p>Page Text 1</p>
        <p>Page Text 2</p>
        <p>Page Text 3</p>
    </div>
    <script>
    const article = document.getElementById("article");
    let tempNode = article.firstElementChild;
    while(tempNode != null){
        console.log(tempNode);
        tempNode = tempNode.nextElementSibling
    }
    </script>
</body>
</html>
```

Здесь опять же получаем элемент с `id="article"`. Затем получаем его первый элемент в переменную `tempNode` и в цикле, пока `tempNode` не будет равен `null`, выводим его значение на консоль и потом присваиваем этой переменной следующий элемент того же уровня (соседний элемент)
```js
tempNode = tempNode.nextElementSibling
```

Таким образом, мы перебирем все элементы одного уровня. Консольный вывод:
```
<h1 id="header">Home Page</h1>
<p>Page Text 1</p>
<p>Page Text 2</p>
<p>Page Text 3</p>
```

Также можно перебрать узлы в обратном порядке — сначала получаем последний узел, а затем обращаемся к предыдущему сестринскому узлу:
```js
const article = document.getElementById("article");
let tempNode = article.lastElementChild;
while(tempNode != null){
    console.log(tempNode);
    tempNode = tempNode.previousElementSibling;
}
```

Как помним, родитель доступен через `parentNode`.

Например:
```js
// родителем <body> является <html>
alert( document.body.parentNode === document.documentElement ); // выведет true

// после <head> идёт <body>
alert( document.head.nextSibling ); // HTMLBodyElement

// перед <body> находится <head>
alert( document.body.previousSibling ); // HTMLHeadElement
```

##### Получение потомков
Здесь и далее мы будем использовать два принципиально разных термина:

- **Дочерние узлы** (или **дети**, *child nodes*) – элементы, которые являются непосредственными детьми узла. Другими словами, элементы, которые лежат непосредственно внутри данного. Например, `<head>` и `<body>` являются детьми элемента `<html>`.

- **Потомки** (*descendant nodes*) – все элементы, которые лежат внутри данного, включая детей, их детей и т.д.

В примере ниже детьми тега `<body>` являются теги `<div>` и `<ul>` (и несколько пустых текстовых узлов):
```html
<html>
<body>
  <div>Начало</div>

  <ul>
    <li>
      <b>Информация</b>
    </li>
  </ul>
</body>
</html>
```

…А потомки `<body>` – это и прямые дети `<div>`, `<ul>` и вложенные в них: `<li>` (ребёнок `<ul>`) и `<b>` (ребёнок `<li>`) – в общем, все элементы поддерева.

Для получения дочерних элементов можно использовать свойство **`children`**:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM Vault</title>
</head>
<body>
    <div id="article">
        <h1 id="header">Home Page</h1>
        <p>Page Text</p>
    </div>
<script>
// выбираем элемент c id="article"
const article = document.getElementById("article");

for(elem of article.children){
    console.log(elem);
}
</script>
</body>
</html>
```

Здесь получаем элемент с `id="article"` и в цикле проходим по всем его дочерним элементам. А это два элемента:
```html
<h1 id="header">Home Page</h1>
<p>Page Text</p>
```

Если же нам надо выбрать вообще все дочерние узлы (не только элементы, но и атрибуты и текст), то применяется метод **`childNodes`**:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <div id="article">
        <h1 id="header">Home Page</h1>
        <p>Page Text</p>
    </div>
<script>
// выбираем элемент c id="article"
const article = document.getElementById("article");

for(node of article.childNodes){
    let type = "";
    if(node.nodeType===1) type="элемент";
    else if(node.nodeType===2) type="атрибут";
    else if(node.nodeType===3) type="текст";

    console.log(node.nodeName, ": ", type);
}
</script>
</body>
</html>
```

Здесь мы выбираем тот же элемент, но теперь перебираем его узлы. Выбираем элемент `div` с классом `article` и пробегаемся по его дочерним узлам. И в цикле выводим имя узла и его тип с помощью свойств `nodeName` и `nodeType`.

И несмотря на то, что в блоке `div#article` только два элемента: заголовок `h1` и параграф, консоль отобразит нам пять узлов.

```
#text :  текст
H1 :  элемент
#text :  текст
P :  элемент
#text :  текст
```

Дело в том, что пробелы между узлами также считаются за отдельные текстовые узлы. Если бы пробелов не было:
```html
<div id="article"><h1 id="header">Home Page</h1><p>Page Text</p></div>
```

то при переборе мы бы обнаружили только два дочерних узла, как и ожидалось.

**Коллекция `childNodes` содержит список всех детей, включая текстовые узлы.**

Пример ниже последовательно выведет детей `document.body`:
```html
<html>
<body>
  <div>Начало</div>

  <ul>
    <li>Информация</li>
  </ul>

  <div>Конец</div>

  <script>
    for (let i = 0; i < document.body.childNodes.length; i++) {
      alert( document.body.childNodes[i] ); // Text, DIV, Text, UL, ..., SCRIPT
    }
  </script>
  ...какой-то HTML-код...
</body>
</html>
```

Обратим внимание на маленькую деталь. Если запустить пример выше, то последним будет выведен элемент `<script>`. На самом деле, в документе есть ещё «какой-то HTML-код», но на момент выполнения скрипта браузер ещё до него не дошёл, поэтому скрипт не видит его.

Кроме того, для получения первого и последнего узла/элемента применяются свойства **`firstChild`**/**`firstElementChild`** и **`lastChild`**/**`lastElementChild`** соответственно.

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <div id="article">
        <h1 id="header">Home Page</h1>
        <p>Page Text</p>
    </div>
<script>
const article = document.getElementById("article");
console.log("First Child:", article.firstElementChild);
console.log("Last Child:", article.lastElementChild);
</script>
</body>
</html>
```

Консольный вывод:
```
First Child: <h1 id="header">Home Page</h1>​
Last Child: <p>Page Text</p>​
```

**Свойства `firstChild` и `lastChild` обеспечивают быстрый доступ к первому и последнему дочернему элементу.**

Они, по сути, являются всего лишь сокращениями. Если у тега есть дочерние узлы, условие ниже всегда верно:
```js
elem.childNodes[0] === elem.firstChild
elem.childNodes[elem.childNodes.length - 1] === elem.lastChild
```

Для проверки наличия дочерних узлов существует также специальная функция `elem.hasChildNodes()`. Метод **`hasChildNodes()`** возвращает `true`, если элемент содержит вложенные узлы:
```js
const article = document.querySelector("div");
if(article.hasChildNodes()){
    console.log("There are child nodes");
}
else{
    console.log("No child nodes");
}
```

Для получения количества дочерних элементов можно применять свойство **`childElementCount`**. Это значение будет эквивалентно значению `children.length`:
```js
const article = document.getElementById("article");
console.log(article.childElementCount); // 2
console.log(article.children.length); // 2
```

##### DOM-коллекции
Как мы уже видели, `childNodes` похож на массив. На самом деле это не массив, а *коллекция* – особый перебираемый объект-псевдомассив.

И есть два важных следствия из этого:

1. Для перебора *коллекции* мы можем использовать `for..of`:

    ```js
    for (let node of document.body.childNodes) {
    alert(node); // покажет все узлы из коллекции
    }
    ```

    Это работает, потому что коллекция является перебираемым объектом (есть требуемый для этого метод `Symbol.iterator`).

2. Методы массивов не будут работать, потому что коллекция – это не массив:

    ```js
    alert(document.body.childNodes.filter); // undefined (у коллекции нет метода filter!)
    ```

Первый пункт – это хорошо для нас. Второй – бывает неудобен, но можно пережить. Если нам хочется использовать именно методы массива, то мы можем создать настоящий массив из коллекции, используя `Array.from`:
```js
alert( Array.from(document.body.childNodes).filter ); // сделали массив
```

!!! warning "DOM-коллекции – только для чтения"

    DOM-коллекции, и даже более – *все* навигационные свойства, перечисленные в этой главе, доступны только для чтения.

    Мы не можем заменить один дочерний узел на другой, просто написав `childNodes[i] = ...`.

    Для изменения DOM требуются другие методы. Мы увидим их в следующей главе.

!!! warning "DOM-коллекции живые"

    Почти все DOM-коллекции, за небольшим исключением, живые. Другими словами, они отражают текущее состояние DOM.

    Если мы сохраним ссылку на `elem.childNodes` и добавим/удалим узлы в DOM, то они появятся в сохранённой коллекции автоматически.

!!! warning "Не используйте цикл `for..in` для перебора коллекций"

    Коллекции перебираются циклом `for..of`. Некоторые начинающие разработчики пытаются использовать для этого цикл `for..in`.

    Не делайте так. Цикл `for..in` перебирает все перечисляемые свойства. А у коллекций есть некоторые «лишние», редко используемые свойства, которые обычно нам не нужны:
    ```html
    <body>
    <script>
    // выводит 0, 1, length, item, values и другие свойства.
    for (let prop in document.body.childNodes) alert(prop);
    </script>
    </body>
    ```

##### nodeValue и получение текстового содержимого
Свойство **`nodeValue`** позволяет получить содержимое текстового узла, то есть его текст. Например:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM Vault</title>
</head>
<body>
    <div id="article">
        <h1 id="header">Home Page</h1>
        <p id="text">Page Text</p>
    </div>
    <script>
    // получаем элемент с id="text"
    const pageText = document.getElementById("text");
    console.log(pageText.nodeValue);    // null
    for(textNode of pageText.childNodes){
        console.log(textNode.nodeValue);
    }
    </script>
</body>
</html>
```

В данном случае мы пытаемся получить текст элемента с `id="text"`. Сначала получаем данный элемент в константу `pageText`. Однако напрямую мы не можем у него вызвать у него свойство `nodeValue`. Если мы это сделаем, то получим **`null`**:
```js
console.log(pageText.nodeValue);    // null
```

Потому что полученный нами элемент не является текстовым узлом. Текстовый узел располагается внутри элемента `pageText`. И чтобы получить текст, нам надо обратиться к этому текстовому узлу через коллекцию `childNodes`:
```js
for(textNode of pageText.childNodes){
    console.log(textNode.nodeValue);
}
```

Хотя мы так можем получить текстовое содержимое элементов, но это не самый оптимальный способ, и далее мы рассмотрим другие способы.[^8.4]

##### Навигация только по элементам
Навигационные свойства, описанные выше, относятся ко *всем* узлам в документе. В частности, в `childNodes` находятся и текстовые узлы и узлы-элементы и узлы-комментарии, если они есть.

Но для большинства задач текстовые узлы и узлы-комментарии нам не нужны. Мы хотим манипулировать узлами-элементами, которые представляют собой теги и формируют структуру страницы.

Поэтому давайте рассмотрим дополнительный набор ссылок, которые учитывают только *узлы-элементы*:

![DOM links elements](../img/dom-links-elements.svg)

Эти ссылки похожи на те, что раньше, только в ряде мест стоит слово `Element`:

- `children` – коллекция детей, которые являются элементами.
- `firstElementChild`, `lastElementChild` – первый и последний дочерний элемент.
- `previousElementSibling`, `nextElementSibling` – соседи-элементы.
- `parentElement` – родитель-элемент.

!!! info "Зачем нужен `parentElement`? Разве может родитель быть *не* элементом?"

    Свойство `parentElement` возвращает родитель-элемент, а `parentNode` возвращает «любого родителя». Обычно эти свойства одинаковы: они оба получают родителя.

    За исключением `document.documentElement`:
    ```js
    alert( document.documentElement.parentNode ); // выведет document
    alert( document.documentElement.parentElement ); // выведет null
    ```

    Причина в том, что родителем корневого узла `document.documentElement` (`<html>`) является `document`. Но `document` – это не узел-элемент, так что `parentNode` вернёт его, а `parentElement` нет.

    Эта деталь может быть полезна, если мы хотим пройти вверх по цепочке родителей от произвольного элемента `elem` к `<html>`, но не до `document`:
    ```js
    while(elem = elem.parentElement) { // идти наверх до <html>
    alert( elem );
    }
    ```

Изменим один из примеров выше: заменим `childNodes` на `children`. Теперь цикл выводит только элементы:
```html
<html>
<body>
  <div>Начало</div>

  <ul>
    <li>Информация</li>
  </ul>

  <div>Конец</div>

  <script>
    for (let elem of document.body.children) {
      alert(elem); // DIV, UL, DIV, SCRIPT
    }
  </script>
  ...
</body>
</html>
```

#### Специфичные навигационные свойства
До сих пор мы описывали основные навигационные ссылки.

Некоторые типы DOM-элементов предоставляют для удобства дополнительные свойства, специфичные для их типа.

Таблицы – отличный пример таких элементов.

**Элемент `<table>`**, в дополнение к свойствам, о которых речь шла выше, поддерживает следующие:

- `table.rows` – коллекция строк `<tr>` таблицы.
- `table.caption`/`tHead`/`tFoot` – ссылки на элементы таблицы `<caption>`, `<thead>`, `<tfoot>`.
- `table.tBodies` – коллекция элементов таблицы `<tbody>` (по спецификации их может быть больше одного).

**`<thead>`**, **`<tfoot>`**, **`<tbody>`** предоставляют свойство `rows`:

- `tbody.rows` – коллекция строк `<tr>` секции.

**`<tr>`**:

- `tr.cells` – коллекция `<td>` и `<th>` ячеек, находящихся внутри строки `<tr>`.
- `tr.sectionRowIndex` – номер строки `<tr>` в текущей секции `<thead>`/`<tbody>`/`<tfoot>`.
- `tr.rowIndex` – номер строки `<tr>` в таблице (включая все строки таблицы).

**`<td>` и `<th>`**:

- `td.cellIndex` – номер ячейки в строке `<tr>`.

Пример использования:
```html
<table id="table">
  <tr>
    <td>один</td><td>два</td>
  </tr>
  <tr>
    <td>три</td><td>четыре</td>
  </tr>
</table>

<script>
  // выводит содержимое первой строки, второй ячейки
  alert( table.rows[0].cells[1].innerHTML ) // "два"
</script>
```

Спецификация: [tabular data](https://html.spec.whatwg.org/multipage/tables.html).

Существуют также дополнительные навигационные ссылки для HTML-форм. Мы рассмотрим их позже, когда начнём работать с формами.

#### Итого
Получив DOM-узел, мы можем перейти к его ближайшим соседям используя навигационные ссылки.

Есть два основных набора ссылок:

- Для всех узлов: `parentNode`, `childNodes`, `firstChild`, `lastChild`, `previousSibling`, `nextSibling`.
- Только для узлов-элементов: `parentElement`, `children`, `firstElementChild`, `lastElementChild`, `previousElementSibling`, `nextElementSibling`.

Некоторые виды DOM-элементов, например таблицы, предоставляют дополнительные ссылки и коллекции для доступа к своему содержимому.[^dom-navigation]

#### Задачи

##### Дочерние элементы в DOM
Для страницы:
```html
<html>
<body>
  <div>Пользователи:</div>
  <ul>
    <li>Джон</li>
    <li>Пит</li>
  </ul>
</body>
</html>
```

Напишите код, как получить…

- элемент `<div>`?
- `<ul>`?
- второй `<li>` (с именем Пит)?

##### Вопрос о соседях
Если `elem` – произвольный узел DOM-элемента…

- Правда, что `elem.lastChild.nextSibling` всегда равен `null`?
- Правда, что `elem.children[0].previousSibling` всегда равен `null`?

##### Выделите ячейки по диагонали
Напишите код, который выделит красным цветом все ячейки в таблице по диагонали.

Вам нужно получить из таблицы `<table>` все диагональные `<td>` и выделить их, используя код:
```js
//  в переменной td находится DOM-элемент для тега <td>
td.style.backgroundColor = 'red';
```

Должно получиться так:

![Table](../img/table-diagonal.png)

### Элементы
Для работы с элементами на веб-странице мы можем использовать как функциональность типа `Node`, который представляет любой узел веб-страницы, так и функциональность типа **`HTMLElement`**, который собственно представляет элемент. То есть объекты `HTMLElement` — это фактически те же самые узлы — объекты `Node`, у которых тип узла (свойство `nodeType`) равно 1.

Каждый элемент веб-страницы соответствует определенному типу в JavaScript. Но все эти типы являются подтипами типа **`HTMLElement`**, который определяет базовую функциональность элементов. Вкратце перечислим актуальные типы элементов:

| Тег | Тип
-- | --
`<a>` | `HTMLAnchorElement`
`<abbr>` | `HTMLElement`
`<address>` | `HTMLElement`
`<area>` | `HTMLAreaElement`
`<audio>` | `HTMLAudioElement`
`<b>` | `HTMLElement`
`<base>` | `HTMLBaseElement`
`<bdo>` | `HTMLElement`
`<blockquote>` | `HTMLQuoteElement`
`<body>` | `HTMLBodyElement`
`<br>` | `HTMLBRElement`
`<button>` | `HTMLButtonElement`
`<caption>` | `HTMLTableCaptionElement`
`<canvas>` | `HTMLCanvasElement`
`<cite>` | `HTMLElement`
`<code>` | `HTMLElement`
`<col>`, `<colgroup`> | `HTMLTableColElement`
`<data>` | `HTMLDataElement`
`<datalist>` | `HTMLDataListElement`
`<dd>` | `HTMLElement`
`<del>` | `HTMLModElement`
`<dfn>` | `HTMLElement`
`<div>` | `HTMLDivElement`
`<dl>` | `HTMLDListElement`
`<dt>` | `HTMLElement`
`<em>` | `HTMLElement`
`<embed>` | `HTMLEmbedElement`
`<fieldset>` | `HTMLFieldSetElement`
`<form>` | `HTMLFormElement`
`<h1>`, `<h2>`, `<h3>`, `<h4>`, `<h5>`, `<h6>` | `HTMLHeadingElement`
`<head>` | `HTMLHeadElement`
`<hr>` | `HTMLHRElement`
`<html>` | `HTMLHtmlElement`
`<i>` | `HTMLElement`
`<iframe>` | `HTMLIFrameElement`
`<img>` | `HTMLImageElement`
`<input>` | `HTMLInputElement`
`<ins>` | `HTMLModElement`
`<kbd>` | `HTMLElement`
`<keygen>` | `HTMLKeygenElement`
`<label>` | `HTMLLabelElement`
`<legend>` | `HTMLLegendElement`
`<li>` | `HTMLLIElement`
`<link>` | `HTMLLinkElement`
`<map>` | `HTMLMapElement`
`<media>` | `HTMLMediaElement`
`<meta>` | `HTMLMetaElement`
`<meter>` | `HTMLMeterElement`
`<noscript>` | `HTMLElement`
`<object>` | `HTMLObjectElement`
`<ol>` | `HTMLOListElement`
`<optgroup>` | `HTMLOptGroupElement`
`<option>` | `HTMLOptionElement`
`<output>` | `HTMLOutputElement`
`<p>` | `HTMLParagraphElement`
`<param>` | `HTMLParamElement`
`<pre>` | `HTMLPreElement`
`<progress>` | `HTMLProgressElement`
`<q>` | `HTMLQuoteElement`
`<s>` | `HTMLElement`
`<samp>` | `HTMLElement`
`<script>` | `HTMLScriptElement`
`<select>` | `HTMLSelectElement`
`<small>` | `HTMLElement`
`<source>` | `HTMLSourceElement`
`<span>` | `HTMLSpanElement`
`<strong>` | `HTMLElement`
`<style>` | `HTMLStyleElement`
`<sub>` | `HTMLElement`
`<sup>` | `HTMLElement`
`<table>` | `HTMLTableElement`
`<tbody>` | `HTMLTableSectionElement`
`<td>` | `HTMLTableCellElement`
`<textarea>` | `HTMLTextAreaElement`
`<tfoot>` | `HTMLTableSectionElement`
`<th>` | `HTMLTableHeaderCellElement`
`<thead>` | `HTMLTableSectionElement`
`<time>` | `HTMLTimeElement`
`<title>` | `HTMLTitleElement`
`<tr>` | `HTMLTableRowElement`
`<track>` | `HTMLTrackElement`
`<ul>` | `HTMLUListElement`
`<var>` | `HTMLElement` / `HTMLUnknownElement`
`<video>` | `HTMLVideoElement`

Мы можем получить конкретный тип элемента с помощью метода **`Object.getPrototypeOf()`**:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <h1 id="header">Home Page</h1>
    <script>
    const header = document.getElementById("header");
    console.log(Object.getPrototypeOf(header)); // HTMLHeadingElement
    </script>
</body>
</html>
```

#### Свойства элементов
Тип `Element` предоставляет ряд свойств, которые хранят информацию об элементе:

- **`tagName`**: возвращает тег элемента

- **`textContent`**: представляет текстовое содержимое элемента

- **`innerText`**: представляет текстовое содержимое элемента (аналогично `textContent`)

- **`innerHTML`**: представляет html-код элемента

Одним из ключевых свойств объекта `Element` является свойство **`tagName`**, которое возвращает тег элемента:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <h1 id="header">Home Page</h1>
    <script>
    const header = document.getElementById("header");
    console.log(header.tagName);  // H1
    </script>
</body>
</html>
```

#### Управление текстом элемента
Свойство **`textContent`** позволяет получить или изменить текстовое содержимое элемента:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <h1 id="header">Home Page</h1>
    <script>
    const header = document.getElementById("header");
    // получаем текст элемента
    console.log(header.textContent);  // Home Page
    // изменяем текст элемента
    header.textContent = "Hello World";
    </script>
</body>
</html>
```

Аналогично можно использовать другое свойство для управление текстом — **`innerText`**:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <h1 id="header">Home Page</h1>
    <script>
    const header = document.getElementById("header");
    // получаем текст элемента
    console.log(header.innerText);  // Home Page
    // изменяем текст элемента
    header.innerText = "Hello World2";
    </script>
</body>
</html>
```

Тем не менее между **`textContent`** и **`innerText`** есть некоторые различия:

- **`textContent`** получает содержимое всех элементов, включая `<script>` и `<style>`, тогда как **`innerText`** этого не делает

- **`innerText`** умеет считывать стили и не возвращает содержимое скрытых элементов, тогда как **`textContent`** этого не делает.

- **`innerText`** позволяет получить CSS, а **`textContent`** — нет.

#### Управление кодом HTML

##### innerHTML: содержимое элемента
Ни **`textContent`**, ни **`innerText`** не позволяют ни получить, ни изменить код html элемента.[^8.6] Например:
```js
header.innerText = "<span style='color:navy;'>Hello World</span>";
```

Это изменит только текст, но не html код. Для управления html применяется свойство **`innerHTML`**:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <h1 id="header">Home Page</h1>
    <script>
    const header = document.getElementById("header");
    // получаем html-код элемента
    console.log(header.innerHTML);  // Home Page
    // изменяем html-код элемента
    header.innerHTML = "<span style='color:navy;'>Hello World</span>";
    </script>
</body>
</html>
```

Свойство [`innerHTML`](https://w3c.github.io/DOM-Parsing/#widl-Element-innerHTML) позволяет получить HTML-содержимое элемента в виде строки.

Мы также можем изменять его. Это один из самых мощных способов менять содержимое на странице.

Пример ниже показывает содержимое `document.body`, а затем полностью заменяет его:
```html
<body>
  <p>Параграф</p>
  <div>DIV</div>

  <script>
    alert( document.body.innerHTML ); // читаем текущее содержимое
    document.body.innerHTML = 'Новый BODY!'; // заменяем содержимое
  </script>

</body>
```

Мы можем попробовать вставить некорректный HTML, браузер исправит наши ошибки:
```html
<body>

  <script>
    document.body.innerHTML = '<b>тест'; // забыли закрыть тег
    alert( document.body.innerHTML ); // <b>тест</b> (исправлено)
  </script>

</body>
```

!!! info "Скрипты не выполнятся"

    Если `innerHTML` вставляет в документ тег `<script>` – он становится частью HTML, но не запускается.

##### innerHTML+= осуществляет перезапись

Мы можем добавить HTML к элементу, используя `elem.innerHTML+="ещё html"`.

Вот так:
```js
chatDiv.innerHTML += "<div>Привет<img src='smile.gif'/> !</div>";
chatDiv.innerHTML += "Как дела?";
```

На практике этим следует пользоваться с большой осторожностью, так как фактически происходит *не* добавление, а перезапись.

Технически эти две строки делают одно и то же:
```js
elem.innerHTML += "...";
// это более короткая запись для:
elem.innerHTML = elem.innerHTML + "..."
```

Другими словами, `innerHTML+=` делает следующее:

1. Старое содержимое удаляется.
2. На его место становится новое значение `innerHTML` (с добавленной строкой).

**Так как содержимое «обнуляется» и переписывается заново, все изображения и другие ресурсы будут перезагружены.**

В примере `chatDiv` выше строка `chatDiv.innerHTML+="Как дела?"` заново создаёт содержимое HTML и перезагружает *smile.gif* (надеемся, картинка закеширована). Если в `chatDiv` много текста и изображений, то эта перезагрузка будет очень заметна.

Есть и другие побочные эффекты. Например, если существующий текст выделен мышкой, то при переписывании `innerHTML` большинство браузеров снимут выделение. А если это поле ввода `<input>` с текстом, введённым пользователем, то текст будет удалён. И т.д.

К счастью, есть и другие способы добавить содержимое, не использующие `innerHTML`, которые мы изучим позже.

##### outerHTML: HTML элемента целиком
Свойство `outerHTML` содержит HTML элемента целиком. Это как `innerHTML` плюс сам элемент.

Посмотрим на пример:
```html
<div id="elem">Привет <b>Мир</b></div>

<script>
  alert(elem.outerHTML); // <div id="elem">Привет <b>Мир</b></div>
</script>
```

**Будьте осторожны: в отличие от `innerHTML`, запись в `outerHTML` не изменяет элемент. Вместо этого элемент заменяется целиком во внешнем контексте.**

Да, звучит странно, и это действительно необычно, поэтому здесь мы и отмечаем это особо.

Рассмотрим пример:
```html
<div>Привет, мир!</div>

<script>
  let div = document.querySelector('div');

  // заменяем div.outerHTML на <p>...</p>
  div.outerHTML = '<p>Новый элемент</p>'; // (*)

  // Содержимое div осталось тем же!
  alert(div.outerHTML); // <div>Привет, мир!</div> (**)
</script>
```

Какая-то магия, да?

В строке `(*)` мы заменили `div` на `<p>Новый элемент</p>`. Во внешнем документе мы видим новое содержимое вместо `<div>`. Но, как видно в строке `(**)`, старая переменная `div` осталась прежней!

Это потому, что использование `outerHTML` не изменяет DOM-элемент, а удаляет его из внешнего контекста и вставляет вместо него новый HTML-код.

То есть, при `div.outerHTML=...` произошло следующее:

- `div` был удалён из документа.
- Вместо него был вставлен другой HTML `<p>Новый элемент</p>`.
- В `div` осталось старое значение. Новый HTML не сохранён ни в какой переменной.

Здесь легко сделать ошибку: заменить `div.outerHTML`, а потом продолжить работать с `div`, как будто там новое содержимое. Но это не так. Подобное верно для `innerHTML`, но не для `outerHTML`.

Мы можем писать в `elem.outerHTML`, но надо иметь в виду, что это не меняет элемент, в который мы пишем. Вместо этого создаётся новый HTML на его месте. Мы можем получить ссылки на новые элементы, обратившись к DOM.

### Поиск элементов на веб-странице
Свойства навигации по DOM хороши, когда элементы расположены рядом. А что, если нет? Как получить произвольный элемент страницы?

Для этого в DOM есть дополнительные методы поиска: `getElement*`, `querySelector*`.[^searching-elements-dom]

Объект `document` предоставляет ряд методов для поиска и управления элементами на веб-странице:

- `getElementById(value)`: выбирает элемент, у которого атрибут `id` равен `value`. Если элемента с таким идентификатором нет, то возвращается `null`.

- `getElementsByTagName(value)`: выбирает все элементы, у которых тег равен `value`. Возвращает список элементов (список типа `NodeList`), который аналогичен массиву.

- `getElementsByClassName(value)`: выбирает все элементы, которые имеют класс `value`. Возвращает список `NodeList`.

- `getElementsByName(value)`: выбирает все элементы, которые называются `value`. Возвращает список `NodeList`.

- `querySelector(value)`: выбирает первый элемент, который соответствует css-селектору `value`.

- `querySelectorAll(value)`: выбирает все элементы, которые соответствуют css-селектору `value`. Возвращает список `NodeList`.

#### Получение элементов по id
Если у элемента есть атрибут `id`, то мы можем получить его вызовом `document.getElementById(id)`, где бы он ни находился.

Например, найдем элемент по id:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <h1 id="header">Home Page</h1>
    <script>
        const headerElement = document.getElementById("header");
        console.log("Text: ", headerElement.innerText); // Text:  Home Page
    </script>
</body>
</html>
```

С помощью вызова `document.getElementById("header")` находим элемент, у которого `id="header"`. А с помощью свойства **`innerText`** можно получить текст найденного элемента.

Например:
```html
<div id="elem">
  <div id="elem-content">Element</div>
</div>

<script>
  // получить элемент
  let elem = document.getElementById('elem');

  // сделать его фон красным
  elem.style.background = 'red';
</script>
```

Также есть глобальная переменная с именем, указанным в `id`:
```html
<div id="elem">
  <div id="elem-content">Элемент</div>
</div>

<script>
  // elem - ссылка на элемент с id="elem"
  elem.style.background = 'red';

  // внутри id="elem-content" есть дефис, так что такой id не может служить именем переменной
  // ...но мы можем обратиться к нему через квадратные скобки: window['elem-content']
</script>
```

…Но это только если мы не объявили в JavaScript переменную с таким же именем, иначе она будет иметь приоритет:
```html
<div id="elem"></div>

<script>
  let elem = 5; // теперь elem равен 5, а не <div id="elem">

  alert(elem); // 5
</script>
```

!!! warning "Пожалуйста, не используйте такие глобальные переменные для доступа к элементам"

    Это поведение соответствует стандарту, но поддерживается в основном для совместимости, как осколок далёкого прошлого.

    Браузер пытается помочь нам, смешивая пространства имён JS и DOM. Это удобно для простых скриптов, которые находятся прямо в HTML, но, вообще говоря, не очень хорошо. Возможны конфликты имён. Кроме того, при чтении JS-кода, не видя HTML, непонятно, откуда берётся переменная.

    Далее мы будем обращаться к элементам по `id` в примерах для краткости, когда очевидно, откуда берётся элемент.

    В реальной жизни лучше использовать `document.getElementById`.

!!! info "Значение id должно быть уникальным"

    Значение `id` должно быть уникальным. В документе может быть только один элемент с данным `id`.

    Если в документе есть несколько элементов с одинаковым значением `id`, то поведение методов поиска непредсказуемо. Браузер может вернуть любой из них случайным образом. Поэтому, пожалуйста, придерживайтесь правила сохранения уникальности `id`.

Стоит отметить, что если элемент не найден, то метод возвращает **`null`**. Поэтому перед использованием элемента рекомендуется проверять его на `null`.

!!! warning "Только `document.getElementById`, а не *`anyElem`*`.getElementById`"

    Метод `getElementById` можно вызвать только для объекта `document`. Он осуществляет поиск по `id` по всему документу.

#### Поиск по определенному тегу
Поиск по определенному тегу:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <h1>Home Page</h1>
    <p>Первый абзац</p>
    <p>Второй абзац</p>
    <script>
        const paragraphs = document.getElementsByTagName("p");

        for (p of paragraphs) {
            console.log(p.innerText);   // выводим текст параграфа
        }
    </script>
</body>
</html>
```

С помощью вызова `document.getElementsByTagName("p")` находим все элементы параграфов. Этот вызов возвращает список типа `NodeList`, который во многом аналогичен массиву и который содержит найденные элементы. Чтобы получить отдельные элементы этого списка, можно пробежаться по этому списку в цикле.

Консольный вывод:
```
Первый абзац
Второй абзац
```

Если нам надо получить только первый элемент, то можно к первому элементу найденной коллекции объектов:
```js
const p = document.getElementsByTagName("p")[0];
console.log(p.innerText);
```

Если элементов с указанным тегом нет на странице, то возвращается пустой список. С помощью свойства **`length`** (как и в случае массивов) можно проверить количество найденных элементов:
```js
const paragraphs = document.getElementsByTagName("p");
console.log(paragraphs.length);
```

Конечно, для перебора списка можно использовать и другие виды циклов:
```js
const paragraphs = document.getElementsByTagName("p");
for (let i=0; i < paragraphs.length; i++) {
    console.log(paragraphs[i].innerText);
}
```

#### Получение элементов по классу
Получение элементов по классу:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <h1>Home Page</h1>
    <p class="text">Page Text</p>
    <p class="contacts">Email: supercorp@zmail.com</p>
    <p class="contacts">Phone: +1-234-567-8901</p>
    <script>
        const contacts = document.getElementsByClassName("contacts");

        for (contact of contacts) {
            console.log(contact.innerText);
        }
    </script>
</body>
</html>
```

В данном случае выбираем все элементы с классом "contacts". Консольный вывод:
```
Email: supercorp@zmail.com
Phone: +1-234-567-8901
```

#### Поиск элементов по атрибуту name
Метод **`getElementsByName()`** позволяет получить список из элементов по имени — атрибуту **`name`**. Данный метод применяется к элементам форм. Например:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <form>
        <p>Language:</p>
        <input type="radio" name="lang" value="Java">
        <label>Java</label>
        <br>
        <input type="radio" name="lang" value="JavaScript" checked>
        <label>JavaScript</label>
        <br>
        <input type="radio" name="lang" value="PHP">
        <label>PHP</label>
        <br>
    </form>
    <script>
    // выбираем все элементы с атрибутом name="lang"
    const langs = document.getElementsByName("lang");
    for (lang of langs) {
        console.log(lang.value);    // получаем значение атрибута value
    }
    </script>
</body>
</html>
```

В данном случае выбираем все элементы, у которых атрибут `name` равен "lang". В примере выше это радиокнопки. Затем на консоль выводим значение атрибута `value` каждого полученного элемента. Консольный вывод:
```
Java
JavaScript
PHP
```

Стоит отметить, что этот метод может работать несколько иначе в старых браузерах типа Internet Explorer или Opera. В частности, он выбирает элемент, если не только его атрибут `name` соответствует переданному значению, но и атрибут `id`.

#### Поиск элементов по селектору CSS

##### querySelectorAll

Самый универсальный метод поиска – это *`elem`*`.querySelectorAll(`*`css`*`)`, он возвращает все элементы внутри *`elem`*, удовлетворяющие данному CSS-селектору.

Следующий запрос получает все элементы `<li>`, которые являются последними потомками в `<ul>`:
```html
<ul>
  <li>Этот</li>
  <li>тест</li>
</ul>
<ul>
  <li>полностью</li>
  <li>пройден</li>
</ul>
<script>
  let elements = document.querySelectorAll('ul > li:last-child');

  for (let elem of elements) {
    alert(elem.innerHTML); // "тест", "пройден"
  }
</script>
```

Этот метод действительно мощный, потому что можно использовать любой CSS-селектор.

!!! info "Псевдоклассы тоже работают"

    Псевдоклассы в CSS-селекторе, в частности `:hover` и `:active`, также поддерживаются. Например, `document.querySelectorAll(':hover')` вернёт коллекцию (в порядке вложенности: от внешнего к внутреннему) из текущих элементов под курсором мыши.

##### querySelector

Метод *`elem`*`.querySelector(`*`css`*`)` возвращает первый элемент, соответствующий данному CSS-селектору.

Выбор по селектору CSS:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <div class="annotation">
        <p>Аннотация статьи</p>
    </div>
    <div class="text">
        <p>Первый абзац</p>
        <p>Второй абзац</p>
    </div>
    <script>
        const elem = document.querySelector(".annotation p");
        console.log(elem.innerText);    // Аннотация статьи
    </script>
</body>
</html>
```

Чтобы получить все элементы по селектору, можно подобным образом использовать метод `document.querySelectorAll`, который возвращает список `NodeList` из найденных элементов:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <div class="annotation">
        <p>Аннотация статьи</p>
    </div>
    <div class="text">
        <p>Первый абзац</p>
        <p>Второй абзац</p>
    </div>
    <script>
        const elems = document.querySelectorAll(".text p");
        for (elem of elems) {
            console.log(elem.innerText);
        }
    </script>
</body>
</html>
```

Вывод браузера:
```
Первый абзац
Второй абзац
```

Таким образом, выражение `document.querySelector(".annotation p")` находит элемент, который соответствует селектору `.annotation p`. Если на странице несколько элементов, соответствующих селектору, то метод выберет первый из них.

Иначе говоря, результат такой же, как при вызове *`elem`*`.querySelectorAll(`*`css`*`)[0]`, но он сначала найдёт все элементы, а потом возьмёт первый, в то время как *`elem`*`.querySelector` найдёт только первый и остановится. Это быстрее, кроме того, его короче писать.

##### Селекторы CSS
Перечислим вкратце список базовых CSS-селекторов, которые можно применять для поиска элементов:

- `*`: выбирает все элементы

- `E`: выбирает все элементы типа `E`

- `[a]`: выбирает все элементы с атрибутом `a`

- `[a="b"]`: выбирает все элементы, в которых атрибут `a` имеет значение `b`

- `[a~="b"]`: выбирает все элементы, в которых атрибут `a` имеет список значений, и одно из этих значений равно `b`

- `[a^="b"]`: выбирает все элементы, в которых значение атрибута `a` начинается на `b`

- `[a$="b"]`: выбирает все элементы, в которых значение атрибута `a` завершается на `b`

- `[a*="b"]`: выбирает все элементы, в которых значение атрибута `a` содержит подстроку `b`

- `[a|="b"]`: выбирает все элементы, в которых значение атрибута `a` представляет ряд значений, разделенных дефисами, и первое из этих значений равно `b`

- `:root`: выбирает корневой элемент документа

- `:nth-child(n)`: выбирает `n`-ый вложенный элемент (отсчет идет с начала)

- `:nth-last-child(n)`: выбирает `n`-ый вложенный элемент (отсчет идет с конца)

- `:nth-of-type(n)`: выбирает `n`-ый сестринский элемент типа `type` (отсчет идет с начала)

- `:nth-last-of-type(n)`: выбирает `n`-ый сестринский элемент типа `type` (отсчет идет с конца)

- `:first-child`: выбирает первый вложенный элемент

- `:last-child`: выбирает последний вложенный элемент

- `:first-of-type`: выбирает первый сестринский элемент типа `type`

- `:last-of-type`: выбирает последний сестринский элемент типа `type`

- `:only-child`: выбирает все элементы, которые имеют только один вложенный элемент

- `:only-of-type`: выбирает все сестринские элементы типа `type`

- `:empty`: выбирает все элементы, которые не имеют вложенных элементов

- `:link`: выбирает все ссылки, которые еще не были нажаты

- `:visited`: выбирает все ссылки, которые уже были нажаты

- `:active`: выбирает все ссылки, которые в текущий момент активны (нажимаются)

- `:hover`: выбирает все ссылки, над которыми в текущий момент находится курсор

- `:focus`: выбирает все элементы, которые в текущий момент получили фокус

- `:target`: выбирает все элементы, к которым можно обратиться с помощью адресов url внутри страницы

- `:lang(en)`: выбирает все элементы, в которых атрибут `lang` имеет значение "en"

- `:enabled`: выбирает все элементы форм, которые доступны для взаимодействия

- `:disabled`: выбирает все элементы форм, которые НЕ доступны для взаимодействия

- `:checked`: выбирает все флажки (чекбоксы) и радиокнопки, которые отмечены

- `.class`: выбирает все элементы с классом `class`

- `#id`: выбирает все элементы с идентификтором `id`

- `:not(s)`: выбирает все элементы, которые не соответствуют селектору `s`

- `E F`: выбирает все элементы типа `F`, которые встречаются в элементах типа `E`

- `E > F`: выбирает все элементы типа `F`, которые являются вложенными в элементы типа `E`

- `E + F`: выбирает все элементы типа `F`, которые располагаются сразу после элементов типа `E`

- `E ~ F`: ввыбирает все элементы типа `F`, которые являются сестринскими по отношению к элементам типа `E`

#### Поиск во вложенных элементах
Подобным образом мы можем искать элементы не только во всем документе, но и в отдельных элементах на веб-странице. Например:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <div id="article">
        <h1 id="header">Home Page</h1>
        <p class="text">Page Text 1</p>
        <p class="text">Page Text 2</p>
    </div>
    <div id="footer">
        <p class="text">Footer Text</p>
    </div>
    <script>
    // получаем элемент с id="article"
    const article = document.getElementById("article");
    // в этом элементе получаем все элементы с class="text"
    const articleContent = article.getElementsByClassName("text");
    for(p of articleContent){
        console.log(p);
    }
    </script>
</body>
</html>
```

В данном случае мы сначала получаем элемент с `id="article"`, затем внутри этого элемента ищем все элементы с `class="text"`. В результате консоль выведет два элемента:
```
<p class="text">Page Text 1</p>
<p class="text">Page Text 2</p>
```

#### matches
Предыдущие методы искали по DOM.

Метод [*`elem`*`.matches(css)`](https://dom.spec.whatwg.org/#dom-element-matches) ничего не ищет, а проверяет, удовлетворяет ли *`elem`* CSS-селектору, и возвращает `true` или `false`.

Этот метод удобен, когда мы перебираем элементы (например, в массиве или в чём-то подобном) и пытаемся выбрать те из них, которые нас интересуют.

Например:
```html
<a href="http://example.com/file.zip">...</a>
<a href="http://ya.ru">...</a>

<script>
  // может быть любая коллекция вместо document.body.children
  for (let elem of document.body.children) {
    if (elem.matches('a[href$="zip"]')) {
      alert("Ссылка на архив: " + elem.href );
    }
  }
</script>
```

#### closest
<dfn title="предок">Предки</dfn> элемента – родитель, родитель родителя, его родитель и так далее. Вместе они образуют цепочку иерархии от элемента до вершины.

Метод *`elem`*`.closest(`*`css`*`)` ищет ближайшего предка, который соответствует CSS-селектору. Сам элемент также включается в поиск.

Другими словами, метод `closest` поднимается вверх от элемента и проверяет каждого из родителей. Если он соответствует селектору, поиск прекращается. Метод возвращает либо предка, либо `null`, если такой элемент не найден.

Например:
```html
<h1>Содержание</h1>

<div class="contents">
  <ul class="book">
    <li class="chapter">Глава 1</li>
    <li class="chapter">Глава 2</li>
  </ul>
</div>

<script>
  let chapter = document.querySelector('.chapter'); // LI

  alert(chapter.closest('.book')); // UL
  alert(chapter.closest('.contents')); // DIV

  alert(chapter.closest('h1')); // null (потому что h1 - не предок)
</script>
```

#### Замечания по поводу использования методов
Таким образом, существует множество методов поиска элементов по тегу, классу и так далее. Может возникнуть вопрос, какой из них лучше использовать. Стоит отметить, что из всех этих способов выбор по id обычно самый быстрый. При всех прочих условиях лучше выбирать метод `getElementById()`.

Также стоит отметить, что остальные методы `getElementsBy*` скорее исторические, так как `querySelector` более чем эффективен. Здесь они рассмотрены для полноты картины, также они могут встретиться в старом коде.

- `elem.getElementsByTagName(`*`tag`*`)` ищет элементы с данным тегом и возвращает их коллекцию. Передав "`*`" вместо тега, можно получить всех потомков.
- `elem.getElementsByClassName(`*`className`*`)` возвращает элементы, которые имеют данный CSS-класс.
- `document.getElementsByName(`*`name`*`)` возвращает элементы с заданным атрибутом name. Очень редко используется.

Например:
```js
// получить все элементы div в документе
let divs = document.getElementsByTagName('div');
```

Найдём все `input` в таблице:
```html
<table id="table">
  <tr>
    <td>Ваш возраст:</td>

    <td>
      <label>
        <input type="radio" name="age" value="young" checked> младше 18
      </label>
      <label>
        <input type="radio" name="age" value="mature"> от 18 до 50
      </label>
      <label>
        <input type="radio" name="age" value="senior"> старше 60
      </label>
    </td>
  </tr>
</table>

<script>
  let inputs = table.getElementsByTagName('input');

  for (let input of inputs) {
    alert( input.value + ': ' + input.checked );
  }
</script>
```

!!! warning "Не забываем про букву "s"!"

    Одна из самых частых ошибок начинающих разработчиков (впрочем, иногда и не только) – это забыть букву "s". То есть пробовать вызывать метод `getElementByTagName` вместо `getElementsByTagName`.

    Буква "s" отсутствует в названии метода `getElementById`, так как в данном случае возвращает один элемент. Но `getElementsByTagName` вернёт список элементов, поэтому "s" обязательна.

Ищем элементы с классом `.article`:
```html
<form name="my-form">
  <div class="article">Article</div>
  <div class="long article">Long article</div>
</form>

<script>
  // ищем по имени атрибута
  let form = document.getElementsByName('my-form')[0];

  // ищем по классу внутри form
  let articles = form.getElementsByClassName('article');
  alert(articles.length); // 2, находим два элемента с классом article
</script>
```

Ряд методов — `getElementsByTagName()`, `getElementsByClassName()`, `getElementsByName()`, `querySelectorAll()` — возвращает список элементов в виде объекта `NodeList`, который аналогичен массиву и который мы можем перебрать и получить каждый отдельный элемент из этого набора.

!!! warning "Возвращает коллекцию, а не элемент!"

    Другая распространённая ошибка – написать:

    ```js
    // не работает
    document.getElementsByTagName('input').value = 5;
    ```

    Попытка присвоить значение *коллекции*, а не элементам внутри неё, не сработает.

    Нужно перебрать коллекцию в цикле или получить элемент по номеру и уже ему присваивать значение, например, так:
    ```js
    // работает (если есть input)
    document.getElementsByTagName('input')[0].value = 5;
    ```

Также для оптимизации работы с DOM для того, чтобы избежать повторной выборки одних и тех же элементов, при первой выборке их лучше сохранять в константы/переменные.

Кроме того, следует иметь в виду, что метод `querySelectorAll()` возвращает статический список `NodeList`, тогда как остальные методы возвращают нестатический список. В чем разница? При изменении элементов нестатического списка все модификации сразу же применяются к веб-странице. При изменении элементов из статического списка такие модификации могут примениться не сразу.[^8.2]

#### Живые коллекции
Все методы "`getElementsBy*`" возвращают *живую* коллекцию. Такие коллекции всегда отражают текущее состояние документа и автоматически обновляются при его изменении.

В приведённом ниже примере есть два скрипта.

1. Первый создаёт ссылку на коллекцию `<div>`. На этот момент её длина равна `1`.
2. Второй скрипт запускается после того, как браузер встречает ещё один `<div>`, теперь её длина – `2`.

```html
<div>First div</div>

<script>
  let divs = document.getElementsByTagName('div');
  alert(divs.length); // 1
</script>

<div>Second div</div>

<script>
  alert(divs.length); // 2
</script>
```

Напротив, `querySelectorAll` возвращает *статическую* коллекцию. Это похоже на фиксированный массив элементов.

Если мы будем использовать его в примере выше, то оба скрипта вернут длину коллекции, равную `1`:
```html
<div>First div</div>

<script>
  let divs = document.querySelectorAll('div');
  alert(divs.length); // 1
</script>

<div>Second div</div>

<script>
  alert(divs.length); // 1
</script>
```

Теперь мы легко видим разницу. Длина статической коллекции не изменилась после появления нового `div` в документе.

#### Итого
Есть 6 основных методов поиска элементов в DOM:

| Метод                  | Ищет по...   | Ищет внутри элемента? | Возвращает живую коллекцию? |
| ---------------------- | ------------ | --------------------- | --------------------------- |
| `querySelector`          | CSS-selector | ✔                     | -                           |
| `querySelectorAll`       | CSS-selector | ✔                     | -                           |
| `getElementById`         | `id`           | -                     | -                           |
| `getElementsByName`      | `name`         | -                     | ✔                           |
| `getElementsByTagName`   | `tag` или '`*`'   | ✔                     | ✔                           |
| `getElementsByClassName` | `class`        | ✔                     | ✔                           |

Безусловно, наиболее часто используемыми в настоящее время являются методы `querySelector` и `querySelectorAll`, но и методы `getElement(s)By*` могут быть полезны в отдельных случаях, а также встречаются в старом коде.

Кроме того:

- Есть метод `elem.matches(css)`, который проверяет, удовлетворяет ли элемент CSS-селектору.
- Метод `elem.closest(css)` ищет ближайшего по иерархии предка, соответствующему данному CSS-селектору. Сам элемент также включён в поиск.

И, напоследок, давайте упомянем ещё один метод, который проверяет наличие отношений между предком и потомком:

- *`elemA`*`.contains(`*`elemB`*`)` вернёт `true`, если *`elemB`* находится внутри *`elemA`* (*`elemB`* потомок *`elemA`*) или когда `elemA==elemB`.

#### Задачи

##### Поиск элементов
Вот документ с таблицей и формой.

Как найти?…

1. Таблицу с `id="age-table"`.
2. Все элементы `label` внутри этой таблицы (их три).
3. Первый `td` в этой таблице (со словом «Age»).
4. Форму `form` с именем `name="search"`.
5. Первый `input` в этой форме.
6. Последний `input` в этой форме.

Откройте страницу [table.html](https://learn.javascript.ru/task/find-elements/table.html) в отдельном окне и используйте для этого браузерные инструменты разработчика.[^searching-elements-dom]

### Создание, добавление, замена и удаление элементов
JavaScript предоставляет ряд методов для управления элементами на веб-страницы. В частности, мы можем создавать и добавлять новые элементы или заменять и удалять уже имеющиеся. Рассмотрим эти методы.[^8.5]

#### Создание элементов
Для создания элементов объект `document` имеет следующие методы:

- **`createElement(elementName)`**: создает элемент html, тег которого передается в качестве параметра. Возвращает созданный элемент

- **`createTextNode(text)`**: создает и возвращает текстовый узел. В качестве параметра передается текст узла.

Создадим элемент с помощью **`createElement`**:
```js
const header = document.createElement("h1");        // создаем заголовок <h1>
console.log(header);  // <h1></h1>
```

Таким образом, переменная `header` будет хранить ссылку на элемент `h1`.

Создадим текстовый узел с помощью **`createTextNode`**:
```js
const  headerText = document.createTextNode("Hello World"); // создаем текстовый узел
console.log( headerText);  // "Hello World"
```

#### Добавление элементов
Однако одного создания элементов недостаточно, их еще надо добавить на веб-страницу.

Для добавления элементов мы можем использовать один из методов объекта Node:

- **`appendChild(newNode)`**: добавляет новый узел `newNode` в конец коллекции дочерних узлов

- **`insertBefore(newNode, referenceNode)`**: добавляет новый узел `newNode` перед узлом `referenceNode`

##### appendChild
Используем метод **`appendChild()`**:
```js
const header = document.createElement("h1");        // создаем заголовок <h1>
const  headerText = document.createTextNode("Hello World"); // создаем текстовый узел
header.appendChild( headerText); // добавляем в элемент h1 текстовый узел
console.log(header);  // <h1>Hello World</h1>
```

И чтобы добавить созданный элемент на страницу, его надо добавить в уже имеющийся на странице элемент:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <script>
    constheader = document.createElement("h1");     // создаем заголовок <h1>
    const headerText = document.createTextNode("Hello World");  // создаем текстовый узел
    header.appendChild(headerText); // добавляем в элемент h1 текстовый узел
    document.body.appendChild(header);  // // добавляем элемент h1 на страницу в элемент body
    </script>
</body>
</html>
```

Сначала создаем обычный элемент заголовка `h2` и текстовый узел. Затем текстовый узел добавляем в элемент заголовка. Затем заголовок добавляем в элемент **`body`**:

![Добавление элемента на веб-страницу в JavaScript](../img/appendChild.png)

Стоит отметить, что нам необязательно для определения текста внутри элемента создавать дополнительный текстовый узел, так как мы можем воспользоваться свойством **`textContent`** и напрямую ему присвоить текст:
```js
const header = document.createElement("h1");        // создаем заголовок <h1>
header.textContent = "Hello World"; // определяем текст элемента
```

В этом случае текстовый узел будет создан неявно при установке текста.

##### insertBefore
Метод `appendChild()` добавляет элемент в конец контейнера. Чтобы более конкретизировать место для добавления, можно использовать другой метод — **`insertBefore()`**, который добавляет один элемент перед другим элементом. Например, у нас есть следующая страница:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <p>Text 1</p>
    <p>Text 2</p>
</body>
</html>
```

Допустим, нам надо добавить в элемент `body` перед первым параграфом заголовок. Мы можем сделать это так:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <p>Text 1</p>
    <p>Text 2</p>
    <script>
    const header = document.createElement("h1");        // создаем заголовок <h1>
    header.textContent = "Page Header"; // определяем текст элемента
    // получаем первый параграф
    const firstP = document.body.firstElementChild;
    // добавляем элемент h1 перед параграфом firstP
    document.body.insertBefore(header, firstP);
    </script>
</body>
</html>
```

![Добавление элемента на веб-страницу в JavaScript с помощью метода insertBefore](../img/appendChild2.png)

Если нам надо вставить новый узел на второе, третье или любое другое место, то нам надо найти узел, перед которым надо вставлять, с помощью комбинаций свойств `firstElementChild`/`lastElementChild` и `nextSibling`/`previousSibling`.

#### Копирование элемента
Иногда элементы бывают довольно сложными по составу, и гораздо проще их скопировать, чем с помощью отдельных вызовов создавать из содержимое. Для копирования уже имеющихся узлов у объекта `N`ode можно использовать метод **`cloneNode()`**:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <div id="article">
        <h1>Home Page</h1>
        <p>Text 1</p>
        <p>Text 2</p>
    </div>
    <script>
    const article = document.getElementById("article");
    // получаем последний параграф
    const lastP = article.lastElementChild;
    // клонируем элемент lastP
    const newLastP = lastP.cloneNode(true);
    // изменяем текст
    newLastP.textContent = "Publication Date: 28/10/2023";
    // добавляем в конец элемента article
    article.appendChild(newLastP);
    </script>
</body>
</html>
```

В метод `cloneNode()` в качестве параметра передается логическое значение: если передается `true`, то элемент будет копироваться со всеми дочерними узлами; если передается `false` — то копируется без дочерних узлов. То есть в данном случае мы копируем узел со всем его содержимым и потом добавляем в конец элемента c `id="article"`.

![Клонирование элементов веб-страницы в JavaScript](../img/cloneNode.png)

#### Замена элемента
Для замены элемента применяется метод **`replaceChild(newNode, oldNode)`** объекта `Node`. Этот метод в качестве первого параметра принимает новый элемент, который заменяет старый элемент oldNode, передаваемый в качестве второго параметра.

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <div id="article">
        <p>Home Page</p>
        <p>Text 1</p>
        <p>Text 2</p>
    </div>
    <script>
    const article = document.getElementById("article");
    // находим узел, который будем заменять
    // пусть это будет первый элемент
    const oldNode = article.firstElementChild;
    // создаем новый элемент
    const newNode = document.createElement("h2");
    // определяем для него текст
    newNode.textContent = "Hello World";
    // заменяем старый узел новым
    article.replaceChild(newNode, oldNode);
    </script>
</body>
</html>
```

В данном случае заменяем первый элемент — первый параграф заголовком `h2`:

![Замена элемента веб-страницы в JavaScript](../img/replaceChild.png)

#### Удаление элемента
Для удаления элемента вызывается метод **`removeChild()`** объекта Node. Этот метод удаляет один из дочерних узлов:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <div id="article">
        <h1>Home Page</h1>
        <p>Text 1</p>
        <p>Text 2</p>
    </div>
    <script>
    const article = document.getElementById("article");
    // находим узел, который будем удалять - последний параграф
    const lastP = article.lastElementChild;
    // удаляем узел
    article.removeChild(lastP);
    </script>
</body>
</html>
```

В данном случае удаляется первый параграф из блока `div`

##### Удаление всех элементов
Иногда возникает необходимость удалить все элементы. Для этого перебираем все элементы контейнера и удаляем их:
```html
<div id="article">
    <h1>Home Page</h1>
    <p>Text 1</p>
    <p>Text 2</p>
</div>
<script>
const article = document.getElementById("article");
while(article.firstChild){
    article.removeChild(article.firstChild);
}
```

### Управление атрибутами элементов
Для управления атрибутами элементов JavaScript предоставляет ряд методов:

- **`getAttribute(attr)`**: возвращает значение атрибута `attr`

- **`createAttribute(attr)`**: создает атрибут `attr`

- **`setAttribute(attr, value)`**: устанавливает для атрибута `attr` значение `value`. Если атрибута нет, то он добавляется

- **`removeAttribute(attr)`**: удаляет атрибут `attr` и его значение[^8.9]

#### Получение атрибута
Для получения атрибута у элемента вызывается метод **`getAttribute()`**, в который передается имя атрибута. Например, пусть у нас на странице есть следующий элемент, который представляет ссылку:
```html
<a id="home" class="link" href="index.html">Home</a>
```

Получим атрибуты этого элемента:
```js
// получаем элемент
const element = document.getElementById("home");
// получаем атрибуты элемента
console.log(element.getAttribute("id"));    // home
console.log(element.getAttribute("class")); // link
console.log(element.getAttribute("href"));  // index.html
```

Стоит отметить, что атрибуты элементы также доступны через его свойства, которые называются аналогично атрибутам (за редким исключением):
```js
// получаем элемент
const element = document.getElementById("home");
// получаем атрибуты элемента
console.log(element.id);    // home
console.log(element.className); // link
console.log(element.href);  // file:///Users/user/Documents/app/index.html
```

Исключение касается в частности атрибута "class", который доступен через свойство **`className`**.

Также свойства могут возвращать немного отличающиеся значения. Например, свойство `href` возвращает полную ссылку, а метод `getAttribute("href")` — непосредственное значение атрибута.

То же самое касается и атрибута **`style`**:
```html
<a id="home" style="color:red;" href="index.html">Home</a>
<script>
// получаем элемент
const element = document.getElementById("home");
// получаем атрибуты элемента
console.log(element.style);    // CSSStyleDeclaration
console.log(element.getAttribute("style")); // color:red;
</script>
```

Метод `getAttribute("style")` возвращает стиль в виде текста, а свойство `style` — объект `CSSStyleDeclaration`, с помощью свойств которого можно получить отдельные аспекты стиля.

#### Установка атрибутов
Для установки значения атрибутов применяется метод **`setAttribute(attr, value)`**, первый параметр которого — устанавливаемый атрибут, а второй — его значение:
```html
<a id="home" href="index.html">Home</a>
<script>
// получаем элемент
const element = document.getElementById("home");
// устанавливаем атрибут href
element.setAttribute("href", "https://example.com");
// устанавливаем атрибут style
element.setAttribute("style", "color:navy;");
</script>
```

Здесь изменяем атрибут "href" и устанавливаем атрибут "style". Поскольку атрибут "style" изначально отсутствует, то он будет добавлен. Но стоит отметить, что в реальности это приведет к тому, что будет создан узел `Node`, который представляет атрибут. У этого узла будет установлено соответствующее значение, и затем узел атрибута добавляется в коллекцию дочерних узлов элемента. То есть фактически это будет выглядеть следующим образом:
```html
<a id="home" href="https://example.com">Home</a>
<script>
// получаем элемент
const element = document.getElementById("home");
// создаем узел-атрибут style
const attribute = document.createAttribute("style");
// устанавливаем значение узла-атрибута
attribute.value = "color:navy;";
// устанавливаем узел атрибута
element.setAttributeNode(attribute);
</script>
```

#### Удаление атрибута
Для удаления атрибута применяется метод **`removeAttribute()`**, в который передается удаляемый атрибут:
```html
<a id="home" href="https://metanit.com" style="color:navy;">Home</a>
<script>
// получаем элемент
const element = document.getElementById("home");
// удаляем атрибут style
element.removeAttribute("style");
</script>
```

### Управление стилем и классами элементов
Для работы со стилевыми свойствами элементов в JavaScript применяются, главным образом, два подхода:

- изменение свойства **`style`**;

- изменение значения атрибута **`class`**.[^8.7]

#### Свойство style
Свойство **`style`** представляет сложный объект **`CSSStyleDeclaration`** и напрямую сопоставляется с атрибутом `style` html-элемента. Этот объект содержит набор свойств CSS, к которым можно обратиться следующим образом:
```js
element.style.свойствоCSS
```

Например, установим цвет шрифта заголовка:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <h1 id="header">Home Page</h1>
    <script>
    const header = document.getElementById("header");
    // получаем значение свойства color
    console.log(header.style.color);    // пустая строка
    // изменяем значение свойства color
    header.style.color = "navy";
    // повторно получаем значение свойства color
    console.log(header.style.color);    // navy
    </script>
</body>
</html>
```

Здесь для заголовка в качестве цвета устанавливаем синий цвет `navy`. В данном случае название свойства `color` совпадает со свойством css. Аналогично мы могли бы установить цвет с помощью css:
```css
#header{
    color:navy;
}
```

Однако ряд свойств css в названиях имеют дефис, например, `font-family`. В JavaScript для этих свойств дефис не употребляется. Только первая буква, которая идет после дефиса, переводится в верхний регистр:
```js
const header = document.getElementById("header");
header.style.fontFamily = "Verdana";
```

#### Свойство className
С помощью свойства **`className`** можно получить или установить значение атрибута `class` элемента html. Например:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
    <style>
        .header-color {color:navy;}
        .header-font {font-family: Verdana;}
    </style>
</head>
<body>
    <h1 id="header" class="header-font">Home Page</h1>
    <script>
    const header = document.getElementById("header");
    // получаем текущий класс
    console.log(header.className);  // header-font
    // устанавливаем класс элемента
    header.className = "header-color";
    // получаем текущий класс
    console.log(header.className);  // header-color
    </script>
</body>
</html>
```

Здесь получаем текущий класс заголовка и затем изменяем его на новый класс — "header-color". Благодаря использованию классов не придется настраивать каждое отдельное свойство css с помощью свойства `style`.

Но при этом надо учитывать, что прежнее значение атрибута `class` удаляется. Поэтому, если нам надо добавить класс, надо объединить его название со старым классом:
```js
header.className = header.className + " header-color";
```

И если надо вовсе удалить все классы, то можно присвоить свойству пустую строку:
```js
header.className = "";
```

#### Свойство classList
Выше было рассмотрено, как добавлять классы к элементу, однако для управления множеством классов гораздо удобнее использовать свойство **`classList`**. Это свойство представляет объект, реализующий следующие методы:

- **`add(className)`**: добавляет класс `className`

- **`remove(className)`**: удаляет класс `className`

- **`toggle(className)`**: переключает у элемента класс на `className`. Если класса нет, то он добавляется, если есть, то удаляется

Например:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
    <style>
        .header-color {color:navy;}
        .header-font {font-family: Verdana;}
        .header-size {font-size: 22px;}
    </style>
</head>
<body>
    <h1 id="header" class="header-size">Home Page</h1>
    <script>
    const header = document.getElementById("header");
    header.classList.remove("header-size");     //  удаляем класс header-size
    header.classList.add("header-font");        // добавляем класс header-font
    header.classList.toggle("header-color");    // переключаем класс header-color
    </script>
</body>
</html>
```

Стоит отметить, что метод `toggle()` дополнительно может принимать условие в качестве второго параметра — если это условие верно (возвращает `true`), то класс переключается:
```js
const i = 5;
const condition = i > 0; // условие
const header = document.getElementById("header");
header.classList.toggle("header-color", condition);    // переключаем класс header-color по условию
```

При необходимости мы можем перебрать все классы из списка `classList` или получить отдельные классы по индексу:
```js
// перебор списка классов
for(headerClass of header.classList){
    console.log(headerClass);
}
console.log(header.classList[0]);   // первый установленный класс
```

### Практическая работа. Реализация поведения "подсказка"

#### Задание
Напишите JS-код, реализующий поведение «подсказка».

При наведении мыши на элемент с атрибутом `data-tooltip`, над ним должна показываться подсказка и скрываться при переходе на другой элемент.

Пример HTML с подсказками:
```html
<button data-tooltip="эта подсказка длиннее, чем элемент">Короткая кнопка</button>
<button data-tooltip="HTML<br>подсказка">Ещё кнопка</button>
```

Иллюстрация результата:

![Tooltip](../img/tooltip_01.png)

Детали оформления:

1. Отступ от подсказки до элемента с `data-tooltip` должен быть 5px по высоте.
2. Подсказка должна быть, по возможности, посередине элемента.
3. Подсказка не должна вылезать за границы экрана, в том числе если страница частично прокручена, если нельзя показать сверху – показывать снизу элемента.
4. Текст подсказки брать из значения атрибута `data-tooltip`. Это может быть произвольный HTML.
5. В один момент может быть показана только одна подсказка.

Иллюстрация поведения:

![Tooltip](../img/tooltip_02.png)

![Tooltip](../img/tooltip_03.png)

![Tooltip](../img/tooltip_04.png)

![Tooltip](../img/tooltip_05.png)

Для решения понадобятся два события:

- `mouseover` срабатывает, когда указатель мыши заходит на элемент.
- `mouseout` срабатывает, когда указатель мыши уходит с элемента.

Применить делегирование событий: установить оба обработчика на элемент `document`, чтобы отслеживать «заход» и «уход» курсора на элементы с атрибутом `data-tooltip` и управлять подсказками с их же помощью.

Допустимо считать, что во всех элементах с атрибутом `data-tooltip` должен использоваться только текст, без вложенных тегов.

После реализации такого поведения люди, даже не знакомые с JavaScript должны иметь возможность добавлять подсказки к элементам.

### Источники информации
[^8.1]: [Введение в DOM](https://metanit.com/web/javascript/8.1.php)
[^8.3]: [Свойства объекта document](https://metanit.com/web/javascript/8.3.php)
[^8.2]: [Поиск элементов на веб-странице](https://metanit.com/web/javascript/8.2.php)
[^8.4]: [Объект Node. Навигация по DOM](https://metanit.com/web/javascript/8.4.php)
[^8.6]: [Элементы](https://metanit.com/web/javascript/8.6.php)
[^8.5]: [Создание, добавление, замена и удаление элементов](https://metanit.com/web/javascript/8.5.php)
[^8.9]: [Управление атрибутами элементов](https://metanit.com/web/javascript/8.9.php)
[^8.7]: [Изменение стиля элементов](https://metanit.com/web/javascript/8.7.php)
[^browser-environment]: [Браузерное окружение, спецификации](https://learn.javascript.ru/browser-environment)
[^dom-nodes]: [DOM-дерево](https://learn.javascript.ru/dom-nodes)
[Навигация по DOM-элементам](https://learn.javascript.ru/dom-navigation)
[^searching-elements-dom]: [Поиск: getElement*, querySelector*](https://learn.javascript.ru/searching-elements-dom)
[^basic-dom-node-properties]: [Свойства узлов: тип, тег и содержимое](https://learn.javascript.ru/basic-dom-node-properties)
