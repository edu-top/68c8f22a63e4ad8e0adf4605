## Объектная модель документа

- [Объектная модель документа](#объектная-модель-документа)
  - [Введение в DOM](#введение-в-dom)
    - [Браузерное окружение](#браузерное-окружение)
    - [DOM (Document Object Model)](#dom-document-object-model)
    - [BOM (Browser Object Model)](#bom-browser-object-model)
    - [Стандарты и спецификации](#стандарты-и-спецификации)
  - [DOM-дерево](#dom-дерево)
    - [Пример DOM](#пример-dom)
    - [Автоисправление](#автоисправление)
    - [Виды узлов DOM](#виды-узлов-dom)
    - [Редкие типы узлов XML DOM](#редкие-типы-узлов-xml-dom)
    - [XSLT-стили](#xslt-стили)
    - [Просмотр структуры DOM](#просмотр-структуры-dom)
    - [Взаимодействие с консолью](#взаимодействие-с-консолью)
    - [Итого](#итого)
  - [Узлы. Навигация по объектам DOM](#узлы-навигация-по-объектам-dom)
    - [Объект Node](#объект-node)
      - [Классы DOM-узлов](#классы-dom-узлов)
      - [Свойства узлов](#свойства-узлов)
      - [Свойство «nodeType»](#свойство-nodetype)
      - [Тег: nodeName и tagName](#тег-nodename-и-tagname)
    - [Свойства объекта document](#свойства-объекта-document)
    - [Навигационные свойства](#навигационные-свойства)
      - [Сверху: documentElement и body](#сверху-documentelement-и-body)
      - [Получение родительского элемента](#получение-родительского-элемента)
      - [Получение элементов одного уровня](#получение-элементов-одного-уровня)
      - [Получение потомков](#получение-потомков)
      - [DOM-коллекции](#dom-коллекции)
      - [Получение текстового содержимого](#получение-текстового-содержимого)
      - [Навигация только по элементам](#навигация-только-по-элементам)
    - [Специфичные навигационные свойства](#специфичные-навигационные-свойства)
    - [Итого](#итого-1)
    - [Задачи](#задачи)
      - [Дочерние элементы в DOM](#дочерние-элементы-в-dom)
      - [Вопрос о соседях](#вопрос-о-соседях)
      - [Выделите ячейки по диагонали](#выделите-ячейки-по-диагонали)
  - [Элементы](#элементы)
    - [Свойства элементов](#свойства-элементов)
    - [Управление текстом элемента](#управление-текстом-элемента)
      - [Свойство textContent](#свойство-textcontent)
      - [Свойство innerText](#свойство-innertext)
    - [Управление кодом HTML](#управление-кодом-html)
      - [innerHTML: содержимое элемента](#innerhtml-содержимое-элемента)
      - [innerHTML+= осуществляет перезапись](#innerhtml-осуществляет-перезапись)
      - [outerHTML: HTML элемента целиком](#outerhtml-html-элемента-целиком)
    - [Свойство «hidden»](#свойство-hidden)
    - [Другие свойства](#другие-свойства)
    - [Итого](#итого-2)
    - [Задачи](#задачи-1)
      - [Считаем потомков](#считаем-потомков)
      - [Что содержит свойство nodeType?](#что-содержит-свойство-nodetype)
      - [Тег в комментарии](#тег-в-комментарии)
      - [Где в DOM-иерархии "document"?](#где-в-dom-иерархии-document)
  - [Поиск элементов на веб-странице](#поиск-элементов-на-веб-странице)
    - [Получение элементов по id](#получение-элементов-по-id)
    - [Поиск по определенному тегу](#поиск-по-определенному-тегу)
    - [Получение элементов по классу](#получение-элементов-по-классу)
    - [Поиск элементов по атрибуту name](#поиск-элементов-по-атрибуту-name)
    - [Поиск элементов по селектору CSS](#поиск-элементов-по-селектору-css)
      - [querySelectorAll](#queryselectorall)
      - [querySelector](#queryselector)
      - [Селекторы CSS](#селекторы-css)
    - [Поиск во вложенных элементах](#поиск-во-вложенных-элементах)
    - [Поиск соответствия: `matches`](#поиск-соответствия-matches)
    - [Ближайший предок: `closest`](#ближайший-предок-closest)
    - [Замечания по поводу использования методов](#замечания-по-поводу-использования-методов)
    - [Живые коллекции и статические списки](#живые-коллекции-и-статические-списки)
      - [Живые коллекции](#живые-коллекции)
      - [Статические коллекции](#статические-коллекции)
    - [Итого](#итого-3)
    - [Задачи](#задачи-2)
      - [Поиск элементов](#поиск-элементов)
  - [Изменение документа](#изменение-документа)
    - [Создание элементов](#создание-элементов)
    - [Добавление элементов](#добавление-элементов)
      - [Методы вставки](#методы-вставки)
      - [insertAdjacentHTML/Text/Element](#insertadjacenthtmltextelement)
      - [Устаревшие методы вставки](#устаревшие-методы-вставки)
        - [appendChild](#appendchild)
        - [insertBefore](#insertbefore)
    - [Копирование узлов](#копирование-узлов)
      - [Клонирование элементов](#клонирование-элементов)
      - [DocumentFragment](#documentfragment)
    - [Замена узлов](#замена-узлов)
      - [Замена через родителя](#замена-через-родителя)
      - [Замена текущего узла](#замена-текущего-узла)
    - [Удаление узлов](#удаление-узлов)
      - [Удаление элемента](#удаление-элемента)
      - [Удаление всех элементов](#удаление-всех-элементов)
    - [Старая школа](#старая-школа)
    - [Несколько слов о «document.write»](#несколько-слов-о-documentwrite)
    - [Итого](#итого-4)
    - [Задачи](#задачи-3)
      - [createTextNode vs innerHTML vs textContent](#createtextnode-vs-innerhtml-vs-textcontent)
      - [Очистите элемент](#очистите-элемент)
      - [Почему остаётся "aaa"?](#почему-остаётся-aaa)
      - [Создайте список](#создайте-список)
      - [Создайте дерево из объекта](#создайте-дерево-из-объекта)
      - [Выведите список потомков в дереве](#выведите-список-потомков-в-дереве)
      - [Создайте календарь в виде таблицы](#создайте-календарь-в-виде-таблицы)
      - [Цветные часы с использованием setInterval](#цветные-часы-с-использованием-setinterval)
      - [Вставьте HTML в список](#вставьте-html-в-список)
      - [Сортировка таблицы](#сортировка-таблицы)
  - [Атрибуты элементов и свойства DOM-объектов](#атрибуты-элементов-и-свойства-dom-объектов)
    - [DOM-свойства](#dom-свойства)
    - [HTML-атрибуты](#html-атрибуты)
    - [Управление атрибутами элементов](#управление-атрибутами-элементов)
      - [Получение атрибута](#получение-атрибута)
      - [Установка атрибутов](#установка-атрибутов)
      - [Удаление атрибута](#удаление-атрибута)
    - [Синхронизация между атрибутами и свойствами](#синхронизация-между-атрибутами-и-свойствами)
    - [DOM-свойства типизированы](#dom-свойства-типизированы)
    - [Нестандартные атрибуты, dataset](#нестандартные-атрибуты-dataset)
    - [Итого](#итого-5)
    - [Задачи](#задачи-4)
      - [Получите атрибут](#получите-атрибут)
      - [Сделайте внешние ссылки оранжевыми](#сделайте-внешние-ссылки-оранжевыми)
  - [Управление стилем и классами элементов](#управление-стилем-и-классами-элементов)
    - [Свойство className](#свойство-classname)
    - [Свойство classList](#свойство-classlist)
    - [Свойство style](#свойство-style)
    - [Сброс стилей](#сброс-стилей)
    - [Следите за единицами измерения](#следите-за-единицами-измерения)
    - [Вычисленные стили: getComputedStyle](#вычисленные-стили-getcomputedstyle)
    - [Итого](#итого-6)
    - [Задачи](#задачи-5)
      - [Создать уведомление](#создать-уведомление)
  - [Размеры и прокрутка элементов](#размеры-и-прокрутка-элементов)
    - [Простой пример](#простой-пример)
    - [Метрики](#метрики)
    - [offsetParent, offsetLeft/Top](#offsetparent-offsetlefttop)
    - [offsetWidth/Height](#offsetwidthheight)
    - [clientTop/Left](#clienttopleft)
    - [clientWidth/Height](#clientwidthheight)
    - [scrollWidth/Height](#scrollwidthheight)
    - [scrollLeft/scrollTop](#scrollleftscrolltop)
    - [Не стоит брать width/height из CSS](#не-стоит-брать-widthheight-из-css)
    - [Итого](#итого-7)
    - [Задачи](#задачи-6)
      - [Найти размер прокрутки снизу](#найти-размер-прокрутки-снизу)
      - [Узнать ширину полосы прокрутки](#узнать-ширину-полосы-прокрутки)
      - [Поместите мяч в центр поля](#поместите-мяч-в-центр-поля)
      - [В чём отличие CSS-свойств width и clientWidth](#в-чём-отличие-css-свойств-width-и-clientwidth)
  - [Размеры и прокрутка окна](#размеры-и-прокрутка-окна)
    - [Ширина/высота окна](#ширинавысота-окна)
    - [Ширина/высота документа](#ширинавысота-документа)
    - [Получение текущей прокрутки](#получение-текущей-прокрутки)
    - [Прокрутка: scrollTo, scrollBy, scrollIntoView](#прокрутка-scrollto-scrollby-scrollintoview)
    - [scrollIntoView](#scrollintoview)
    - [Запретить прокрутку](#запретить-прокрутку)
    - [Итого](#итого-8)
  - [Координаты](#координаты)
    - [Координаты относительно окна: getBoundingClientRect](#координаты-относительно-окна-getboundingclientrect)
    - [elementFromPoint(x, y)](#elementfrompointx-y)
    - [Применение для fixed позиционирования](#применение-для-fixed-позиционирования)
    - [Координаты относительно документа](#координаты-относительно-документа)
    - [Итого](#итого-9)
    - [Задачи](#задачи-7)
      - [Найдите координаты точек относительно окна браузера](#найдите-координаты-точек-относительно-окна-браузера)
      - [Покажите заметку рядом с элементом](#покажите-заметку-рядом-с-элементом)
      - [Покажите заметку около элемента (абсолютное позиционирование)](#покажите-заметку-около-элемента-абсолютное-позиционирование)
      - [Расположите заметку внутри элемента (абсолютное позиционирование)](#расположите-заметку-внутри-элемента-абсолютное-позиционирование)
  - [Практическая работа. Навигация по DOM-узлам](#практическая-работа-навигация-по-dom-узлам)
    - [Задание](#задание)
  - [Практическая работа. Работа с DOM-элементами](#практическая-работа-работа-с-dom-элементами)
    - [Задание](#задание-1)
  - [Практическая работа. Поиск элементов на веб-странице](#практическая-работа-поиск-элементов-на-веб-странице)
  - [Практическая работа. Модификация веб-страницы](#практическая-работа-модификация-веб-страницы)
    - [Задание](#задание-2)
  - [Практическая работа. Управление атрибутами элементов](#практическая-работа-управление-атрибутами-элементов)
    - [Задание](#задание-3)
  - [Практическая работа. Создание уведомления](#практическая-работа-создание-уведомления)
    - [Задание](#задание-4)
  - [Практическая работа. Реализация поведения "подсказка"](#практическая-работа-реализация-поведения-подсказка)
    - [Задание](#задание-5)
  - [Источники информации](#источники-информации)

### Введение в DOM
*[DOM]: Document Object Model
*[BOM]: Browser Object Model
*[DTD]: Document Type Definition
*[PI]: Processing Instruction
*[CDATA]: Character Data

#### Браузерное окружение
Язык JavaScript изначально был создан для веб-браузеров. Но с тех пор он значительно эволюционировал и превратился в кроссплатформенный язык программирования для решения широкого круга задач.

Сегодня JavaScript может использоваться в браузере, на веб-сервере или в какой-то другой среде, даже в кофеварке. Каждая среда предоставляет свою функциональность, которую спецификация JavaScript называет <dfn title="окружение">окружением</dfn>.

Окружение предоставляет свои объекты и дополнительные функции, в дополнение базовым языковым. Браузеры, например, дают средства для управления веб-страницами. Node.js делает доступными какие-то серверные возможности и так далее.

На картинке ниже в общих чертах показано, что доступно для JavaScript в браузерном окружении:

![Window object](../svg/windowObjects.svg)

Как мы видим, имеется корневой объект `window`, который выступает в 2 ролях:

1. Во-первых, это глобальный объект для JavaScript-кода, об этом более подробно говорится в главе **Глобальный объект**.
2. Во-вторых, он также представляет собой окно браузера и располагает методами для управления им.

Например, здесь мы используем `window` как глобальный объект:
```js
function sayHi() {
  alert("Hello");
}

// глобальные функции доступны как методы глобального объекта:
window.sayHi();
```

А здесь мы используем `window` как объект окна браузера, чтобы узнать его высоту:
```js
alert(window.innerHeight); // внутренняя высота окна браузера
```

Существует гораздо больше свойств и методов для управления окном браузера. Мы рассмотрим их позднее.[^browser-environment]

#### DOM (Document Object Model)
Хотя веб-браузером и вообще вебом область действия JavaScript не ограничивается, однако по прежнему одной из ключевых задач JavaScript является взаимодействие с пользователем и манипуляция элементами веб-страницы в браузере. Для JavaScript веб-страница доступна в виде **объектной модели документа** (document object model) или сокращенно **DOM**. <dfn title="DOM">DOM</dfn> описывает структуру веб-станицы в виде древовидного представления и предоставляет разработчику способ получить доступ к отдельным элементам веб-страницы.

<dfn title="Document Object Model">Document Object Model</dfn>, сокращённо DOM – объектная модель документа, которая представляет все содержимое страницы в виде объектов, которые можно менять.

Объект `document` – основная «входная точка». С его помощью мы можем что-то создавать или менять на странице.

Например:
```js
// заменим цвет фона на красный
document.body.style.background = "red";

// а через секунду вернём как было
setTimeout(() => document.body.style.background = "", 1000);
```

Мы использовали в примере только `document.body.style`, но на самом деле возможности по управлению страницей намного шире. Различные свойства и методы описаны в спецификации:

- **DOM Living Standard** на https://dom.spec.whatwg.org

!!! info "DOM – не только для браузеров"

    Спецификация DOM описывает структуру документа и предоставляет объекты для манипуляций со страницей. Существуют и другие, отличные от браузеров, инструменты, использующие DOM.

    Например, серверные скрипты, которые загружают и обрабатывают HTML-страницы, также могут использовать DOM. При этом они могут поддерживать спецификацию не полностью.

!!! info "CSSOM для стилей"

    Правила стилей CSS структурированы иначе чем HTML. Для них есть отдельная спецификация [CSSOM](https://www.w3.org/TR/cssom-1/), которая объясняет, как стили должны представляться в виде объектов, как их читать и писать.

    CSSOM используется вместе с DOM при изменении стилей документа. В реальности CSSOM требуется редко, обычно правила CSS статичны. Мы редко добавляем/удаляем стили из JavaScript, но и это возможно.

#### BOM (Browser Object Model)
Важно не путать понятия **BOM** (Browser Object Model — объектная модель браузера) и **DOM** (объектная модель документа). Если BOM предоставляет доступ к браузеру и его свойствам в целом, то DOM предоставляет доступ к отдельной веб-странице или html-документу и его элементам.

<dfn title="объектная модель браузера">Объектная модель браузера</dfn> (Browser Object Model, BOM) – это дополнительные объекты, предоставляемые браузером (окружением), чтобы работать со всем, кроме документа.

Например:

- Объект [navigator](https://developer.mozilla.org/ru/docs/Web/API/Window/navigator) даёт информацию о самом браузере и операционной системе. Среди множества его свойств самыми известными являются: `navigator.userAgent` – информация о текущем браузере, и `navigator.platform` – информация о платформе (может помочь в понимании того, в какой ОС открыт браузер – Windows/Linux/Mac и так далее).
- Объект [location](https://developer.mozilla.org/ru/docs/Web/API/Window/location) позволяет получить текущий URL и перенаправить браузер по новому адресу.

Вот как мы можем использовать объект `location`:
```js
alert(location.href); // показывает текущий URL
if (confirm("Перейти на Wikipedia?")) {
  location.href = "https://wikipedia.org"; // перенаправляет браузер на другой URL
}
```

Функции `alert`/`confirm`/`prompt` тоже являются частью BOM: они не относятся непосредственно к странице, но представляют собой методы объекта окна браузера для коммуникации с пользователем.

BOM является частью общей [спецификации HTML](https://html.spec.whatwg.org/).  Спецификация HTML по адресу https://html.spec.whatwg.org не только про «язык HTML» (теги, атрибуты), она также покрывает целое множество объектов, методов и специфичных для каждого браузера расширений DOM. Это всё «HTML в широком смысле». Для некоторых вещей есть отдельные спецификации, перечисленные на https://spec.whatwg.org.

#### Стандарты и спецификации
Говоря о стандартах, у нас есть:

- **Спецификация DOM**

    описывает структуру документа, манипуляции с контентом и события, подробнее на https://dom.spec.whatwg.org.

- **Спецификация CSSOM**

    Описывает файлы стилей, правила написания стилей и манипуляций с ними, а также то, как это всё связано со страницей, подробнее на https://www.w3.org/TR/cssom-1/.

- **Спецификация HTML**

    Описывает язык HTML (например, теги) и BOM (объектную модель браузера) – разные функции браузера: `setTimeout`, `alert`, `location` и так далее, подробнее на https://html.spec.whatwg.org. Тут берётся за основу спецификация DOM и расширяется дополнительными свойствами и методами.

Кроме того, некоторые классы описаны отдельно на https://spec.whatwg.org/.

По этим ссылкам содержится очень много информации, которую невозможно изучить полностью и держать в уме.

Когда нужно будет прочитать о каком-то свойстве или методе, справочник на сайте Mozilla https://developer.mozilla.org/ru/ тоже очень хороший ресурс, хотя ничто не сравнится с чтением спецификации: она сложная и объёмная, но сделает знания максимально полными.

Для поиска чего-либо обычно удобно использовать интернет-поиск со словами «WHATWG [термин]» или «MDN [термин]», например https://google.com?q=whatwg+localstorage, https://google.com?q=mdn+localstorage.

А теперь давайте перейдём к изучению DOM, так как страница – это основа всего.[^browser-environment]

### DOM-дерево
Основой HTML-документа являются теги.

В соответствии с объектной моделью документа («Document Object Model», коротко DOM), каждый HTML-тег является объектом. Вложенные теги являются «детьми» родительского элемента. Текст, который находится внутри тега, также является объектом.

Все эти объекты доступны при помощи JavaScript, мы можем использовать их для изменения страницы.

Например, `document.body` – объект для тега `<body>`.

Если запустить этот код, то `<body>` станет красным на 3 секунды:
```js
document.body.style.background = 'red'; // сделать фон красным

setTimeout(() => document.body.style.background = '', 3000); // вернуть назад
```

Это был лишь небольшой пример того, что может DOM. Скоро мы изучим много способов работать с DOM, но сначала нужно познакомиться с его структурой.

#### Пример DOM
Начнём с такого, простого, документа:
```html
<!DOCTYPE HTML>
<html>
<head>
  <title>О лосях</title>
</head>
<body>
  Правда о лосях.
</body>
</html>
```

DOM – это представление HTML-документа в виде дерева тегов. Вот как оно выглядит:

![DOM tree](../img/dom-tree_1.png)

Каждый узел этого дерева – это объект.

Теги являются *узлами-элементами* (или просто элементами). Они образуют структуру дерева: `<html>` – это корневой узел, `<head>` и `<body>` его дочерние узлы и т.д.

Текст внутри элементов образует *текстовые узлы*, обозначенные как `#text`. Текстовый узел содержит в себе только строку текста. У него не может быть потомков, т.е. он находится всегда на самом нижнем уровне.

Например, в теге `<title>` есть текстовый узел `"О лосях"`.

Обратите внимание на специальные символы в текстовых узлах:

- перевод строки: `↵` (в JavaScript он обозначается как `\n`)
- пробел: `␣`

Пробелы и переводы строки – это полноправные символы, как буквы и цифры. Они образуют текстовые узлы и становятся частью дерева DOM. Так, в примере выше в теге `<head>` есть несколько пробелов перед `<title>`, которые образуют текстовый узел `#text` (он содержит в себе только перенос строки и несколько пробелов).

Существует всего два исключения из этого правила:

1. По историческим причинам пробелы и перевод строки перед тегом `<head>` игнорируются
2. Если мы записываем что-либо после закрывающего тега `</body>`, браузер автоматически перемещает эту запись в конец `body`, поскольку спецификация HTML требует, чтобы всё содержимое было внутри `<body>`. Поэтому после закрывающего тега `</body>` не может быть никаких пробелов.

В остальных случаях всё просто – если в документе есть пробелы (или любые другие символы), они становятся текстовыми узлами дерева DOM, и если мы их удалим, то в DOM их тоже не будет.

Здесь пробельных текстовых узлов нет:
```html
<!DOCTYPE HTML>
<html><head><title>О лосях</title></head><body>Правда о лосях.</body></html>
```

![DOM tree](../img/dom-tree_2.png)

!!! info "Пробелы по краям строк и пробельные текстовые узлы скрыты в инструментах разработки"

    Когда мы работаем с деревом DOM, используя инструменты разработчика в браузере (которые мы рассмотрим позже), пробелы в начале/конце текста и пустые текстовые узлы (переносы строк) между тегами обычно не отображаются.

    Таким образом инструменты разработки экономят место на экране.

    В дальнейших иллюстрациях DOM мы также будем для краткости пропускать пробельные текстовые узлы там, где они не имеют значения. Обычно они не влияют на то, как отображается документ.

Например, рассмотрим простейшую страницу:
```html
<!DOCTYPE html>
<html>
<head>
    <title>Page Title</title>
</head>
<body>
    <h2>Page Header</h2>
    <div>
        <h3>Block Header</h3>
        <p>Text</p>
    </div>
</body>
</html>
```

Дерево DOM для этой страницы будет выглядеть следующим образом:

![DOM-tree in JavaScript](../img/domtree.png)

Таким образом, все компоненты упорядочены в DOM иерархическим образом, где каждый компонент представляет отдельный узел. То есть каждый элемент, например, элемент `div`, представляет собой узел. Но также и текст внутри элемента представляет отдельный узел.

#### Автоисправление
Если браузер сталкивается с некорректно написанным HTML-кодом, он автоматически корректирует его при построении DOM.

Например, в начале документа всегда должен быть тег `<html>`. Даже если его нет в документе – он будет в дереве DOM, браузер его создаст. То же самое касается и тега `<body>`.

Например, если HTML-файл состоит из единственного слова "Привет", браузер обернёт его в теги `<html>` и `<body>`, добавит необходимый тег `<head>`, и DOM будет выглядеть так:

![DOM tree](../img/dom-tree_3.png)

При генерации DOM браузер самостоятельно обрабатывает ошибки в документе, закрывает теги и так далее.

Есть такой документ с незакрытыми тегами:
```html
<p>Привет
<li>Мама
<li>и
<li>Папа
```

…Но DOM будет нормальным, потому что браузер сам закроет теги и восстановит отсутствующие детали:

![DOM tree](../img/dom-tree_4.png)

!!! warning "Таблицы всегда содержат `<tbody>`"

    Важный «особый случай» – работа с таблицами. По стандарту DOM у них должен быть `<tbody>`, но в HTML их можно написать (официально) без него. В этом случае браузер добавляет `<tbody>` в DOM самостоятельно.

    Для такого HTML:
    ```html
    <table id="table"><tr><td>1</td></tr></table>
    ```

    DOM-структура будет такой:

    ![DOM tree](../img/dom-tree_5.png)

    Видите? Из пустоты появился `<tbody>`, как будто документ и был таким. Важно знать об этом, иначе при работе с таблицами возможны сюрпризы.

#### Виды узлов DOM
Есть и некоторые другие типы узлов, кроме элементов и текстовых узлов.

Например, узел-комментарий:
```html
<!DOCTYPE HTML>
<html>
<body>
  Правда о лосях.
  <ol>
    <li>Лось -- животное хитрое</li>
    <!-- комментарий -->
    <li>...и коварное!</li>
  </ol>
</body>
</html>
```

![DOM tree](../img/dom-tree_6.png)

Здесь мы видим узел нового типа – *комментарий*, обозначенный как `#comment`, между двумя текстовыми узлами.

Казалось бы – зачем комментарий в DOM? Он никак не влияет на визуальное отображение. Но есть важное правило: если что-то есть в HTML, то оно должно быть в DOM-дереве.

**Все, что есть в HTML, даже комментарии, является частью DOM.**

Даже директива `<!DOCTYPE...>`, которую мы ставим в начале HTML, тоже является DOM-узлом. Она находится в дереве DOM прямо перед `<html>`. Мы не будем рассматривать этот узел, мы даже не рисуем его на наших диаграммах, но он существует.

Даже объект document, представляющий весь документ, формально является DOM-узлом.

Существует [12 типов узлов](https://dom.spec.whatwg.org/#node).

- **`Document`**: корневой узел html-документа, представляет весь документ в целом  (`nodeType = 9`).

- **`Element`**:  HTML-элемент (`<div>`, `<p>`), основной рабочий узел (`nodeType = 1`).

- **`Text`**: текст элемента, текстовое содержимое между тегами (`nodeType = 3`).

- **`Attr`**: атрибут html-элемента (`href="..."`), устаревший тип (`nodeType = 2`).

- **`DocumentType`**: DTD или тип схемы XML-документа (`<!DOCTYPE html>`) (`nodeType = 10`).

- **`DocumentFragment`**: место для временного хранения частей документа, временный контейнер для фрагментов DOM, не входит в дерево (`nodeType = 11`).

- **`EntityReference`**: ссылка на сущность XML-документа (XML-сущность) (`&copy;`) (`nodeType = 5`).

- **`ProcessingInstruction`**: инструкция обработки веб-страницы (`<?xml-stylesheet?>`) (`nodeType = 7`).

- **`Comment`**: элемент комментария, HTML/XML-комментарий (`<!-- -->`) (`nodeType = 8`).

- **`CDATASection`**: секция CDATA в документе XML, неразборный текст XML (`<![CDATA[...]]>`), как `Text` (`nodeType = 4`).

- **`Entity`**: необработанная сущность DTD, объявление сущности DTD (`<!ENTITY>`) (`nodeType = 6`).

- **`Notation`**: нотация, объявленная в DTD (нотация DTD) (`<!NOTATION>`) (`nodeType = 12`).

Несмотря на такое большое количество типов узлов, как правило, применяются первые 4 типа.[^8.1]

- `document` – «входная точка» в DOM;
- узлы-элементы – HTML-теги, основные строительные блоки;
- текстовые узлы – содержат текст;
- комментарии – иногда в них можно включить информацию, которая не будет показана, но доступна в DOM для чтения JS.

*Статус узлов DOM*

| Узел                  | nodeType | HTML5 | XML | Использование сегодня              |
| --------------------- | -------- | ----- | --- | ---------------------------------- |
| `Element`               | 1        | ✅     | ✅   | Основной                           |
| `Attr`                  | 2        | ❌     | ❌   | Устарел (рекомендуется использовать `getAttribute`) |
| `Text`                  | 3        | ✅     | ✅   | Основной                           |
| `CDATASection`          | 4        | ❌     | ✅   | Только XML (?XML only)                           |
| `EntityReference`       | 5        | ❌     | ⚠️  | Редко (legacy XML)                 |
| `Entity`                | 6        | ❌     | ⚠️  | Устарел                            |
| `ProcessingInstruction` | 7        | ⚠️    | ✅   | XSLT стили                         |
| `Comment`               | 8        | ✅     | ✅   | Часто                              |
| `Document`              | 9        | ✅     | ✅   | Основной                           |
| `DocumentType`          | 10       | ✅     | ✅   | Только `DOCTYPE`                     |
| `DocumentFragment`      | 11       | ✅     | ✅   | Часто (batch updates)              |
| `Notation`              | 12       | ❌     | ⚠️  | Устарел                            |

**Вывод**: в веб-разработке активно используются только `Document`, `Element`, `Text`, `DocumentFragment`, `Comment`. Остальные — артефакты XML/DTD 1998 года.

#### Редкие типы узлов XML DOM
**DTD** (Document Type Definition) — это определение типа документа, первое средство валидации структуры XML.

DTD описывает правила построения XML-документа:

- Какие элементы допустимы и в какой последовательности

- Какие атрибуты разрешены у элементов

- Тип содержимого элементов (#PCDATA, другие элементы)

- Вложенность и обязательность

Синтаксис в XML
```xml
<!DOCTYPE root-element [
  <!ELEMENT note (to,from,heading,body)>  <!-- структура -->
  <!ELEMENT to (#PCDATA)>                 <!-- только текст -->
  <!ATTLIST note type CDATA #REQUIRED>    <!-- атрибуты -->
]>
<note type="important">
  <to>Иван</to>
  <from>Петр</from>
</note>
```

В браузере `document.doctype` возвращает объект `DocumentType`:
```js
console.log(document.doctype);
// #documentType html // для HTML5
console.log(document.doctype.name);    // "html"
console.log(document.doctype.publicId); // ""
```

В настоящее время считается устаревшим стандартом (1998), заменен XML Schema (XSD):

- Нет типов данных (только текст/элементы)

- Сложный синтаксис

- HTML5 использует упрощенный `<!DOCTYPE html>`

Таким образом, DTD — исторический артефакт для валидации простых XML. В веб-разработке остался только как `<!DOCTYPE>` для активации standards mode.

`EntityReference` — ссылка на сущность из DTD. Заменяется на значение сущности при парсинге.

```xml
<!DOCTYPE doc [
  <!ENTITY copy "©">
]>
<doc>&copy; текст</doc>  <!-- EntityReference: &copy; -->
```

В DOM: `nodeName = "copy"`, `nodeType = 5`.​

`ProcessingInstruction` — инструкция обработки (PI) для приложений (XML-стили, XSLT).

```xml
<?xml-stylesheet type="text/xsl" href="style.xsl"?>
```

В DOM: `nodeName = "xml-stylesheet"`, `nodeValue = 'type="text/xsl" href="style.xsl"'`, `nodeType = 7`.

`CDATASection` обозначает секцию CDATA — текст, не парсируемый как XML (для HTML в XML).

```xml
<![CDATA[<script>alert("ok")</script>]]>  <!-- Текст как есть -->
```

В DOM: `nodeType = 4`, обычный текстовый узел с особым флагом.

`Entity` — объявление сущности из DTD (необрабатанная).

```xml
<!ENTITY logo SYSTEM "logo.gif">
```

В DOM: `document.doctype.entities.getNamedItem("logo"), nodeType = 6`.

`Notation` — нотация DTD — описание внешних типов данных (старые изображения).

```xml
<!NOTATION GIF PUBLIC "image/gif">
```

В DOM: `document.doctype.notations.getNamedItem("GIF")`, `nodeType = 12`.

Все эти узлы — артефакты XML 1.0 (1998) для DTD. В веб-разработке практически не встречаются, остались только в legacy XML.

#### XSLT-стили
*[XML]: eXtensible Markup Language
*[XSL]: eXtensible Stylesheet Language
*[RSS]: Really Simple Syndication
*[XSLT]: XSL Transformations
*[RDF]: Resource Description Framework
*[OWL]: Web Ontology Language
*[FOAF]: Friend of a Friend
*[SPARQL]: SPARQL Protocol and RDF Query Language
*[JSON]: JavaScript Object Notation

<dfn title="XML">XML</dfn> — eXtensible Markup Language (расширяемый язык разметки). Структурированный формат данных с пользовательскими тегами (1998).
```xml
<user id="1">
  <name>Иван</name>
  <age>30</age>
</user>
```

<dfn title="XSL">XSL</dfn> — eXtensible Stylesheet Language (семейство). Включает:

- XSLT — преобразование XML в HTML/XML

- XPath — запросы к XML

- XSL-FO — форматирование (PDF)

```xml
<?xml-stylesheet type="text/xsl" href="style.xsl"?>
```

<dfn title="XSLT стили">XSLT стили</dfn> — это таблицы преобразований XML (XSL Transformations), которые определяют, как XML-документ преобразуется в другой формат (HTML, другой XML).

**Как работают**
1. XML-документ содержит данные

2. XSLT-стиль содержит правила преобразования (ё<xsl:template>ё)

3. XSLT-процессор (браузер, Saxon) применяет стиль к данным

```xml
<!-- data.xml -->
<users>
  <user id="1"><name>Иван</name></user>
</users>
```

```xml
<!-- style.xsl -->
<xsl:stylesheet version="1.0">
  <xsl:template match="/users">
    <ul>
      <xsl:for-each select="user">
        <li><xsl:value-of select="name"/></li>
      </xsl:for-each>
    </ul>
  </xsl:template>
</xsl:stylesheet>
```

Результат: `<ul><li>Иван</li></ul>`

*Подключение через `ProcessingInstruction`*:
```xml
<!-- В XML-документе -->
<?xml-stylesheet type="text/xsl" href="style.xsl"?>
<users>...</users>
```

Браузер автоматически применяет XSLT и показывает HTML.

| Задача      | Пример                  |
| ----------- | ----------------------- |
| XML → HTML | Данные → веб-страница  |
| XML → XML  | Конвертация форматов    |
| Отчеты      | XML-данные → PDF/Excel |
| RSS → HTML | Ленты новостей          |

Современный статус — устаревшая технология (1999):

- ✅ Server-side: Node.js (xslt4node), Java (Saxon)

- ❌ Client-side: Браузеры не поддерживают (кроме IE)

- ❌ SPA: React/Vue заменили полностью

**Вывод**: XSLT — мощный инструмент для серверных XML-преобразований, но в веб-фронтенде заменен JavaScript-фреймворками.

<dfn title="RSS">RSS</dfn> — RDF Site Summary / Really Simple Syndication. Формат лент новостей на базе XML.

```xml
<rss version="2.0">
  <channel>
    <item>
      <title>Новость</title>
      <link>https://example.com</link>
      <pubDate>2025-12-18</pubDate>
    </item>
  </channel>
</rss>
```

| Технология | Назначение     | Год  | Статус                     |
| ---------- | -------------- | ---- | -------------------------- |
| XML        | Данные/конфиги | 1998 | ✅ JSON заменил             |
| XSL/XSLT   | XML → HTML    | 1999 | ❌ Устарело (JS фреймворки) |
| RSS        | Ленты новостей | 1999 | ✅ Жив (подкасты, блоги)    |

**Вывод**: XML — универсальный формат данных, XSL — устаревшие стили/преобразования, RSS — живой стандарт новостных фидов.

<dfn title="RDF">RDF</dfn> (Resource Description Framework) — Среда описания ресурсов, модель данных для Семантической паутины (Semantic Web).

RDF представляет данные как граф триплетов:
```
субъект → предикат → объект
Иван    → возраст   → 30
```

Всё идентифицируется URI (уникальными ссылками).

*Пример*:
```
@prefix foaf: <http://xmlns.com/foaf/0.1/> .

<ivan> foaf:name "Иван Иванов" .
<ivan> foaf:age 30 .
<ivan> foaf:knows <maria> .
```

Графически:
```
[Иван] ──name───> "Иван Иванов"
       ──age───> 30
       ──knows──> [Мария]
```

*Форматы*:
| Синтаксис | Пример                                   | Использование      |
| --------- | ---------------------------------------- | ------------------ |
| Turtle    | `@prefix foaf: <...>`                    | Читаемый человеком |
| RDF/XML   | `<rdf:Description>`                      | Legacy             |
| JSON-LD   | `{"@id": "ivan"}`                        | Современный веб    |
| RDFa      | `<span property="foaf:name">Иван</span>` | В HTML             |

RSS 1.0 использует RDF для описания лент:
```xml
<rdf:RDF>
  <item rdf:about="http://example.com/post1">
    <title>Новость</title>
  </item>
</rdf:RDF>
```

*Назначение*
| Область               | Пример                                       |
| --------------------- | -------------------------------------------- |
| Семантическая паутина | Linked Data, DBpedia                         |
| Онтологии             | OWL (Web Ontology Language)                  |
| Метаданные            | FOAF (Friend of a Friend)                    |
| SPARQL-запросы        | SELECT ?person WHERE { ?person foaf:age 30 } |

Статус — живой стандарт W3C (1999–наст. время):

- ✅ JSON-LD — в Schema.org, Google Knowledge Graph

- ✅ SPARQL — запросы к RDF

- ❌ RDF/XML — устарел

**Вывод**: RDF — фундамент Семантической паутины, позволяет машинам понимать связи между данными. Сегодня популярен через JSON-LD в SEO и структурированных данных.

#### Просмотр структуры DOM
Чтобы посмотреть структуру DOM в реальном времени, можно попробовать [Live DOM Viewer](https://software.hixie.ch/utilities/js/live-dom-viewer/). Просто введите что-нибудь в поле, и ниже вы увидите, как меняется DOM.

Другой способ исследовать DOM – это использовать инструменты разработчика браузера. Это то, что мы каждый день делаем при разработке.

Для этого откройте страницу [elks.html](https://learn.javascript.ru/article/dom-nodes/elks.html), включите инструменты разработчика и перейдите на вкладку Elements.

Выглядит примерно так:

![Elks](../img/elks.png)

Вы можете увидеть DOM, понажимать на элементы, детально рассмотреть их и так далее.

Обратите внимание, что структура DOM в инструментах разработчика отображается в упрощённом виде. Текстовые узлы показаны как простой текст. И кроме пробелов нет никаких «пустых» текстовых узлов. Ну и отлично, потому что большую часть времени нас будут интересовать узлы-элементы.

Клик по этой ![button glyph](../img/btn-glyph.png) кнопке в левом верхнем углу инспектора позволяет при помощи мыши (или другого устройства ввода) выбрать элемент на веб-странице и «проинспектировать» его (браузер сам найдёт и отметит его во вкладке Elements). Этот способ отлично подходит, когда у нас огромная HTML-страница (и соответствующий ей огромный DOM), и мы хотим увидеть, где находится интересующий нас элемент.

Есть и другой способ сделать это: можно кликнуть на странице по элементу правой кнопкой мыши и в контекстном меню выбрать «Inspect».

![Inspect](../img/inspect.png)

В правой части инструментов разработчика находятся следующие подразделы:

- **Styles** – здесь мы видим CSS, применённый к текущему элементу: правило за правилом, включая встроенные стили (выделены серым). Почти всё можно отредактировать на месте, включая размеры, внешние и внутренние отступы.
- **Computed** – здесь мы видим итоговые CSS-свойства элемента, которые он приобрёл в результате применения всего каскада стилей (в том числе унаследованные свойства и т.д.).
- **Event Listeners** – в этом разделе мы видим обработчики событий, привязанные к DOM-элементам (мы поговорим о них в следующей части учебника).
… и т.д.

Лучший способ изучить инструменты разработчика – это прокликать их. Большинство значений можно менять и тут же смотреть результат.

#### Взаимодействие с консолью
При работе с DOM нам часто требуется применить к нему JavaScript. Например: получить узел и запустить какой-нибудь код для его изменения, чтобы посмотреть результат. Вот несколько подсказок, как перемещаться между вкладками Elements и Console.

Для начала:

1. На вкладке Elements выберите первый элемент `<li>`.
2. Нажмите <kbd>Esc</kbd> – прямо под вкладкой Elements откроется Console.

Последний элемент, выбранный во вкладке Elements, доступен в консоли как `$0`; предыдущий, выбранный до него, как `$1` и т.д.

Теперь мы можем запускать на них команды. Например `$0.style.background = 'red'` сделает выбранный элемент красным, как здесь:

![Dom console](../img/domconsole0.png)

Это мы посмотрели как получить узел из Elements в Console.

Есть и обратный путь: если есть переменная `node`, ссылающаяся на DOM-узел, можно использовать в консоли команду `inspect(node)`, чтобы увидеть этот элемент во вкладке Elements.

Или мы можем просто вывести DOM-узел в консоль и исследовать «на месте», как `document.body` ниже:

![DOM console](../img/domconsole1.png)

Это может быть полезно для отладки. В следующей главе мы рассмотрим доступ и изменение DOM при помощи JavaScript.

Инструменты разработчика браузера отлично помогают в разработке: мы можем исследовать DOM, пробовать с ним что-то делать и смотреть, что идёт не так.

#### Итого
HTML/XML документы представлены в браузере в виде DOM-дерева.

- Теги становятся узлами-элементами и формируют структуру документа.
- Текст становится текстовыми узлами.
- … и т.д. Всё, что записано в HTML, есть и в DOM-дереве, даже комментарии.

Для изменения элементов или проверки DOM-дерева мы можем использовать инструменты разработчика в браузере.

Здесь мы рассмотрели основы, наиболее часто используемые и важные действия для начала разработки. Подробную документацию по инструментам разработки Chrome Developer Tools можно найти на странице https://developers.google.com/web/tools/chrome-devtools. Лучший способ изучить инструменты – походить по разным вкладкам, почитать меню: большинство действий очевидны для пользователя.

У DOM-узлов есть свойства и методы, которые позволяют выбирать любой из элементов, изменять, перемещать их на странице и многое другое. Мы вернёмся к ним в последующих разделах.[^dom-nodes]

### Узлы. Навигация по объектам DOM

#### Объект Node
DOM позволяет нам делать что угодно с элементами и их содержимым, но для начала нужно получить соответствующий DOM-объект.

Каждый отдельный узел, будь то html-элемент, его атрибут или текст, в структуре DOM представлен объектом **`Node`**. Может возникнуть вопрос: как связаны элементы веб-страницы и узлы веб-страницы? И тут надо отметить, что любой элемент веб-страницы является узлом, но не любой узел является элементом (например, атрибуты и текст элементов также являются отдельными узлами).[^8.4]

Теперь давайте более внимательно взглянем на DOM-узлы. Далее мы подробнее разберём, что они собой представляют и изучим их основные свойства.

##### Классы DOM-узлов

*[IDL]: Interface description language

У разных DOM-узлов могут быть разные свойства. Например, у узла, соответствующего тегу `<a>`, есть свойства, связанные со ссылками, а у соответствующего тегу `<input>` – свойства, связанные с полем ввода и т.д. Текстовые узлы отличаются от узлов-элементов. Но у них есть общие свойства и методы, потому что все классы DOM-узлов образуют единую иерархию.

Каждый DOM-узел принадлежит соответствующему встроенному классу.

Корнем иерархии является [EventTarget](https://dom.spec.whatwg.org/#eventtarget), от него наследует [Node](https://dom.spec.whatwg.org/#interface-node) и остальные DOM-узлы.

На рисунке ниже изображены основные классы:

![DOM class hierarchy](../svg/dom-class-hierarchy.svg)

Существуют следующие классы:

- [`EventTarget`](https://dom.spec.whatwg.org/#eventtarget) – это корневой «абстрактный» класс для всего.

    Объекты этого класса никогда не создаются. Он служит основой, благодаря которой все DOM-узлы поддерживают так называемые «события», о которых мы поговорим позже.

- [`Node`](https://dom.spec.whatwg.org/#interface-node) – также является «абстрактным» классом, и служит основой для DOM-узлов.

    Он обеспечивает базовую функциональность: `parentNode`, `nextSibling`, `childNodes` и т.д. (это геттеры). Объекты класса `Node` никогда не создаются. Но есть определённые классы узлов, которые наследуются от него (и следовательно наследуют функционал `Node`).

- [`Document`](https://dom.spec.whatwg.org/#interface-document), по историческим причинам часто наследуется `HTMLDocument` (хотя последняя спецификация этого не навязывает) – это документ в целом.

    Глобальный объект `document` принадлежит именно к этому классу. Он служит точкой входа в DOM.

- [`CharacterData`](https://dom.spec.whatwg.org/#interface-characterdata) – «абстрактный» класс. Вот, кем он наследуется:

  - [`Text`](https://dom.spec.whatwg.org/#interface-text) – класс, соответствующий тексту внутри элементов. Например, `Hello` в `<p>Hello</p>`.

  - [`Comment`](https://dom.spec.whatwg.org/#interface-comment) – класс для комментариев. Они не отображаются, но каждый комментарий становится членом DOM.

- [`Element`](https://dom.spec.whatwg.org/#interface-element) – это базовый класс для DOM-элементов.

    Он обеспечивает навигацию на уровне элементов: `nextElementSibling`, `children`. А также и методы поиска элементов: `getElementsByTagName`, `querySelector`.

    Браузер поддерживает не только HTML, но также XML и SVG. Таким образом, класс `Element` служит основой для более специфичных классов: `SVGElement`, `XmlElement` (они нам здесь не нужны) и `HTMLElement`.

- И наконец, [`HTMLElement`](https://html.spec.whatwg.org/multipage/dom.html#htmlelement) является базовым классом для всех остальных HTML-элементов. Мы будем работать с ним большую часть времени.

    От него наследуются конкретные элементы:

  - [`HTMLInputElement`](https://html.spec.whatwg.org/multipage/forms.html#htmlinputelement) – класс для тега `<input>`,
  - [`HTMLBodyElement`](https://html.spec.whatwg.org/multipage/semantics.html#htmlbodyelement) – класс для тега `<body>`,
  - [`HTMLAnchorElement`](https://html.spec.whatwg.org/multipage/semantics.html#htmlanchorelement) – класс для тега `<a>`,
  - …и т.д.

Также существует множество других тегов со своими собственными классами, которые могут иметь определенные свойства и методы, в то время как некоторые элементы, такие как `<span>`, `<section>` и `<article>`, не имеют каких-либо определенных свойств, поэтому они являются экземплярами класса `HTMLElement`.

Таким образом, полный набор свойств и методов данного узла является результатом цепочки наследования.

Рассмотрим DOM-объект для тега `<input>`. Он принадлежит классу [`HTMLInputElement`](https://html.spec.whatwg.org/multipage/forms.html#htmlinputelement).

Он получает свойства и методы из (в порядке наследования):

- `HTMLInputElement` – этот класс предоставляет специфичные для элементов формы свойства,
- `HTMLElement` – предоставляет общие для HTML-элементов методы (и геттеры/сеттеры),
- `Element` – предоставляет типовые методы элемента,
- `Node` – предоставляет общие свойства DOM-узлов,
- `EventTarget` – обеспечивает поддержку событий (поговорим о них дальше),
- …и, наконец, он наследует от `Object`, поэтому доступны также методы «обычного объекта», такие как `hasOwnProperty`.

Для того, чтобы узнать имя класса DOM-узла, вспомним, что обычно у объекта есть свойство `constructor`. Оно ссылается на конструктор класса, и в свойстве `constructor.name` содержится его имя:
```js
alert( document.body.constructor.name ); // HTMLBodyElement
```

…Или мы можем просто привести его к строке:
```js
alert( document.body ); // [object HTMLBodyElement]
```

Проверить наследование можно также при помощи `instanceof`:
```js
alert( document.body instanceof HTMLBodyElement ); // true
alert( document.body instanceof HTMLElement ); // true
alert( document.body instanceof Element ); // true
alert( document.body instanceof Node ); // true
alert( document.body instanceof EventTarget ); // true
```

Как видно, DOM-узлы – это обычные JavaScript объекты. Для наследования они используют классы, основанные на прототипах.

В этом легко убедиться, если вывести в консоли браузера любой элемент через `console.dir(`*`elem`*`)`. Или даже напрямую обратиться к методам, которые хранятся в `HTMLElement.prototype`, `Element.prototype` и т.д.

!!! info "`console.dir(elem)` и `console.log(elem)`"

    Большинство браузеров поддерживают в инструментах разработчика две команды: `console.log` и `console.dir`. Они выводят свои аргументы в консоль. Для JavaScript-объектов эти команды обычно выводят одно и то же.

    Но для DOM-элементов они работают по-разному:

    - `console.log(`*`elem`*`)` выводит элемент в виде DOM-дерева.
    - `console.dir(`*`elem`*`)` выводит элемент в виде DOM-объекта, что удобно для анализа его свойств.

    Попробуйте сами на `document.body`. Вы увидите разницу во всех современных браузерах (кроме Firefox, где `console.log(`*`elem`*`)` и `console.dir(`*`elem`*`)` выводят одно и то же – элемент в виде DOM-объекта).

!!! info "Спецификация IDL"

    В спецификации для описания классов DOM используется не JavaScript, а специальный язык [Interface description language](https://ru.wikipedia.org/wiki/%D0%AF%D0%B7%D1%8B%D0%BA_%D0%BE%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D1%8F_%D0%B8%D0%BD%D1%82%D0%B5%D1%80%D1%84%D0%B5%D0%B9%D1%81%D0%BE%D0%B2) (IDL), с которым достаточно легко разобраться.

    В IDL все свойства представлены с указанием их типов. Например, `DOMString`, `boolean` и т.д.

    Небольшой отрывок IDL с комментариями:

    ```js
    // Объявление HTMLInputElement
    // Двоеточие ":" после HTMLInputElement означает, что он наследует от HTMLElement
    interface HTMLInputElement: HTMLElement {
      // далее идут свойства и методы элемента <input>

      // "DOMString" означает, что значение свойства - строка
      attribute DOMString accept;
      attribute DOMString alt;
      attribute DOMString autocomplete;
      attribute DOMString value;

      // boolean - значит, что autofocus хранит логический тип данных (true/false)
      attribute boolean autofocus;
      ...
      // "void" перед методом означает, что данный метод не возвращает значение
      void select();
      ...
    }
    ```

##### Свойства узлов
Объект **`Node`** предоставляет ряд свойств, с помощью которых мы можем получить информацию о данном узле:

- **`childNodes`**: содержит коллекцию дочерних узлов

- **`children`**: содержит коллекцию дочерних узлов, которые являются элементами

- **`firstChild`**: возвращает первый дочерний узел текущего узла

- **`firstElementChild`**: возвращает первый дочерний узел, который является элементом

- **`lastChild`**: возвращает последний дочерний узел текущего узла

- **`lastElementChild`**: возвращает последний дочерний узел, который является элементом

- **`previousSibling`**: возвращает предыдущий узел, который находится на одном уровне с текущим

- **`nextSibling`**: возвращает следующий узел, который находится на одном уровне с текущим

- **`previousElementSibling`**: возвращает предыдущий узел, который является элементом и который находится на одном уровне с текущим

- **`nextElementSibling`**: возвращает следующий узел, который является элементом и который находится на одном уровне с текущим

- **`ownerDocument`**: возвращает корневой узел документа

- **`parentNode`**: возвращает родительский узел для текущего узла

- **`parentElement`**: возвращает родительский узел, который является элементом

- **`nodeName`**: возвращает имя узла

- **`nodeType`**: возвращает тип узла в виде числа

- **`nodeValue`**: возвращает текст текстового узла

Прежде всего мы можем использовать свойства **`nodeName`** и **`nodeType`**, чтобы узнать тип узла:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <div id="article">
        <h1 id="header">Home Page</h1>
        <p>Page Text</p>
    </div>
<script>
const article = document.getElementById("article");
console.log(article.nodeName);  // DIV
console.log(article.nodeType);  // 1
</script>
</body>
</html>
```

Здесь получаем информацию по элементу с `id="header"`. В частности, свойство `nodeName` возвратит имя тега элемента — **`div`**, а свойство `nodeType` — число 1. 

##### Свойство «nodeType»
Свойство `nodeType` предоставляет ещё один, «старомодный» способ узнать «тип» DOM-узла.

Его значением является число:

- `elem.nodeType == 1` для узлов-элементов,
- `elem.nodeType == 3` для текстовых узлов,
- `elem.nodeType == 9` для объектов документа,

В [спецификации](https://dom.spec.whatwg.org/#node) можно посмотреть остальные значения.

Например:
```html
<body>
  <script>
  let elem = document.body;

  // давайте разберёмся: какой тип узла находится в elem?
  alert(elem.nodeType); // 1 => элемент

  // и его первый потомок...
  alert(elem.firstChild.nodeType); // 3 => текст

  // для объекта document значение типа -- 9
  alert( document.nodeType ); // 9
  </script>
</body>
```

Каждому типу узлов соответствует определенное число:

| nodeType | Название константы          | Тип узла              | Описание                | nodeName           | nodeValue  |
| -------- | --------------------------- | --------------------- | ----------------------- | ------------------ | ---------- |
| 1        | `ELEMENT_NODE`                | Элемент               | HTML-элемент `<div>`, `<p>` | имя тега           | `null`       |
| 2        | `ATTRIBUTE_NODE`              | Атрибут               | `href="..."` (устарело)   | имя атрибута       | значение   |
| 3        | `TEXT_NODE`                   | Текст                 | Текст между тегами      | `#text`              | содержимое |
| 4        | `CDATA_SECTION_NODE`          | CDATASection          | `<![CDATA[...]]>`         | `#cdata-section`     | содержимое |
| 5        | `ENTITY_REFERENCE_NODE`       | `EntityReference`       | `&copy;`                  | имя сущности       | `null`       |
| 6        | `ENTITY_NODE`                 | `Entity`                | `<!ENTITY logo>`          | имя сущности       | `null`       |
| 7        | `PROCESSING_INSTRUCTION_NODE` | `ProcessingInstruction` | `<?xml-stylesheet?>`      | `target`             | содержимое |
| 8        | `COMMENT_NODE`                | `Comment`               | `<!-- комментарий -->`    | `#comment`           | текст      |
| 9        | `DOCUMENT_NODE`               | `Document`              | Корень документа        | `#document`          | `null`       |
| 10       | `DOCUMENT_TYPE_NODE`          | `DocumentType`          | `<!DOCTYPE html>`         | имя `DOCTYPE`        | `null`       |
| 11       | `DOCUMENT_FRAGMENT_NODE`      | `DocumentFragment`      | Временный контейнер     | `#document-fragment` | `null`       |
| 12       | `NOTATION_NODE`               | `Notation`              | `<!NOTATION GIF>`         | имя нотации        | `null`       |

RDF в контексте DOM не имеет специального `nodeType` — это формат данных (XML/RDFa/JSON-LD), парсится в обычные `Element`/`Text` узлы:
```xml
<!-- RDF/XML → ELEMENT_NODE (1) + TEXT_NODE (3) -->
<rdf:Description rdf:about="ivan">
  <foaf:name>Иван</foaf:name>  <!-- nodeType = 1, 3 -->
</rdf:Description>
```

Таким образом, `nodeType` определяет DOM-структуру, RDF — семантику данных внутри `Element`/`Text` узлов.

В современных скриптах, чтобы узнать тип узла, мы можем использовать метод `instanceof` и другие способы проверить класс, но иногда `nodeType` проще использовать. Мы не можем изменить значение `nodeType`, только прочитать его.

##### Тег: nodeName и tagName
Получив DOM-узел, мы можем узнать имя его тега из свойств `nodeName` и `tagName`.

Например:
```js
alert( document.body.nodeName ); // BODY
alert( document.body.tagName ); // BODY
```

Есть ли какая-то разница между `tagName` и `nodeName`?

Да, она отражена в названиях свойств, но не очевидна.

- Свойство `tagName` есть только у элементов `Element`.
- Свойство `nodeName` определено для любых узлов `Node`:
  - для элементов оно равно `tagName`.
  - для остальных типов узлов (текст, комментарий и т.д.) оно содержит строку с типом узла.

Другими словами, свойство `tagName` есть только у узлов-элементов (поскольку они происходят от класса `Element`), а `nodeName` может что-то сказать о других типах узлов.

Например, сравним `tagName` и `nodeName` на примере объекта `document` и узла-комментария:
```html
<body><!-- комментарий -->

  <script>
    // для комментария
    alert( document.body.firstChild.tagName ); // undefined (не элемент)
    alert( document.body.firstChild.nodeName ); // #comment

    // for document
    alert( document.tagName ); // undefined (не элемент)
    alert( document.nodeName ); // #document
  </script>
</body>
```

Если мы имеем дело только с элементами, то можно использовать `tagName` или `nodeName`, нет разницы.

!!! info "Имена тегов (кроме XHTML) всегда пишутся в верхнем регистре"

    В браузере существуют два режима обработки документа: HTML и XML. HTML-режим обычно используется для веб-страниц. XML-режим включается, если браузер получает XML-документ с заголовком: `Content-Type: application/xml+xhtml`.

    В HTML-режиме значения `tagName`/`nodeName` всегда записаны в верхнем регистре. Будет выведено BODY вне зависимости от того, как записан тег в HTML `<body>` или `<BoDy>`.

    В XML-режиме регистр сохраняется «как есть». В настоящее время XML-режим применяется редко.

#### Свойства объекта document
Все операции с DOM начинаются с объекта `document`. Это главная «точка входа» в DOM. Из него мы можем получить доступ к любому узлу. Объект `document` определен в глобальном объекте `window` и предназначен для работы со структурой DOM в JavaScript. Для получения базовой информации о веб-странице объект `document` предоставляет ряд свойств:

- **`title`**: представляет заголовок документа (который указан в элементе `<title>`)

- **`lastModified`**: содержит дату последнего изменения документа

- **`URL`**: содержит адрес URL текущего документа

- **`domain`**: содержит домен, к которому принадлежит веб-страница документа

- **`documentElement`**: предоставляет доступ к корневому элементу `<html>`

- **`body`**: предоставляет доступ к элементу `<body>` на веб-странице

- **`head`**: предоставляет доступ к элементу `<head>` на веб-странице

- **`cookie`**: содержит коллекцию всех куки для текущего документа

- **`images`**: содержит коллекцию всех объектов изображений (элементов `img`)

- **`links`**: содержит коллекцию ссылок — элементов `<a>` и `<area>`, у которых определен атрибут `href`

- **`anchors`**: предоставляет доступ к коллекции элементов `<a>`, у которых определен атрибут name

- **`forms`**: содержит коллекцию всех форм на веб-странице

Эти свойства не предоставляют доступ ко всем элементам, однако позволяют получить наиболее часто используемые элементы на веб-странице. Например, получим корневой узел документа:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
<script>
console.log(document.documentElement);
</script>
</body>
</html>
```

В результате на консоль будет выведено содержимое текущей веб-страницы, как оно определено в коде выше.

Или выведем базовую информацию о документе:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
<script>
console.log(document.title);
console.log(document.lastModified);
console.log(document.domain);
console.log(document.URL);
</script>
</body>
</html>
```

Консольный вывод:
```
DevPM
12/07/2025 10:56:12

file:///Users/user/Documents/app/index.html
```

Получим все изображения на странице:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <img src="picure1.png" alt="Картинка 1" />
    <img src="picure2.png" alt="Картинка 2" />
    <img src="picure3.png" alt="Картинка 3" />
    <script>
        const images = document.images;
        // изменим первое изображение
        images[0].src="picture_4.jpg";
        images[0].alt="Новая картинка";
        // перебирем все изображения
        for(img of images){
            console.log(`Url: "${img.src}" Alt:"${img.alt}"`);
        }
    </script>
</body>
</html>
```

Подобно тому, как в коде html мы можем установить атрибуты у элемента `img`, так и в коде javascript мы можем через свойства `src` и `alt` получить и установить значения этих атрибутов. Причем в данном случае не важно, существуют или нет файлы изображений. Консольный вывод будет наподобие следующего:
```
Url: "app/picture_4.jpg" Alt:"Новая картинка"
Url: "app/picure2.png" Alt:"Картинка 2"
Url: "app/picure3.png" Alt:"Картинка 3"
```

Рассмотрим получение всех ссылок на странице:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <a href="article1.html">Статья 1</a>
    <a href="article2.html">Статья 2</a>
    <a href="article3.html">Статья 3</a>
    <script>
        const links = document.links;
        // перебираем все ссылки
        for(link of links){
            console.log(`Href: "${link.href}" Text: "${link.innerText}"`);
        }
    </script>
</body>
</html>
```

Опять же, так как у ссылки определен атрибут `href`, то при переборе ссылок мы можем получить его значение.[^8.3]

#### Навигационные свойства
Так выглядят основные ссылки, по которым можно переходить между узлами DOM:

![DOM navigation links](../svg/dom-links.svg)

Поговорим об этом подробнее.

##### Сверху: documentElement и body
Самые верхние элементы дерева доступны как свойства объекта `document`:

- `<html>` = `document.documentElement`

    Самый верхний узел документа: `document.documentElement`. В DOM он соответствует тегу `<html>`.

- `<body>` = `document.body`

    Другой часто используемый DOM-узел – узел тега `<body>`: `document.body`.

- `<head>` = `document.head`

    Тег `<head>` доступен как `document.head`.

!!! warning "Есть одна тонкость: document.body может быть равен null"

    Нельзя получить доступ к элементу, которого ещё не существует в момент выполнения скрипта.

    В частности, если скрипт находится в `<head>`, `document.body` в нём недоступен, потому что браузер его ещё не прочитал.

    Поэтому, в примере ниже первый `alert` выведет `null`:
    ```html
    <html>

    <head>
    <script>
        alert( "Из HEAD: " + document.body ); // null, <body> ещё нет
    </script>
    </head>

    <body>

    <script>
        alert( "Из BODY: " + document.body ); // HTMLBodyElement, теперь он есть
    </script>

    </body>
    </html>
    ```

!!! info "В мире DOM `null` означает «не существует»"

    В DOM значение `null` значит «не существует» или «нет такого узла».

##### Получение родительского элемента
Для получения родительского элемента применяются свойства **`parentNode`** и **`parentElement`**. Например:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <div id="article">
        <h1 id="header">Home Page</h1>
        <p>Page Text</p>
    </div>
    <script>
    // выбираем все элемент c id="header"
    const header = document.getElementById("header");
    // получаем родительский элемента
    const headerParent = header?.parentElement;
    // можно так
    // const headerParent = header?.parentNode;
    console.log(headerParent);    // выводим родительский элемент на консоль
    </script>
</body>
</html>
```

Здесь выводим на консоль элемент, в который помещен элемент с `id="header"`.

Стоит отметить, что хотя оба метода в принципе возвращают один и тот же элемент, однако есть исключение — элемент `<html>`. Для него родительским узлом будет объект `document`, а вот родительского элемента у него не будет (будет значение `null`):
```js
const htmlEl = document.getElementsByTagName("html")[0];
const parentElem = htmlEl.parentElement;
const parentNode = htmlEl.parentNode;
console.log(parentElem);    // null
console.log(parentNode);    // объект document
```

##### Получение элементов одного уровня
*Соседи* (*siblings*) – это узлы, у которых один и тот же родитель.

Например, здесь `<head>` и `<body>` соседи:
```html
<html>
  <head>...</head><body>...</body>
</html>
```

- говорят, что `<body>` – «следующий» или «правый» сосед `<head>`
- также можно сказать, что `<head>` «предыдущий» или «левый» сосед `<body>`.

Следующий узел того же родителя (следующий сосед) – в свойстве `nextSibling`, а предыдущий – в `previousSibling`.

Таким образом, свойства **`previousSibling`**/**`previousElementSibling`** и **`nextSibling`**/**`nextElementSibling`** позволяют получить предыдущий и следующий элементы, которые располагаются на одном уровне с текущим. Например:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <div id="article">
        <h1 id="header">Home Page</h1>
        <p>Page Text 1</p>
        <p>Page Text 2</p>
        <p>Page Text 3</p>
    </div>
    <script>
    const article = document.getElementById("article");
    let tempNode = article.firstElementChild;
    while(tempNode != null){
        console.log(tempNode);
        tempNode = tempNode.nextElementSibling
    }
    </script>
</body>
</html>
```

Здесь опять же получаем элемент с `id="article"`. Затем получаем его первый элемент в переменную `tempNode` и в цикле, пока `tempNode` не будет равен `null`, выводим его значение на консоль и потом присваиваем этой переменной следующий элемент того же уровня (соседний элемент)
```js
tempNode = tempNode.nextElementSibling
```

Таким образом, мы перебирем все элементы одного уровня. Консольный вывод:
```
<h1 id="header">Home Page</h1>
<p>Page Text 1</p>
<p>Page Text 2</p>
<p>Page Text 3</p>
```

Также можно перебрать узлы в обратном порядке — сначала получаем последний узел, а затем обращаемся к предыдущему сестринскому узлу:
```js
const article = document.getElementById("article");
let tempNode = article.lastElementChild;
while(tempNode != null){
    console.log(tempNode);
    tempNode = tempNode.previousElementSibling;
}
```

Как помним, родитель доступен через `parentNode`.

Например:
```js
// родителем <body> является <html>
alert( document.body.parentNode === document.documentElement ); // выведет true

// после <head> идёт <body>
alert( document.head.nextSibling ); // HTMLBodyElement

// перед <body> находится <head>
alert( document.body.previousSibling ); // HTMLHeadElement
```

##### Получение потомков
Здесь и далее мы будем использовать два принципиально разных термина:

- **Дочерние узлы** (или **дети**, *child nodes*) – элементы, которые являются непосредственными детьми узла. Другими словами, элементы, которые лежат непосредственно внутри данного. Например, `<head>` и `<body>` являются детьми элемента `<html>`.

- **Потомки** (*descendant nodes*) – все элементы, которые лежат внутри данного, включая детей, их детей и т.д.

В примере ниже детьми тега `<body>` являются теги `<div>` и `<ul>` (и несколько пустых текстовых узлов):
```html
<html>
<body>
  <div>Начало</div>

  <ul>
    <li>
      <b>Информация</b>
    </li>
  </ul>
</body>
</html>
```

…А потомки `<body>` – это и прямые дети `<div>`, `<ul>` и вложенные в них: `<li>` (ребёнок `<ul>`) и `<b>` (ребёнок `<li>`) – в общем, все элементы поддерева.

Для получения дочерних элементов можно использовать свойство **`children`**:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM Vault</title>
</head>
<body>
    <div id="article">
        <h1 id="header">Home Page</h1>
        <p>Page Text</p>
    </div>
<script>
// выбираем элемент c id="article"
const article = document.getElementById("article");

for(elem of article.children){
    console.log(elem);
}
</script>
</body>
</html>
```

Здесь получаем элемент с `id="article"` и в цикле проходим по всем его дочерним элементам. А это два элемента:
```html
<h1 id="header">Home Page</h1>
<p>Page Text</p>
```

Если же нам надо выбрать вообще все дочерние узлы (не только элементы, но и атрибуты и текст), то применяется метод **`childNodes`**:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <div id="article">
        <h1 id="header">Home Page</h1>
        <p>Page Text</p>
    </div>
<script>
// выбираем элемент c id="article"
const article = document.getElementById("article");

for(node of article.childNodes){
    let type = "";
    if(node.nodeType===1) type="элемент";
    else if(node.nodeType===2) type="атрибут";
    else if(node.nodeType===3) type="текст";

    console.log(node.nodeName, ": ", type);
}
</script>
</body>
</html>
```

Здесь мы выбираем тот же элемент, но теперь перебираем его узлы. Выбираем элемент `div` с классом `article` и пробегаемся по его дочерним узлам. И в цикле выводим имя узла и его тип с помощью свойств `nodeName` и `nodeType`.

И несмотря на то, что в блоке `div#article` только два элемента: заголовок `h1` и параграф, консоль отобразит нам пять узлов.

```
#text :  текст
H1 :  элемент
#text :  текст
P :  элемент
#text :  текст
```

Дело в том, что пробелы между узлами также считаются за отдельные текстовые узлы. Если бы пробелов не было:
```html
<div id="article"><h1 id="header">Home Page</h1><p>Page Text</p></div>
```

то при переборе мы бы обнаружили только два дочерних узла, как и ожидалось.

**Коллекция `childNodes` содержит список всех детей, включая текстовые узлы.**

Пример ниже последовательно выведет детей `document.body`:
```html
<html>
<body>
  <div>Начало</div>

  <ul>
    <li>Информация</li>
  </ul>

  <div>Конец</div>

  <script>
    for (let i = 0; i < document.body.childNodes.length; i++) {
      alert( document.body.childNodes[i] ); // Text, DIV, Text, UL, ..., SCRIPT
    }
  </script>
  ...какой-то HTML-код...
</body>
</html>
```

Обратим внимание на маленькую деталь. Если запустить пример выше, то последним будет выведен элемент `<script>`. На самом деле, в документе есть ещё «какой-то HTML-код», но на момент выполнения скрипта браузер ещё до него не дошёл, поэтому скрипт не видит его.

Кроме того, для получения первого и последнего узла/элемента применяются свойства **`firstChild`**/**`firstElementChild`** и **`lastChild`**/**`lastElementChild`** соответственно.

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <div id="article">
        <h1 id="header">Home Page</h1>
        <p>Page Text</p>
    </div>
<script>
const article = document.getElementById("article");
console.log("First Child:", article.firstElementChild);
console.log("Last Child:", article.lastElementChild);
</script>
</body>
</html>
```

Консольный вывод:
```
First Child: <h1 id="header">Home Page</h1>​
Last Child: <p>Page Text</p>​
```

**Свойства `firstChild` и `lastChild` обеспечивают быстрый доступ к первому и последнему дочернему элементу.**

Они, по сути, являются всего лишь сокращениями. Если у тега есть дочерние узлы, условие ниже всегда верно:
```js
elem.childNodes[0] === elem.firstChild
elem.childNodes[elem.childNodes.length - 1] === elem.lastChild
```

Для проверки наличия дочерних узлов существует также специальная функция `elem.hasChildNodes()`. Метод **`hasChildNodes()`** возвращает `true`, если элемент содержит вложенные узлы:
```js
const article = document.querySelector("div");
if(article.hasChildNodes()){
    console.log("There are child nodes");
}
else{
    console.log("No child nodes");
}
```

Для получения количества дочерних элементов можно применять свойство **`childElementCount`**. Это значение будет эквивалентно значению `children.length`:
```js
const article = document.getElementById("article");
console.log(article.childElementCount); // 2
console.log(article.children.length); // 2
```

##### DOM-коллекции
Как мы уже видели, `childNodes` похож на массив. На самом деле это не массив, а <dfn title="коллекция">коллекция</dfn> – особый перебираемый объект-псевдомассив.

И есть два важных следствия из этого:

1. Для перебора *коллекции* мы можем использовать `for..of`:

    ```js
    for (let node of document.body.childNodes) {
    alert(node); // покажет все узлы из коллекции
    }
    ```

    Это работает, потому что коллекция является перебираемым объектом (есть требуемый для этого метод `Symbol.iterator`).

2. Методы массивов не будут работать, потому что коллекция – это не массив:

    ```js
    alert(document.body.childNodes.filter); // undefined (у коллекции нет метода filter!)
    ```

Первый пункт – это хорошо для нас. Второй – бывает неудобен, но можно пережить. Если нам хочется использовать именно методы массива, то мы можем создать настоящий массив из коллекции, используя `Array.from`:
```js
alert( Array.from(document.body.childNodes).filter ); // сделали массив
```

!!! warning "DOM-коллекции – только для чтения"

    DOM-коллекции, и даже более – *все* навигационные свойства, перечисленные в этой главе, доступны только для чтения.

    Мы не можем заменить один дочерний узел на другой, просто написав `childNodes[i] = ...`.

    Для изменения DOM требуются другие методы. Мы увидим их в следующей главе.

!!! warning "DOM-коллекции живые"

    Почти все DOM-коллекции, за небольшим исключением, живые. Другими словами, они отражают текущее состояние DOM.

    Если мы сохраним ссылку на `elem.childNodes` и добавим/удалим узлы в DOM, то они появятся в сохранённой коллекции автоматически.

!!! warning "Не используйте цикл `for..in` для перебора коллекций"

    Коллекции перебираются циклом `for..of`. Некоторые начинающие разработчики пытаются использовать для этого цикл `for..in`.

    Не делайте так. Цикл `for..in` перебирает все перечисляемые свойства. А у коллекций есть некоторые «лишние», редко используемые свойства, которые обычно нам не нужны:
    ```html
    <body>
    <script>
    // выводит 0, 1, length, item, values и другие свойства.
    for (let prop in document.body.childNodes) alert(prop);
    </script>
    </body>
    ```

##### Получение текстового содержимого
Свойства `nodeValue` и `data` позволяют получить текстовое содержимое узла. Эти свойства очень похожи при использовании, есть лишь небольшие различия в спецификации. Чаще используется `data`, потому что оно короче.

Прочитаем содержимое текстового узла и комментария:
```html
<body>
  Привет
  <!-- Комментарий -->
  <script>
    let text = document.body.firstChild;
    alert(text.data); // Привет

    let comment = text.nextSibling;
    alert(comment.data); // Комментарий
  </script>
</body>
```

Мы можем представить, для чего нам может понадобиться читать или изменять текстовый узел, но комментарии?

Иногда их используют для вставки информации и инструкций шаблонизатора в HTML, как в примере ниже:
```html
<!-- if isAdmin -->
  <div>Добро пожаловать, Admin!</div>
<!-- /if -->
```

…Затем JavaScript может прочитать это из свойства `data` и обработать инструкции.

Свойство **`nodeValue`** позволяет получить содержимое текстового узла, то есть его текст. Например:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM Vault</title>
</head>
<body>
    <div id="article">
        <h1 id="header">Home Page</h1>
        <p id="text">Page Text</p>
    </div>
    <script>
    // получаем элемент с id="text"
    const pageText = document.getElementById("text");
    console.log(pageText.nodeValue);    // null
    for(textNode of pageText.childNodes){
        console.log(textNode.nodeValue);
    }
    </script>
</body>
</html>
```

В данном случае мы пытаемся получить текст элемента с `id="text"`. Сначала получаем данный элемент в константу `pageText`. Однако напрямую мы не можем у него вызвать у него свойство `nodeValue`. Если мы это сделаем, то получим **`null`**:
```js
console.log(pageText.nodeValue);    // null
```

Потому что полученный нами элемент не является текстовым узлом. Текстовый узел располагается внутри элемента `pageText`. И чтобы получить текст, нам надо обратиться к этому текстовому узлу через коллекцию `childNodes`:
```js
for(textNode of pageText.childNodes){
    console.log(textNode.nodeValue);
}
```

Хотя мы так можем получить текстовое содержимое элементов, но это не самый оптимальный способ, и далее мы рассмотрим другие способы.[^8.4]

##### Навигация только по элементам
Навигационные свойства, описанные выше, относятся ко *всем* узлам в документе. В частности, в `childNodes` находятся и текстовые узлы и узлы-элементы и узлы-комментарии, если они есть.

Но для большинства задач текстовые узлы и узлы-комментарии нам не нужны. Мы хотим манипулировать узлами-элементами, которые представляют собой теги и формируют структуру страницы.

Поэтому давайте рассмотрим дополнительный набор ссылок, которые учитывают только *узлы-элементы*:

![DOM links elements](../svg/dom-links-elements.svg)

Эти ссылки похожи на те, что раньше, только в ряде мест стоит слово `Element`:

- `children` – коллекция детей, которые являются элементами.
- `firstElementChild`, `lastElementChild` – первый и последний дочерний элемент.
- `previousElementSibling`, `nextElementSibling` – соседи-элементы.
- `parentElement` – родитель-элемент.

!!! info "Зачем нужен `parentElement`? Разве может родитель быть *не* элементом?"

    Свойство `parentElement` возвращает родитель-элемент, а `parentNode` возвращает «любого родителя». Обычно эти свойства одинаковы: они оба получают родителя.

    За исключением `document.documentElement`:
    ```js
    alert( document.documentElement.parentNode ); // выведет document
    alert( document.documentElement.parentElement ); // выведет null
    ```

    Причина в том, что родителем корневого узла `document.documentElement` (`<html>`) является `document`. Но `document` – это не узел-элемент, так что `parentNode` вернёт его, а `parentElement` нет.

    Эта деталь может быть полезна, если мы хотим пройти вверх по цепочке родителей от произвольного элемента `elem` к `<html>`, но не до `document`:
    ```js
    while(elem = elem.parentElement) { // идти наверх до <html>
    alert( elem );
    }
    ```

Изменим один из примеров выше: заменим `childNodes` на `children`. Теперь цикл выводит только элементы:
```html
<html>
<body>
  <div>Начало</div>

  <ul>
    <li>Информация</li>
  </ul>

  <div>Конец</div>

  <script>
    for (let elem of document.body.children) {
      alert(elem); // DIV, UL, DIV, SCRIPT
    }
  </script>
  ...
</body>
</html>
```

#### Специфичные навигационные свойства
До сих пор мы описывали основные навигационные ссылки.

Некоторые типы DOM-элементов предоставляют для удобства дополнительные свойства, специфичные для их типа.

Таблицы – отличный пример таких элементов.

**Элемент `<table>`**, в дополнение к свойствам, о которых речь шла выше, поддерживает следующие:

- `table.rows` – коллекция строк `<tr>` таблицы.
- `table.caption`/`tHead`/`tFoot` – ссылки на элементы таблицы `<caption>`, `<thead>`, `<tfoot>`.
- `table.tBodies` – коллекция элементов таблицы `<tbody>` (по спецификации их может быть больше одного).

**`<thead>`**, **`<tfoot>`**, **`<tbody>`** предоставляют свойство `rows`:

- `tbody.rows` – коллекция строк `<tr>` секции.

**`<tr>`**:

- `tr.cells` – коллекция `<td>` и `<th>` ячеек, находящихся внутри строки `<tr>`.
- `tr.sectionRowIndex` – номер строки `<tr>` в текущей секции `<thead>`/`<tbody>`/`<tfoot>`.
- `tr.rowIndex` – номер строки `<tr>` в таблице (включая все строки таблицы).

**`<td>` и `<th>`**:

- `td.cellIndex` – номер ячейки в строке `<tr>`.

Пример использования:
```html
<table id="table">
  <tr>
    <td>один</td><td>два</td>
  </tr>
  <tr>
    <td>три</td><td>четыре</td>
  </tr>
</table>

<script>
  // выводит содержимое первой строки, второй ячейки
  alert( table.rows[0].cells[1].innerHTML ) // "два"
</script>
```

Спецификация: [tabular data](https://html.spec.whatwg.org/multipage/tables.html).

Существуют также дополнительные навигационные ссылки для HTML-форм. Мы рассмотрим их позже, когда начнём работать с формами.

#### Итого
Получив DOM-узел, мы можем перейти к его ближайшим соседям используя навигационные ссылки.

Есть два основных набора ссылок:

- Для всех узлов: `parentNode`, `childNodes`, `firstChild`, `lastChild`, `previousSibling`, `nextSibling`.
- Только для узлов-элементов: `parentElement`, `children`, `firstElementChild`, `lastElementChild`, `previousElementSibling`, `nextElementSibling`.

Некоторые виды DOM-элементов, например таблицы, предоставляют дополнительные ссылки и коллекции для доступа к своему содержимому.[^dom-navigation]

#### Задачи

##### Дочерние элементы в DOM
Для страницы:
```html
<html>
<body>
  <div>Пользователи:</div>
  <ul>
    <li>Джон</li>
    <li>Пит</li>
  </ul>
</body>
</html>
```

Напишите код, как получить…

- элемент `<div>`?
- `<ul>`?
- второй `<li>` (с именем Пит)?

<details>
<summary>Решение</summary>

Есть несколько способов для получения элементов, например:

DOM-узел элемента `<div>`:
```js
document.body.firstElementChild
// или
document.body.children[0]
// или (первый узел пробел, поэтому выбираем второй)
document.body.childNodes[1]
```

DOM-узел элемента `<ul>`:
```js
document.body.lastElementChild
// или
document.body.children[1]
```

Второй `<li>` (с именем Пит):
```js
// получаем <ul>, и его последнего ребёнка
document.body.lastElementChild.lastElementChild
```

</details>

##### Вопрос о соседях
Если `elem` – произвольный узел DOM-элемента…

- Правда, что `elem.lastChild.nextSibling` всегда равен `null`?
- Правда, что `elem.children[0].previousSibling` всегда равен `null`?

<details>
<summary>Решение</summary>

1. Да. Верно. Элемент `elem.lastChild` всегда последний, у него нет ссылки `nextSibling`.
2. Нет. Неверно. Потому что `elem.children[0]` – потомок-элемент. Но перед ним могут быть другие узлы. Например, `previousSibling` может быть текстовым узлом.

Обратите внимание, что в обоих случаях, если детей нет, то будет ошибка. При этом `elem.lastChild` равен `null`, а значит – ошибка при попытке доступа к `elem.lastChild.nextSibling`.

</details>

##### Выделите ячейки по диагонали
Напишите код, который выделит красным цветом все ячейки в таблице по диагонали.

Вам нужно получить из таблицы `<table>` все диагональные `<td>` и выделить их, используя код:
```js
//  в переменной td находится DOM-элемент для тега <td>
td.style.backgroundColor = 'red';
```

Должно получиться так:

![Table](../img/table-diagonal.png)

<details>
<summary>Решение</summary>

Для получения доступа к диагональным ячейкам таблицы используем свойства `rows` и `cells`.

[Исходный код](../src/10_dom/diagonal-selection.html)

</details>

### Элементы
Для работы с элементами на веб-странице мы можем использовать как функциональность типа `Node`, который представляет любой узел веб-страницы, так и функциональность типа **`HTMLElement`**, который собственно представляет элемент. То есть объекты `HTMLElement` — это фактически те же самые узлы — объекты `Node`, у которых тип узла (свойство `nodeType`) равно 1.

Каждый элемент веб-страницы соответствует определенному типу в JavaScript. Но все эти типы являются подтипами типа **`HTMLElement`**, который определяет базовую функциональность элементов. Вкратце перечислим актуальные типы элементов:

| Тег | Тип
-- | --
`<a>` | `HTMLAnchorElement`
`<abbr>` | `HTMLElement`
`<address>` | `HTMLElement`
`<area>` | `HTMLAreaElement`
`<audio>` | `HTMLAudioElement`
`<b>` | `HTMLElement`
`<base>` | `HTMLBaseElement`
`<bdo>` | `HTMLElement`
`<blockquote>` | `HTMLQuoteElement`
`<body>` | `HTMLBodyElement`
`<br>` | `HTMLBRElement`
`<button>` | `HTMLButtonElement`
`<caption>` | `HTMLTableCaptionElement`
`<canvas>` | `HTMLCanvasElement`
`<cite>` | `HTMLElement`
`<code>` | `HTMLElement`
`<col>`, `<colgroup`> | `HTMLTableColElement`
`<data>` | `HTMLDataElement`
`<datalist>` | `HTMLDataListElement`
`<dd>` | `HTMLElement`
`<del>` | `HTMLModElement`
`<dfn>` | `HTMLElement`
`<div>` | `HTMLDivElement`
`<dl>` | `HTMLDListElement`
`<dt>` | `HTMLElement`
`<em>` | `HTMLElement`
`<embed>` | `HTMLEmbedElement`
`<fieldset>` | `HTMLFieldSetElement`
`<form>` | `HTMLFormElement`
`<h1>`, `<h2>`, `<h3>`, `<h4>`, `<h5>`, `<h6>` | `HTMLHeadingElement`
`<head>` | `HTMLHeadElement`
`<hr>` | `HTMLHRElement`
`<html>` | `HTMLHtmlElement`
`<i>` | `HTMLElement`
`<iframe>` | `HTMLIFrameElement`
`<img>` | `HTMLImageElement`
`<input>` | `HTMLInputElement`
`<ins>` | `HTMLModElement`
`<kbd>` | `HTMLElement`
`<keygen>` | `HTMLKeygenElement`
`<label>` | `HTMLLabelElement`
`<legend>` | `HTMLLegendElement`
`<li>` | `HTMLLIElement`
`<link>` | `HTMLLinkElement`
`<map>` | `HTMLMapElement`
`<media>` | `HTMLMediaElement`
`<meta>` | `HTMLMetaElement`
`<meter>` | `HTMLMeterElement`
`<noscript>` | `HTMLElement`
`<object>` | `HTMLObjectElement`
`<ol>` | `HTMLOListElement`
`<optgroup>` | `HTMLOptGroupElement`
`<option>` | `HTMLOptionElement`
`<output>` | `HTMLOutputElement`
`<p>` | `HTMLParagraphElement`
`<param>` | `HTMLParamElement`
`<pre>` | `HTMLPreElement`
`<progress>` | `HTMLProgressElement`
`<q>` | `HTMLQuoteElement`
`<s>` | `HTMLElement`
`<samp>` | `HTMLElement`
`<script>` | `HTMLScriptElement`
`<select>` | `HTMLSelectElement`
`<small>` | `HTMLElement`
`<source>` | `HTMLSourceElement`
`<span>` | `HTMLSpanElement`
`<strong>` | `HTMLElement`
`<style>` | `HTMLStyleElement`
`<sub>` | `HTMLElement`
`<sup>` | `HTMLElement`
`<table>` | `HTMLTableElement`
`<tbody>` | `HTMLTableSectionElement`
`<td>` | `HTMLTableCellElement`
`<textarea>` | `HTMLTextAreaElement`
`<tfoot>` | `HTMLTableSectionElement`
`<th>` | `HTMLTableHeaderCellElement`
`<thead>` | `HTMLTableSectionElement`
`<time>` | `HTMLTimeElement`
`<title>` | `HTMLTitleElement`
`<tr>` | `HTMLTableRowElement`
`<track>` | `HTMLTrackElement`
`<ul>` | `HTMLUListElement`
`<var>` | `HTMLElement` / `HTMLUnknownElement`
`<video>` | `HTMLVideoElement`

Мы можем получить конкретный тип элемента с помощью метода **`Object.getPrototypeOf()`**:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <h1 id="header">Home Page</h1>
    <script>
    const header = document.getElementById("header");
    console.log(Object.getPrototypeOf(header)); // HTMLHeadingElement
    </script>
</body>
</html>
```

#### Свойства элементов
Тип `Element` предоставляет ряд свойств, которые хранят информацию об элементе:

- **`tagName`**: возвращает тег элемента

- **`textContent`**: представляет текстовое содержимое элемента

- **`innerText`**: представляет текстовое содержимое элемента (аналогично `textContent`)

- **`innerHTML`**: представляет html-код элемента

Одним из ключевых свойств объекта `Element` является свойство **`tagName`**, которое возвращает тег элемента:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <h1 id="header">Home Page</h1>
    <script>
    const header = document.getElementById("header");
    console.log(header.tagName);  // H1
    </script>
</body>
</html>
```

#### Управление текстом элемента

##### Свойство textContent
Свойство **`textContent`** позволяет получить или изменить текстовое содержимое элемента:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <h1 id="header">Home Page</h1>
    <script>
    const header = document.getElementById("header");
    // получаем текст элемента
    console.log(header.textContent);  // Home Page
    // изменяем текст элемента
    header.textContent = "Hello World";
    </script>
</body>
</html>
```

Свойство `textContent` предоставляет доступ к *тексту* внутри элемента за вычетом всех `<`*`тегов`*`>`.

Например:
```html
<div id="news">
  <h1>Срочно в номер!</h1>
  <p>Марсиане атаковали человечество!</p>
</div>

<script>
  // Срочно в номер! Марсиане атаковали человечество!
  alert(news.textContent);
</script>
```

Как мы видим, возвращается только текст, как если бы все `<`*`теги`*`>` были вырезаны, но текст в них остался.

На практике редко появляется необходимость читать текст таким образом.

**Намного полезнее возможность записывать текст в `textContent`, т.к. позволяет писать текст «безопасным способом».**

Представим, что у нас есть произвольная строка, введённая пользователем, и мы хотим показать её.

- С `innerHTML` вставка происходит «как HTML», со всеми HTML-тегами.
- С `textContent` вставка получается «как текст», все символы трактуются буквально.

Сравним два тега `div`:
```html
<div id="elem1"></div>
<div id="elem2"></div>

<script>
  let name = prompt("Введите ваше имя?", "<b>Винни-пух!</b>");

  elem1.innerHTML = name;
  elem2.textContent = name;
</script>
```

1. В первый `<div>` имя приходит «как HTML»: все теги стали именно тегами, поэтому мы видим имя, выделенное жирным шрифтом.
2. Во второй `<div>` имя приходит «как текст», поэтому мы видим `<b>Винни-пух!</b>`.

В большинстве случаев мы рассчитываем получить от пользователя текст и хотим, чтобы он интерпретировался как текст. Мы не хотим, чтобы на сайте появлялся произвольный HTML-код. Присваивание через `textContent` – один из способов от этого защититься.

##### Свойство innerText
Аналогично можно использовать другое свойство для управление текстом — **`innerText`**:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <h1 id="header">Home Page</h1>
    <script>
    const header = document.getElementById("header");
    // получаем текст элемента
    console.log(header.innerText);  // Home Page
    // изменяем текст элемента
    header.innerText = "Hello World2";
    </script>
</body>
</html>
```

Тем не менее между **`textContent`** и **`innerText`** есть некоторые различия:

- **`textContent`** получает содержимое всех элементов, включая `<script>` и `<style>`, тогда как **`innerText`** этого не делает

- **`innerText`** умеет считывать стили и не возвращает содержимое скрытых элементов, тогда как **`textContent`** этого не делает.

- **`innerText`** позволяет получить CSS, а **`textContent`** — нет.

#### Управление кодом HTML

##### innerHTML: содержимое элемента
Ни **`textContent`**, ни **`innerText`** не позволяют ни получить, ни изменить код html элемента.[^8.6] Например:
```js
header.innerText = "<span style='color:navy;'>Hello World</span>";
```

Это изменит только текст, но не html код. Для управления html применяется свойство **`innerHTML`**:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <h1 id="header">Home Page</h1>
    <script>
    const header = document.getElementById("header");
    // получаем html-код элемента
    console.log(header.innerHTML);  // Home Page
    // изменяем html-код элемента
    header.innerHTML = "<span style='color:navy;'>Hello World</span>";
    </script>
</body>
</html>
```

Свойство [`innerHTML`](https://w3c.github.io/DOM-Parsing/#widl-Element-innerHTML) позволяет получить HTML-содержимое элемента в виде строки.

Мы также можем изменять его. Это один из самых мощных способов менять содержимое на странице.

Пример ниже показывает содержимое `document.body`, а затем полностью заменяет его:
```html
<body>
  <p>Параграф</p>
  <div>DIV</div>

  <script>
    alert( document.body.innerHTML );         // читаем текущее содержимое
    document.body.innerHTML = 'Новый BODY!';  // заменяем содержимое
  </script>

</body>
```

Мы можем попробовать вставить некорректный HTML, браузер исправит наши ошибки:
```html
<body>

  <script>
    document.body.innerHTML = '<b>тест';    // забыли закрыть тег
    alert( document.body.innerHTML );       // <b>тест</b> (исправлено)
  </script>

</body>
```

!!! info "Скрипты не выполнятся"

    Если `innerHTML` вставляет в документ тег `<script>` – он становится частью HTML, но не запускается.

##### innerHTML+= осуществляет перезапись

Мы можем добавить HTML к элементу, используя *`elem`*`.innerHTML+="ещё html"`.

Вот так:
```js
chatDiv.innerHTML += "<div>Привет<img src='smile.gif'/> !</div>";
chatDiv.innerHTML += "Как дела?";
```

На практике этим следует пользоваться с большой осторожностью, так как фактически происходит *не* добавление, а перезапись.

Технически эти две строки делают одно и то же:
```js
elem.innerHTML += "...";
// это более короткая запись для:
elem.innerHTML = elem.innerHTML + "..."
```

Другими словами, `innerHTML+=` делает следующее:

1. Старое содержимое удаляется.
2. На его место становится новое значение `innerHTML` (с добавленной строкой).

**Так как содержимое «обнуляется» и переписывается заново, все изображения и другие ресурсы будут перезагружены.**

В примере `chatDiv` выше строка `chatDiv.innerHTML+="Как дела?"` заново создаёт содержимое HTML и перезагружает *smile.gif* (надеемся, картинка закеширована). Если в `chatDiv` много текста и изображений, то эта перезагрузка будет очень заметна.

Есть и другие побочные эффекты. Например, если существующий текст выделен мышкой, то при переписывании `innerHTML` большинство браузеров снимут выделение. А если это поле ввода `<input>` с текстом, введённым пользователем, то текст будет удалён. И так далее.

К счастью, есть и другие способы добавить содержимое, не использующие `innerHTML`, которые мы изучим позже.

##### outerHTML: HTML элемента целиком
Свойство `outerHTML` содержит HTML элемента целиком. Это как `innerHTML` плюс сам элемент.

Посмотрим на пример:
```html
<div id="elem">Привет <b>Мир</b></div>

<script>
  alert(elem.outerHTML); // <div id="elem">Привет <b>Мир</b></div>
</script>
```

**Будьте осторожны: в отличие от `innerHTML`, запись в `outerHTML` не изменяет элемент. Вместо этого элемент заменяется целиком во внешнем контексте.**

Да, звучит странно, и это действительно необычно, так что рассмотрим это на отдельном примере:
```html
<div>Привет, мир!</div>

<script>
  let div = document.querySelector('div');

  // заменяем div.outerHTML на <p>...</p>
  div.outerHTML = '<p>Новый элемент</p>'; // (*)

  // Содержимое div осталось тем же!
  alert(div.outerHTML); // <div>Привет, мир!</div> (**)
</script>
```

Какая-то магия, да?

В строке `(*)` мы заменили `div` на `<p>Новый элемент</p>`. Во внешнем документе мы видим новое содержимое вместо `<div>`. Но, как видно в строке `(**)`, старая переменная `div` осталась прежней!

Это потому, что использование `outerHTML` не изменяет DOM-элемент, а удаляет его из внешнего контекста и вставляет вместо него новый HTML-код.

То есть, при `div.outerHTML=...` произошло следующее:

- `div` был удалён из документа.
- Вместо него был вставлен другой HTML `<p>Новый элемент</p>`.
- В `div` осталось старое значение. Новый HTML не сохранён ни в какой переменной.

Здесь легко сделать ошибку: заменить `div.outerHTML`, а потом продолжить работать с `div`, как будто там новое содержимое. Но это не так. Подобное верно для `innerHTML`, но не для `outerHTML`.

Мы можем писать в `elem.outerHTML`, но надо иметь в виду, что это не меняет элемент, в который мы пишем. Вместо этого создаётся новый HTML на его месте. Мы можем получить ссылки на новые элементы, обратившись к DOM.

#### Свойство «hidden»
Атрибут и DOM-свойство «hidden» указывает на то, видим ли мы элемент или нет.

Мы можем использовать его в HTML или назначать при помощи JavaScript, как в примере ниже:
```html
<div>Оба тега DIV внизу невидимы</div>

<div hidden>С атрибутом "hidden"</div>

<div id="elem">С назначенным JavaScript свойством "hidden"</div>

<script>
  elem.hidden = true;
</script>
```

Технически, `hidden` работает так же, как `style="display:none"`. Но его применение проще.

Мигающий элемент:
```html
<div id="elem">Мигающий элемент</div>

<script>
  setInterval(() => elem.hidden = !elem.hidden, 1000);
</script>
```

#### Другие свойства
У DOM-элементов есть дополнительные свойства, в частности, зависящие от класса:

- `value` – значение для `<input>`, `<select>` и `<textarea>` (`HTMLInputElement`, `HTMLSelectElement`…).
- `href` – адрес ссылки «href» для `<a href="...">` (`HTMLAnchorElement`).
- `id` – значение атрибута «id» для всех элементов (`HTMLElement`).
- …и многие другие…

Например:
```html
<input type="text" id="elem" value="значение">

<script>
  alert(elem.type);   // "text"
  alert(elem.id);     // "elem"
  alert(elem.value);  // значение
</script>
```

Большинство стандартных HTML-атрибутов имеют соответствующее DOM-свойство, и мы можем получить к нему доступ.

Если мы хотим узнать полный список поддерживаемых свойств для данного класса, можно найти их в спецификации. Например, класс `HTMLInputElement` описывается здесь: https://html.spec.whatwg.org/#htmlinputelement.

Если же нам нужно быстро что-либо узнать или нас интересует специфика определённого браузера – мы всегда можем вывести элемент в консоль, используя `console.dir(`*`elem`*`)`, и прочитать все свойства. Или исследовать «свойства DOM» во вкладке Elements браузерных инструментов разработчика.

#### Итого
Каждый DOM-узел принадлежит определённому классу. Классы формируют иерархию. Весь набор свойств и методов является результатом наследования.

Главные свойства DOM-узла:

- `nodeType`

    Свойство `nodeType` позволяет узнать тип DOM-узла. Его значение – числовое: `1` для элементов, `3` для текстовых узлов, и т.д. Только для чтения.

- `nodeName`/`tagName`

    Для элементов это свойство возвращает название тега (записывается в верхнем регистре, за исключением XML-режима). Для узлов-неэлементов `nodeName` описывает, что это за узел. Только для чтения.

- `innerHTML`

    Внутреннее HTML-содержимое узла-элемента. Можно изменять.

- `outerHTML`

    Полный HTML узла-элемента. Запись в *`elem`*`.outerHTML` не меняет *`elem`*. Вместо этого она заменяет его во внешнем контексте.

- `nodeValue`/`data`

    Содержимое узла-неэлемента (текст, комментарий). Эти свойства практически одинаковые, обычно мы используем `data`. Можно изменять.

- `textContent`

    Текст внутри элемента: HTML за вычетом всех `<`*`тегов`*`>`. Запись в него помещает текст в элемент, при этом все специальные символы и теги интерпретируются как текст. Можно использовать для защиты от вставки произвольного HTML кода.

- `hidden`

    Когда значение установлено в `true`, делает то же самое, что и CSS `display:none`.
В зависимости от своего класса DOM-узлы имеют и другие свойства. Например у элементов `<input>` (`HTMLInputElement`) есть свойства `value`, `type`, у элементов `<a>` (`HTMLAnchorElement`) есть `href` и т.д. Большинство стандартных HTML-атрибутов имеют соответствующие свойства DOM.

Большинство стандартных HTML-атрибутов имеют соответствующее DOM-свойство. Впрочем, HTML-атрибуты и свойства DOM не всегда одинаковы, подробнее эта тема будет раскрыта далее.

#### Задачи

##### Считаем потомков
У нас есть дерево, структурированное как вложенные списки `ul`/`li`.

Напишите код, который выведет каждый элемент списка `<li>`:

1. Какой в нём текст (без поддерева)?
2. Какое число потомков – всех вложенных `<li>` (включая глубоко вложенные)?

<details>
<summary>Решение</summary>

Пройдём циклом по всем элементам `<li>`:
```js
for (let li of document.querySelectorAll('li')) {
  ...
}
```

В цикле нам нужно получить текст в каждом элементе `li`. Мы можем прочитать текстовое содержимое элемента списка из первого дочернего узла `li`, который будет текстовым узлом:
```js
for (let li of document.querySelectorAll('li')) {
  let title = li.firstChild.data;

  // переменная title содержит текст элемента <li>
}
```

Так мы сможем получить количество потомков как `li.getElementsByTagName('li').length`.

[Исходный код](../src/10_dom/counting-descendants.html)

</details>

##### Что содержит свойство nodeType?
Что выведет этот код?

```html
<html>

<body>
  <script>
    alert(document.body.lastChild.nodeType);
  </script>
</body>

</html>
```

<details>
<summary>Решение</summary>

Здесь есть подвох.

Во время выполнения `<script>` последним DOM-узлом является `<script>`, потому что браузер ещё не обработал остальную часть страницы.

Поэтому результатом будет `1` (узел-элемент).

```html
<html>

<body>
  <script>
    alert(document.body.lastChild.nodeType);
  </script>
</body>

</html>
```

</details>

##### Тег в комментарии
Что выведет этот код?

```html
<script>
  let body = document.body;

  body.innerHTML = "<!--" + body.tagName + "-->";

  alert( body.firstChild.data ); // что выведет?
</script>
```

<details>
<summary>Решение</summary>

Ответ: **`BODY`**.

```html
<script>
  let body = document.body;

  body.innerHTML = "<!--" + body.tagName + "-->";

  alert( body.firstChild.data ); // BODY
</script>
```

Происходящее по шагам:

1. Заменяем содержимое `<body>` на комментарий. Он будет иметь вид `<!--BODY-->`, т.к. `body.tagName == "BODY"`. Как мы помним, свойство `tagName` в HTML всегда находится в верхнем регистре.
2. Этот комментарий теперь является первым и единственным потомком `body.firstChild`.
3. Значение свойства `data` для элемента-комментария – это его содержимое (внутри `<!--...-->`): "BODY".

</details>

##### Где в DOM-иерархии "document"?
Объектом какого класса является `document`?

Какое место он занимает в DOM-иерархии?

Наследует ли он от `Node` или от `Element`, или может от `HTMLElement`?

<details>
<summary>Решение</summary>

Объектом какого класса является `document`, можно выяснить так:
```js
alert(document); // [object HTMLDocument]
```

Или так:
```js
alert(document.constructor.name); // HTMLDocument
```

Итак, `document` – объект класса `HTMLDocument`.

Какое место HTMLDocument занимает в иерархии?

Можно поискать в документации. Но попробуем выяснить это самостоятельно.

Пройдём по цепочке прототипов по ссылке `__proto__`.

Как мы знаем, методы класса находятся в `prototype` конструктора. Например, в `HTMLDocument.prototype` находятся методы для объектов типа `document`.

Также внутри `prototype` есть ссылка на функцию-конструктор:
```js
alert(HTMLDocument.prototype.constructor === HTMLDocument); // true
```

Чтобы получить имя класса в строковой форме, используем `constructor.name`. Сделаем это для всей цепочки прототипов `document` вверх до класса `Node`:
```js
alert(HTMLDocument.prototype.constructor.name); // HTMLDocument
alert(HTMLDocument.prototype.__proto__.constructor.name); // Document
alert(HTMLDocument.prototype.__proto__.__proto__.constructor.name); // Node
```

Вот и иерархия.

Мы также можем исследовать объект с помощью `console.dir(document)` и увидеть имена функций-конструкторов, открыв `__proto__`. Браузерная консоль берёт их как раз из свойства `constructor`.

</details>

### Поиск элементов на веб-странице
Свойства навигации по DOM хороши, когда элементы расположены рядом. А что, если нет? Как получить произвольный элемент страницы?

Для этого в DOM есть дополнительные методы поиска: `getElement*`, `querySelector*`.[^searching-elements-dom]

Объект `document` предоставляет ряд методов для поиска и управления элементами на веб-странице:

- `getElementById(value)`: выбирает элемент, у которого атрибут `id` равен `value`. Если элемента с таким идентификатором нет, то возвращается `null`.

- `getElementsByTagName(value)`: выбирает все элементы, у которых тег равен `value`. Возвращает список элементов (список типа `NodeList`), который аналогичен массиву.

- `getElementsByClassName(value)`: выбирает все элементы, которые имеют класс `value`. Возвращает список `NodeList`.

- `getElementsByName(value)`: выбирает все элементы, которые называются `value`. Возвращает список `NodeList`.

- `querySelector(value)`: выбирает первый элемент, который соответствует css-селектору `value`.

- `querySelectorAll(value)`: выбирает все элементы, которые соответствуют css-селектору `value`. Возвращает список `NodeList`.

#### Получение элементов по id
Если у элемента есть атрибут `id`, то мы можем получить его вызовом `document.getElementById(id)`, где бы он ни находился.

Например, найдем элемент по id:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <h1 id="header">Home Page</h1>
    <script>
        const headerElement = document.getElementById("header");
        console.log("Text: ", headerElement.innerText); // Text:  Home Page
    </script>
</body>
</html>
```

С помощью вызова `document.getElementById("header")` находим элемент, у которого `id="header"`. А с помощью свойства **`innerText`** можно получить текст найденного элемента.

Например:
```html
<div id="elem">
  <div id="elem-content">Element</div>
</div>

<script>
  // получить элемент
  let elem = document.getElementById('elem');

  // сделать его фон красным
  elem.style.background = 'red';
</script>
```

Также автоматически доступна глобальная переменная с именем, указанным в `id`:
```html
<div id="elem">
  <div id="elem-content">Элемент</div>
</div>

<script>
  // elem - ссылка на элемент с id="elem"
  elem.style.background = 'red';

  // внутри id="elem-content" есть дефис, так что такой id не может служить именем переменной
  // ...но мы можем обратиться к нему через квадратные скобки: window['elem-content']
</script>
```

…Но это только если мы не объявили в JavaScript переменную с таким же именем, иначе она будет иметь приоритет:
```html
<div id="elem"></div>

<script>
  let elem = 5; // теперь elem равен 5, а не <div id="elem">

  alert(elem);  // 5
</script>
```

!!! warning "Не используйте такие глобальные переменные для доступа к элементам"

    Это поведение соответствует стандарту, но поддерживается в основном для совместимости, как осколок далёкого прошлого.

    Браузер пытается помочь нам, смешивая пространства имён JS и DOM. Это удобно для простых скриптов, которые находятся прямо в HTML, но, вообще говоря, не очень хорошо. Возможны конфликты имён. Кроме того, при чтении JS-кода, не видя HTML, непонятно, откуда берётся переменная.

    Далее мы будем обращаться к элементам по `id` в примерах для краткости, когда очевидно, откуда берётся элемент.

    В реальной жизни лучше использовать `document.getElementById`.

!!! info "Значение id должно быть уникальным"

    Значение `id` должно быть уникальным. В документе может быть только один элемент с данным `id`.

    Если в документе есть несколько элементов с одинаковым значением `id`, то поведение методов поиска непредсказуемо. Браузер может вернуть любой из них случайным образом. Поэтому, пожалуйста, придерживайтесь правила сохранения уникальности `id`.

Стоит отметить, что если элемент не найден, то метод возвращает **`null`**. Поэтому перед использованием элемента рекомендуется проверять его на `null`.

!!! warning "Только `document.getElementById`, а не *`anyElem`*`.getElementById`"

    Метод `getElementById` можно вызвать только для объекта `document`. Он осуществляет поиск по `id` по всему документу.

#### Поиск по определенному тегу
Поиск по определенному тегу:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <h1>Home Page</h1>
    <p>Первый абзац</p>
    <p>Второй абзац</p>
    <script>
        const paragraphs = document.getElementsByTagName("p");

        for (p of paragraphs) {
            console.log(p.innerText);   // выводим текст параграфа
        }
    </script>
</body>
</html>
```

С помощью вызова `document.getElementsByTagName("p")` находим все элементы параграфов. Этот вызов возвращает список типа `NodeList`, который во многом аналогичен массиву и который содержит найденные элементы. Чтобы получить отдельные элементы этого списка, можно пробежаться по этому списку в цикле.

Консольный вывод:
```
Первый абзац
Второй абзац
```

Если нам надо получить только первый элемент, то можно взять первый элемент найденной коллекции объектов по индексу:
```js
const p = document.getElementsByTagName("p")[0];
console.log(p.innerText);
```

Если элементов с указанным тегом нет на странице, то возвращается пустой список. С помощью свойства **`length`** (как и в случае массивов) можно проверить количество найденных элементов:
```js
const paragraphs = document.getElementsByTagName("p");
console.log(paragraphs.length);
```

Конечно, для перебора списка можно использовать и другие виды циклов:
```js
const paragraphs = document.getElementsByTagName("p");
for (let i=0; i < paragraphs.length; i++) {
    console.log(paragraphs[i].innerText);
}
```

#### Получение элементов по классу
Получение элементов по классу:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <h1>Home Page</h1>
    <p class="text">Page Text</p>
    <p class="contacts">Email: supercorp@zmail.com</p>
    <p class="contacts">Phone: +1-234-567-8901</p>
    <script>
        const contacts = document.getElementsByClassName("contacts");

        for (contact of contacts) {
            console.log(contact.innerText);
        }
    </script>
</body>
</html>
```

В данном случае выбираем все элементы с классом "contacts". Консольный вывод:
```
Email: supercorp@zmail.com
Phone: +1-234-567-8901
```

#### Поиск элементов по атрибуту name
Метод **`getElementsByName()`** позволяет получить список из элементов по имени — атрибуту **`name`**. Данный метод применяется к элементам форм. Например:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <form>
        <p>Language:</p>
        <input type="radio" name="lang" value="Java">
        <label>Java</label>
        <br>
        <input type="radio" name="lang" value="JavaScript" checked>
        <label>JavaScript</label>
        <br>
        <input type="radio" name="lang" value="PHP">
        <label>PHP</label>
        <br>
    </form>
    <script>
    // выбираем все элементы с атрибутом name="lang"
    const langs = document.getElementsByName("lang");
    for (lang of langs) {
        console.log(lang.value);    // получаем значение атрибута value
    }
    </script>
</body>
</html>
```

В данном случае выбираем все элементы, у которых атрибут `name` равен "lang". В примере выше это радиокнопки. Затем на консоль выводим значение атрибута `value` каждого полученного элемента. Консольный вывод:
```
Java
JavaScript
PHP
```

Стоит отметить, что этот метод может работать несколько иначе в старых браузерах типа Internet Explorer или Opera. В частности, он выбирает элемент, если не только его атрибут `name` соответствует переданному значению, но и атрибут `id`.

#### Поиск элементов по селектору CSS

##### querySelectorAll

Самый универсальный метод поиска – это *`elem`*`.querySelectorAll(`*`css`*`)`, он возвращает все элементы внутри *`elem`*, удовлетворяющие данному CSS-селектору.

Следующий запрос получает все элементы `<li>`, которые являются последними потомками в `<ul>`:
```html
<ul>
  <li>Этот</li>
  <li>тест</li>
</ul>
<ul>
  <li>полностью</li>
  <li>пройден</li>
</ul>
<script>
  let elements = document.querySelectorAll('ul > li:last-child');

  for (let elem of elements) {
    alert(elem.innerHTML); // "тест", "пройден"
  }
</script>
```

Этот метод действительно мощный, потому что можно использовать любой CSS-селектор.

!!! info "Псевдоклассы тоже работают"

    Псевдоклассы в CSS-селекторе, в частности `:hover` и `:active`, также поддерживаются. Например, `document.querySelectorAll(':hover')` вернёт коллекцию (в порядке вложенности: от внешнего к внутреннему) из текущих элементов под курсором мыши.

##### querySelector

Метод *`elem`*`.querySelector(`*`css`*`)` возвращает первый элемент, соответствующий данному CSS-селектору.

Выбор по селектору CSS:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <div class="annotation">
        <p>Аннотация статьи</p>
    </div>
    <div class="text">
        <p>Первый абзац</p>
        <p>Второй абзац</p>
    </div>
    <script>
        const elem = document.querySelector(".annotation p");
        console.log(elem.innerText);    // Аннотация статьи
    </script>
</body>
</html>
```

Чтобы получить все элементы по селектору, можно подобным образом использовать метод `document.querySelectorAll`, который возвращает список `NodeList` из найденных элементов:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <div class="annotation">
        <p>Аннотация статьи</p>
    </div>
    <div class="text">
        <p>Первый абзац</p>
        <p>Второй абзац</p>
    </div>
    <script>
        const elems = document.querySelectorAll(".text p");
        for (elem of elems) {
            console.log(elem.innerText);
        }
    </script>
</body>
</html>
```

Вывод браузера:
```
Первый абзац
Второй абзац
```

Таким образом, выражение `document.querySelector(".annotation p")` находит элемент, который соответствует селектору `.annotation p`. Если на странице несколько элементов, соответствующих селектору, то метод выберет первый из них.

Иначе говоря, результат такой же, как при вызове *`elem`*`.querySelectorAll(`*`css`*`)[0]`, но он сначала найдёт все элементы, а потом возьмёт первый, в то время как *`elem`*`.querySelector` найдёт только первый и остановится. Это быстрее, кроме того, его короче писать.

##### Селекторы CSS
Перечислим вкратце список базовых CSS-селекторов, которые можно применять для поиска элементов:

- `*`: выбирает все элементы

- `E`: выбирает все элементы типа `E`

- `[a]`: выбирает все элементы с атрибутом `a`

- `[a="b"]`: выбирает все элементы, в которых атрибут `a` имеет значение `b`

- `[a~="b"]`: выбирает все элементы, в которых атрибут `a` имеет список значений, и одно из этих значений равно `b`

- `[a^="b"]`: выбирает все элементы, в которых значение атрибута `a` начинается на `b`

- `[a$="b"]`: выбирает все элементы, в которых значение атрибута `a` завершается на `b`

- `[a*="b"]`: выбирает все элементы, в которых значение атрибута `a` содержит подстроку `b`

- `[a|="b"]`: выбирает все элементы, в которых значение атрибута `a` представляет ряд значений, разделенных дефисами, и первое из этих значений равно `b`

- `:root`: выбирает корневой элемент документа

- `:nth-child(n)`: выбирает `n`-ый вложенный элемент (отсчет идет с начала)

- `:nth-last-child(n)`: выбирает `n`-ый вложенный элемент (отсчет идет с конца)

- `:nth-of-type(n)`: выбирает `n`-ый сестринский элемент типа `type` (отсчет идет с начала)

- `:nth-last-of-type(n)`: выбирает `n`-ый сестринский элемент типа `type` (отсчет идет с конца)

- `:first-child`: выбирает первый вложенный элемент

- `:last-child`: выбирает последний вложенный элемент

- `:first-of-type`: выбирает первый сестринский элемент типа `type`

- `:last-of-type`: выбирает последний сестринский элемент типа `type`

- `:only-child`: выбирает все элементы, которые имеют только один вложенный элемент

- `:only-of-type`: выбирает все сестринские элементы типа `type`

- `:empty`: выбирает все элементы, которые не имеют вложенных элементов

- `:link`: выбирает все ссылки, которые еще не были нажаты

- `:visited`: выбирает все ссылки, которые уже были нажаты

- `:active`: выбирает все ссылки, которые в текущий момент активны (нажимаются)

- `:hover`: выбирает все ссылки, над которыми в текущий момент находится курсор

- `:focus`: выбирает все элементы, которые в текущий момент получили фокус

- `:target`: выбирает все элементы, к которым можно обратиться с помощью адресов url внутри страницы

- `:lang(en)`: выбирает все элементы, в которых атрибут `lang` имеет значение "en"

- `:enabled`: выбирает все элементы форм, которые доступны для взаимодействия

- `:disabled`: выбирает все элементы форм, которые НЕ доступны для взаимодействия

- `:checked`: выбирает все флажки (чекбоксы) и радиокнопки, которые отмечены

- `.class`: выбирает все элементы с классом `class`

- `#id`: выбирает все элементы с идентификтором `id`

- `:not(s)`: выбирает все элементы, которые не соответствуют селектору `s`

- `E F`: выбирает все элементы типа `F`, которые встречаются в элементах типа `E`

- `E > F`: выбирает все элементы типа `F`, которые являются вложенными в элементы типа `E`

- `E + F`: выбирает все элементы типа `F`, которые располагаются сразу после элементов типа `E`

- `E ~ F`: ввыбирает все элементы типа `F`, которые являются сестринскими по отношению к элементам типа `E`

#### Поиск во вложенных элементах
Подобным образом мы можем искать элементы не только во всем документе, но и в отдельных элементах на веб-странице. Например:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <div id="article">
        <h1 id="header">Home Page</h1>
        <p class="text">Page Text 1</p>
        <p class="text">Page Text 2</p>
    </div>
    <div id="footer">
        <p class="text">Footer Text</p>
    </div>
    <script>
    // получаем элемент с id="article"
    const article = document.getElementById("article");
    // в этом элементе получаем все элементы с class="text"
    const articleContent = article.getElementsByClassName("text");
    for(p of articleContent){
        console.log(p);
    }
    </script>
</body>
</html>
```

В данном случае мы сначала получаем элемент с `id="article"`, затем внутри этого элемента ищем все элементы с `class="text"`. В результате консоль выведет два элемента:
```
<p class="text">Page Text 1</p>
<p class="text">Page Text 2</p>
```

#### Поиск соответствия: `matches`
Предыдущие методы искали по DOM.

Метод [*`elem`*`.matches(css)`](https://dom.spec.whatwg.org/#dom-element-matches) ничего не ищет, а проверяет, удовлетворяет ли *`elem`* CSS-селектору, и возвращает `true` или `false`.

Этот метод удобен, когда мы перебираем элементы (например, в массиве или в чём-то подобном) и пытаемся выбрать те из них, которые нас интересуют.

Например:
```html
<a href="http://example.com/file.zip">...</a>
<a href="http://ya.ru">...</a>

<script>
  // может быть любая коллекция вместо document.body.children
  for (let elem of document.body.children) {
    if (elem.matches('a[href$="zip"]')) {
      alert("Ссылка на архив: " + elem.href );
    }
  }
</script>
```

#### Ближайший предок: `closest`
<dfn title="предок">Предки</dfn> элемента – родитель, родитель родителя, его родитель и так далее. Вместе они образуют цепочку иерархии от элемента до вершины.

Метод *`elem`*`.closest(`*`css`*`)` ищет ближайшего предка, который соответствует CSS-селектору. Сам элемент также включается в поиск.

Другими словами, метод `closest` поднимается вверх от элемента и проверяет каждого из родителей. Если он соответствует селектору, поиск прекращается. Метод возвращает либо предка, либо `null`, если такой элемент не найден.

Например:
```html
<h1>Содержание</h1>

<div class="contents">
  <ul class="book">
    <li class="chapter">Глава 1</li>
    <li class="chapter">Глава 2</li>
  </ul>
</div>

<script>
  let chapter = document.querySelector('.chapter'); // LI

  alert(chapter.closest('.book')); // UL
  alert(chapter.closest('.contents')); // DIV

  alert(chapter.closest('h1')); // null (потому что h1 - не предок)
</script>
```

#### Замечания по поводу использования методов
Таким образом, существует множество методов поиска элементов по тегу, классу и так далее. Может возникнуть вопрос, какой из них лучше использовать. Стоит отметить, что из всех этих способов выбор по id обычно самый быстрый. При всех прочих условиях лучше выбирать метод `getElementById()`.

Также стоит отметить, что остальные методы `getElementsBy*` скорее исторические, так как `querySelector` более чем эффективен. Здесь они рассмотрены для полноты картины, также они могут встретиться в старом коде.

- `elem.getElementsByTagName(`*`tag`*`)` ищет элементы с данным тегом и возвращает их коллекцию. Передав "`*`" вместо тега, можно получить всех потомков.
- `elem.getElementsByClassName(`*`className`*`)` возвращает элементы, которые имеют данный CSS-класс.
- `document.getElementsByName(`*`name`*`)` возвращает элементы с заданным атрибутом name. Очень редко используется.

Например:
```js
// получить все элементы div в документе
let divs = document.getElementsByTagName('div');
```

Найдём все `input` в таблице:
```html
<table id="table">
  <tr>
    <td>Ваш возраст:</td>

    <td>
      <label>
        <input type="radio" name="age" value="young" checked> младше 18
      </label>
      <label>
        <input type="radio" name="age" value="mature"> от 18 до 50
      </label>
      <label>
        <input type="radio" name="age" value="senior"> старше 60
      </label>
    </td>
  </tr>
</table>

<script>
  let inputs = table.getElementsByTagName('input');

  for (let input of inputs) {
    alert( input.value + ': ' + input.checked );
  }
</script>
```

!!! warning "Не забываем про букву "s"!"

    Одна из самых частых ошибок начинающих разработчиков (впрочем, иногда и не только) – это забыть букву "s". То есть пробовать вызывать метод `getElementByTagName` вместо `getElementsByTagName`.

    Буква "s" отсутствует в названии метода `getElementById`, так как в данном случае возвращает один элемент. Но `getElementsByTagName` вернёт список элементов, поэтому "s" обязательна.

Ищем элементы с классом `.article`:
```html
<form name="my-form">
  <div class="article">Article</div>
  <div class="long article">Long article</div>
</form>

<script>
  // ищем по имени атрибута
  let form = document.getElementsByName('my-form')[0];

  // ищем по классу внутри form
  let articles = form.getElementsByClassName('article');
  alert(articles.length); // 2, находим два элемента с классом article
</script>
```

Ряд методов — `getElementsByTagName()`, `getElementsByClassName()`, `getElementsByName()`, `querySelectorAll()` — возвращает список элементов в виде объекта `NodeList`, который аналогичен массиву и который мы можем перебрать и получить каждый отдельный элемент из этого набора.

!!! warning "Возвращает коллекцию, а не элемент!"

    Другая распространённая ошибка – написать:

    ```js
    // не работает
    document.getElementsByTagName('input').value = 5;
    ```

    Попытка присвоить значение *коллекции*, а не элементам внутри неё, не сработает.

    Нужно перебрать коллекцию в цикле или получить элемент по номеру и уже ему присваивать значение, например, так:
    ```js
    // работает (если есть input)
    document.getElementsByTagName('input')[0].value = 5;
    ```

Также для оптимизации работы с DOM для того, чтобы избежать повторной выборки одних и тех же элементов, при первой выборке их лучше сохранять в константы/переменные.

#### Живые коллекции и статические списки
Кроме того, следует иметь в виду, что метод `querySelectorAll()` возвращает статический список `NodeList`, тогда как остальные методы возвращают нестатический список. В чем разница? При изменении элементов нестатического списка все модификации сразу же применяются к веб-странице. При изменении элементов из статического списка такие модификации могут примениться не сразу.[^8.2]

Живые коллекции:
- Эффективны для отслеживания динамических списков
- Всегда актуальны
- Медленнее (пересчет при каждом обращении)

Статические коллекции:
- Быстрее для одноразового перебора
- Предсказуемое поведение
- Не "ломаются" при изменении DOM во время итерации

**Правило**: используйте `querySelectorAll()` для массовых операций, "живые" коллекции — для мониторинга состояния DOM.

##### Живые коллекции
Все методы "`getElementsBy*`" возвращают *живую* коллекцию. Такие коллекции всегда отражают текущее состояние документа и автоматически обновляются при его изменении.

В приведённом ниже примере есть два скрипта.

1. Первый создаёт ссылку на коллекцию `<div>`. На этот момент её длина равна `1`.
2. Второй скрипт запускается после того, как браузер встречает ещё один `<div>`, теперь её длина – `2`.

```html
<div>First div</div>

<script>
  let divs = document.getElementsByTagName('div');
  alert(divs.length); // 1
</script>

<div>Second div</div>

<script>
  alert(divs.length); // 2
</script>
```

Браузер хранит коллекцию как ссылки на узлы DOM, а не копии. При обращении к `length` или индексу происходит пересчет соответствующих узлов.

##### Статические коллекции
Напротив, `querySelectorAll` возвращает *статическую* коллекцию. Это похоже на фиксированный массив элементов.

Если мы будем использовать его в примере выше, то оба скрипта вернут длину коллекции, равную `1`:
```html
<div>First div</div>

<script>
  let divs = document.querySelectorAll('div');
  alert(divs.length); // 1
</script>

<div>Second div</div>

<script>
  alert(divs.length); // 1
</script>
```

Теперь мы легко видим разницу. Длина статической коллекции не изменилась после появления нового `div` в документе.

Браузер создает массив указателей на узлы в момент вызова. Дальнейшие изменения DOM не отслеживаются.

#### Итого
Есть 6 основных методов поиска элементов в DOM:

| Метод                  | Ищет по...   | Ищет внутри элемента? | Возвращает живую коллекцию? |
| ---------------------- | ------------ | --------------------- | --------------------------- |
| `querySelector`          | CSS-selector | ✔                     | -                           |
| `querySelectorAll`       | CSS-selector | ✔                     | -                           |
| `getElementById`         | `id`           | -                     | -                           |
| `getElementsByName`      | `name`         | -                     | ✔                           |
| `getElementsByTagName`   | `tag` или '`*`'   | ✔                     | ✔                           |
| `getElementsByClassName` | `class`        | ✔                     | ✔                           |

Безусловно, наиболее часто используемыми в настоящее время являются методы `querySelector` и `querySelectorAll`, но и методы `getElement(s)By*` могут быть полезны в отдельных случаях, а также встречаются в старом коде.

Кроме того:

- Есть метод `elem.matches(css)`, который проверяет, удовлетворяет ли элемент CSS-селектору.
- Метод `elem.closest(css)` ищет ближайшего по иерархии предка, соответствующему данному CSS-селектору. Сам элемент также включён в поиск.

И, напоследок, давайте упомянем ещё один метод, который проверяет наличие отношений между предком и потомком:

- *`elemA`*`.contains(`*`elemB`*`)` вернёт `true`, если *`elemB`* находится внутри *`elemA`* (*`elemB`* потомок *`elemA`*) или когда `elemA==elemB`.

#### Задачи

##### Поиск элементов
Вот документ с таблицей и формой.

Как найти?…

1. Таблицу с `id="age-table"`.
2. Все элементы `label` внутри этой таблицы (их три).
3. Первый `td` в этой таблице (со словом «Age»).
4. Форму `form` с именем `name="search"`.
5. Первый `input` в этой форме.
6. Последний `input` в этой форме.

Откройте страницу [table.html](https://learn.javascript.ru/task/find-elements/table.html) в отдельном окне и используйте для этого браузерные инструменты разработчика.[^searching-elements-dom]

<details>
<summary>Решение</summary>

Есть много путей как это сделать.

Вот некоторые:
```js
// 1. Таблица с `id="age-table"`.
let table = document.getElementById('age-table')

// 2. Все label в этой таблице
table.getElementsByTagName('label')
// или
document.querySelectorAll('#age-table label')

// 3. Первый td в этой таблице
table.rows[0].cells[0]
// или
table.getElementsByTagName('td')[0]
// или
table.querySelector('td')

// 4. Форма с name="search"
// предполагаем, что есть только один элемент с таким name в документе
let form = document.getElementsByName('search')[0]
// или, именно форма:
document.querySelector('form[name="search"]')

// 5. Первый input в этой форме
form.getElementsByTagName('input')[0]
// или
form.querySelector('input')

// 6. Последний input в этой форме
let inputs = form.querySelectorAll('input') // найти все input
inputs[inputs.length-1] // взять последний
```

</details>

### Изменение документа
Модификации DOM – это ключ к созданию «живых» страниц.

Здесь мы увидим, как создавать новые элементы «на лету» и изменять уже существующие.[^modifying-document]

JavaScript предоставляет ряд методов для управления элементами на веб-страницы. В частности, мы можем создавать и добавлять новые элементы или заменять и удалять уже имеющиеся.[^8.5] Рассмотрим методы на примере – а именно, добавим на страницу сообщение, которое будет выглядеть получше, чем `alert`.

Вот такое:
```html
<style>
.alert {
  padding: 15px;
  border: 1px solid #d6e9c6;
  border-radius: 4px;
  color: #3c763d;
  background-color: #dff0d8;
}
</style>

<div class="alert">
  <strong>Всем привет!</strong> Вы прочитали важное сообщение.
</div>
```

![Task custom alert](../img/task-custom-alert.png)

Это был пример HTML. Теперь давайте создадим такой же `div`, используя JavaScript (предполагаем, что стили в HTML или во внешнем CSS-файле).

#### Создание элементов
Для создания элементов объект `document` имеет следующие методы:

- **`createElement(elementName)`**: создает элемент html, тег которого передается в качестве параметра. Возвращает созданный элемент.

  **`document.createElement(`*`tag`*`)`** создаёт новый *элемент* с заданным тегом:
  ```js
  let div = document.createElement('div');
  ```

- **`createTextNode(text)`**: создает и возвращает текстовый узел. В качестве параметра передается текст узла.

  **`document.createTextNode(`*`text`*`)`** создаёт новый *текстовый узел* с заданным текстом:
  ```js
  let textNode = document.createTextNode('А вот и я');
  ```

Создадим элемент с помощью **`createElement`**:
```js
const header = document.createElement("h1");        // создаем заголовок <h1>
console.log(header);  // <h1></h1>
```

Таким образом, переменная `header` будет хранить ссылку на элемент `h1`.

Создадим текстовый узел с помощью **`createTextNode`**:
```js
const  headerText = document.createTextNode("Hello World"); // создаем текстовый узел
console.log( headerText);  // "Hello World"
```

Большую часть времени нам нужно создавать узлы элементов, такие как `div` для сообщения.

В нашем случае сообщение – это `div` с классом `alert` и HTML в нём:
```js
let div = document.createElement('div');
div.className = "alert";
div.innerHTML = "<strong>Всем привет!</strong> Вы прочитали важное сообщение.";
```

Мы создали элемент, но пока он только в переменной. Мы не можем видеть его на странице, поскольку он не является частью документа.

#### Добавление элементов
Однако одного создания элементов недостаточно, их еще надо добавить на веб-страницу.

Чтобы наш `div` появился, нам нужно вставить его где-нибудь в `document`. Например, в `document.body`.

Для этого есть метод `append`, в нашем случае: `document.body.append(div)`.

Вот полный пример:
```html
<style>
.alert {
  padding: 15px;
  border: 1px solid #d6e9c6;
  border-radius: 4px;
  color: #3c763d;
  background-color: #dff0d8;
}
</style>

<script>
  let div = document.createElement('div');
  div.className = "alert";
  div.innerHTML = "<strong>Всем привет!</strong> Вы прочитали важное сообщение.";

  document.body.append(div);
</script>
```

##### Методы вставки
Вот методы для различных вариантов вставки:

- `node.append(`*`...nodes`* или *`strings`*`)` – добавляет узлы или строки в конец `node`,
- `node.prepend(`*`...nodes`* или *`strings`*`)` – вставляет узлы или строки в начало `node`,
- `node.before(`*`...nodes`* или *`strings`*`)` – вставляет узлы или строки до `node`,
- `node.after(`*`...nodes`* или *`strings`*`)` – вставляет узлы или строки после `node`,
- `node.replaceWith(`*`...nodes`* или *`strings`*`)` – заменяет `node` заданными узлами или строками.

Вот пример использования этих методов, чтобы добавить новые элементы в список и текст до/после него:
```html
<ol id="ol">
  <li>0</li>
  <li>1</li>
  <li>2</li>
</ol>

<script>
  ol.before('before'); // вставить строку "before" перед <ol>
  ol.after('after'); // вставить строку "after" после <ol>

  let liFirst = document.createElement('li');
  liFirst.innerHTML = 'prepend';
  ol.prepend(liFirst); // вставить liFirst в начало <ol>

  let liLast = document.createElement('li');
  liLast.innerHTML = 'append';
  ol.append(liLast); // вставить liLast в конец <ol>
</script>
```

![Append methods](../img/append-methods.png)

Наглядная иллюстрация того, куда эти методы вставляют:

![Before prepend append after](../svg/before-prepend-append-after.svg)

Итоговый список будет таким:
```html
before
<ol id="ol">
  <li>prepend</li>
  <li>0</li>
  <li>1</li>
  <li>2</li>
  <li>append</li>
</ol>
after
```

Эти методы могут вставлять несколько узлов и текстовых фрагментов за один вызов.

Например, здесь вставляется строка и элемент:
```html
<div id="div"></div>
<script>
  div.before('<p>Привет</p>', document.createElement('hr'));
</script>
```

Весь текст вставляется *как текст*.

Поэтому финальный HTML будет:
```html
&lt;p&gt;Привет&lt;/p&gt;
<hr>
<div id="div"></div>
```

Другими словами, строки вставляются безопасным способом, как делает это `elem.textContent`.

Поэтому эти методы могут использоваться только для вставки DOM-узлов или текстовых фрагментов.

А что, если мы хотим вставить HTML именно «как html», со всеми тегами и прочим, как делает это `elem.innerHTML`?

##### insertAdjacentHTML/Text/Element
С этим может помочь другой, довольно универсальный метод: `elem.insertAdjacentHTML(where, html)`.

Первый параметр – это специальное слово, указывающее, куда по отношению к `elem` производить вставку. Значение должно быть одним из следующих:

- "`beforebegin`" – вставить html непосредственно перед `elem`,
- "`afterbegin`" – вставить html в начало `elem`,
- "`beforeend`" – вставить html в конец `elem`,
- "`afterend`" – вставить html непосредственно после `elem`.

Второй параметр – это HTML-строка, которая будет вставлена именно «как HTML».

Например:
```html
<div id="div"></div>
<script>
  div.insertAdjacentHTML('beforebegin', '<p>Привет</p>');
  div.insertAdjacentHTML('afterend', '<p>Пока</p>');
</script>
```

…приведёт к:
```html
<p>Привет</p>
<div id="div"></div>
<p>Пока</p>
```

Так мы можем добавлять произвольный HTML на страницу.

Варианты вставки:

![Insert adjacent](../svg/insert-adjacent.svg)

Мы можем легко заметить сходство между этой и предыдущей картинкой. Точки вставки фактически одинаковые, но этот метод вставляет HTML.

У метода есть два брата:

- `elem.insertAdjacentText(where, text)` – такой же синтаксис, но строка `text` вставляется «как текст», вместо HTML,
- `elem.insertAdjacentElement(where, element)` – такой же синтаксис, но вставляет элемент `element`.

Они существуют, в основном, чтобы унифицировать синтаксис. На практике часто используется только `insertAdjacentHTML`. Потому что для элементов и текста у нас есть методы `append`/`prepend`/`before`/`after` – их быстрее написать, и они могут вставлять как узлы, так и текст.

Так что, вот альтернативный вариант показа сообщения:
```html
<style>
.alert {
  padding: 15px;
  border: 1px solid #d6e9c6;
  border-radius: 4px;
  color: #3c763d;
  background-color: #dff0d8;
}
</style>

<script>
  document.body.insertAdjacentHTML("afterbegin", `<div class="alert">
    <strong>Всем привет!</strong> Вы прочитали важное сообщение.
  </div>`);
</script>
```

##### Устаревшие методы вставки
Для добавления элементов мы можем использовать один из методов объекта `Node`:

- **`appendChild(newNode)`**: добавляет новый узел `newNode` в конец коллекции дочерних узлов

- **`insertBefore(newNode, referenceNode)`**: добавляет новый узел `newNode` перед узлом `referenceNode`

###### appendChild
Используем метод **`appendChild()`**:
```js
const header = document.createElement("h1");        // создаем заголовок <h1>
const  headerText = document.createTextNode("Hello World"); // создаем текстовый узел
header.appendChild( headerText); // добавляем в элемент h1 текстовый узел
console.log(header);  // <h1>Hello World</h1>
```

И чтобы добавить созданный элемент на страницу, его надо добавить в уже имеющийся на странице элемент:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <script>
    constheader = document.createElement("h1");     // создаем заголовок <h1>
    const headerText = document.createTextNode("Hello World");  // создаем текстовый узел
    header.appendChild(headerText); // добавляем в элемент h1 текстовый узел
    document.body.appendChild(header);  // // добавляем элемент h1 на страницу в элемент body
    </script>
</body>
</html>
```

Сначала создаем обычный элемент заголовка `h2` и текстовый узел. Затем текстовый узел добавляем в элемент заголовка. Затем заголовок добавляем в элемент **`body`**:

![Добавление элемента на веб-страницу в JavaScript](../img/appendChild.png)

Стоит отметить, что нам необязательно для определения текста внутри элемента создавать дополнительный текстовый узел, так как мы можем воспользоваться свойством **`textContent`** и напрямую ему присвоить текст:
```js
const header = document.createElement("h1");        // создаем заголовок <h1>
header.textContent = "Hello World"; // определяем текст элемента
```

В этом случае текстовый узел будет создан неявно при установке текста.

###### insertBefore
Метод `appendChild()` добавляет элемент в конец контейнера. Чтобы более конкретизировать место для добавления, можно использовать другой метод — **`insertBefore()`**, который добавляет один элемент перед другим элементом. Например, у нас есть следующая страница:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <p>Text 1</p>
    <p>Text 2</p>
</body>
</html>
```

Допустим, нам надо добавить в элемент `body` перед первым параграфом заголовок. Мы можем сделать это так:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <p>Text 1</p>
    <p>Text 2</p>
    <script>
    const header = document.createElement("h1");        // создаем заголовок <h1>
    header.textContent = "Page Header"; // определяем текст элемента
    // получаем первый параграф
    const firstP = document.body.firstElementChild;
    // добавляем элемент h1 перед параграфом firstP
    document.body.insertBefore(header, firstP);
    </script>
</body>
</html>
```

![Добавление элемента на веб-страницу в JavaScript с помощью метода insertBefore](../img/appendChild2.png)

Если нам надо вставить новый узел на второе, третье или любое другое место, то нам надо найти узел, перед которым надо вставлять, с помощью комбинаций свойств `firstElementChild`/`lastElementChild` и `nextSibling`/`previousSibling`.

#### Копирование узлов
Как вставить ещё одно сообщение, подобное тому, что обсуждалось выше?

Мы могли бы создать функцию и поместить код туда. Альтернатива – *клонировать* существующий `div` и изменить текст внутри него (при необходимости). Иногда, когда у нас есть большой элемент, это может быть быстрее и проще.

##### Клонирование элементов
Когда элементы являются довольно сложными по составу, то бывает гораздо проще их скопировать, чем с помощью отдельных вызовов создавать из содержимое. Для копирования уже имеющихся узлов у объекта `Node` можно использовать метод **`cloneNode()`**:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <div id="article">
        <h1>Home Page</h1>
        <p>Text 1</p>
        <p>Text 2</p>
    </div>
    <script>
    const article = document.getElementById("article");
    // получаем последний параграф
    const lastP = article.lastElementChild;
    // клонируем элемент lastP
    const newLastP = lastP.cloneNode(true);
    // изменяем текст
    newLastP.textContent = "Publication Date: 28/10/2023";
    // добавляем в конец элемента article
    article.appendChild(newLastP);
    </script>
</body>
</html>
```

В метод `cloneNode()` в качестве параметра передается логическое значение: если передается `true`, то элемент будет копироваться со всеми дочерними узлами; если передается `false` — то копируется без дочерних узлов. То есть в данном случае мы копируем узел со всем его содержимым и потом добавляем в конец элемента c `id="article"`.

![Клонирование элементов веб-страницы в JavaScript](../img/cloneNode.png)

Пример копирования сообщения:
```html
<style>
.alert {
  padding: 15px;
  border: 1px solid #d6e9c6;
  border-radius: 4px;
  color: #3c763d;
  background-color: #dff0d8;
}
</style>

<div class="alert" id="div">
  <strong>Всем привет!</strong> Вы прочитали важное сообщение.
</div>

<script>
  let div2 = div.cloneNode(true); // клонировать сообщение
  div2.querySelector('strong').innerHTML = 'Всем пока!'; // изменить клонированный элемент

  div.after(div2); // показать клонированный элемент после существующего div
</script>
```

Здесь вызов `elem.cloneNode(true)` создаёт «глубокий» клон элемента – со всеми атрибутами и дочерними элементами. Если мы вызовем `elem.cloneNode(false)`, тогда клон будет без дочерних элементов.[^modifying-document]

##### DocumentFragment
`DocumentFragment` является специальным DOM-узлом, который служит обёрткой для передачи списков узлов.

Мы можем добавить к нему другие узлы, но когда мы вставляем его куда-то, он «исчезает», вместо него вставляется его содержимое.

Например, `getListContent` ниже генерирует фрагмент с элементами `<li>`, которые позже вставляются в `<ul>`:
```html
<ul id="ul"></ul>

<script>
function getListContent() {
  let fragment = new DocumentFragment();

  for(let i=1; i<=3; i++) {
    let li = document.createElement('li');
    li.append(i);
    fragment.append(li);
  }

  return fragment;
}

ul.append(getListContent()); // (*)
</script>
```

Обратите внимание, что на последней строке с `(*)` мы добавляем `DocumentFragment`, но он «исчезает», поэтому структура будет:
```html
<ul>
  <li>1</li>
  <li>2</li>
  <li>3</li>
</ul>
```

`DocumentFragment` редко используется. Зачем добавлять элементы в специальный вид узла, если вместо этого мы можем вернуть массив узлов? Переписанный пример:
```html
<ul id="ul"></ul>

<script>
function getListContent() {
  let result = [];

  for(let i=1; i<=3; i++) {
    let li = document.createElement('li');
    li.append(i);
    result.push(li);
  }

  return result;
}

ul.append(...getListContent()); // append + оператор "..." = друзья!
</script>
```

Здесь `DocumentFragment` упоминается в основном потому, что он используется в некоторых других областях, например, для элемента `template`, который рассматривается в теме, посвященной веб-компонентам.

#### Замена узлов

##### Замена через родителя
Для замены элемента применяется метод **`replaceChild(newNode, oldNode)`** объекта `Node`. Этот метод в качестве первого параметра принимает новый элемент, который заменяет старый элемент `oldNode`, передаваемый в качестве второго параметра.

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <div id="article">
        <p>Home Page</p>
        <p>Text 1</p>
        <p>Text 2</p>
    </div>
    <script>
    const article = document.getElementById("article");
    // находим узел, который будем заменять
    // пусть это будет первый элемент
    const oldNode = article.firstElementChild;
    // создаем новый элемент
    const newNode = document.createElement("h2");
    // определяем для него текст
    newNode.textContent = "Hello World";
    // заменяем старый узел новым
    article.replaceChild(newNode, oldNode);
    </script>
</body>
</html>
```

В данном случае заменяем первый элемент — первый параграф заголовком `h2`:

![Замена элемента веб-страницы в JavaScript](../img/replaceChild.png)

Замену DOM-узла с помощью `replaceChild()` считают устаревшей в некоторых контекстах из-за современных альтернатив и мелких ограничений метода. В старых традициях DOM-API замену узла осуществляли через родительский элемент методом `replaceChild(newChild, oldChild)`. Этот метод имеет необычный порядок аргументов и может быть менее интуитивным, особенно для чтения кода. Рекомендуют переходить на более простые и читаемые способы работать с DOM, такие как `Element.replaceWith()` или более гибкие методы манипуляции, например через удаление и вставку или через создание нового узла и прямую замены на родителе.

##### Замена текущего узла
**`Element.replaceWith()`** — современный и более читаемый способ заменить элемент непосредственно на самом заменяемом узле. Он принимает новые узлы (или текст) как аргументы и возвращает удалённый узел, если нужно обрабатывать результат. Это упрощает код и делает намерение явнее. `Node.replaceChild()` остаётся доступным и совместимым, но чаще выбирают более простой синтаксис через `replaceWith` или манипуляции с родителем в связке с `createElement`/`cloneNode`, чтобы сделать код понятнее и короче.

Замена элемента на другой элемент:

- современно: `currentElement.replaceWith(newElement)`;

- через родителя: `parent.replaceChild(newElement, currentElement)`.

Замена текстового узла:

- современно: `currentText.replaceWith("Новый текст")`;

- через родителя: `parent.replaceChild(document.createTextNode("Новый текст"), currentText)`.

*Заменяет весь элемент на новый контент в DOM*:
```js
// HTML: <span id="target">Старый текст</span>

const target = document.getElementById('target');
target.replaceWith('<strong>Новый текст!</strong>');
// Результат: <strong>Новый текст!</strong>
```

*Заменяет только текстовое содержимое внутри элемента*:
```js
// HTML: <p id="para">Старый текст</p>

const para = document.getElementById('para');
const textNode = para.firstChild;  // Получаем текстовый узел
textNode.replaceWith('Новый текст внутри параграфа!');
// Результат: <p id="para">Новый текст внутри параграфа!</p>
```

Когда использовать:

- `Element.replaceWith()` — когда нужно заменить весь элемент и его позицию

- `textNode.replaceWith()` — когда нужно изменить только содержимое текста

#### Удаление узлов
Для удаления узла есть методы `node.remove()`.

Например, сделаем так, чтобы наше сообщение удалялось через секунду:
```html
<style>
.alert {
  padding: 15px;
  border: 1px solid #d6e9c6;
  border-radius: 4px;
  color: #3c763d;
  background-color: #dff0d8;
}
</style>

<script>
  let div = document.createElement('div');
  div.className = "alert";
  div.innerHTML = "<strong>Всем привет!</strong> Вы прочитали важное сообщение.";

  document.body.append(div);
  setTimeout(() => div.remove(), 1000);
</script>
```

Если нам нужно *переместить* элемент в другое место – нет необходимости удалять его со старого.

**Все методы вставки автоматически удаляют узлы со старых мест.**

Например, давайте поменяем местами элементы:
```html
<div id="first">Первый</div>
<div id="second">Второй</div>
<script>
  // нет необходимости вызывать метод remove
  second.after(first); // берёт #second и после него вставляет #first
</script>
```

##### Удаление элемента
Для удаления элемента также имеется метод **`removeChild(`*`node`*`)`** объекта Node. Этот метод удаляет один из дочерних узлов и возвращает удаленный узел:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <div id="article">
        <h1>Home Page</h1>
        <p>Text 1</p>
        <p>Text 2</p>
    </div>
    <script>
    const article = document.getElementById("article");
    // находим узел, который будем удалять - последний параграф
    const lastP = article.lastElementChild;
    // удаляем узел
    article.removeChild(lastP);
    </script>
</body>
</html>
```

В данном случае удаляется первый параграф из блока `div`. В настоящее время данный метод считается устаревшим по удобству использования (требует родительского элемента) — появились более простые альтернативы:
```js
// Старый способ (Node.removeChild)
const parent = document.getElementById('container');
const child = document.getElementById('target');
parent.removeChild(child);  // Нужно знать родителя

// Современный способ (Element.remove)
document.getElementById('target').remove();  // Элемент удаляет сам себя
```

Следует использовать `element.remove()` для удаления — это стандартный современный подход с 2016 года, а `removeChild()` оставить для случаев, когда нужна ссылка на удаленный узел.

##### Удаление всех элементов
Иногда возникает необходимость удалить все элементы. Для этого перебираем все элементы контейнера и удаляем их (впрочем, есть и более простые способы):
```html
<div id="article">
    <h1>Home Page</h1>
    <p>Text 1</p>
    <p>Text 2</p>
</div>
<script>
const article = document.getElementById("article");

// 1. Классический способ
while(article.firstChild) {
    article.removeChild(article.firstChild);
}

// 2. Современный способ с Element.remove() (рекомендуемый)
while(article.firstChild) {
    article.firstChild.remove();
}

// 3. Самый короткий - textContent = '' (удаляет ВСЕ содержимое разом)
article.textContent = '';

// 4. innerHTML = '' (тоже удаляет всё разом)
article.innerHTML = '';
</script>
```

#### Старая школа
Информация ниже помогает понять старые скрипты, но не нужна для новой разработки.

Есть множество более старых методов вставки и удаления, которые существуют по историческим причинам.

Сейчас уже нет причин их использовать, так как современные методы `append`, `prepend`, `before`, `after`, `remove`, `replaceWith` более гибкие и удобные.

Здесь они упоминаются только потому, что их можно найти во многих старых скриптах:

- **`parentElem.appendChild(node)`**

    Добавляет `node` в конец дочерних элементов `parentElem`.

    Следующий пример добавляет новый `<li>` в конец `<ol>`:
    ```html
    <ol id="list">
      <li>0</li>
      <li>1</li>
      <li>2</li>
    </ol>

    <script>
      let newLi = document.createElement('li');
      newLi.innerHTML = 'Привет, мир!';

      list.appendChild(newLi);
    </script>
    ```

- **`parentElem.insertBefore(node, nextSibling)`**

    Вставляет `node` перед `nextSibling` в `parentElem`.

    Следующий пример вставляет новый элемент перед вторым `<li>`:

    ```html
    <ol id="list">
      <li>0</li>
      <li>1</li>
      <li>2</li>
    </ol>
    <script>
      let newLi = document.createElement('li');
      newLi.innerHTML = 'Привет, мир!';

      list.insertBefore(newLi, list.children[1]);
    </script>
    ```

    Чтобы вставить `newLi` в начало, мы можем сделать вот так:

    ```js
    list.insertBefore(newLi, list.firstChild);
    ```

- **`parentElem.replaceChild(node, oldChild)`**

    Заменяет `oldChild` на `node` среди дочерних элементов `parentElem`.

- **`parentElem.removeChild(node)`**

    Удаляет `node` из `parentElem` (предполагается, что он родитель `node`).

    Этот пример удалит первый `<li>` из `<ol>`:
    ```html
    <ol id="list">
      <li>0</li>
      <li>1</li>
      <li>2</li>
    </ol>

    <script>
      let li = list.firstElementChild;
      list.removeChild(li);
    </script>
    ```

Все эти методы возвращают вставленный/удалённый узел. Другими словами, `parentElem.appendChild(node)` вернёт `node`. Но обычно возвращаемое значение не используют, просто вызывают метод.

#### Несколько слов о «document.write»
Есть ещё один, очень древний метод добавления содержимого на веб-страницу: `document.write`.

Синтаксис:
```html
<p>Где-то на странице...</p>
<script>
  document.write('<b>Привет из JS</b>');
</script>
<p>Конец</p>
```

Вызов `document.write(html)` записывает html на страницу «прямо здесь и сейчас». Строка html может быть динамически сгенерирована, поэтому метод достаточно гибкий. Мы можем использовать JavaScript, чтобы создать полноценную веб-страницу и записать её в документ.

Этот метод пришёл к нам со времён, когда ещё не было ни DOM, ни стандартов… Действительно старые времена. Он всё ещё живёт, потому что есть скрипты, которые используют его.

В современных скриптах он редко встречается из-за следующего важного ограничения:

**Вызов `document.write` работает только во время загрузки страницы.**

Если вызвать его позже, то существующее содержимое документа затрётся.

Например:
```html
<p>Через одну секунду содержимое этой страницы будет заменено...</p>
<script>
  // document.write через 1 секунду
  // вызов происходит после того, как страница загрузится, поэтому метод затирает содержимое
  setTimeout(() => document.write('<b>...Этим.</b>'), 1000);
</script>
```

Так что после того, как страница загружена, он уже непригоден к использованию, в отличие от других методов DOM, которые мы рассмотрели выше.

Это его недостаток.

Есть и преимущество. Технически, когда `document.write` запускается во время чтения HTML браузером, и что-то пишет в документ, то браузер воспринимает это так, как будто это изначально было частью загруженного HTML-документа.

Поэтому он работает невероятно быстро, ведь при этом *нет модификации DOM*. Метод пишет прямо в текст страницы, пока DOM ещё в процессе создания.

Так что, если нам нужно динамически добавить много текста в HTML, и мы находимся на стадии загрузки, и для нас очень важна скорость, это может помочь. Но на практике эти требования редко сочетаются. И обычно мы можем увидеть этот метод в скриптах просто потому, что они старые.

#### Итого
Методы для создания узлов:

- `document.createElement(`*`tag`*`)` – создаёт элемент с заданным тегом,
- `document.createTextNode(`*`value`*`)` – создаёт текстовый узел (редко используется),
- `elem.cloneNode(`*`deep`*`)` – клонирует элемент, если `deep==true`, то со всеми дочерними элементами.

Вставка и удаление:

- `node.append(...nodes or strings)` – вставляет в `node` в конец,
- `node.prepend(...nodes or strings)` – вставляет в `node` в начало,
- `node.before(...nodes or strings)` – вставляет прямо перед `node`,
- `node.after(...nodes or strings)` – вставляет сразу после `node`,
- `node.replaceWith(...nodes or strings)` – заменяет `node`.
`node.remove()` – удаляет `node`.

Устаревшие методы:

- `parent.appendChild(node)`
- `parent.insertBefore(node, nextSibling)`
- `parent.removeChild(node)`
- `parent.replaceChild(newElem, node)`

Все эти методы возвращают `node`.

Если нужно вставить фрагмент HTML, то `elem.insertAdjacentHTML(where, html)` осуществляет вставку в зависимости от `where`:

- "beforebegin" – вставляет html прямо перед `elem`,
- "afterbegin" – вставляет html в `elem` в начало,
- "beforeend" – вставляет html в `elem` в конец,
- "afterend" – вставляет html сразу после `elem`.

Также существуют похожие методы `elem.insertAdjacentText` и `elem.insertAdjacentElement`, они вставляют текстовые строки и элементы, но они редко используются.

Чтобы добавить HTML на страницу до завершения её загрузки:

- `document.write(html)`

После загрузки страницы такой вызов затирает документ. В основном встречается в старых скриптах.

#### Задачи

##### createTextNode vs innerHTML vs textContent

У нас есть пустой DOM-элемент `elem` и строка `text`.

Какие из этих 3-х команд работают одинаково?

1. `elem.append(document.createTextNode(text))`
2. `elem.innerHTML = text`
3. `elem.textContent = text`

<details>
<summary>Решение</summary>

Ответ: **1 и 3**.

Результатом обеих команд будет добавление `text` «как текст» в `elem`.

Пример:
```html
<div id="elem1"></div>
<div id="elem2"></div>
<div id="elem3"></div>
<script>
  let text = '<b>текст</b>';

  elem1.append(document.createTextNode(text));
  elem2.innerHTML = text;
  elem3.textContent = text;
</script>
```

</details>

##### Очистите элемент

Создайте функцию `clear(elem)`, которая удаляет всё содержимое из `elem`.

```html
<ol id="elem">
  <li>Привет</li>
  <li>Мир</li>
</ol>

<script>
  function clear(elem) { /* ваш код */ }

  clear(elem); // очищает список
</script>
```

<details>
<summary>Решение</summary>

Сначала давайте посмотрим, как *не* надо это делать:
```js
function clear(elem) {
  for (let i=0; i < elem.childNodes.length; i++) {
      elem.childNodes[i].remove();
  }
}
```

Это не будет работать, потому что вызов `remove()` сдвигает коллекцию `elem.childNodes`, поэтому элементы начинаются каждый раз с индекса `0`. А `i` увеличивается, и некоторые элементы будут пропущены.

Цикл `for..of` делает то же самое.

Правильным вариантом может быть:
```js
function clear(elem) {
  while (elem.firstChild) {
    elem.firstChild.remove();
  }
}
```

А также есть более простой способ сделать то же самое:
```js
function clear(elem) {
  elem.innerHTML = '';
}
```

</details>

##### Почему остаётся "aaa"?

В примере ниже вызов `table.remove()` удаляет таблицу из документа.

Но если вы запустите его, вы увидите, что текст `"aaa"` все еще виден.

Почему так происходит?

```html
<table id="table">
  aaa
  <tr>
    <td>Тест</td>
  </tr>
</table>

<script>
  alert(table); // таблица, как и должно быть

  table.remove();
  // почему в документе остался текст "ааа"?
</script>
```

<details>
<summary>Решение</summary>

HTML в задаче некорректен. В этом всё дело.

Браузер исправил ошибку автоматически. Но внутри `<table>` не может быть текста: в соответствии со спецификацией допускаются только табличные теги. Поэтому браузер показывает "aaa" до `<table>`.

Теперь очевидно, что когда мы удаляем таблицу, текст остаётся.

На этот вопрос можно легко ответить, изучив DOM, используя инструменты браузера. Вы увидите `"aaa"` до элемента `<table>`.

Вообще, в стандарте HTML описано, как браузеру обрабатывать некорректный HTML, так что такое действие браузера является правильным.

</details>

##### Создайте список

Напишите интерфейс для создания списка.

Для каждого пункта:

1. Запрашивайте содержимое пункта у пользователя с помощью `prompt`.
2. Создавайте элемент `<li>` и добавляйте его к `<ul>`.
3. Продолжайте до тех пор, пока пользователь не отменит ввод (нажатием клавиши <kbd>Esc</kbd> или введя пустую строку).

Все элементы должны создаваться динамически.

Если пользователь вводит HTML-теги, они должны обрабатываться как текст.

<details>
<summary>Решение</summary>

Обратите внимание на использование `textContent` для добавления содержимого в `<li>`.

[Исходный код](../src/10_dom/list.html)

</details>

##### Создайте дерево из объекта

Напишите функцию `createTree`, которая создаёт вложенный список `ul`/`li` из объекта.

Например:
```js
let data = {
  "Рыбы": {
    "форель": {},
    "лосось": {}
  },

  "Деревья": {
    "Огромные": {
      "секвойя": {},
      "дуб": {}
    },
    "Цветковые": {
      "яблоня": {},
      "магнолия": {}
    }
  }
};
```

Синтаксис:
```js
let container = document.getElementById('container');
createTree(container, data); // создаёт дерево в контейнере
```

Результат (дерево):

![Tree example](../img/tree-example.png)

Выберите один из двух способов решения этой задачи:

1. Создать строку, а затем присвоить через `container.innerHTML`.
2. Создавать узлы через методы DOM.

Если получится – сделайте оба.

P.S. Желательно, чтобы в дереве не было лишних элементов, в частности пустых `<ul></ul>` на нижнем уровне.

<details>
<summary>Решение</summary>

Самый лёгкий способ – это использовать рекурсию.

1. [Решение с innerHTML](../src/10_dom/tree-from-obj_1.html).

2. [Решение через DOM](../src/10_dom/tree-from-obj_2.html).

</details>

##### Выведите список потомков в дереве

Есть дерево, организованное в виде вложенных списков `ul`/`li`.

Напишите код, который добавит каждому элементу списка `<li>` количество вложенных в него элементов. Узлы нижнего уровня, без детей – пропускайте.

Результат:

![Tree descendants](../img/tree-descendants.png)

<details>
<summary>Решение</summary>

Чтобы добавить текст к каждому `<li>`, мы можем изменить текстовый узел `data`.

[Исходный код](../src/10_dom/tree-descendants.html)

</details>

##### Создайте календарь в виде таблицы

Напишите функцию `createCalendar(elem, year, month)`.

Вызов функции должен создать календарь для заданного месяца `month` в году `year` и вставить его в `elem`.

Календарь должен быть таблицей, где неделя – это `<tr>`, а день – это `<td>`. У таблицы должен быть заголовок с названиями дней недели, каждый день – `<th>`, первым днём недели должен быть понедельник.

Например, `createCalendar(cal, 2012, 9)` сгенерирует в `cal` следующий календарь:

![Calendar example](../img/calendar-example.png)

P.S. В этой задаче достаточно сгенерировать календарь, кликабельным его делать не нужно.

<details>
<summary>Решение</summary>

Для решения задачи сгенерируем таблицу в виде строки: `"<table>...</table>"`, а затем присвоим в `innerHTML`.

Алгоритм:

1. Создать заголовок таблицы с `<th>` и именами дней недели.
2. Создать объект даты `d = new Date(year, month-1)`. Это первый день месяца `month` (с учётом того, что месяцы в JS начинаются от 0, а не от 1).
3. Ячейки первого ряда пустые от начала и до дня недели `d.getDay()`, с которого начинается месяц. Заполним `<td></td>`.
4. Увеличить день в `d`: `d.setDate(d.getDate()+1)`. Если `d.getMonth()` ещё не в следующем месяце, то добавим новую ячейку `<td>` в календарь. Если это воскресенье, то добавим новую строку «`</tr><tr>`».
5. Если месяц закончился, но строка таблицы ещё не заполнена, добавим в неё пустые `<td>`, чтобы сделать в календаре красивые пустые квадратики.

[Исходный код](../src/10_dom/calendar.html)

</details>

##### Цветные часы с использованием setInterval

Создайте цветные часы как в примере ниже:

![Color watch example](../img/color-watch-example.png)

Для стилизации используйте HTML/CSS, JavaScript должен только обновлять время в элементах.

<details>
<summary>Решение</summary>

Для начала придумаем подходящую HTML/CSS-структуру.

Здесь каждый компонент времени удобно поместить в соответствующий `<span>`:
```html
<div id="clock">
  <span class="hour">hh</span>:<span class="min">mm</span>:<span class="sec">ss</span>
</div>
```

Каждый `span` раскрашивается при помощи CSS.

Функция `update` будет обновлять часы, `setInterval` вызывает её каждую секунду:
```js
function update() {
  let clock = document.getElementById('clock');
  let date = new Date(); // (*)
  let hours = date.getHours();
  if (hours < 10) hours = '0' + hours;
  clock.children[0].innerHTML = hours;

  let minutes = date.getMinutes();
  if (minutes < 10) minutes = '0' + minutes;
  clock.children[1].innerHTML = minutes;

  let seconds = date.getSeconds();
  if (seconds < 10) seconds = '0' + seconds;
  clock.children[2].innerHTML = seconds;
}
```

В строке `(*)` каждый раз мы получаем текущую дату. Вызовы `setInterval` не надёжны: они могут происходить с задержками.

Функция `clockStart` для запуска часов:
```js
let timerId;

function clockStart() { // запустить часы
  timerId = setInterval(update, 1000);
  update(); // (*)
}

function clockStop() {
  clearInterval(timerId);
  timerId = null;
}
```

Обратите внимание, что вызов `update()` не только запланирован, но и тут же производится в строке `(*)`. Иначе посетителю пришлось бы ждать до первого выполнения `setInterval`, то есть целую секунду.

[Исходный код](../src/10_dom/color-watch.html)

</details>

##### Вставьте HTML в список

Напишите код для вставки `<li>2</li><li>3</li>` между этими двумя `<li>`:
```html
<ul id="ul">
  <li id="one">1</li>
  <li id="two">4</li>
</ul>
```

<details>
<summary>Решение</summary>

Когда нам необходимо вставить фрагмент HTML-кода, можно использовать `insertAdjacentHTML`, он лучше всего подходит для таких задач.

Решение:
```js
one.insertAdjacentHTML('afterend', '<li>2</li><li>3</li>');
```

</details>

##### Сортировка таблицы

Вот таблица:
```html
<table>
<thead>
  <tr>
    <th>Name</th><th>Surname</th><th>Age</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>John</td><td>Smith</td><td>10</td>
  </tr>
  <tr>
    <td>Pete</td><td>Brown</td><td>15</td>
  </tr>
  <tr>
    <td>Ann</td><td>Lee</td><td>5</td>
  </tr>
  <tr>
    <td>...</td><td>...</td><td>...</td>
  </tr>
</tbody>
</table>
```

В ней может быть больше строк.

Напишите код для сортировки по столбцу `"name"`.

<details>
<summary>Решение</summary>

Решение короткое, но может показаться немного сложным, поэтому здесь я предоставлю подробные комментарии:
```js
let sortedRows = Array.from(table.rows)
  .slice(1)
  .sort((rowA, rowB) => rowA.cells[0].innerHTML > rowB.cells[0].innerHTML ? 1 : -1);

table.tBodies[0].append(...sortedRows);
```

1. Получим все `<tr>`, как `table.querySelectorAll('tr')`, затем сделаем массив из них, потому что нам понадобятся методы массива.

2. Первый TR (`table.rows[0]`) – это заголовок таблицы, поэтому мы берём `.slice(1)`.

3. Затем отсортируем их по содержимому в первом `<td>` (по имени).

4. Теперь вставим узлы в правильном порядке `.append(...sortedRows)`.

    Таблицы всегда имеют неявный элемент `<tbody>`, поэтому нам нужно получить его и вставить в него: простой `table.append(...)` потерпит неудачу.

    Обратите внимание: нам не нужно их удалять, просто «вставляем их заново», они автоматически покинут старое место.

[Исходный код](../src/10_dom/table-sorting.html)

</details>

### Атрибуты элементов и свойства DOM-объектов
Когда браузер загружает страницу, он «читает» (также говорят: «парсит») HTML и генерирует из него DOM-объекты. Для узлов-элементов большинство стандартных HTML-атрибутов автоматически становятся свойствами DOM-объектов.

Например, для такого тега `<body id="page">` у DOM-объекта будет такое свойство `body.id="page"`.

Но преобразование атрибута в свойство происходит не один-в-один! В этой главе мы уделим внимание различию этих двух понятий, чтобы посмотреть, как работать с ними, когда они одинаковые и когда разные.[^dom-attributes-and-properties]

#### DOM-свойства
Ранее мы уже видели встроенные DOM-свойства. Их много. Но технически нас никто не ограничивает, и если этого мало – мы можем добавить своё собственное свойство.

DOM-узлы – это обычные объекты JavaScript. Мы можем их изменять.

Например, создадим новое свойство для `document.body`:
```js
document.body.myData = {
  name: 'Caesar',
  title: 'Imperator'
};

alert(document.body.myData.title); // Imperator
```

Мы можем добавить и метод:
```js
document.body.sayTagName = function() {
  alert(this.tagName);
};

document.body.sayTagName(); // BODY (значением "this" в этом методе будет document.body)
```

Также можно изменять встроенные прототипы, такие как `Element.prototype` и добавлять новые методы ко всем элементам:
```js
Element.prototype.sayHi = function() {
  alert(`Hello, I'm ${this.tagName}`);
};

document.documentElement.sayHi(); // Hello, I'm HTML
document.body.sayHi();            // Hello, I'm BODY
```

Итак, DOM-свойства и методы ведут себя так же, как и обычные объекты JavaScript:

- им можно присвоить любое значение;
- они регистрозависимы (нужно писать `elem.nodeType`, не `elem.NoDeTyPe`).

#### HTML-атрибуты
В HTML у тегов могут быть атрибуты. Когда браузер парсит HTML, чтобы создать DOM-объекты для тегов, он распознаёт *стандартные* атрибуты и создаёт DOM-свойства для них.

Таким образом, когда у элемента есть `id` или другой *стандартный* атрибут, создаётся соответствующее свойство. Но этого не происходит, если атрибут нестандартный.

Например:
```html
<body id="test" something="non-standard">
  <script>
    alert(document.body.id);        // test
    // нестандартный атрибут не преобразуется в свойство
    alert(document.body.something); // undefined
  </script>
</body>
```

Необходимо учитывать, что стандартный атрибут для одного тега может быть нестандартным для другого. Например, атрибут "`type`" является стандартным для элемента `<input>` ([`HTMLInputElement`](https://html.spec.whatwg.org/#htmlinputelement)), но не является стандартным для `<body>` ([`HTMLBodyElement`](https://html.spec.whatwg.org/#htmlbodyelement)). Стандартные атрибуты описаны в спецификации для соответствующего класса элемента.

Мы можем увидеть это на примере ниже:
```html
<body id="body" type="...">
  <input id="input" type="text">
  <script>
    alert(input.type);  // text
    alert(body.type);   // undefined: DOM-свойство не создалось, потому что оно нестандартное
  </script>
</body>
```

Таким образом, для нестандартных атрибутов не будет соответствующих DOM-свойств. Есть ли способ получить такие атрибуты?

Конечно. Все атрибуты доступны с помощью следующих методов:

- `elem.hasAttribute(name)` – проверяет наличие атрибута.
- `elem.getAttribute(name)` – получает значение атрибута.
- `elem.setAttribute(name, value)` – устанавливает значение атрибута.
- `elem.removeAttribute(name)` – удаляет атрибут.

Эти методы работают именно с тем, что написано в HTML.

Кроме этого, получить все атрибуты элемента можно с помощью свойства `elem.attributes`: коллекция объектов, которая принадлежит ко встроенному классу `Attr` со свойствами `name` и `value`.

Вот демонстрация чтения нестандартного свойства:
```html
<body something="non-standard">
  <script>
    alert(document.body.getAttribute('something')); // non-standard
  </script>
</body>
```

У HTML-атрибутов есть следующие особенности:

- Их имена регистронезависимы (`id` то же самое, что и `ID`).
- Их значения всегда являются строками.

Расширенная демонстрация работы с атрибутами:
```html
<body>
  <div id="elem" about="Elephant"></div>

  <script>
    alert( elem.getAttribute('About') );  // (1) 'Elephant', чтение

    elem.setAttribute('Test', 123);       // (2), запись

    alert( elem.outerHTML );              // (3), посмотрим, есть ли атрибут в HTML (да)

    for (let attr of elem.attributes) {   // (4) весь список
      alert( `${attr.name} = ${attr.value}` );
    }
  </script>
</body>
```

Стоит обратить внимание на следующие моменты:

1. `getAttribute('About')` – здесь первая буква заглавная, а в HTML – строчная. Но это не важно: имена атрибутов регистронезависимы.
2. Мы можем присвоить что угодно атрибуту, но это станет строкой. Поэтому в этой строчке мы получаем значение "`123`".
3. Все атрибуты, в том числе те, которые мы установили, видны в `outerHTML`.
4. Коллекция `attributes` является перебираемой. В ней есть все атрибуты элемента (стандартные и нестандартные) в виде объектов со свойствами `name` и `value`.

#### Управление атрибутами элементов
Для управления атрибутами элементов JavaScript предоставляет ряд методов:

- **`getAttribute(attr)`**: возвращает значение атрибута `attr`

- **`createAttribute(attr)`**: создает атрибут `attr`

- **`setAttribute(attr, value)`**: устанавливает для атрибута `attr` значение `value`. Если атрибута нет, то он добавляется

- **`removeAttribute(attr)`**: удаляет атрибут `attr` и его значение[^8.9]

##### Получение атрибута
Для получения атрибута у элемента вызывается метод **`getAttribute()`**, в который передается имя атрибута. Например, пусть у нас на странице есть следующий элемент, который представляет ссылку:
```html
<a id="home" class="link" href="index.html">Home</a>
```

Получим атрибуты этого элемента:
```js
// получаем элемент
const element = document.getElementById("home");
// получаем атрибуты элемента
console.log(element.getAttribute("id"));    // home
console.log(element.getAttribute("class")); // link
console.log(element.getAttribute("href"));  // index.html
```

Стоит отметить, что атрибуты элементы также доступны через его свойства, которые называются аналогично атрибутам (за редким исключением):
```js
// получаем элемент
const element = document.getElementById("home");
// получаем атрибуты элемента
console.log(element.id);    // home
console.log(element.className); // link
console.log(element.href);  // file:///Users/user/Documents/app/index.html
```

Исключение касается в частности атрибута "class", который доступен через свойство **`className`**.

Также свойства могут возвращать немного отличающиеся значения. Например, свойство `href` возвращает полную ссылку, а метод `getAttribute("href")` — непосредственное значение атрибута.

То же самое касается и атрибута **`style`**:
```html
<a id="home" style="color:red;" href="index.html">Home</a>
<script>
// получаем элемент
const element = document.getElementById("home");
// получаем атрибуты элемента
console.log(element.style);    // CSSStyleDeclaration
console.log(element.getAttribute("style")); // color:red;
</script>
```

Метод `getAttribute("style")` возвращает стиль в виде текста, а свойство `style` — объект `CSSStyleDeclaration`, с помощью свойств которого можно получить отдельные аспекты стиля.

##### Установка атрибутов
Для установки значения атрибутов применяется метод **`setAttribute(attr, value)`**, первый параметр которого — устанавливаемый атрибут, а второй — его значение:
```html
<a id="home" href="index.html">Home</a>
<script>
// получаем элемент
const element = document.getElementById("home");
// устанавливаем атрибут href
element.setAttribute("href", "https://example.com");
// устанавливаем атрибут style
element.setAttribute("style", "color:navy;");
</script>
```

Здесь изменяем атрибут "href" и устанавливаем атрибут "style". Поскольку атрибут "style" изначально отсутствует, то он будет добавлен. Но стоит отметить, что в реальности это приведет к тому, что будет создан узел `Node`, который представляет атрибут. У этого узла будет установлено соответствующее значение, и затем узел атрибута добавляется в коллекцию дочерних узлов элемента. То есть фактически это будет выглядеть следующим образом:
```html
<a id="home" href="https://example.com">Home</a>
<script>
// получаем элемент
const element = document.getElementById("home");
// создаем узел-атрибут style
const attribute = document.createAttribute("style");
// устанавливаем значение узла-атрибута
attribute.value = "color:navy;";
// устанавливаем узел атрибута
element.setAttributeNode(attribute);
</script>
```

##### Удаление атрибута
Для удаления атрибута применяется метод **`removeAttribute()`**, в который передается удаляемый атрибут:
```html
<a id="home" href="https://example.com" style="color:navy;">Home</a>
<script>
// получаем элемент
const element = document.getElementById("home");
// удаляем атрибут style
element.removeAttribute("style");
</script>
```

#### Синхронизация между атрибутами и свойствами
Когда стандартный атрибут изменяется, соответствующее свойство автоматически обновляется. Это работает и в обратную сторону (за некоторыми исключениями).

В примере ниже `id` модифицируется как атрибут, и можно увидеть, что свойство также изменено. То же самое работает и в обратную сторону:
```html
<input>

<script>
  let input = document.querySelector('input');

  // атрибут => свойство
  input.setAttribute('id', 'id');
  alert(input.id);                  // id (обновлено)

  // свойство => атрибут
  input.id = 'newId';
  alert(input.getAttribute('id'));  // newId (обновлено)
</script>
```

Но есть и исключения, например, `input.value` синхронизируется только в одну сторону – *атрибут* → *значение*, но не в обратную:
```html
<input>

<script>
  let input = document.querySelector('input');

  // атрибут => значение
  input.setAttribute('value', 'text');
  alert(input.value); // text

  // свойство => атрибут
  input.value = 'newValue';
  alert(input.getAttribute('value')); // text (не обновилось!)
</script>
```

В примере выше:

- изменение атрибута `value` обновило свойство,
- но изменение свойства не повлияло на атрибут.

Иногда эта «особенность» может пригодиться, потому что действия пользователя могут приводить к изменениям `value`, и если после этого мы захотим восстановить «оригинальное» значение из HTML, оно будет в атрибуте.

#### DOM-свойства типизированы
DOM-свойства не всегда являются строками. Например, свойство `input.checked` (для чекбоксов) имеет логический тип:
```html
<input id="input" type="checkbox" checked> checkbox

<script>
  alert(input.getAttribute('checked')); // значение атрибута: пустая строка
  alert(input.checked);                 // значение свойства: true
</script>
```

Есть и другие примеры. Атрибут `style` – строка, но свойство `style` является объектом:
```html
<div id="div" style="color:red;font-size:120%">Hello</div>

<script>
  // строка
  alert(div.getAttribute('style')); // color:red;font-size:120%

  // объект
  alert(div.style); // [object CSSStyleDeclaration]
  alert(div.style.color); // red
</script>
```

Хотя большинство свойств всё же строки.

При этом некоторые из них, хоть и строки, могут отличаться от атрибутов. Например, DOM-свойство `href` всегда содержит *полный* URL, даже если атрибут содержит относительный URL или просто `#hash`.

Ниже пример:
```html
<a id="a" href="#hello">link</a>
<script>
  // атрибут
  alert(a.getAttribute('href')); // #hello

  // свойство
  alert(a.href ); // полный URL в виде http://site.com/page#hello
</script>
```

Если же нужно значение `href` или любого другого атрибута в точности, как оно записано в HTML, можно воспользоваться `getAttribute`.

#### Нестандартные атрибуты, dataset
При написании HTML мы используем много стандартных атрибутов. Но что насчёт нестандартных, пользовательских? Давайте посмотрим, полезны они или нет, и для чего они нужны.

Иногда нестандартные атрибуты используются для передачи пользовательских данных из HTML в JavaScript, или чтобы «помечать» HTML-элементы для JavaScript.

Как тут:
```html
<!-- пометить div, чтобы показать здесь поле "name" -->
<div show-info="name"></div>
<!-- а здесь возраст "age" -->
<div show-info="age"></div>

<script>
  // код находит элемент с пометкой и показывает запрошенную информацию
  let user = {
    name: "Pete",
    age: 25
  };

  for(let div of document.querySelectorAll('[show-info]')) {
    // вставить соответствующую информацию в поле
    let field = div.getAttribute('show-info');
    div.innerHTML = user[field]; // сначала Pete в name, потом 25 в age
  }
</script>
```

Также они могут быть использованы, чтобы стилизовать элементы.

Например, здесь для состояния заказа используется атрибут `order-state`:
```html
<style>
  /* стили зависят от пользовательского атрибута "order-state" */
  .order[order-state="new"] {
    color: green;
  }

  .order[order-state="pending"] {
    color: blue;
  }

  .order[order-state="canceled"] {
    color: red;
  }
</style>

<div class="order" order-state="new">
  A new order.
</div>

<div class="order" order-state="pending">
  A pending order.
</div>

<div class="order" order-state="canceled">
  A canceled order.
</div>
```

Почему атрибут может быть предпочтительнее таких классов, как `.order-state-new`, `.order-state-pending`, `.order-state-canceled`?

Это потому, что атрибутом удобнее управлять. Состояние может быть изменено достаточно просто:
```js
// немного проще, чем удаление старого/добавление нового класса
div.setAttribute('order-state', 'canceled');
```

Но с пользовательскими атрибутами могут возникнуть проблемы. Что если мы используем нестандартный атрибут для наших целей, а позже он появится в стандарте и будет выполнять какую-то функцию? Язык HTML живой, он растёт, появляется больше атрибутов, чтобы удовлетворить потребности разработчиков. В этом случае могут возникнуть неожиданные эффекты.

Чтобы избежать конфликтов, существуют атрибуты вида [data-*](https://html.spec.whatwg.org/#embedding-custom-non-visible-data-with-the-data-*-attributes).

**Все атрибуты, начинающиеся с префикса «data-», зарезервированы для использования программистами. Они доступны в свойстве `dataset`.**

Например, если у `elem` есть атрибут "`data-about`", то обратиться к нему можно как `elem.dataset.about`.

Как тут:
```html
<body data-about="Elephants">
<script>
  alert(document.body.dataset.about); // Elephants
</script>
```

Атрибуты, состоящие из нескольких слов, к примеру `data-order-state`, становятся свойствами, записанными с помощью верблюжьей нотации: `dataset.orderState`.

Вот переписанный пример «состояния заказа»:
```html
<style>
  .order[data-order-state="new"] {
    color: green;
  }

  .order[data-order-state="pending"] {
    color: blue;
  }

  .order[data-order-state="canceled"] {
    color: red;
  }
</style>

<div id="order" class="order" data-order-state="new">
  A new order.
</div>

<script>
  // чтение
  alert(order.dataset.orderState); // new

  // изменение
  order.dataset.orderState = "pending"; // (*)
</script>
```

Использование `data-*` атрибутов – валидный, безопасный способ передачи пользовательских данных.

Пожалуйста, примите во внимание, что мы можем не только читать, но и изменять data-атрибуты. Тогда CSS обновит представление соответствующим образом: в примере выше последняя строка `(*)` меняет цвет на синий.

#### Итого
- Атрибуты – это то, что написано в HTML.
- Свойства – это то, что находится в DOM-объектах.

Небольшое сравнение:

| | Свойства | Атрибуты                                                                  |                        |
| -------- | ------------------------------------------------------------------------- | ---------------------- |
| Тип      | Любое значение, стандартные свойства имеют типы, описанные в спецификации | Строка                 |
| Имя      | Имя регистрозависимо                                                      | Имя регистронезависимо |

Методы для работы с атрибутами:

- `elem.hasAttribute(name)` – проверить на наличие.
- `elem.getAttribute(name)` – получить значение.
- `elem.setAttribute(name, value)` – установить значение.
- `elem.removeAttribute(name)` – удалить атрибут.
- `elem.attributes` – это коллекция всех атрибутов.

В большинстве ситуаций предпочтительнее использовать DOM-свойства. Нужно использовать атрибуты только тогда, когда DOM-свойства не подходят, когда нужны именно атрибуты, например:

- Нужен нестандартный атрибут. Но если он начинается с `data-`, тогда нужно использовать `dataset`.
- Мы хотим получить именно то значение, которое написано в HTML. Значение DOM-свойства может быть другим, например, свойство `href` – всегда полный URL, а нам может понадобиться получить «оригинальное» значение.

#### Задачи

##### Получите атрибут
Напишите код для выбора элемента с атрибутом `data-widget-name` из документа и прочитайте его значение.

```html
<!DOCTYPE html>
<html>
<body>

  <div data-widget-name="menu">Choose the genre</div>

  <script>
    /* your code */
  </script>
</body>
</html>
```

<details>
<summary>Решение</summary>

```html
<!DOCTYPE html>
<html>
<body>

  <div data-widget-name="menu">Choose the genre</div>

  <script>
    // получаем элемент
    let elem = document.querySelector('[data-widget-name]');

    // читаем значение
    alert(elem.dataset.widgetName);
    // или так
    alert(elem.getAttribute('data-widget-name'));
  </script>
</body>
</html>
```

</details>

##### Сделайте внешние ссылки оранжевыми
Сделайте все внешние ссылки оранжевыми, изменяя их свойство `style`.

Ссылка является внешней, если:

- Её `href` содержит `://`
- Но не начинается с `http://internal.com`.

Пример:
```html
<a name="list">the list</a>
<ul>
  <li><a href="http://google.com">http://google.com</a></li>
  <li><a href="/tutorial">/tutorial.html</a></li>
  <li><a href="local/path">local/path</a></li>
  <li><a href="ftp://ftp.com/my.zip">ftp://ftp.com/my.zip</a></li>
  <li><a href="http://nodejs.org">http://nodejs.org</a></li>
  <li><a href="http://internal.com/test">http://internal.com/test</a></li>
</ul>

<script>
  // добавление стиля для одной ссылки
  let link = document.querySelector('a');
  link.style.color = 'orange';
</script>
```

Результат должен быть таким:

![Task orange external links](../img/task-orange-external-links.png)

<details>
<summary>Решение</summary>

Во-первых, мы должны найти все внешние ссылки.

Это можно сделать двумя способами.

Первый – это найти все ссылки, используя `document.querySelectorAll('a')`, а затем отфильтровать ненужное:
```js
let links = document.querySelectorAll('a');

for (let link of links) {
  let href = link.getAttribute('href');
  if (!href) continue; // нет атрибута

  if (!href.includes('://')) continue; // нет протокола

  if (href.startsWith('http://internal.com')) continue; // внутренняя

  link.style.color = 'orange';
}
```

Пожалуйста, обратите внимание: мы используем `link.getAttribute('href')`. Не `link.href`, потому что нам нужно значение из HTML.

…Другой, более простой путь – добавить проверку в CSS-селектор:
```js
// найти все ссылки, атрибут href у которых содержит ://
// и при этом href не начинается с http://internal.com
let selector = 'a[href*="://"]:not([href^="http://internal.com"])';
let links = document.querySelectorAll(selector);

links.forEach(link => link.style.color = 'orange');
```

[Исходный код](../src/10_dom/orange-links.html)

</details>

### Управление стилем и классами элементов
До того, как изучать способы работы со стилями и классами в JavaScript, необходимо вспомнить о том, что существует два способа задания стилей для элемента:

1. Создать класс в CSS и использовать его: `<div class="...">`
2. Писать стили непосредственно в атрибуте style: `<div style="...">`.

JavaScript может менять и классы, и свойство `style`. Таким образом, для работы со стилевыми свойствами элементов в JavaScript применяются, главным образом, два подхода:

- изменение свойства **`style`**;

- изменение значения атрибута **`class`**.[^8.7]

Классы – всегда предпочтительный вариант по сравнению со `style`. Мы должны манипулировать свойством `style` только в том случае, если классы «не могут справиться».

Например, использование `style` является приемлемым, если мы вычисляем координаты элемента динамически и хотим установить их из JavaScript:
```js
let top =  /* сложные расчёты */;
let left = /* сложные расчёты */;

elem.style.left = left; // например, '123px', значение вычисляется во время работы скрипта
elem.style.top = top;   // например, '456px'
```

Мы также можем установить сразу несколько стилей для элемента, используя свойство `cssText`. Но с ним нужно быть осторожнее, т.к оно может как добавить стили к существующим, так и полностью перезаписать их на новые:
```js
let top =  /* сложные расчёты */;
let left = /* сложные расчёты */;

// полная перезапись стилей elem, используем =
elem.style.cssText = `
  top: ${top};
  left: ${left};
`;

// добавление новых стилей к существующим стилям elem, используем +=
elem.style.cssText += `
  top: ${top};
  left: ${left};
`;

// если элементу уже заданы стили, которые мы хотим добавить (+=),
// они будут перезаписаны на новые.
```

В других случаях, например, чтобы сделать текст красным, добавить значок фона – описываем это в CSS и добавляем класс (JavaScript может это сделать). Это более гибкое и лёгкое в поддержке решение.[^styles-and-classes]

#### Свойство className
Изменение класса является одним из наиболее часто используемых действий в скриптах.

Когда-то давно в JavaScript существовало ограничение: зарезервированное слово типа "class" не могло быть свойством объекта. Это ограничение сейчас отсутствует, но в то время было невозможно иметь свойство `elem.class`.

Поэтому для классов было введено схожее свойство "className": `elem.className` соответствует атрибуту "class".

Например:
```html
<body class="main page">
  <script>
    alert(document.body.className); // main page
  </script>
</body>
```

Итак, с помощью свойства **`className`** можно получить или установить значение атрибута `class` элемента html. Например:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
    <style>
        .header-color {color:navy;}
        .header-font {font-family: Verdana;}
    </style>
</head>
<body>
    <h1 id="header" class="header-font">Home Page</h1>
    <script>
      const header = document.getElementById("header");
      // получаем текущий класс
      console.log(header.className);  // header-font
      // устанавливаем класс элемента
      header.className = "header-color";
      // получаем текущий класс
      console.log(header.className);  // header-color
    </script>
</body>
</html>
```

Здесь получаем текущий класс заголовка и затем изменяем его на новый класс — "header-color". Благодаря использованию классов не придется настраивать каждое отдельное свойство css с помощью свойства `style`.

Но при этом надо учитывать, что прежнее значение атрибута `class` удаляется. Поэтому, если нам надо добавить класс, надо объединить его название со старым классом:
```js
header.className = header.className + " header-color";
```

И если надо вовсе удалить все классы, то можно присвоить свойству пустую строку:
```js
header.className = "";
```

#### Свойство classList
Если мы присваиваем что-то `elem.className`, то это заменяет всю строку с классами. Иногда это то, что нам нужно, но часто мы хотим добавить/удалить один класс. Для этого есть другое свойство: `elem.classList`.

Выше было рассмотрено, как добавлять классы к элементу, однако для управления множеством классов гораздо удобнее использовать свойство **`classList`**. Это свойство представляет собой специальный объект  с методами для добавления/удаления одного класса.

Например:
```html
<body class="main page">
  <script>
    // добавление класса
    document.body.classList.add('article');

    alert(document.body.className); // main page article
  </script>
</body>
```

Так что мы можем работать как со строкой полного класса, используя `className`, так и с отдельными классами, используя `classList`. Выбираем тот вариант, который нам удобнее.

Объект `classList` реализует следующие методы:

- **`element.clasList.add(className)`**: добавляет класс `className`

- **`element.clasList.remove(className)`**: удаляет класс `className`

- **`element.clasList.toggle(className)`**: переключает у элемента класс на `className`. Если класса нет, то он добавляется, если есть, то удаляется

- **`elem.classList.contains("class")`** – проверка наличия класса, возвращает `true`/`false`.

Например:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
    <style>
        .header-color {color:navy;}
        .header-font {font-family: Verdana;}
        .header-size {font-size: 22px;}
    </style>
</head>
<body>
    <h1 id="header" class="header-size">Home Page</h1>
    <script>
    const header = document.getElementById("header");
    header.classList.remove("header-size");     //  удаляем класс header-size
    header.classList.add("header-font");        // добавляем класс header-font
    header.classList.toggle("header-color");    // переключаем класс header-color
    </script>
</body>
</html>
```

Стоит отметить, что метод `toggle()` дополнительно может принимать условие в качестве второго параметра — если это условие верно (возвращает `true`), то класс переключается:
```js
const i = 5;
const condition = i > 0; // условие
const header = document.getElementById("header");
header.classList.toggle("header-color", condition);    // переключаем класс header-color по условию
```

Кроме того, `classList` является перебираемым, поэтому можно перечислить все классы при помощи `for..of`:
```html
<body class="main page">
  <script>
    for (let name of document.body.classList) {
      alert(name); // main, затем page
    }
  </script>
</body>
```

Таким образом, при необходимости мы можем перебрать все классы из списка `classList` или получить отдельные классы по индексу:
```js
// перебор списка классов
for(headerClass of header.classList){
    console.log(headerClass);
}
console.log(header.classList[0]);   // первый установленный класс
```

#### Свойство style
Свойство **`style`** представляет сложный объект **`CSSStyleDeclaration`** и напрямую сопоставляется с атрибутом `style` html-элемента. Этот объект содержит набор свойств CSS, к которым можно обратиться следующим образом:
```js
element.style.свойствоCSS
```

Например, установим цвет шрифта заголовка:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <h1 id="header">Home Page</h1>
    <script>
    const header = document.getElementById("header");
    // получаем значение свойства color
    console.log(header.style.color);    // пустая строка
    // изменяем значение свойства color
    header.style.color = "navy";
    // повторно получаем значение свойства color
    console.log(header.style.color);    // navy
    </script>
</body>
</html>
```

Здесь для заголовка в качестве цвета устанавливаем синий цвет `navy`. В данном случае название свойства `color` совпадает со свойством css. Аналогично мы могли бы установить цвет с помощью css:
```css
#header{
    color:navy;
}
```

Однако ряд свойств css в названиях имеют дефис, например, `font-family`. В JavaScript для этих свойств дефис не употребляется. Только первая буква, которая идет после дефиса, переводится в верхний регистр:
```js
const header = document.getElementById("header");
header.style.fontFamily = "Verdana";
```

Таким образом, свойство `elem.style` – это объект, который соответствует тому, что написано в атрибуте "style".

Свойства из одного слова записываются так же, с маленькой буквы:
```css
background  => elem.style.background
top         => elem.style.top
opacity     => elem.style.opacity
```

Для свойств из нескольких слов используется [camelCase](https://ru.wikipedia.org/wiki/CamelCase):
```css
background-color  => elem.style.backgroundColor
z-index           => elem.style.zIndex
border-left-width => elem.style.borderLeftWidth
```

Например:
```js
document.body.style.backgroundColor = prompt('background color?', 'green');
```

!!! info "Свойства с префиксом"

    Стили с браузерным префиксом, например, `-moz-border-radius`, `-webkit-border-radius` преобразуются по тому же принципу: дефис означает заглавную букву.

    Например:
    ```js
    button.style.MozBorderRadius = '5px';
    button.style.WebkitBorderRadius = '5px';
    ```

#### Сброс стилей
Иногда нам нужно добавить свойство стиля, а потом, позже, убрать его.

Например, чтобы скрыть элемент, мы можем задать `elem.style.display = "none"`.

Затем мы можем удалить свойство `style.display`, чтобы вернуться к первоначальному состоянию. Вместо `delete elem.style.display` мы должны присвоить ему пустую строку: `elem.style.display = ""`.

```js
// если мы запустим этот код, <body> "мигнёт"
document.body.style.display = "none"; // скрыть

setTimeout(() => document.body.style.display = "", 1000); // возврат к нормальному состоянию
```

Если мы установим в `style.display` пустую строку, то браузер применит CSS-классы и встроенные стили, как если бы такого свойства `style.display` вообще не было.

#### Следите за единицами измерения
Не забудьте добавить к значениям единицы измерения.

Например, мы должны устанавливать `10px`, а не просто `10` в свойство `elem.style.top`. Иначе это не сработает:
```html
<body>
  <script>
    // не работает!
    document.body.style.margin = 20;
    alert(document.body.style.margin); // '' (пустая строка, присваивание игнорируется)

    // сейчас добавим единицу измерения (px) - и заработает
    document.body.style.margin = '20px';
    alert(document.body.style.margin);      // 20px

    alert(document.body.style.marginTop);   // 20px
    alert(document.body.style.marginLeft);  // 20px
  </script>
</body>
```

Пожалуйста, обратите внимание, браузер «распаковывает» свойство `style.margin` в последних строках и выводит `style.marginLeft` и `style.marginTop` из него.

#### Вычисленные стили: getComputedStyle
Итак, изменить стиль очень просто. Но как его *прочитать*?

Например, мы хотим знать размер, отступы, цвет элемента. Как это сделать?

**Свойство `style` оперирует только значением атрибута `"style"`, без учёта CSS-каскада.**

Поэтому, используя `elem.style`, мы не можем прочитать ничего, что приходит из классов CSS.

Например, здесь `style` не может видеть отступы:
```html
<head>
  <style> body { color: red; margin: 5px } </style>
</head>
<body>

  Красный текст
  <script>
    alert(document.body.style.color); // пусто
    alert(document.body.style.marginTop); // пусто
  </script>
</body>
```

…Но что, если нам нужно, скажем, увеличить отступ на `20px`? Для начала нужно его текущее значение получить.

Для этого есть метод: `getComputedStyle`.

Синтаксис:
```js
getComputedStyle(element, [pseudo])
```

- **`element`**

  Элемент, значения для которого нужно получить

- **`pseudo`**

  Указывается, если нужен стиль псевдоэлемента, например `::before`. Пустая строка или отсутствие аргумента означают сам элемент.

Результат вызова – объект со стилями, похожий на `elem.style`, но с учётом всех CSS-классов.

Например:
```html
<head>
  <style> body { color: red; margin: 5px } </style>
</head>
<body>

  <script>
    let computedStyle = getComputedStyle(document.body);

    // сейчас мы можем прочитать отступ и цвет

    alert( computedStyle.marginTop ); // 5px
    alert( computedStyle.color ); // rgb(255, 0, 0)
  </script>

</body>
```

!!! info "Вычисленное (computed) и окончательное (resolved) значения"

    Есть две концепции в [CSS](https://drafts.csswg.org/cssom/#resolved-values):

    1. <dfn title="вычисленное">Вычисленное значение</dfn> (*computed value*) – это то, которое получено после применения всех CSS-правил и CSS-наследования. Например, `height:1em` или `font-size:125%`.
    2. <dfn title="окончательное значение">Окончательное значение</dfn> (*resolved value*) – непосредственно применяемое к элементу. Значения `1em` или `125%` являются относительными. Браузер берёт вычисленное значение и делает все единицы измерения фиксированными и абсолютными, например, `height:20px` или `font-size:16px`. Для геометрических свойств разрешённые значения могут иметь плавающую точку, например, `width:50.5px`.

    Давным-давно `getComputedStyle` был создан для получения вычисленных значений, но оказалось, что окончательные значения гораздо удобнее, и стандарт изменился.

    Так что, в настоящее время `getComputedStyle` фактически возвращает окончательное значение свойства, для геометрии оно обычно в пикселях.

!!! warning "`getComputedStyle` требует полное свойство!"

    Для правильного получения значения нужно указать точное свойство. Например: `paddingLeft`, `marginTop`, `borderTopWidth`. При обращении к сокращённому: `padding`, `margin`, `border` – правильный результат не гарантируется.

    Например, если есть свойства `paddingLeft`/`paddingTop`, то что мы получим вызывая `getComputedStyle(elem).padding`? Ничего, или, может быть, «сгенерированное» значение из известных внутренних отступов? Стандарта для этого нет.

!!! info "Стили, применяемые к посещённым `:visited` ссылкам, скрываются!"

    Посещённые ссылки могут быть окрашены с помощью псевдокласса `:visited`.

    Но `getComputedStyle` не даёт доступ к этой информации, чтобы произвольная страница не могла определить, посещал ли пользователь ту или иную ссылку, проверив стили.

    JavaScript не видит стили, применяемые с помощью `:visited`. Кроме того, в CSS есть ограничение, которое запрещает в целях безопасности применять к `:visited` CSS-стили, изменяющие геометрию элемента. Это гарантирует, что нет обходного пути для «злой» страницы проверить, была ли ссылка посещена и, следовательно, нарушить конфиденциальность.

#### Итого
Для управления классами существуют два DOM-свойства:

- `className` – строковое значение, удобно для управления всем набором классов.
- `classList` – объект с методами `add`/`remove`/`toggle`/`contains`, удобно для управления отдельными классами.

Чтобы изменить стили:

- Свойство `style` является объектом со стилями в формате `camelCase`. Чтение и запись в него работают так же, как изменение соответствующих свойств в атрибуте "style". Чтобы узнать, как добавить в него `important` и делать некоторые другие редкие вещи – смотрите [документацию](https://developer.mozilla.org/ru/docs/Web/API/CSSStyleDeclaration).

- Свойство `style.cssText` соответствует всему атрибуту `"style"`, полной строке стилей.

Для чтения окончательных стилей (с учётом всех классов, после применения CSS и вычисления окончательных значений) используется:

- Метод `getComputedStyle(elem, [pseudo])` возвращает объект, похожий по формату на `style`. Только для чтения.

#### Задачи

##### Создать уведомление
важность: 5
Напишите функцию `showNotification(options)`, которая создаёт уведомление: `<div class="notification">` с заданным содержимым. Уведомление должно автоматически исчезнуть через 1,5 секунды.

Пример объекта `options`:
```js
// показывает элемент с текстом "Hello" рядом с правой верхней частью окна.
showNotification({
  top: 10, // 10px от верхней границы окна (по умолчанию 0px)
  right: 10, // 10px от правого края окна (по умолчанию 0px)
  html: "Hello!", // HTML-уведомление
  className: "welcome" // дополнительный класс для div (необязательно)
});
```

Используйте CSS-позиционирование для отображения элемента в заданных координатах. Исходный документ имеет необходимые стили.

<details>
<summary>Решение</summary>

[Исходный код](../src/10_dom/create-notification.html)

</details>

### Размеры и прокрутка элементов
Существует множество JavaScript-свойств, которые позволяют считывать информацию об элементе: ширину, высоту и другие геометрические характеристики. Далее будем называть их «метрики».

Они часто требуются, когда нам нужно передвигать или позиционировать элементы с помощью JavaScript.[^size-and-scroll]

#### Простой пример
В качестве простого примера демонстрации свойств мы будем использовать следующий элемент:
```html
<div id="example">
  ...Текст...
</div>
<style>
  #example {
    width: 300px;
    height: 200px;
    border: 25px solid #E8C48F;
    padding: 20px;
    overflow: auto;
  }
</style>
```

У элемента есть рамка (`border`), внутренний отступ (`padding`) и прокрутка. Полный набор характеристик. Обратите внимание, тут нет внешних отступов (`margin`), потому что они не являются частью элемента, для них нет особых JavaScript-свойств.

Результат выглядит так:

![Metic CSS](../svg/metric-css.svg)

[Исходный код](../samples/10_dom/element-metrics.html)

!!! info "Внимание, полоса прокрутки"
    В иллюстрации выше намеренно продемонстрирован самый сложный и полный случай, когда у элемента есть ещё и полоса прокрутки. Некоторые браузеры (не все) отбирают место для неё, забирая его у области, отведённой для содержимого (помечена как «content width» выше).

    Таким образом, без учёта полосы прокрутки ширина области содержимого (content width) будет `300px`, но если предположить, что ширина полосы прокрутки равна `16px` (её точное значение зависит от устройства и браузера), тогда остаётся только `300 - 16 = 284px`, и мы должны это учитывать. Вот почему примеры в этой главе даны с полосой прокрутки. Без неё некоторые вычисления будут проще.

!!! info "Область padding-bottom (нижний внутренний отступ) может быть заполнена текстом"
    Нижние внутренние отступы `padding-bottom` изображены пустыми на наших иллюстрациях, но если элемент содержит много текста, то он будет перекрывать `padding-bottom`, это нормально.

#### Метрики
Вот общая картина с геометрическими свойствами:

![Metics all](../svg/metric-all.svg)

Значениями свойств являются числа, подразумевается, что они в пикселях.

Давайте начнём исследовать, начиная снаружи элемента.

#### offsetParent, offsetLeft/Top
Эти свойства редко используются, но так как они являются «самыми внешними» метриками, мы начнём с них.

В свойстве `offsetParent` находится предок элемента, который используется внутри браузера для вычисления координат при рендеринге.

То есть, ближайший предок, который удовлетворяет следующим условиям:

1. Является CSS-позиционированным (CSS-свойство `position` равно `absolute`, `relative`, `fixed` или `sticky`),
2. или `<td>`, `<th>`, `<table>`,
3. или `<body>`.

Свойства `offsetLeft`/`offsetTop` содержат координаты x/y относительно верхнего левого угла `offsetParent`.

В примере ниже внутренний `<div>` имеет элемент `<main>` в качестве `offsetParent`, а свойства `offsetLeft`/`offsetTop` являются сдвигами относительно верхнего левого угла (180):
```html
<main style="position: relative" id="main">
  <article>
    <div id="example" style="position: absolute; left: 180px; top: 180px">...</div>
  </article>
</main>
<script>
  alert(example.offsetParent.id); // main
  alert(example.offsetLeft); // 180 (обратите внимание: число, а не строка "180px")
  alert(example.offsetTop); // 180
</script>
```

![Metic offsetParent](../svg/metric-offset-parent.svg)

Существует несколько ситуаций, когда `offsetParent` равно `null`:

1. Для скрытых элементов (с CSS-свойством `display:none` или когда его нет в документе).
2. Для элементов `<body>` и `<html>`.
3. Для элементов с `position:fixed`.

#### offsetWidth/Height
Теперь переходим к самому элементу.

Эти два свойства – самые простые. Они содержат «внешнюю» ширину/высоту элемента, то есть его полный размер, включая рамки.

![Metic offsetWidth/Height](../svg/metric-offset-width-height.svg)

Для нашего элемента:

- `offsetWidth = 390` – внешняя ширина блока, её можно получить сложением CSS-ширины (`300px`), внутренних отступов (`2 * 20px`) и рамок (`2 * 25px`).
- `offsetHeight = 290` – внешняя высота блока.

!!! info "Метрики для не показываемых элементов равны нулю."
    Координаты и размеры в JavaScript устанавливаются только для видимых элементов.

    Если элемент (или любой его родитель) имеет `display:none` или отсутствует в документе, то все его метрики равны нулю (или `null`, если это `offsetParent`).

    Например, свойство `offsetParent` равно `null`, а `offsetWidth` и `offsetHeight` равны `0`, когда мы создали элемент, но ещё не вставили его в документ, или если у элемента (или у его родителя) `display:none`.

    Мы можем использовать это, чтобы делать проверку на видимость:
    ```js
    function isHidden(elem) {
      return !elem.offsetWidth && !elem.offsetHeight;
    }
    ```

    Заметим, что функция `isHidden` также вернёт `true` для элементов, которые в принципе показываются, но их размеры равны нулю.

#### clientTop/Left
Пойдём дальше. Внутри элемента у нас рамки (border).

Для них есть свойства-метрики `clientTop` и `clientLeft`.

В нашем примере:

- `clientLeft = 25` – ширина левой рамки
- `clientTop = 25` – ширина верхней рамки

![Metric clientLeft/Top](../svg/metric-client-left-top.svg)

…Но на самом деле эти свойства – вовсе не ширины рамок, а отступы внутренней части элемента от внешней.

В чём же разница?

Она возникает, когда документ располагается справа налево (операционная система на арабском языке или иврите). Полоса прокрутки в этом случае находится слева, и тогда свойство `clientLeft` включает в себя ещё и ширину полосы прокрутки.

В этом случае `clientLeft` будет равно `25`, но с прокруткой – `25 + 16 = 41`.

Вот соответствующий пример на иврите:

![Metric clientLeft/Top RTL](../svg/metric-client-left-top-rtl.svg)

#### clientWidth/Height
Эти свойства – размер области внутри рамок элемента.

Они включают в себя ширину области содержимого вместе с внутренними отступами `padding`, но без прокрутки:

![Metric clientWidth/Height](../svg/metric-client-width-height.svg)

На рисунке выше посмотрим вначале на высоту `clientHeight`.

Горизонтальной прокрутки нет, так что это в точности то, что внутри рамок: CSS-высота `200px` плюс верхние и нижние внутренние отступы (`2 * 20px`), итого `240px`.

Теперь `clientWidth` – ширина содержимого здесь равна не `300px`, а `284px`, т.к. `16px` отведено для полосы прокрутки. Таким образом: `284px` плюс левый и правый отступы – всего `324px`.

**Если нет внутренних отступов `padding`, то `clientWidth`/`Height` в точности равны размеру области содержимого внутри рамок за вычетом полосы прокрутки (если она есть).**

![Metric clientWidth no padding](../svg/metric-client-width-nopadding.svg)

Поэтому в тех случаях, когда мы точно знаем, что отступов нет, можно использовать `clientWidth`/`clientHeight` для получения размеров внутренней области содержимого.

#### scrollWidth/Height
Эти свойства – как `clientWidth`/`clientHeight`, но также включают в себя прокрученную (которую не видно) часть элемента.

![Metric scollWidth/Height](../svg/metric-scroll-width-height.svg)

На рисунке выше:

- `scrollHeight = 723` – полная внутренняя высота, включая прокрученную область.
- `scrollWidth = 324` – полная внутренняя ширина, в данном случае прокрутки нет, поэтому она равна `clientWidth`.

Эти свойства можно использовать, чтобы «распахнуть» элемент на всю ширину/высоту.

Таким кодом:
```js
// распахнуть элемент на всю высоту
element.style.height = `${element.scrollHeight}px`;
```

#### scrollLeft/scrollTop
Свойства `scrollLeft`/`scrollTop` – ширина/высота невидимой, прокрученной в данный момент, части элемента слева и сверху.

Следующая иллюстрация показывает значения `scrollHeight` и `scrollTop` для блока с вертикальной прокруткой.

![Metric scrollLeft/Top](../svg/metric-scroll-top.svg)

Другими словами, свойство `scrollTop` – это «сколько уже прокручено вверх».

!!! info "Свойства `scrollLeft`/`scrollTop` можно изменять"
    В отличие от большинства свойств, которые доступны только для чтения, значения `scrollLeft`/`scrollTop` можно изменять, и браузер выполнит прокрутку элемента.

    При клике на следующий элемент будет выполняться код `elem.scrollTop += 10`. Поэтому он будет прокручиваться на `10px` вниз.

    Установка значения `scrollTop` на `0` или на большое значение, такое как `1e9`, прокрутит элемент в самый верх/низ соответственно.

#### Не стоит брать width/height из CSS
Мы рассмотрели метрики, которые есть у DOM-элементов, и которые можно использовать для получения различных высот, ширин и прочих расстояний.

Но как мы уже знаем, CSS-высоту и ширину можно извлечь, используя `getComputedStyle`.

Так почему бы не получать, к примеру, ширину элемента при помощи `getComputedStyle`, вот так?

```js
let elem = document.body;

alert( getComputedStyle(elem).width ); // показывает CSS-ширину elem
```

Почему мы должны использовать свойства-метрики вместо этого? На то есть две причины:

1. Во-первых, CSS-свойства `width`/`height` зависят от другого свойства – `box-sizing`, которое определяет, «что такое», собственно, эти CSS-ширина и высота. Получается, что изменение `box-sizing`, к примеру, для более удобной вёрстки, сломает такой JavaScript.

2. Во-вторых, CSS свойства `width`/`height` могут быть равны `auto`, например, для инлайнового элемента:

    ```html
    <span id="elem">Привет!</span>

    <script>
      alert( getComputedStyle(elem).width ); // auto
    </script>
    ```

    Конечно, с точки зрения CSS `width:auto` – совершенно нормально, но нам-то в JavaScript нужен конкретный размер в `px`, который мы могли бы использовать для вычислений. Получается, что в данном случае ширина из CSS вообще бесполезна.

Есть и ещё одна причина: полоса прокрутки. Бывает, без полосы прокрутки код работает прекрасно, но стоит ей появиться, как начинают проявляться баги. Так происходит потому, что полоса прокрутки «отъедает» место от области внутреннего содержимого в некоторых браузерах. Таким образом, реальная ширина содержимого *меньше* CSS-ширины. Как раз это и учитывают свойства `clientWidth`/`clientHeight`.

…Но с `getComputedStyle(elem).width` ситуация иная. Некоторые браузеры (например, Chrome) возвращают реальную внутреннюю ширину с вычетом ширины полосы прокрутки, а некоторые (например, Firefox) – именно CSS-свойство (игнорируя полосу прокрутки). Эти кроссбраузерные отличия – ещё один повод не использовать `getComputedStyle`, а использовать свойства-метрики.

На ОС Windows браузеры Firefox, Chrome и Edge резервируют место для полосы прокрутки. Но Firefox отображает `300px`, в то время как Chrome и Edge – меньше. Это из-за того, что Firefox возвращает именно CSS-ширину, а остальные браузеры – «реальную» ширину за вычетом прокрутки.

Обратите внимание: описанные различия касаются только чтения свойства `getComputedStyle(...).width` из JavaScript, визуальное отображение корректно в обоих случаях.

#### Итого
У элементов есть следующие геометрические свойства (метрики):

- `offsetParent` – ближайший CSS-позиционированный родитель или ближайший `td`, `th`, `table`, `body`.
- `offsetLeft`/`offsetTop` – позиция в пикселях верхнего левого угла относительно `offsetParent`.
- `offsetWidth`/`offsetHeight` – «внешняя» ширина/высота элемента, включая рамки.
- `clientLeft`/`clientTop` – расстояние от верхнего левого внешнего угла до внутренного. Для операционных систем с ориентацией слева-направо эти свойства равны ширинам левой/верхней рамки. Если язык ОС таков, что ориентация справа налево, так что вертикальная полоса прокрутки находится не справа, а слева, то `clientLeft` включает в своё значение её ширину.
- `clientWidth`/`clientHeight` – ширина/высота содержимого вместе с внутренними отступами `padding`, но без полосы прокрутки.
- `scrollWidth`/`scrollHeight` – ширина/высота содержимого, аналогично `clientWidth`/`Height`, но учитывают прокрученную, невидимую область элемента.
- `scrollLeft`/`scrollTop` – ширина/высота прокрученной сверху части элемента, считается от верхнего левого угла.

Все свойства доступны только для чтения, кроме `scrollLeft`/`scrollTop`, изменение которых заставляет браузер прокручивать элемент.

#### Задачи

##### Найти размер прокрутки снизу

Свойство `elem.scrollTop` содержит размер прокрученной области при отсчёте сверху. А как подсчитать размер прокрутки снизу (назовём его `scrollBottom`)?

Напишите соответствующее выражение для произвольного элемента `elem`.

P.S. Проверьте: если прокрутки нет вообще или элемент полностью прокручен – оно должно давать `0`.

<details>
<summary>Решение</summary>

Решение:
```js
let scrollBottom = elem.scrollHeight - elem.scrollTop - elem.clientHeight;
```

Другими словами: (вся высота) минус (часть, прокрученная сверху) минус (видимая часть) – результат в точности соответствует размеру прокрутки снизу.

</details>

##### Узнать ширину полосы прокрутки

Напишите код, который возвращает ширину стандартной полосы прокрутки.

Для Windows она обычно колеблется от `12px` до `20px`. Если браузер не выделяет место под полосу прокрутки (так тоже бывает, она может быть прозрачной над текстом), тогда значение может быть `0px`.

P.S. Ваш код должен работать в любом HTML-документе, независимо от его содержимого.

<details>
<summary>Решение</summary>

Чтобы получить ширину полосы прокрутки, создадим элемент с прокруткой, но без рамок и внутренних отступов.

Тогда разница между его полной шириной `offsetWidth` и шириной внутреннего содержимого `clientWidth` будет равна как раз прокрутке:
```js
// создадим элемент с прокруткой
let div = document.createElement('div');

div.style.overflowY = 'scroll';
div.style.width = '50px';
div.style.height = '50px';

// мы должны вставить элемент в документ, иначе размеры будут равны 0
document.body.append(div);
let scrollWidth = div.offsetWidth - div.clientWidth;

div.remove();

alert(scrollWidth);
```

</details>

##### Поместите мяч в центр поля

Исходный документ выглядит так:

![Ball field](../img/ball-field.png)

Каковы координаты центра поля?

Вычислите их и используйте, чтобы поместить мяч в центр поля:

![Ball field](../img/ball-field-center.png)

- Элемент должен позиционироваться за счёт JavaScript, а не CSS.
- Код должен работать с любым размером мяча (10, 20, 30 пикселей) и любым размером поля без привязки к исходным значениям.

P.S. Да, центрирование можно сделать при помощи чистого CSS, но задача именно на JavaScript. Далее будут другие темы и более сложные ситуации, когда JavaScript будет уже точно необходим, это – своего рода «разминка».

[Исходный код документа](../src/10_dom/ball-field.html)

<details>
<summary>Решение</summary>

Мяч имеет CSS-свойство `position:absolute`. Это означает, что координаты `left`/`top` измеряются относительно ближайшего спозиционированного элемента, которым является `#field` (т.к. у него есть CSS-свойство `position:relative`).

Координаты отсчитываются от внутреннего верхнего левого угла поля:

![Field](../svg/field.svg)

Ширина и высота внутреннего поля – это `clientWidth`/`clientHeight`. Таким образом, его центр имеет координаты (`clientWidth/2`, `clientHeight/2`).

…Но если мы установим мячу такие значения `ball.style.left`/`top`, то в центре будет не сам мяч, а его левый верхний угол:
```js
ball.style.left = Math.round(field.clientWidth / 2) + 'px';
ball.style.top = Math.round(field.clientHeight / 2) + 'px';
```

Вот как это выглядит:

![Ball field](../img/ball-field.png)

Для того, чтобы центр мяча находился в центре поля, нам нужно сместить мяч на половину его ширины влево и на половину его высоты вверх:
```js
ball.style.left = Math.round(field.clientWidth / 2 - ball.offsetWidth / 2) + 'px';
ball.style.top = Math.round(field.clientHeight / 2 - ball.offsetHeight / 2) + 'px';
```

**Внимание, подводный камень!**

Код выше стабильно работать не будет, потому что `<img>` идёт без ширины/высоты:
```html
<img src="ball.png" id="ball">
```

Если браузеру неизвестны ширина и высота изображения (из атрибута HTML-тега или CSS-свойств), он считает их равными 0 до тех пор, пока изображение не загрузится.

При первой загрузке браузер обычно кеширует изображения, так что при последующей загрузке оно будет доступно тут же, вместе с размерами. Но при первой загрузке значение ширины мяча `ball.offsetWidth` равно 0. Это приводит к вычислению неверных координат.

Мы можем исправить это, добавив атрибуты `width`/`height` тегу `<img>`:
```html
<img src="ball.png" width="40" height="40" id="ball">
```

…Или задав размеры в CSS:
```css
#ball {
  width: 40px;
  height: 40px;
}
```

[Исходный код](../src/10_dom/ball-into-center.html)

</details>

##### В чём отличие CSS-свойств width и clientWidth

В чём отличие между `getComputedStyle(elem).width` и `elem.clientWidth`?

Укажите хотя бы 3 отличия, лучше – больше.

<details>
<summary>Решение</summary>

Отличия:

1. `clientWidth` возвращает число, а `getComputedStyle(elem).width` – строку с `px` на конце.
2. `getComputedStyle` не всегда даст ширину, он может вернуть, к примеру, "auto" для строчного элемента.
3. `clientWidth` соответствует внутренней области элемента, включая внутренние отступы padding, а CSS-ширина (при стандартном значении `box-sizing`) соответствует внутренней области *без внутренних отступов* `padding`.
4. Если есть полоса прокрутки, и для неё зарезервировано место, то некоторые браузеры вычитают его из CSS-ширины (т.к. оно больше недоступно для содержимого), а некоторые – нет. Свойство `clientWidth` всегда ведёт себя одинаково: оно всегда обозначает размер за вычетом прокрутки, т.е. реально доступный для содержимого.

</details>

### Размеры и прокрутка окна
Как узнать ширину и высоту окна браузера? Как получить полную ширину и высоту документа, включая прокрученную часть? Как прокрутить страницу с помощью JavaScript?

Для большинства таких запросов мы можем использовать корневой элемент документа `document.documentElement`, который соответствует тегу `<html>`. Однако есть дополнительные методы и особенности, которые необходимо учитывать.[^size-and-scroll-window]

#### Ширина/высота окна
Чтобы получить ширину/высоту окна, можно взять свойства `clientWidth`/`clientHeight` из `document.documentElement`:

![Document clientWidth/Height](../svg/document-client-width-height.svg)

!!! warning "Не `window.innerWidth`/`Height`"

    Браузеры также поддерживают свойства `window.innerWidth/innerHeight`. Вроде бы, похоже на то, что нам нужно. Почему же не использовать их?

    Если есть полоса прокрутки, и она занимает какое-то место, то свойства `clientWidth`/`clientHeight` указывают на ширину/высоту документа без неё (за её вычетом). Иными словами, они возвращают высоту/ширину видимой части документа, доступной для содержимого.

    А `window.innerWidth/innerHeight` включают в себя полосу прокрутки.

    Если полоса прокрутки занимает некоторое место, то эти две строки выведут разные значения:
    ```js
    alert( window.innerWidth ); // полная ширина окна
    alert( document.documentElement.clientWidth ); // ширина окна за вычетом полосы прокрутки
    ```

    В большинстве случаев нам нужна *доступная* ширина окна: для рисования или позиционирования. Полоса прокрутки «отъедает» её часть. Поэтому следует использовать `documentElement.clientHeight`/`Width`.

!!! warning "`DOCTYPE` – это важно"
    Обратите внимание, что геометрические свойства верхнего уровня могут работать немного иначе, если в HTML нет `<!DOCTYPE HTML>`. Возможны странности.

    В современном HTML мы всегда должны указывать `DOCTYPE`.

#### Ширина/высота документа
Теоретически, т.к. корневым элементом документа является `documentElement`, и он включает в себя всё содержимое, мы можем получить полный размер документа как `documentElement.scrollWidth`/`scrollHeight`.

Но именно на этом элементе, для страницы в целом, эти свойства работают не так, как предполагается. В Chrome/Safari/Opera, если нет прокрутки, то `documentElement.scrollHeight` может быть даже меньше, чем `documentElement.clientHeight`! С точки зрения элемента это невозможная ситуация.

Чтобы надёжно получить полную высоту документа, нам следует взять максимальное из этих свойств:
```js
let scrollHeight = Math.max(
  document.body.scrollHeight, document.documentElement.scrollHeight,
  document.body.offsetHeight, document.documentElement.offsetHeight,
  document.body.clientHeight, document.documentElement.clientHeight
);

alert('Полная высота документа с прокручиваемой частью: ' + scrollHeight);
```

Почему? Лучше не спрашивайте. Эти несоответствия идут с древних времён. Глубокой логики здесь нет.

#### Получение текущей прокрутки
Обычные элементы хранят текущее состояние прокрутки в `elem.scrollLeft/scrollTop`.

Что же со страницей? В большинстве браузеров мы можем обратиться к `documentElement.scrollLeft`/`Top`, за исключением основанных на старом WebKit (Safari), где есть ошибка (5991), и там нужно использовать `document.body` вместо `document.documentElement`.

К счастью, нам совсем не обязательно запоминать эти особенности, потому что текущую прокрутку можно прочитать из свойств `window.pageXOffset`/`pageYOffset`:
```js
alert('Текущая прокрутка сверху: ' + window.pageYOffset);
alert('Текущая прокрутка слева: ' + window.pageXOffset);
```

Эти свойства доступны только для чтения.

!!! info "В качестве свойств объекта `window` также доступны `scrollX` и `scrollY`"
    По историческим причинам существует два аналога `window.pageXOffset` и `window.pageYOffset`:

    - `window.pageXOffset` – то же самое, что и `window.scrollX`.
    - `window.pageYOffset` – то же самое, что и `window.scrollY`.

#### Прокрутка: scrollTo, scrollBy, scrollIntoView

!!! warning "Важно:"
    Для прокрутки страницы из JavaScript её DOM должен быть полностью построен.

    Например, если мы попытаемся прокрутить страницу из скрипта, подключенного в `<head>`, это не сработает.

Обычные элементы можно прокручивать, изменяя `scrollTop`/`scrollLeft`.

Мы можем сделать то же самое для страницы в целом, используя `document.documentElement.scrollTop`/`Left` (кроме основанных на старом WebKit (Safari), где, как сказано выше, `document.body.scrollTop`/`Left`).

Есть и другие способы, в которых подобных несовместимостей нет: специальные методы [`window.scrollBy(x,y)`](https://developer.mozilla.org/ru/docs/Web/API/Window/scrollBy) и [`window.scrollTo(pageX,pageY)`](https://developer.mozilla.org/ru/docs/Web/API/Window/scrollTo).

- Метод `scrollBy(x,y)` прокручивает страницу относительно её текущего положения. Например, `scrollBy(0,10)` прокручивает страницу на `10px` вниз.

- Метод `scrollTo(pageX,pageY)` прокручивает страницу на абсолютные координаты (`pageX`,`pageY`). То есть, чтобы левый-верхний угол видимой части страницы имел данные координаты относительно левого верхнего угла документа. Это всё равно, что поставить `scrollLeft`/`scrollTop`. Для прокрутки в самое начало мы можем использовать `scrollTo(0,0)`.


В обоих методах вместо координат также может использоваться объект `options`, как аргумент:
```js
window.scrollTo(options);
window.scrollBy(options);
```

`options` поддерживает три свойства:
```js
window.scrollTo({
  top: 100,
  left: 0,
  behavior: "smooth"
});
```

- `top` – то же самое, что `y`/`pageY`

- `left` – то же самое, что `x`/`pageX`

- `behavior` – определяет, каким образом будет прокручиваться страница:

    - "smooth" – плавно (не поддерживается в IE и в старых версиях Safari)
    - "instant" – мгновенно
    - "auto" – определяется браузером (зависит от CSS-свойства [`scroll-behavior`](https://developer.mozilla.org/ru/docs/Web/CSS/scroll-behavior))

#### scrollIntoView
Для полноты картины давайте рассмотрим ещё один метод: [`elem.scrollIntoView(top)`](https://developer.mozilla.org/ru/docs/Web/API/Element/scrollIntoView).

Вызов `elem.scrollIntoView(top)` прокручивает страницу, чтобы `elem` оказался вверху. У него есть один аргумент:

- если `top=true` (по умолчанию), то страница будет прокручена, чтобы `elem` появился в верхней части окна. Верхний край элемента совмещён с верхней частью окна.
- если `top=false`, то страница будет прокручена, чтобы `elem` появился внизу. Нижний край элемента будет совмещён с нижним краем окна.

Как и `scrollTo`/`scrollBy`, `scrollIntoView` также принимает объект `options` как аргумент (он немного отличается):
```js
this.scrollIntoView(options).
```

`options` поддерживает три свойства:
```js
this.scrollIntoView({
  behavior: "smooth",
  block: "end",
  inline: "nearest"
});
```

- `behavior` – анимация прокрутки (`smooth`, `instant`, `auto`)
- `block` – вертикальное выравнивание (`start`, `center`, `end`, `nearest`). Значение по умолчанию: `start`
- `inline` – горизонтальное выравнивание (`start`, `center`, `end`, `nearest`). Значение по умолчанию: `nearest`

#### Запретить прокрутку
Иногда нам нужно сделать документ «непрокручиваемым». Например, при показе большого диалогового окна над документом – чтобы посетитель мог прокручивать это окно, но не документ.

Чтобы запретить прокрутку страницы, достаточно установить `document.body.style.overflow = "hidden"`.

Аналогичным образом мы можем «заморозить» прокрутку для других элементов, а не только для `document.body`.

Недостатком этого способа является то, что сама полоса прокрутки исчезает. Если она занимала некоторую ширину, то теперь эта ширина освободится, и содержимое страницы расширится, текст «прыгнет», заняв освободившееся место.

Это выглядит немного странно, но это можно обойти, если сравнить `clientWidth` до и после остановки, и если `clientWidth` увеличится (значит полоса прокрутки исчезла), то добавить `padding` в `document.body` вместо полосы прокрутки, чтобы оставить ширину содержимого прежней.

#### Итого
Размеры:

- Ширина/высота видимой части документа (ширина/высота области содержимого): `document.documentElement.clientWidth`/`Height`

- Ширина/высота всего документа со всей прокручиваемой областью страницы:

    ```js
    let scrollHeight = Math.max(
      document.body.scrollHeight, document.documentElement.scrollHeight,
      document.body.offsetHeight, document.documentElement.offsetHeight,
      document.body.clientHeight, document.documentElement.clientHeight
    );
    ```

Прокрутка:

- Прокрутку окна можно получить так: `window.pageYOffset`/`pageXOffset`.

- Изменить текущую прокрутку:

    - `window.scrollTo(pageX,pageY)` – абсолютные координаты,
    - `window.scrollBy(x,y)` – прокрутка относительно текущего места,
    - `elem.scrollIntoView(top)` – прокрутить страницу так, чтобы сделать `elem` видимым (выровнять относительно верхней/нижней части окна).[^size-and-scroll-window]

### Координаты
Чтобы передвигать элементы по экрану, нам следует познакомиться с системами координат.

Большинство соответствующих методов JavaScript работают в одной из двух указанных ниже систем координат:

1. **Относительно окна браузера** – как `position:fixed`, отсчёт идёт от верхнего левого угла окна.

- мы будем обозначать эти координаты как `clientX`/`clientY`, причина выбора таких имён будет ясна позже, когда мы изучим свойства событий.

2. **Относительно документа** – как `position:absolute` на уровне документа, отсчёт идёт от верхнего левого угла документа.

- мы будем обозначать эти координаты как `pageX`/`pageY`.

Когда страница полностью прокручена в самое начало, то верхний левый угол окна совпадает с левым верхним углом документа, при этом обе этих системы координат тоже совпадают. Но если происходит прокрутка, то координаты элементов в контексте окна меняются, так как они двигаются, но в то же время их координаты относительно документа остаются такими же.[^coordinates]

На приведённой картинке взята точка в документе и показаны её координаты до прокрутки (слева) и после (справа):

![Document and window coordinates scrolled](../svg/document-and-window-coordinates-scrolled.svg)

При прокрутке документа:

- `pageY` – координата точки относительно документа осталась без изменений, так как отсчёт по-прежнему ведётся от верхней границы документа (сейчас она прокручена наверх).
- `clientY` – координата точки относительно окна изменилась (стрелка на рисунке стала короче), так как точка стала ближе к верхней границе окна.

#### Координаты относительно окна: getBoundingClientRect
Метод `elem.getBoundingClientRect()` возвращает координаты в контексте окна для минимального по размеру прямоугольника, который заключает в себе элемент `elem`, в виде объекта встроенного класса [`DOMRect`](https://www.w3.org/TR/geometry-1/#domrect).

Основные свойства объекта типа `DOMRect`:

- `x`/`y` – X/Y-координаты начала прямоугольника относительно окна,
- `width`/`height` – ширина/высота прямоугольника (могут быть отрицательными).

Дополнительные, «зависимые», свойства:

- `top`/`bottom` – Y-координата верхней/нижней границы прямоугольника,
- `left`/`right` – X-координата левой/правой границы прямоугольника.

Если вы прокрутите страницу, то расположение кнопки в окне поменяется, и, соответственно, её координаты в контексте окна тоже (при вертикальной прокрутке – `y`/`top`/`bottom`).

Вот картинка с результатами вызова `elem.getBoundingClientRect()`:

![Coordinates](../svg/coordinates.svg)

Как вы видите, `x`/`y` и `width`/`height` уже точно задают прямоугольник. Остальные свойства могут быть легко вычислены на их основе:

- `left = x`
- `top = y`
- `right = x + width`
- `bottom = y + height`

Заметим:

- Координаты могут считаться с десятичной частью, например `10.5`. Это нормально, ведь браузер использует дроби в своих внутренних вычислениях. Мы не обязаны округлять значения при установке `style.left/top`.
- Координаты могут быть отрицательными. Например, если страница прокручена так, что элемент `elem` ушёл вверх за пределы окна, то вызов `elem.getBoundingClientRect().top` вернёт отрицательное значение.

!!! info "Зачем вообще нужны зависимые свойства? Для чего существуют top/left, если есть x/y?"
    С математической точки зрения, прямоугольник однозначно задаётся начальной точкой `(x,y)` и вектором направления `(width,height)`.

    Так что дополнительные зависимые свойства существуют лишь для удобства.

    Что же касается `top`/`left`, то они на самом деле не всегда равны `x`/`y`. Технически, значения `width`/`height` могут быть отрицательными. Это позволяет задать «направленный» прямоугольник, например, для выделения мышью с отмеченным началом и концом.

    То есть, отрицательные значения `width`/`height` означают, что прямоугольник «растет» влево-вверх из правого угла.

    Вот прямоугольник с отрицательными `width` и `height` (например, `width=-200`, `height=-100`):

    ![Coordinates negative](../svg/coordinates-negative.svg)

    Как вы видите, свойства `left`/`top` при этом не равны `x`/`y`.

    Впрочем, на практике результат вызова `elem.getBoundingClientRect()` всегда возвращает положительные значения для ширины/высоты. Здесь мы упомянули отрицательные `width`/`height` лишь для того, чтобы было понятно, зачем существуют эти с виду дублирующие свойства.

!!! warning "Internet Explorer и Edge: не поддерживают `x`/`y`"
    Internet Explorer и Edge не поддерживают свойства `x`/`y` по историческим причинам.

    Таким образом, мы можем либо сделать полифил (добавив соответствующие геттеры в `DomRect.prototype`), либо использовать `top`/`left`, так как это всегда одно и то же при положительных `width`/`height`, в частности – в результате вызова `elem.getBoundingClientRect()`.

!!! warning "Координаты right/bottom отличаются от одноимённых CSS-свойств"
    Есть очевидное сходство между координатами относительно окна и CSS `position:fixed`.

    Но в CSS свойство `right` означает расстояние от правого края, и свойство `bottom` означает расстояние от нижнего края окна браузера.

    Если взглянуть на картинку выше, то видно, что в JavaScript это не так. Все координаты в контексте окна считаются от верхнего левого угла, включая `right`/`bottom`.

#### elementFromPoint(x, y)
Вызов `document.elementFromPoint(x, y)` возвращает самый глубоко вложенный элемент в окне, находящийся по координатам `(x, y)`.

Синтаксис:
```js
let elem = document.elementFromPoint(x, y);
```

Например, код ниже выделяет с помощью стилей и выводит имя тега элемента, который сейчас в центре окна браузера:
```js
let centerX = document.documentElement.clientWidth / 2;
let centerY = document.documentElement.clientHeight / 2;

let elem = document.elementFromPoint(centerX, centerY);

elem.style.background = "red";
alert(elem.tagName);
```

Поскольку используются координаты в контексте окна, то элемент может быть разным, в зависимости от того, какая сейчас прокрутка.

!!! warning "Для координат за пределами окна метод `elementFromPoint` возвращает `null`"
    Метод `document.elementFromPoint(x,y)` работает, только если координаты `(x,y)` относятся к видимой части содержимого окна.

    Если любая из координат представляет собой отрицательное число или превышает размеры окна, то возвращается `null`.

    Вот типичная ошибка, которая может произойти, если в коде нет соответствующей проверки:
    ```js
    let elem = document.elementFromPoint(x, y);
    // если координаты ведут за пределы окна, то elem = null
    elem.style.background = ''; // Ошибка!
    ```

#### Применение для fixed позиционирования
Чаще всего нам нужны координаты для позиционирования чего-либо.

Чтобы показать что-то около нужного элемента, мы можем вызвать `getBoundingClientRect`, чтобы получить его координаты, а затем использовать CSS-свойство position вместе с `left`/`top` (или `right`/`bottom`).

Например, функция `createMessageUnder(elem, html)` ниже показывает сообщение под элементом `elem`:
```js
let elem = document.getElementById("coords-show-mark");

function createMessageUnder(elem, html) {
  // создаём элемент, который будет содержать сообщение
  let message = document.createElement('div');
  // для стилей лучше было бы использовать css-класс здесь
  message.style.cssText = "position:fixed; color: red";

  // устанавливаем координаты элементу, не забываем про "px"!
  let coords = elem.getBoundingClientRect();

  message.style.left = coords.left + "px";
  message.style.top = coords.bottom + "px";

  message.innerHTML = html;

  return message;
}

// Использование:
// добавим сообщение на страницу на 5 секунд
let message = createMessageUnder(elem, 'Hello, world!');
document.body.append(message);
setTimeout(() => message.remove(), 5000);
```

Код можно изменить, чтобы показывать сообщение слева, справа, снизу, применять к нему CSS-анимации и так далее. Это просто, так как в нашем распоряжении имеются все координаты и размеры элемента.

Но обратите внимание на одну важную деталь: при прокрутке страницы сообщение уплывает от кнопки.

Причина весьма очевидна: сообщение позиционируется с помощью `position:fixed`, поэтому оно остаётся всегда на том же самом месте в окне при прокрутке страницы.

Чтобы изменить это, нам нужно использовать другую систему координат, где сообщение позиционировалось бы относительно документа, и свойство `position:absolute`.

#### Координаты относительно документа
В такой системе координат отсчёт ведётся от левого верхнего угла документа, не окна.

В CSS координаты относительно окна браузера соответствуют свойству `position:fixed`, а координаты относительно документа – свойству `position:absolute` на самом верхнем уровне вложенности.

Мы можем воспользоваться свойствами `position:absolute` и `top`/`left`, чтобы привязать что-нибудь к конкретному месту в документе. При этом прокрутка страницы не имеет значения. Но сначала нужно получить верные координаты.

Не существует стандартного метода, который возвращал бы координаты элемента относительно документа, но мы можем написать его сами.

Две системы координат связаны следующими формулами:

- `pageY` = `clientY` + высота вертикально прокрученной части документа.
- `pageX` = `clientX` + ширина горизонтально прокрученной части документа.

Функция `getCoords(elem)` берёт координаты в контексте окна с помощью `elem.getBoundingClientRect()` и добавляет к ним значение соответствующей прокрутки:
```js
// получаем координаты элемента в контексте документа
function getCoords(elem) {
  let box = elem.getBoundingClientRect();

  return {
    top: box.top + window.pageYOffset,
    right: box.right + window.pageXOffset,
    bottom: box.bottom + window.pageYOffset,
    left: box.left + window.pageXOffset
  };
}
```

Если бы в примере выше мы использовали её вместе с `position:absolute`, то при прокрутке сообщение оставалось бы рядом с элементом.

Модифицированная функция `createMessageUnder`:
```js
function createMessageUnder(elem, html) {
  let message = document.createElement('div');
  message.style.cssText = "position:absolute; color: red";

  let coords = getCoords(elem);

  message.style.left = coords.left + "px";
  message.style.top = coords.bottom + "px";

  message.innerHTML = html;

  return message;
}
```

#### Итого
Любая точка на странице имеет координаты:

1. Относительно окна браузера – `elem.getBoundingClientRect()`.
2. Относительно документа – `elem.getBoundingClientRect()` плюс текущая прокрутка страницы.

Координаты в контексте окна подходят для использования с `position:fixed`, а координаты относительно документа – для использования с `position:absolute`.

Каждая из систем координат имеет свои преимущества и недостатки. Иногда будет лучше применить одну, а иногда – другую, как это и происходит с позиционированием в CSS, где мы выбираем между `absolute` и `fixed`.

#### Задачи

##### Найдите координаты точек относительно окна браузера

В ифрейме ниже располагается документ с зелёным «полем».

Используйте JavaScript, чтобы найти координаты углов, обозначенных стрелками.

В [документе](../samples/10_dom/point-coords.html) уже реализована функциональность, когда при клике на любом месте показываются соответствующие координаты.

![Point coordinates](../img/point-coords.png)

Ваш код должен при помощи DOM получить четыре пары координат:

1. верхний левый, внешний угол (это просто).
2. нижний правый, внешний угол (тоже просто).
3. верхний левый, внутренний угол (чуть сложнее).
4. нижний правый, внутренний угол (есть несколько способов, выберите один).

Координаты, вычисленные вами, должны совпадать с теми, которые возвращаются по клику мыши.

P.S. Код должен работать, если у элемента другие размеры или есть рамка, без привязки к конкретным числам.

<details>
<summary>Решение</summary>

**Внешние углы**

Координаты внешних углов – это как раз то, что возвращает функция [`elem.getBoundingClientRect()`](https://developer.mozilla.org/ru/docs/DOM/element.getBoundingClientRect).

Координаты верхнего левого внешнего угла будут в переменной `answer1` и нижнего правого – в `answer2`:
```js
let coords = elem.getBoundingClientRect();

let answer1 = [coords.left, coords.top];
let answer2 = [coords.right, coords.bottom];
```

**Верхний левый внутренний угол**

Тут значения отличаются на ширину рамки. Надёжный способ получить интересующее значение – это использовать `clientLeft`/`clientTop`:
```js
let answer3 = [coords.left + field.clientLeft, coords.top + field.clientTop];
```

**Нижний правый внутренний угол**

В нашем случае нужно вычесть размеры рамки из внешних координат.

Это может быть сделано с помощью CSS:
```js
let answer4 = [
  coords.right - parseInt(getComputedStyle(field).borderRightWidth),
  coords.bottom - parseInt(getComputedStyle(field).borderBottomWidth)
];
```

Другим вариантом решения было бы добавление `clientWidth`/`clientHeight` к координатам верхнего левого угла. Так даже было бы лучше.
```js
let answer4 = [
  coords.left + elem.clientLeft + elem.clientWidth,
  coords.top + elem.clientTop + elem.clientHeight
];
```

[Код решения](../src/10_dom/point-coords.html)

</details>

##### Покажите заметку рядом с элементом

Создайте функцию `positionAt(anchor, position, elem)`, которая позиционирует элемент `elem` в зависимости от значения свойства `position` рядом с элементом `anchor`.

Аргумент `position` – строка с одним из 3 значений:

- `"top"` – расположить `elem` прямо над `anchor`
- `"right"` – расположить `elem` непосредственно справа от `anchor`
- `"bottom"` – расположить `elem` прямо под `anchor`

Она используется внутри функции `showNote(anchor, position, html)`, которая уже есть в исходном коде задачи. Она создаёт и показывает элемент-«заметку» с текстом `html` на заданной позиции `position` рядом с элементом `anchor`.

Демо заметки:

![Note beside](../img/note-beside.png)

<details>
<summary>Решение</summary>

В этой задаче нам нужно только аккуратно вычислить координаты. Смотрите код для изучения деталей реализации.

Обратите внимание, что элементы должны уже быть в документе перед чтением `offsetHeight` и других свойств. Спрятанный (`display:none`) элемент или элемент вне документа не имеют размеров.

[Код решения](../src/10_dom/note-beside.html)

</details>

##### Покажите заметку около элемента (абсолютное позиционирование)

Измените код решения [предыдущего задания](#покажите-заметку-рядом-с-элементом) так, чтобы элемент заметки использовал свойство `position:absolute` вместо `position:fixed`.

Это предотвратит расхождение элементов при прокрутке страницы.

Используйте решение предыдущего задания для начала. Чтобы проверить решение в условиях с прокруткой, добавьте стиль элементу `<body style="height: 2000px">`.

<details>
<summary>Решение</summary>

Решение достаточно простое:

- Используйте `position:absolute` в CSS вместо `position:fixed` для элемента с классом `.note`.
- Используйте функцию [`getCoords()`](#координаты-относительно-документа) из раздела [Координаты](#координаты), чтобы получить координаты относительно документа.

[Код решения](../src/10_dom/note-absolute.html)

</details>

##### Расположите заметку внутри элемента (абсолютное позиционирование)

Усовершенствуйте решение предыдущего задания [Покажите заметку около элемента (абсолютное позиционирование)](#покажите-заметку-около-элемента-абсолютное-позиционирование): научите функцию `positionAt(anchor, position, elem)` вставлять `elem` внутрь `anchor`.

Новые значения для аргумента `position`:

- `top-out`, `right-out`, `bottom-out` – работают так же, как раньше, они вставляют `elem` сверху/справа/снизу `anchor`.
- `top-in`, `right-in`, `bottom-in` – вставляют `elem` внутрь `anchor`: приклеивают его к верхнему/правому/нижнему краю.

Например:
```js
// показывает заметку поверх цитаты
positionAt(blockquote, "top-out", note);

// показывает заметку внутри цитаты вблизи верхнего края элемента
positionAt(blockquote, "top-in", note);
```

![Note beside](../img/note-inside.png)

Для начала возьмите решение задания [Покажите заметку около элемента (абсолютное позиционирование)](#покажите-заметку-около-элемента-абсолютное-позиционирование).


<details>
<summary>Решение</summary>

[Код решения](../src/10_dom/note-inside.html)

</details>

### Практическая работа. Навигация по DOM-узлам

#### Задание

1. **Дочерние элементы в DOM**

    Для страницы:
    ```html
    <html>
    <body>
      <div>Пользователи:</div>
      <ul>
        <li>Джон</li>
        <li>Пётр</li>
      </ul>
    </body>
    </html>
    ```

    Написать код, позволяющий получить:

    - элемент `<div>`;
    - `<ul>`;
    - второй `<li>` (с именем Пит).

    <details>
    <summary>Решение</summary>

    Есть несколько способов для получения элементов, например:

    DOM-узел элемента `<div>`:
    ```js
    document.body.firstElementChild
    // или
    document.body.children[0]
    // или (первый узел пробел, поэтому выбираем второй)
    document.body.childNodes[1]
    ```

    DOM-узел элемента `<ul>`:
    ```js
    document.body.lastElementChild
    // или
    document.body.children[1]
    ```

    Второй `<li>` (с именем Пётр):
    ```js
    // получаем <ul>, и его последнего ребёнка
    document.body.lastElementChild.lastElementChild
    ```

    </details>

2. **Выделение ячеек по диагонали**

    Написать код, который выделит красным цветом все ячейки в таблице по диагонали.

    Необходимо получить из таблицы `<table>` все диагональные `<td>` и выделить их, используя код:
    ```js
    //  в переменной td находится DOM-элемент для тега <td>
    td.style.backgroundColor = 'red';
    ```

    Должно получиться так:

    ![Table](../img/diagonal-selection.png)

    <details>
    <summary>Решение</summary>

    Для получения доступа к диагональным ячейкам таблицы используем свойства `rows` и `cells`.

    [Исходный код](../src/10_dom/diagonal-selection.html)

    </details>

### Практическая работа. Работа с DOM-элементами

#### Задание

Написать код, который выведет каждый элемент любого многоуровнего списка `<li>` со следующей информацией:

- внутренний текст (без поддерева);
- уровень элемента списка;
- число элементов-потомков – всех вложенных `<li>`.

Информация должна выводиться в консоль в виде списка, отформатированного аналогично HTML-списку. Должны поддерживаться как маркированные, так и нумерованные списки, содержащие любое количество элементов любой вложенности.

<details>
<summary>Пример верстки</summary>

```html
 <main>
    <section aria-labelledby="toc-title">
      <h1 id="toc-title">Содержание</h1>
      <ol>
        <li>
          Введение в DOM
          <ul>
            <li>Браузерное окружение</li>
            <li>DOM (Document Object Model)</li>
            <li>BOM (Browser Object Model)</li>
            <li>Стандарты и спецификации</li>
          </ul>
        </li>
        <li>
          DOM-дерево
          <ul>
            <li>Виды узлов DOM</li>
            <li>Просмотр структуры DOM</li>
            <li>Взаимодействие с консолью</li>
          </ul>
        </li>
        <li>
          Узлы DOM
          <ul>
            <li>
              Объект Node
              <ul>
                <li>Классы DOM-узлов</li>
                <li>Свойства узлов</li>
                <li>Свойство «nodeType»</li>
                <li>Тег: nodeName и tagName</li>
              </ul>
            </li>
            <li>Свойства объекта document</li>
            <li>Навигационные свойства</li>
            <li>Специфичные навигационные свойства</li>
          </ul>
        </li>
      </ol>
    </section>
  </main>
```
</details>

<details>
<summary>Пример результата</summary>

```
1. Введение в DOM. Уровень 1. Потомков: 4.
    - Браузерное окружение. Уровень 2. Потомков: 0.
    - DOM (Document Object Model). Уровень 2. Потомков: 0.
    - BOM (Browser Object Model). Уровень 2. Потомков: 0.
    - Стандарты и спецификации. Уровень 2. Потомков: 0.
2. DOM-дерево. Уровень 1. Потомков: 3.
   - Виды узлов DOM. Уровень 2. Потомков: 0.
   - Просмотр структуры DOM. Уровень 2. Потомков: 0.
   - Взаимодействие с консолью. Уровень 2. Потомков: 0.
3. Узлы DOM. Уровень 1. Потомков: 4.
    - Объект Node. Уровень 2. Потомков: 4.
      - Классы DOM-узлов. Уровень 3. Потомков 0.
      - Свойства узлов. Уровень 3. Потомков 0.
      - Свойство «nodeType». Уровень 3. Потомков 0.
      - Тег: nodeName и tagName. Уровень 3. Потомков 0.
    - Свойства объекта document. Уровень 2. Потомков: 0.
    - Навигационные свойства. Уровень 2. Потомков: 0.
    - Специфичные навигационные свойства. Уровень 2. Потомков: 0.
```

</details>

Для обхода элементов использовать навигационные свойства. Результат предоставить в виде отдельного файла-сценария, который можно подключить к любому HTML-файлу, содержащего список.

<details>
<summary>Тестовый список</summary>

**Объектная модель документа**

1. Введение в DOM
    - Браузерное окружение
    - DOM (Document Object Model)
    - BOM (Browser Object Model)
    - Стандарты и спецификации
2. DOM-дерево
   - Виды узлов DOM
   - Просмотр структуры DOM
   - Взаимодействие с консолью
3. Узлы DOM
    - Объект Node
      - Классы DOM-узлов
      - Свойства узлов
      - Свойство «nodeType»
      - Тег: nodeName и tagName
    - Свойства объекта document
    - Навигационные свойства
    - Специфичные навигационные свойства
4. Элементы
    - Свойства элементов
    - Управление текстом элемента
      - Свойство textContent
      - Свойство innerText
    - Управление кодом HTML
      - innerHTML: содержимое элемента
      - innerHTML: перезапись содержимого
      - outerHTML: HTML элемента целиком
    - Свойство «hidden»
    - Другие свойства
5. Поиск элементов на веб-странице
    - Получение элементов по id
    - Поиск по определенному тегу
    - Получение элементов по классу
    - Поиск элементов по атрибуту name
    - Поиск элементов по селектору CSS
    - Поиск во вложенных элементах
    - Живые коллекции
6. Изменение документа
    - Создание элементов
    - Добавление элементов
      - Методы вставки
      - insertAdjacentHTML/Text/Element
      - Устаревшие методы вставки
        - appendChild
        - insertBefore
    - Копирование узлов
      - Клонирование элементов
      - DocumentFragment
    - Замена узлов
      - Замена через родителя
      - Замена текущего узла
    - Удаление узлов
      - Удаление элемента
      - Удаление всех элементов
7. Атрибуты элементов и свойства DOM-объектов
    - DOM-свойства
    - HTML-атрибуты
    - Управление атрибутами элементов
      - Получение атрибута
      - Установка атрибутов
      - Удаление атрибута
    - Синхронизация между атрибутами и свойствами
    - DOM-свойства типизированы
    - Нестандартные атрибуты, dataset
8. Управление стилем и классами элементов
    - Свойство className
    - Свойство classList
    - Свойство style
    - Сброс стилей
    - Следите за единицами измерения
    - Вычисленные стили: getComputedStyle

</details>

<details>
<summary>Решение</summary>

Пройдём циклом по всем элементам `<li>`:
```js
for (let li of document.querySelectorAll('li')) {
  ...
}
```

В цикле нам нужно получить текст в каждом элементе `li`. Мы можем прочитать текстовое содержимое элемента списка из первого дочернего узла `li`, который будет текстовым узлом:
```js
for (let li of document.querySelectorAll('li')) {
  let title = li.firstChild.data;

  // переменная title содержит текст элемента <li>
}
```

Так мы сможем получить количество потомков как `li.getElementsByTagName('li').length`.

[Исходный код](../src/10_dom/counting-descendants.html)

</details>

### Практическая работа. Поиск элементов на веб-странице
На заданной странице (код прилагается к заданию) найти следующие элементы:

1. Таблицу с идентификатором `"age-table"`.
2. Все элементы меток (`label`) внутри этой таблицы (их три).
3. Первую ячейку (`td`) в этой таблице (со словом «Возраст»).
4. Форму `form` с именем "search".
5. Первое поле ввода (`input`) в этой форме.
6. Последнее поле ввода в этой форме.

Результаты поиска соответствующих элементов по пунктам выводить в консоль: четных пунктов в виде объектов, нечетных — в виде элементов. Приложить решение в виде отдельного файла-сценария.

[Код страницы](../src/10_dom/elements-search/index.html)

<details>
<summary>Решение</summary>

Есть много путей как это сделать.

Вот некоторые:
```js
// 1. Таблица с `id="age-table"`.
let table = document.getElementById('age-table')

// 2. Все label в этой таблице
table.getElementsByTagName('label')
// или
document.querySelectorAll('#age-table label')

// 3. Первый td в этой таблице
table.rows[0].cells[0]
// или
table.getElementsByTagName('td')[0]
// или
table.querySelector('td')

// 4. Форма с name="search"
// предполагаем, что есть только один элемент с таким name в документе
let form = document.getElementsByName('search')[0]
// или, именно форма:
document.querySelector('form[name="search"]')

// 5. Первый input в этой форме
form.getElementsByTagName('input')[0]
// или
form.querySelector('input')

// 6. Последний input в этой форме
let inputs = form.querySelectorAll('input') // найти все input
inputs[inputs.length-1] // взять последний
```

</details>

### Практическая работа. Модификация веб-страницы

#### Задание
Выполнить набор задач, представленных ниже.

1. **Список**

    Написать интерфейс для создания списка.

    1. Для каждого пункта списка:

       - запрашивать содержимое пункта у пользователя с помощью `prompt`;
       - создавать элемент `<li>` и добавлять его к `<ul>`;
       - продолжать до тех пор, пока пользователь не отменит ввод (нажатием клавиши <kbd>Esc</kbd> или введя пустую строку).

    2. Все элементы должны создаваться динамически.

    3. Если пользователь вводит HTML-теги, они должны обрабатываться как текст.

    <details>
    <summary>Решение</summary>

    Обратите внимание на использование `textContent` для добавления содержимого в `<li>`.

    [Исходный код](../src/10_dom/list.html)

    </details>

2. **Дерево из объекта**

    Написать функцию `createTree`, которая создаёт вложенный список `ul`/`li` из объекта.

    Например:
    ```js
    let data = {
      "Рыбы": {
        "форель": {},
        "лосось": {}
      },

      "Деревья": {
        "Огромные": {
          "секвойя": {},
          "дуб": {}
        },
        "Цветковые": {
          "яблоня": {},
          "магнолия": {}
        }
      }
    };
    ```

    Синтаксис:
    ```js
    let container = document.getElementById('container');
    createTree(container, data); // создаёт дерево в контейнере
    ```

    Результат (дерево):

    ![Tree example](../img/obj-tree.png)

    1. Для решения этой задачи использовать следующие способы (постараться реализовать оба):

       - создать строку, а затем присвоить через `container.innerHTML`;
       - создавать узлы через методы DOM.

    2. В дереве не должно быть лишних элементов, в частности пустых `<ul></ul>` на нижнем уровне.

    <details>
    <summary>Решение</summary>

    Самый лёгкий способ – это использовать рекурсию.

    4. [Решение с innerHTML](../src/10_dom/tree-from-obj_1.html).

    5. [Решение через DOM](../src/10_dom/tree-from-obj_2.html).

    </details>

3. **Список потомков в дереве**

    Есть дерево, организованное в виде вложенных списков `ul`/`li`.

    1. Написать код, который добавит каждому элементу списка `<li>` количество вложенных в него элементов.
    2. Узлы нижнего уровня (без детей) пропускать.

    Результат:

    ![Tree descendants](../img/tree-obj.png)

    <details>
    <summary>Решение</summary>

    Чтобы добавить текст к каждому `<li>`, мы можем изменить текстовый узел `data`.

    [Исходный код](../src/10_dom/tree-descendants.html)

    </details>

4. **Календарь в виде таблицы**

    Написать функцию `createCalendar(elem, year, month)`.

    1. Вызов функции должен создать календарь для заданного месяца `month` в году `year` и вставить его в `elem`.

    2. Календарь должен быть таблицей, где неделя – это `<tr>`, а день – это `<td>`. У таблицы должен быть заголовок с названиями дней недели, каждый день – `<th>`, первым днём недели должен быть понедельник.

    3. Достаточно сгенерировать календарь, интерактивным (кликабельным) его делать не нужно.

    Например, `createCalendar(cal, 2012, 9)` сгенерирует в `cal` следующий календарь:

    ![Calendar example](../img/calendar-dom.png)

    <details>
    <summary>Решение</summary>

    Для решения задачи сгенерируем таблицу в виде строки: `"<table>...</table>"`, а затем присвоим в `innerHTML`.

    Алгоритм:

    1. Создать заголовок таблицы с `<th>` и именами дней недели.
    2. Создать объект даты `d = new Date(year, month-1)`. Это первый день месяца `month` (с учётом того, что месяцы в JS начинаются от 0, а не от 1).
    3. Ячейки первого ряда пустые от начала и до дня недели `d.getDay()`, с которого начинается месяц. Заполним `<td></td>`.
    4. Увеличить день в `d`: `d.setDate(d.getDate()+1)`. Если `d.getMonth()` ещё не в следующем месяце, то добавим новую ячейку `<td>` в календарь. Если это воскресенье, то добавим новую строку «`</tr><tr>`».
    5. Если месяц закончился, но строка таблицы ещё не заполнена, добавим в неё пустые `<td>`, чтобы сделать в календаре красивые пустые квадратики.

    [Исходный код](../src/10_dom/calendar.html)

    </details>

Решение приложить в виде отдельных файлов-сценариев.

### Практическая работа. Управление атрибутами элементов

#### Задание
Выполнить набор задач, представленных ниже.

1. **Получение атрибута**

    Написать код для выбора элемента с атрибутом `data-widget-name` из документа и прочитать его значение.

    ```html
    <!DOCTYPE html>
    <html>
    <body>

      <div data-widget-name="menu">Choose the genre</div>

      <script>
        /* your code */
      </script>
    </body>
    </html>
    ```

    <details>
    <summary>Решение</summary>

    ```html
    <!DOCTYPE html>
    <html>
    <body>

      <div data-widget-name="menu">Choose the genre</div>

      <script>
        // получаем элемент
        let elem = document.querySelector('[data-widget-name]');

        // читаем значение
        alert(elem.dataset.widgetName);
        // или так
        alert(elem.getAttribute('data-widget-name'));
      </script>
    </body>
    </html>
    ```

    </details>

2. **Оранжевые внешние ссылки**

    Сделать все внешние ссылки оранжевыми, изменяя их свойство `style`.

    Ссылка является внешней, если:

    - её `href` содержит `://`;
    - но не начинается с `http://internal.com`.

    Пример:
    ```html
    <a name="list">Источники информации</a>
    <ul>
      <li><a href="http://google.com">http://google.com</a></li>
      <li><a href="/tutorial">/tutorial.html</a></li>
      <li><a href="local/path">local/path</a></li>
      <li><a href="ftp://ftp.com/my.zip">ftp://ftp.com/my.zip</a></li>
      <li><a href="http://nodejs.org">http://nodejs.org</a></li>
      <li><a href="http://internal.com/test">http://internal.com/test</a></li>
    </ul>

    <script>
      // добавление стиля для одной ссылки
      let link = document.querySelector('a');
      link.style.color = 'orange';
    </script>
    ```

    Результат должен быть таким:

    ![Task orange external links](../img/orange-links_0.png)

    <details>
    <summary>Решение</summary>

    Во-первых, мы должны найти все внешние ссылки.

    Это можно сделать двумя способами.

    Первый – это найти все ссылки, используя `document.querySelectorAll('a')`, а затем отфильтровать ненужное:
    ```js
    let links = document.querySelectorAll('a');

    for (let link of links) {
      let href = link.getAttribute('href');
      if (!href) continue; // нет атрибута

      if (!href.includes('://')) continue; // нет протокола

      if (href.startsWith('http://internal.com')) continue; // внутренняя

      link.style.color = 'orange';
    }
    ```

    Пожалуйста, обратите внимание: мы используем `link.getAttribute('href')`. Не `link.href`, потому что нам нужно значение из HTML.

    …Другой, более простой путь – добавить проверку в CSS-селектор:
    ```js
    // найти все ссылки, атрибут href у которых содержит ://
    // и при этом href не начинается с http://internal.com
    let selector = 'a[href*="://"]:not([href^="http://internal.com"])';
    let links = document.querySelectorAll(selector);

    links.forEach(link => link.style.color = 'orange');
    ```

    [Исходный код](../src/10_dom/orange-links.html)

    </details>

Решение приложить в виде отдельных файлов-сценариев.

### Практическая работа. Создание уведомления

#### Задание

Написать функцию `showNotification(options)`, которая создаёт уведомление: `<div class="notification">` с заданным содержимым. Уведомление должно автоматически исчезнуть через 1,5 секунды (для чего использовать встроенную функцию `setTimeout`).

Пример объекта `options`:
```js
// показывает элемент с текстом "Hello" рядом с правой верхней частью окна.
showNotification({
  top: 10, // 10px от верхней границы окна (по умолчанию 0px)
  right: 10, // 10px от правого края окна (по умолчанию 0px)
  html: "Hello!", // HTML-уведомление
  className: "welcome" // дополнительный класс для div (необязательно)
});
```

Использовать CSS-позиционирование для отображения элемента в заданных координатах. Исходный документ должен иметь необходимые стили.

<details>
<summary>Решение</summary>

[Исходный код](../src/10_dom/create-notification/index.html)

</details>

Решение приложить в виде html-файла, содержащего сценарий и демонстрирующий работу разработанной функции.

### Практическая работа. Реализация поведения "подсказка"

#### Задание
Напишите JS-код, реализующий поведение «подсказка».

При наведении мыши на элемент с атрибутом `data-tooltip`, над ним должна показываться подсказка и скрываться при переходе на другой элемент.

Пример HTML с подсказками:
```html
<button data-tooltip="эта подсказка длиннее, чем элемент">Короткая кнопка</button>
<button data-tooltip="HTML<br>подсказка">Ещё кнопка</button>
```

Иллюстрация результата:

![Tooltip](../img/tooltip_01.png)

Детали оформления:

1. Отступ от подсказки до элемента с `data-tooltip` должен быть 5px по высоте.
2. Подсказка должна быть, по возможности, посередине элемента.
3. Подсказка не должна вылезать за границы экрана, в том числе если страница частично прокручена, если нельзя показать сверху – показывать снизу элемента.
4. Текст подсказки брать из значения атрибута `data-tooltip`. Это может быть произвольный HTML.
5. В один момент может быть показана только одна подсказка.

Иллюстрация поведения:

![Tooltip](../img/tooltip_02.png)

![Tooltip](../img/tooltip_03.png)

![Tooltip](../img/tooltip_04.png)

![Tooltip](../img/tooltip_05.png)

Для решения понадобятся два события:

- `mouseover` срабатывает, когда указатель мыши заходит на элемент.
- `mouseout` срабатывает, когда указатель мыши уходит с элемента.

Применить делегирование событий: установить оба обработчика на элемент `document`, чтобы отслеживать «заход» и «уход» курсора на элементы с атрибутом `data-tooltip` и управлять подсказками с их же помощью.

Допустимо считать, что во всех элементах с атрибутом `data-tooltip` должен использоваться только текст, без вложенных тегов.

После реализации такого поведения люди, даже не знакомые с JavaScript должны иметь возможность добавлять подсказки к элементам.

### Источники информации
[^8.1]: [Введение в DOM](https://metanit.com/web/javascript/8.1.php)
[^8.3]: [Свойства объекта document](https://metanit.com/web/javascript/8.3.php)
[^8.2]: [Поиск элементов на веб-странице](https://metanit.com/web/javascript/8.2.php)
[^8.4]: [Объект Node. Навигация по DOM](https://metanit.com/web/javascript/8.4.php)
[^8.6]: [Элементы](https://metanit.com/web/javascript/8.6.php)
[^8.5]: [Создание, добавление, замена и удаление элементов](https://metanit.com/web/javascript/8.5.php)
[^8.9]: [Управление атрибутами элементов](https://metanit.com/web/javascript/8.9.php)
[^8.7]: [Изменение стиля элементов](https://metanit.com/web/javascript/8.7.php)
[^browser-environment]: [Браузерное окружение, спецификации](https://learn.javascript.ru/browser-environment)
[^dom-nodes]: [DOM-дерево](https://learn.javascript.ru/dom-nodes)
[^dom-navigation]: [Навигация по DOM-элементам](https://learn.javascript.ru/dom-navigation)
[^searching-elements-dom]: [Поиск: getElement*, querySelector*](https://learn.javascript.ru/searching-elements-dom)
[^basic-dom-node-properties]: [Свойства узлов: тип, тег и содержимое](https://learn.javascript.ru/basic-dom-node-properties)
[^dom-attributes-and-properties]: [Атрибуты и свойства](https://learn.javascript.ru/dom-attributes-and-properties)
[^modifying-document]: [Изменение документа](https://learn.javascript.ru/modifying-document)
[^styles-and-classes]: [Стили и классы](https://learn.javascript.ru/styles-and-classes)
[^size-and-scroll]: [Размеры и прокрутка элементов](https://learn.javascript.ru/size-and-scroll)
[^size-and-scroll-window]: [Размеры и прокрутка окна](https://learn.javascript.ru/size-and-scroll-window)
[^coordinates]: [Координаты](https://learn.javascript.ru/coordinates)
