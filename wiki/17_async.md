# Асинхронное программирование

- [Асинхронные действия и коллбеки](#асинхронные-действия-и-коллбеки)
  - [Асинхронные действия](#асинхронные-действия)
  - [Обратные вызовы](#обратные-вызовы)
  - [Перехват ошибок](#перехват-ошибок)
  - [Колбэк в колбэке](#колбэк-в-колбэке)
  - [Недостатки колбеков](#недостатки-колбеков)
  - [Решение проблемы](#решение-проблемы)
- [Промисы](#промисы)
  - [Введение в промисы](#введение-в-промисы)
    - [resolve и reject](#resolve-и-reject)
    - [Успешное выполнение промиса](#успешное-выполнение-промиса)
    - [Передача информации об ошибке](#передача-информации-об-ошибке)
    - [Объединение resolve и reject](#объединение-resolve-и-reject)
  - [Получение результата операции в Promise](#получение-результата-операции-в-promise)
    - [Метод Promise.resolve](#метод-promiseresolve)
    - [Определение промиса через функцию](#определение-промиса-через-функцию)
      - [Гибкая настройка функции](#гибкая-настройка-функции)
  - [Обработка ошибок в Promise](#обработка-ошибок-в-promise)
    - [Функция catch](#функция-catch)
    - [Генерация ошибки](#генерация-ошибки)
      - [throw](#throw)
      - [try..catch](#trycatch)
    - [Обработка ошибки с помощью функции then](#обработка-ошибки-с-помощью-функции-then)
  - [Очистка](#очистка)
    - [Метод finally](#метод-finally)
    - [Особенности finally](#особенности-finally)
    - [Пример: loadScript](#пример-loadscript)
    - [Задачи](#задачи)
      - [Можно ли "перевыполнить" промис?](#можно-ли-перевыполнить-промис)
      - [Задержка на промисах](#задержка-на-промисах)
      - [Анимация круга с помощью промиса](#анимация-круга-с-помощью-промиса)
  - [Цепочка промисов](#цепочка-промисов)
    - [Возвращаем промисы](#возвращаем-промисы)
    - [Создание цепочек промисов](#создание-цепочек-промисов)
    - [Пример: loadScript](#пример-loadscript-1)
    - [Более сложный пример: fetch](#более-сложный-пример-fetch)
    - [Итого](#итого)
    - [Задачи](#задачи-1)
      - [Промисы: сравните then и catch](#промисы-сравните-then-и-catch)
    - [Обработка ошибок](#обработка-ошибок)
      - [Неявный try…catch](#неявный-trycatch)
      - [Обработка ошибок в цепочке промисов](#обработка-ошибок-в-цепочке-промисов)
      - [Возвращение Promise из catch](#возвращение-promise-из-catch)
      - [Пробрасывание ошибок](#пробрасывание-ошибок)
    - [Необработанные ошибки](#необработанные-ошибки)
    - [Метод finally](#метод-finally-1)
    - [Итого](#итого-1)
    - [Задачи](#задачи-2)
      - [Ошибка в setTimeout](#ошибка-в-settimeout)
  - [Promise API](#promise-api)
    - [Promise.all](#promiseall)
    - [Promise.allSettled](#promiseallsettled)
      - [Полифил](#полифил)
    - [Promise.race](#promiserace)
    - [Promise.any](#promiseany)
    - [Сравнение методов](#сравнение-методов)
    - [Promise.resolve/reject](#promiseresolvereject)
      - [Promise.resolve](#promiseresolve)
      - [Promise.reject](#promisereject)
    - [Итого](#итого-2)
  - [Промисификация](#промисификация)
- [Async/await](#asyncawait)
  - [Async и await](#async-и-await)
    - [Выполнение последовательности асинхронных операций](#выполнение-последовательности-асинхронных-операций)
    - [Обработка ошибок](#обработка-ошибок-1)
  - [Асинхронные итераторы](#асинхронные-итераторы)
    - [Цикл for-await-of](#цикл-for-await-of)
    - [Создание асинхронного итератора](#создание-асинхронного-итератора)
  - [Асинхронные генераторы](#асинхронные-генераторы)
    - [await в асинхронных генераторах](#await-в-асинхронных-генераторах)
- [Источники информации](#источники-информации)

## Асинхронные действия и коллбеки
При стандартном выполнении JavaScript инструкции выполняются последовательно, одна за другой. То есть сначала выполняется первая инструкция, потом вторая и так далее. Однако что, если одна из этих операций выполняется продолжительное время. Например, она выполняет какую-то высоконагруженную работу, как обращение по сети или обращение к базе данных, что может занять неопределенное и иногда продолжительное время. В итоге при последовательном выполнении все последующие операции будут ожидать выполнения этой операции. Чтобы избежать подобной ситуации, JavaScript позволяет избежать подобного сценария с помощью *асинхронных функций*.[^17.9]

Например, определим простую асинхронную функцию, которая эмулирует долгую работу с помощью вызова `setTimeout()` и задержки в 1 секунду, а затем выводит на консоль случайное число:
```js
function asyncFunction() {
    setTimeout(()=>{
        let result = 22;
        console.log("result:", result);
    }, 1000);
}
asyncFunction();
console.log("Конец программы");
```

Вместо `setTimeout()` здесь мог бы быть запрос к базе данных или запрос к сетевому ресурсу, которые могли бы занять продолжительное время и результат которых был бы получен через некоторое время. И в результате значение числа было бы ведено на консоль в самом конце выполнения программы:
```
Конец программы
result: 22
```

Здесь мы видим, что асинхронная функция не блокирует выполнение остальных инструкций программы. Однако при работе с подобными функциями мы можем столкнуться с рядом проблем. Так, асинхронные функции не возвращают результат асинхронного вычисления через ключевое слово `return`, а передают его в качестве параметра функции обратного вызова.

```js
function asyncFunction() {
    let result;
    setTimeout(()=>{result = 22;}, 1000);
    return result;
}
const asyncResult = asyncFunction();
console.log("result:", asyncResult) // result: undefined
```

Здесь асинхронная функция `asyncFunction` вызывается в синхронной манере, в итоге мы получаем неопределенный результат. Потому что переменная `asyncResult` устанавливается до того, как функция `asyncFunction` сгенерирует результат.

Другая проблема связана с генерацией ошибок через оператор **`throw`**:
```js
function asyncFunction() {
    let result;
    setTimeout(()=>{
        result = 22;
        if(result < 50) {
            throw new Error("Некорректное значение");
        }
    }, 1000);
    return result;
}
try {
    const asyncResult = asyncFunction();
    console.log("result:", asyncResult)
}
catch(error) {
    console.error("Error:", error); // Эта строка НЕ выполняется
}
console.log("Конец программы");
```

Здесь обработка ошибки в блоке `catch` работать не будет, так как к моменту выдачи ошибки вызывающий код уже ушел и некому поймать ошибку.

### Асинхронные действия
Многие действия в JavaScript *асинхронные*.

Например, рассмотрим функцию `loadScript(src)`:
```js
function loadScript(src) {
  let script = document.createElement('script');
  script.src = src;
  document.head.append(script);
}
```

Эта функция загружает на страницу новый скрипт. Когда в тело документа добавится конструкция `<script src="…">`, браузер загрузит скрипт и выполнит его.

Вот пример использования этой функции:
```js
// загрузит и выполнит скрипт
loadScript('/my/script.js');
```

Такие функции называют «асинхронными», потому что действие (загрузка скрипта) будет завершено не сейчас, а потом.

Если после вызова `loadScript(…)` есть какой-то код, то он не будет ждать, пока скрипт загрузится.

```js
loadScript('/my/script.js');
// код, написанный после вызова функции loadScript,
// не будет дожидаться полной загрузки скрипта
// ...
```

Мы хотели бы использовать новый скрипт, как только он будет загружен. Скажем, он объявляет новую функцию, которую мы хотим выполнить.

Но если мы просто вызовем эту функцию после `loadScript(…)`, у нас ничего не выйдет:
```js
loadScript('/my/script.js'); // в скрипте есть "function newFunction() {…}"

newFunction(); // такой функции не существует!
```

Действительно, ведь у браузера не было времени загрузить скрипт. Сейчас функция loadScript никак не позволяет отследить момент загрузки. Скрипт загружается, а потом выполняется. Но нам нужно точно знать, когда это произойдёт, чтобы использовать функции и переменные из этого скрипта.

### Обратные вызовы
Изначально обработки результата и ошибок в асинхронных функциях представляло использование коллбеков-функций обратного вызова, которые передавались в другую функцию и вызывались позже в некоторый момент времени. Простейший шаблон использования коллбеков:
```js
function asyncFunction(callback) {
    console.log("Перед вызовом коллбека");
    callback();
    console.log("После вызова коллбека");
}
function callbackFunc() {
    console.log("Вызов коллбека");
}
asyncFunction(callbackFunc);
```

Здесь функция `asyncFunction` (условно асинхронная функция) принимает функцию обратного вызова — `callback` и вызывает ее в коде.

Например, используем коллбек для получения и обработки результата и ошибки асинхронной функции:
```js
function handleResult(error, result){
    if(error) {     // если передана ошибка
        console.error(error);
    }
    else {          // если асинхронная функция завершилась успешно
        console.log("Result:", result);
    }
}

function asyncFunction(callback) {
    setTimeout(()=>{
        let result = Math.floor(Math.random() * 100) + 1;
        if(result < 50) {
                    // если меньше 50, устанавливаем ошибку
            callback(new Error("Некорректное значение: " + result), null);
        }
        else{
                    // в остальных случаях устанавливаем результат
            callback(null, result);
        }
    }, 1000);
}
asyncFunction(handleResult);
```

В качестве коллбека в асинхронную функцию `asyncFunction` передается функция `handleResult`
```js
asyncFunction(handleResult);
```

Для примера, чтобы число представляло случайное значение, здесь применяется метод `Math.random()`.

```js
let result = Math.floor(Math.random() * 100) + 1;
```

Если сгенерированное число меньше 50, то устанавливаем первый параметр функции `handleResult`, который представляет ошибку:
```js
if(result < 50) {
    // если меньше 50, устанавливаем ошибку
    callback(new Error("Некорректное значение: " + result), null);
}
```

В остальных случаях устанавливаем результат, а для ошибки передаем `null`:
```js
else{
    // в остальных случаях устанавливаем результат
    callback(null, result);
}
```

Консольный вывод при успешной обработке (когда сгенерированное число равно или больше 50):
```
Result: 70
```

Если сгенерированное число меньше 50, то будет выводиться ошибка:
```
Error: Некорректное значение: 35
```

Давайте передадим функцию `callback` вторым аргументом в `loadScript`, чтобы вызвать её, когда скрипт загрузится:
```js
function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;
  script.onload = () => callback(script);
  document.head.append(script);
}
```

Само событие `onload` описано в разделе, посвященном загрузке ресурсов, оно в основном выполняет функцию после загрузки и выполнения скрипта.

Теперь, если мы хотим вызвать функцию из скрипта, нужно делать это в колбэке:
```js
loadScript('/my/script.js', function() {
  // эта функция вызовется после того, как загрузится скрипт
  newFunction(); // теперь всё работает
  ...
});
```

Смысл такой: вторым аргументом передаётся функция (обычно анонимная), которая выполняется по завершении действия.

Возьмём для примера реальный скрипт с библиотекой функций:
```js
function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;
  script.onload = () => callback(script);
  document.head.append(script);
}

loadScript('https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.2.0/lodash.js', script => {
  alert(`Здорово, скрипт ${script.src} загрузился`);
  alert( _ ); // функция, объявленная в загруженном скрипте
});
```

Такое написание называют **асинхронным программированием с использованием колбэков**. В функции, которые выполняют какие-либо асинхронные операции, передаётся аргумент `callback` — функция, которая будет вызвана по завершению асинхронного действия.

Мы поступили похожим образом в `loadScript`, но это, конечно, распространённый подход.[^callbacks]

### Перехват ошибок
В примерах выше мы не думали об ошибках. А что если загрузить скрипт не удалось? Колбэк должен уметь реагировать на возможные проблемы.

Ниже улучшенная версия `loadScript`, которая умеет отслеживать ошибки загрузки:
```js
function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;

  script.onload = () => callback(null, script);
  script.onerror = () => callback(new Error(`Не удалось загрузить скрипт ${src}`));

  document.head.append(script);
}
```

Мы вызываем `callback(null, script)` в случае успешной загрузки и `callback(error)`, если загрузить скрипт не удалось.

Живой пример:
```js
loadScript('/my/script.js', function(error, script) {
  if (error) {
    // обрабатываем ошибку
  } else {
    // скрипт успешно загружен
  }
});
```

Опять же, подход, который мы использовали в `loadScript`, также распространён и называется «**колбэк с первым аргументом-ошибкой**» («error-first callback»).

Правила таковы:

1. Первый аргумент функции `callback` зарезервирован для ошибки. В этом случае вызов выглядит вот так: `callback(err)`.
2. Второй и последующие аргументы — для результатов выполнения. В этом случае вызов выглядит вот так: `callback(null, result1, result2…)`.

Одна и та же функция `callback` используется и для информирования об ошибке, и для передачи результатов.[^callbacks]

### Колбэк в колбэке
Как нам загрузить два скрипта один за другим: сначала первый, а за ним второй?

Первое, что приходит в голову, вызвать `loadScript` ещё раз уже внутри колбэка, вот так:
```js
loadScript('/my/script.js', function(script) {

  alert(`Здорово, скрипт ${script.src} загрузился, загрузим ещё один`);

  loadScript('/my/script2.js', function(script) {
    alert(`Здорово, второй скрипт загрузился`);
  });

});
```

Когда внешняя функция `loadScript` выполнится, вызовется та, что внутри колбэка.

А что если нам нужно загрузить ещё один скрипт?..

```js
loadScript('/my/script.js', function(script) {

  loadScript('/my/script2.js', function(script) {

    loadScript('/my/script3.js', function(script) {
      // ...и так далее, пока все скрипты не будут загружены
    });

  })

});
```

Каждое новое действие мы вынуждены вызывать внутри колбэка. Этот вариант подойдёт, когда у нас одно-два действия, но для большего количества уже не удобно. Альтернативные подходы мы скоро разберём.[^callbacks]

### Недостатки колбеков
Выше рассматривалась классическая схема использования коллбеков для обработки результата асинхронной функции. На первый взгляд это рабочий способ написания асинхронного кода. Так и есть. Однако она имеет как минимум один большой недостаток: чрезмерное использование функций обратного вызова может привести к созданию структуры кода, известной среди разработчиков JavaScript как **callback hell** (ад коллбеков).

Для одного или двух вложенных вызовов всё выглядит нормально. Но для нескольких асинхронных действий, которые нужно выполнить друг за другом, код выглядит вот так:
```js
loadScript('1.js', function(error, script) {

  if (error) {
    handleError(error);
  } else {
    // ...
    loadScript('2.js', function(error, script) {
      if (error) {
        handleError(error);
      } else {
        // ...
        loadScript('3.js', function(error, script) {
          if (error) {
            handleError(error);
          } else {
            // ...и так далее, пока все скрипты не будут загружены (*)
          }
        });

      }
    })
  }
});
```

В примере выше:

1. Мы загружаем *1.js*. Продолжаем, если нет ошибок.
2. Мы загружаем *2.js*. Продолжаем, если нет ошибок.
3. Мы загружаем *3.js*. Продолжаем, если нет ошибок. И так далее `(*)`.

Такая структура кода возникает, когда коллбек в одной асинхронной функции вызывает другую асинхронную функцию, коллбек которой, в свою очередь, может вызывать третью асинхронную функцию и так далее. Пример подобной структуры:
```js
asyncFunction( (error, result) => {
    asyncFunction2( (error2, result2) => {
        asyncFunction3( (error3, result3) => {
            asyncFunction4( (error4, result4) => {
                // некоторый код
            });
        });
    });
});
```

Чем больше вложенных вызовов, тем наш код будет иметь всё большую вложенность, которую сложно поддерживать, особенно если вместо `...` у нас код, содержащий другие цепочки вызовов, условия и т.д.

Иногда это называют «адом колбэков» или «адской пирамидой колбэков».

![Callback hell](../svg/callback-hell.svg)

Пирамида вложенных вызовов растёт вправо с каждым асинхронным действием. В итоге вы сами будете путаться, где что есть.

Такой подход к написанию кода не приветствуется.

### Решение проблемы
Мы можем попытаться решить эту проблему, изолируя каждое действие в отдельную функцию, вот так:
```js
loadScript('1.js', step1);

function step1(error, script) {
  if (error) {
    handleError(error);
  } else {
    // ...
    loadScript('2.js', step2);
  }
}

function step2(error, script) {
  if (error) {
    handleError(error);
  } else {
    // ...
    loadScript('3.js', step3);
  }
}

function step3(error, script) {
  if (error) {
    handleError(error);
  } else {
    // ...и так далее, пока все скрипты не будут загружены (*)
  }
};
```

Заметили? Этот код делает всё то же самое, но вложенность отсутствует, потому что все действия вынесены в отдельные функции.

Код абсолютно рабочий, но кажется разорванным на куски. Его трудно читать, вы наверняка заметили это. Приходится прыгать глазами между кусками кода, когда пытаешься его прочесть. Это неудобно, особенно, если читатель не знаком с кодом и не знает, что за чем следует.

Кроме того, все функции `step*` одноразовые, и созданы лишь только, чтобы избавиться от «адской пирамиды вызовов». Никто не будет их переиспользовать где-либо ещё. Таким образом, мы, кроме всего прочего, засоряем пространство имён.

Нужно найти способ получше.

К счастью, такие способы существуют. Именно для решения этой проблемы начиная со стандарта ES2015 в JavaScript была добавлена поддержка промисов, которые рассматриваются далее.

## Промисы

### Введение в промисы
Представьте, что вы известный певец, которого фанаты постоянно донимают расспросами о предстоящем сингле.

Чтобы получить передышку, вы обещаете разослать им сингл, когда он будет выпущен. Вы даёте фанатам список, в который они могут записаться. Они могут оставить там свой e-mail, чтобы получить песню, как только она выйдет. И даже больше: если что-то пойдёт не так, например, в студии будет пожар и песню выпустить не выйдет, они также получат уведомление об этом.

Все счастливы! Вы счастливы, потому что вас больше не донимают фанаты, а фанаты больше не беспокоятся, что пропустят новый сингл.

Это аналогия из реальной жизни для ситуаций, с которыми мы часто сталкиваемся в программировании:

1. Есть «создающий» код, который делает что-то, что занимает время. Например, загружает данные по сети. В нашей аналогии это – «певец».
2. Есть «потребляющий» код, который хочет получить результат «создающего» кода, когда он будет готов. Он может быть необходим более чем одной функции. Это – «фанаты».
3. `Promise` (по англ. *promise*, будем называть такой объект «промис») – это специальный объект в JavaScript, который связывает «создающий» и «потребляющий» коды вместе. В терминах нашей аналогии – это «список для подписки». «Создающий» код может выполняться сколько потребуется, чтобы получить результат, а промис делает результат доступным для кода, который подписан на него, когда результат готов.

Аналогия не совсем точна, потому что объект `Promise` в JavaScript гораздо сложнее простого списка подписок: он обладает дополнительными возможностями и ограничениями. Но для начала и такая аналогия хороша.[^promise-basics]

Итак, <dfn title="промис">Промис</dfn> (*promise*) — это объект, представляющий результат успешного или неудачного завершения асинхронной операции. <dfn title="асинхронная операция">Асинхронная операция</dfn>, упрощенно говоря, — это некоторое действие, выполняется независимо от окружающего ее кода, в котором она вызывается, не блокирует выполнение вызываемого кода.

Промис может находиться в одном из следующих состояний:

- **`pending`** (состояние ожидания): начальное состояние, промис создан, но выполнение еще не завершено

- **`fulfilled`** (успешно завершено): действие, которое представляет промис, успешно завершено

- **`rejected`** (завершено с ошибкой): при выполнении действия, которое представляет промис, произошла ошибка

Для создания промиса применяется конструктор типа **`Promise`**:
```js
new Promise(executor)
```

В качестве параметра конструктор принимает функцию, которая выполняется при создании промиса. Обычно эта функция представляет асинхронные операции, которые занимают продолжительное время. Например, определим простейший промис:
```js
const myPromise = new Promise(function(){
    console.log("Выполнение асинхронной операции");
});
```

Здесь функция просто выводит на консоль сообщение. Соответственно при выполнении этого кода мы увидим на консоли сообщение `"Выполнение асинхронной операции"`.

При создании промиса, когда его функция еще не начала выполняться, промис переходит в состояние "pending", то есть ожидает выполнения.

Для эмуляции асинхронности определим несколько промисов:
```js
const myPromise3000 = new Promise(function(){
    console.log("[myPromise3000] Выполнение асинхронной операции");
    setTimeout(()=>console.log("[myPromise3000] Завершение асинхронной операции"), 3000);
});
const myPromise1000 = new Promise(function(){
    console.log("[myPromise1000] Выполнение асинхронной операции");
    setTimeout(()=>console.log("[myPromise1000] Завершение асинхронной операции"), 1000);
});
const myPromise2000 = new Promise(function(){
    console.log("[myPromise2000] Выполнение асинхронной операции");
    setTimeout(()=>console.log("[myPromise2000] Завершение асинхронной операции"), 2000);
});
```

Здесь определены три однотипных промиса. Чтобы каждый из них не выполнялся сразу, они используют функцию `setTimeout` с задержкой в несколько секунд. Для разных промисов длительность задержки различается. И в данном случае мы получим следующий консольный вывод:
```
[myPromise3000] Выполнение асинхронной операции
[myPromise1000] Выполнение асинхронной операции
[myPromise2000] Выполнение асинхронной операции
[myPromise1000] Завершение асинхронной операции
[myPromise2000] Завершение асинхронной операции
[myPromise3000] Завершение асинхронной операции
```

Здесь мы видим, что первым начал выполняться промис `myPromise3000`, однако он же завершился последним, так как для него установлено наибольшее время задержки — 3 секунды. Однако его задержка не помешала выполнению остальных промисов.[^17.1]

#### resolve и reject
Как правило, функция, которая передается в конструктор `Promise`, принимает два параметра:
```js
const myPromise = new Promise(function(resolve, reject){
    console.log("Выполнение асинхронной операции");
});
```

Оба этих параметра — `resolve` и `reject` — также представляют функции. И каждая из этих функций принимает параметр любого типа.

Первый параметр — функция `resolve` — вызывается в случае успешного выполнения. Мы можем в нее передать значение, которое мы можем получить в результате успешного выполнения.

Второй параметр — функция `reject` — вызывается, если выполнение операции завершилось с ошибкой. Мы можем в нее передать значение, которое представит некоторую информацию об ошибке.

Полный синтаксис создания `Promise`:
```js
let promise = new Promise(function(resolve, reject) {
  // функция-исполнитель (executor)
  // "певец"
});
```

Функция, переданная в конструкцию `new Promise`, называется <dfn title="исполнитель">исполнитель</dfn> (*executor*). Когда `Promise` создаётся, она запускается автоматически. Она должна содержать «создающий» код, который когда-нибудь создаст результат. В терминах нашей аналогии: *исполнитель* – это «певец».

Её аргументы `resolve` и `reject` – это колбэки, которые предоставляет сам JavaScript. Наш код – только внутри исполнителя.

Когда он получает результат, сейчас или позже – не важно, он должен вызвать один из этих колбэков:

- `resolve(value)` — если работа завершилась успешно, с результатом `value`.
- `reject(error)` — если произошла ошибка, error – объект ошибки.

Итак, исполнитель запускается автоматически, он должен выполнить работу, а затем вызвать `resolve` или `reject`.

У объекта `promise`, возвращаемого конструктором `new Promise`, есть внутренние свойства:

- `state` («состояние») — вначале `"pending"` («ожидание»), потом меняется на `"fulfilled"` («выполнено успешно») при вызове `resolve` или на `"rejected"` («выполнено с ошибкой») при вызове `reject`.
- `result` («результат») — вначале `undefined`, далее изменяется на `value` при вызове `resolve(value)` или на `error` при вызове `reject(error)`.

Так что исполнитель по итогу переводит `promise` в одно из двух состояний:

![Promise resolve/reject](../svg/promise-resolve-reject.svg)

Позже мы рассмотрим, как «фанаты» узнают об этих изменениях.

Ниже пример конструктора `Promise` и простого исполнителя с кодом, дающим результат с задержкой (через `setTimeout`):
```js
let promise = new Promise(function(resolve, reject) {
  // эта функция выполнится автоматически, при вызове new Promise

  // через 1 секунду сигнализировать, что задача выполнена с результатом "done"
  setTimeout(() => resolve("done"), 1000);
});
```

Мы можем наблюдать две вещи, запустив код выше:

1. Функция-исполнитель запускается сразу же при вызове `new Promise`.
2. Исполнитель получает два аргумента: `resolve` и `reject` — это функции, встроенные в JavaScript, поэтому нам не нужно их писать. Нам нужно лишь позаботиться, чтобы исполнитель вызвал одну из них по готовности.

Спустя одну секунду «обработки» исполнитель вызовет `resolve("done")`, чтобы передать результат:

![Promise resolve](../svg/promise-resolve-1.svg)

Это был пример успешно выполненной задачи, в результате мы получили «успешно выполненный» промис.

А теперь пример, в котором исполнитель сообщит, что задача выполнена с ошибкой:
```js
let promise = new Promise(function(resolve, reject) {
  // спустя одну секунду будет сообщено, что задача выполнена с ошибкой
  setTimeout(() => reject(new Error("Whoops!")), 1000);
});
```

![Promise reject](../svg/promise-reject-1.svg)

Подведём промежуточные итоги: исполнитель выполняет задачу (что-то, что обычно требует времени), затем вызывает `resolve` или `reject`, чтобы изменить состояние соответствующего `Promise`.

Промис – и успешный, и отклонённый будем называть «завершённым», в отличие от изначального промиса «в ожидании».

!!! info "Может быть что-то одно: либо результат, либо ошибка"
    Исполнитель должен вызвать что-то одно: `resolve` или `reject`. Состояние промиса может быть изменено только один раз.

    Все последующие вызовы `resolve` и `reject` будут проигнорированы:
    ```js
    let promise = new Promise(function(resolve, reject) {
      resolve("done");

      reject(new Error("…")); // игнорируется
      setTimeout(() => resolve("…")); // игнорируется
    });
    ```

    Идея в том, что задача, выполняемая исполнителем, может иметь только один итог: результат или ошибку.

    Также заметим, что функция `resolve`/`reject` ожидает только один аргумент (или ни одного). Все дополнительные аргументы будут проигнорированы.


#### Успешное выполнение промиса
Итак, первый параметр функции в конструкторе `Promise` — функция `resolve` — выполняется при успешном выполненим. В эту функцию обычно передается значение, которое представляет результат операции при успешном выполнении. Это значение может представлять любой объект. Например, передадим в эту функцию строку:
```js
const myPromise = new Promise(function(resolve){
    console.log("Выполнение асинхронной операции");

    resolve("Привет мир!");
});
```

Функция `resolve()` вызывается в конце выполняемой операции после всех действий. При вызове этой функции промис переходит в состояние `fulfilled` (успешно выполнено).

При этом стоит отметить, что теоретически мы можем возвратить из функции результат, но практического смысла в этом не будет:
```js
const myPromise = new Promise(function(resolve, reject){
    console.log("Выполнение асинхронной операции");

    return "Привет мир!";
});
```

Данное возвращаемое значение мы не сможем передать во вне. И если действительно надо возвратить какой-то результат, то он передается в функцию `resolve()`.

#### Передача информации об ошибке
Второй параметр функции в конструкторе `Promise` — функция `reject` — вызывается при возникновении ошибки. В эту функцию обычно передается некоторая информация об ошибке, которое может представлять любой объект. Например:
```js
const myPromise = new Promise(function(resolve, reject){
    console.log("Выполнение асинхронной операции");
    reject("Переданы некорректные данные");
});
```

При вызове функции `reject()` промис переходит в состояние `rejected` (завершилось с ошибкой).

!!! info "Вызывайте `reject` с объектом `Error`"
    В случае, если что-то пошло не так, мы должны вызвать `reject`. Это можно сделать с аргументом любого типа (как и `resolve`), но рекомендуется использовать объект `Error` (или унаследованный от него). Почему так? Скоро нам станет понятно.[^promise-basics]

#### Объединение resolve и reject
Естественно мы можем определить логику, при которой в зависимости от условий будут выполняться обе функции:
```js
const x = 4;
const y = 0;
const myPromise = new Promise(function(resolve, reject){

    if(y === 0) {
        reject("Переданы некорректные данные");
    }
    else{
        const z = x / y;
        resolve(z);
    }
});
```

В данном случае, если значени константы `y` равно 0, то сообщаем об ошибке, вызывая функцию `reject()`. Если не равно 0, то выполняем операцию деления и передаем результат в функцию `resolve()`.

!!! info "Вызов `resolve`/`reject` сразу"
    Обычно исполнитель делает что-то асинхронное и после этого вызывает `resolve`/`reject`, то есть через какое-то время. Но это не обязательно, `resolve` или `reject` могут быть вызваны сразу:
    ```js
    let promise = new Promise(function(resolve, reject) {
      // задача, не требующая времени
      resolve(123); // мгновенно выдаст результат: 123
    });
    ```

    Это может случиться, например, когда мы начали выполнять какую-то задачу, но тут же увидели, что ранее её уже выполняли, и результат закеширован.

    Такая ситуация нормальна. Мы сразу получим успешно завершённый `Promise`.[^promise-basics]

!!! info "Свойства `state` и `result` – внутренние"
    Свойства `state` и `result` – это внутренние свойства объекта `Promise` и мы не имеем к ним прямого доступа. Для обработки результата следует использовать методы `.then`/`.catch`/`.finally`, про них речь пойдёт дальше.[^promise-basics]

### Получение результата операции в Promise
Объект `Promise` служит связующим звеном между исполнителем («создающим» кодом или «певцом») и функциями-потребителями («фанатами»), которые получат либо результат, либо ошибку. Функции-потребители могут быть зарегистрированы (подписаны) с помощью методов `.then` и `.catch`.[^promise-basics]

Ранее мы рассмотрели, как из функции промиса мы можем передать во вне результат асинхронной операции:
```js
const myPromise = new Promise(function(resolve){
    console.log("Выполнение асинхронной операции");
    resolve("Привет мир!");
});
```

Теперь получим это значение. Для получения результата операции промиса применяется функция **`then()`** объекта `Promise`:
```js
then(onFulfilled, onRejected);
```

Первый параметр функции — `onFulfilled` — представляет функцию, которая выполняется при успешном завершении промиса и в качестве параметра получает переданные в `resolve()` данные.

Второй параметр функции — `onRejected` представляет функцию, которая выполняется при возникновении ошибки и в качестве параметра получает переданные в `reject()` данные.

Синтаксис:
```js
promise.then(
  function(result) { /* обработает успешное выполнение */ },
  function(error) { /* обработает ошибку */ }
);
```

Первый аргумент метода `.then` – функция, которая выполняется, когда промис переходит в состояние «выполнен успешно», и получает результат.

Второй аргумент `.then` – функция, которая выполняется, когда промис переходит в состояние «выполнен с ошибкой», и получает ошибку.

Например, вот реакция на успешно выполненный промис:
```js
let promise = new Promise(function(resolve, reject) {
  setTimeout(() => resolve("done!"), 1000);
});

// resolve запустит первую функцию, переданную в .then
promise.then(
  result => alert(result), // выведет "done!" через одну секунду
  error => alert(error) // не будет запущена
);
```

Выполнилась первая функция.

А в случае ошибки в промисе – выполнится вторая:
```js
let promise = new Promise(function(resolve, reject) {
  setTimeout(() => reject(new Error("Whoops!")), 1000);
});

// reject запустит вторую функцию, переданную в .then
promise.then(
  result => alert(result), // не будет запущена
  error => alert(error) // выведет "Error: Whoops!" спустя одну секунду
);
```

Если мы заинтересованы только в результате успешного выполнения задачи, то в `then` можно передать только одну функцию:
```js
let promise = new Promise(resolve => {
  setTimeout(() => resolve("done!"), 1000);
});

promise.then(alert); // выведет "done!" спустя одну секунду
```

Функция **`then()`** возвращает также объект `Promise`.

Так, получим переданные данные:
```js
const myPromise = new Promise(function(resolve){
    console.log("Выполнение асинхронной операции");
    resolve("Привет мир!");
});
myPromise.then(function(value){
    console.log(`Из промиса получены данные: ${value}`);
})
```

То есть параметр `value` здесь будет представлять строку `"Привет мир!"`, которая передается в `resolve("Привет мир!")`. В итоге консольный вывод будет выглядеть следующим образом:
```
Выполнение асинхронной операции
Из промиса получены данные: Привет мир!
```

Для примера вызове несколько промисов, чтобы увидеть асинхронность в деле:
```js
const myPromise3000 = new Promise(function(resolve){
    console.log("[myPromise3000] Выполнение асинхронной операции");
    setTimeout(()=>{resolve("[myPromise3000] Привет мир!")}, 3000);
});
const myPromise1000 = new Promise(function(resolve){
    console.log("[myPromise1000] Выполнение асинхронной операции");
    setTimeout(()=>{resolve("[myPromise1000] Привет мир!")}, 1000);
});
const myPromise2000 = new Promise(function(resolve){
    console.log("[myPromise2000] Выполнение асинхронной операции");
    setTimeout(()=>{resolve("[myPromise2000] Привет мир!")}, 2000);
});

myPromise3000.then((value)=>console.log(value));
myPromise1000.then((value)=>console.log(value));
myPromise2000.then((value)=>console.log(value));
```

Здесь определены три однотипных промиса. Чтобы каждый из них не выполнялся сразу, они используют функцию `setTimeout` и устанавливают возвращаемое значение только через несколько секунд. Для разных промисов длительность задержки различается. И в данном случае мы получим следующий консольный вывод:
```
[myPromise3000] Выполнение асинхронной операции
[myPromise1000] Выполнение асинхронной операции
[myPromise2000] Выполнение асинхронной операции
[myPromise1000] Привет мир!
[myPromise2000] Привет мир!
[myPromise3000] Привет мир!
```

Здесь мы видим, что первым начал выполняться промис `myPromise3000`, однако он же завершился последним, так как для него установлено наибольшее время задержки — 3 секунды. Однако его задержка не помешала выполнению остальных промисов.

При этом нам необязательно вообще передавать в `resolve()` какое-либо значение. Возможно, асинхронная операция просто выполняется и передает во вне никакого результата.

```js
const x = 4;
const y = 8;
const myPromise = new Promise(function(){
    console.log("Выполнение асинхронной операции");
    const z = x + y;
    console.log(`Результат операции: ${z}`)
});
myPromise.then();
```

В данном случае функция в промисе вычисляет сумму чисел `x` и `y` и выводит результат на консоль.

#### Метод Promise.resolve
Иногда требуется просто вернуть из промиса некоторое значение. Для этого можно использовать метод **`Promise.resolve()`**. В этот метод передается возвращаемое из промиса значение. Метод **`Promise.resolve()`** возвращает объект `Promise`:
```js
const myPromise = Promise.resolve("Привет мир!");

myPromise.then(value => console.log(value));     // Привет мир!
```

#### Определение промиса через функцию
Нередко промис определяется через функцию, которая возвращет объект `Promise`. Например:
```js
function sum(x, y){
    return new Promise(function(resolve){
        const result = x + y;
        resolve(result);
    })
}
sum(3, 5).then(function(value){ console.log("Результат операции:", value);});
sum(25, 4).then(function(value){ console.log("Сумма чисел:", value);});
```

Здесь функция `sum()` принимает два числа и возвращает промис, который инкапсулирует операцию сумму этих чисел. После вычисления сумма чисел передается в `resolve()`, соответственно мы ее затем можем получить через метод `then()`. Определение промиса через функцию позволяет нам, с одной стороны, при вызове функции передавать разные значения. А с другой стороны, работать с результатом этой функции как с промисом и настроить при каждом конкретном вызове обработку полученного значения.

Результат работы программы:
```
Результат операции: 8
Сумма чисел: 29
```

Однако, что если у нас совпадает принцип обработки полученного из асинхронной функции значения?

```js
sum(3, 5).then(function(value){ console.log("Результат операции:", value);});
sum(25, 4).then(function(value){ console.log("Результат операции:", value);});
```

В этом случае логика обработки будет повторяться. Но поскольку метод `then()` также возвращает объект `Promise`, то мы можем сделать следующим образом:
```js
function sum(x, y){
    return new Promise(function(resolve){
        const result = x + y;
        resolve(result);
    }).then(function(value){ console.log("Результат операции:", value);});
}
sum(3, 5);
sum(25, 4);
```

##### Гибкая настройка функции
А что, если мы хотим, чтобы у программиста был выбор: если он хочет, то может определить свой обработчик, а если нет, то применяется некоторый обработчик по умолчанию. В этом случае мы можем определить функцию обработчика в качестве параметра функции, а если он не передан, то устанавливать обработчик по умолчанию:
```js
function sum(x, y, func){
    // если обработчик не установлен, то устанавливаем обработчик по умолчанию
    if(func===undefined) func = function(value){ console.log("Результат операции:", value);};

    return new Promise(function(resolve){
        const result = x + y;
        resolve(result);
    }).then(func);
}
sum(3, 5);
sum(25, 4, function(value){ console.log("Сумма:", value);});
```

Здесь при первом вызове функции `sum() (sum(3, 5))` будет срабатывать обработчик по умолчанию. Во втором случае обработчик явным образом передается через третий параметр, соответственно он будет задействован `sum(25, 4, function(value){ console.log("Сумма:", value);})`.[^17.2]

### Обработка ошибок в Promise
Если бы мы хотели только обработать ошибку, то можно было бы использовать `null` в качестве первого аргумента: `.then(null, errorHandlingFunction)`. Вместе с тем, одним из преимуществ промисов является более простая обработка ошибок, позволяющая воспользоваться методом `.catch(errorHandlingFunction)`, который сделает то же самое:
```js
let promise = new Promise((resolve, reject) => {
  setTimeout(() => reject(new Error("Ошибка!")), 1000);
});

// .catch(f) это то же самое, что promise.then(null, f)
promise.catch(alert); // выведет "Error: Ошибка!" спустя одну секунду
```

Вызов `.catch(f)` – это сокращённый, «укороченный» вариант `.then(null, f)`.[^promise-basics]

#### Функция catch
Для получения и обработки ошибки мы можем использовать функцию **`catch()`** объекта `Promise`, которая в качестве параметра принимает функцию обработчика ошибки:
```js
const myPromise = new Promise(function(resolve, reject){
    console.log("Выполнение асинхронной операции");
    reject("Переданы некорректные данные");
});
myPromise.catch( function(error){
    console.log(error);
});
```

Функция **`catch()`** в качестве параметра принимает обработчик ошибки. Параметром этой функции-обработчика является то значение, которое передается в `reject()`.[^17.3]

Консольный вывод:
```
Выполнение асинхронной операции
Переданы некорректные данные
```

#### Генерация ошибки
Выше для извещения о возникшей ошибке вызывалась функция `reject()`. Но стоит отметить, что ошибка может возникнуть и без вызова функции `reject()`. И если в выполняемой в промисе операции генерируется ошибка в силу тех или иных причин, то вся операция также завершается ошибкой. Например, в следующем коде вызывается нигде не определенная функция `getSomeWork()`:
```js
const myPromise = new Promise(function(resolve){
    console.log("Выполнение асинхронной операции");
    getSomeWork();      // вызов не существующей функции
    resolve("Hello world!");
});
myPromise.catch( function(error){
    console.log(error);
});
```

Поскольку функция `getSomeWork()` нигде не объявлена, то выполнение асинхронной задачи завершится ошибкой и не дойдет до вызова `resolve("Hello world!")`. Поэтому сработает функция обработки ошибок из `catch()`, которая через параметр `error` получит информацию о возникшей ошибке, и в консоли браузера мы увидим сообщение об ошибке:
```
Выполнение асинхронной операции
ReferenceError: getSomeWork is not defined
    at index.html:39
    at new Promise (<anonymous>)
    at index.html:37
```

##### throw
Также ошибка может быть результатом вызова оператора **`throw`**, который генерирует ошибку:
```js
const myPromise = new Promise(function(resolve, reject){
    console.log("Выполнение асинхронной операции");
    const parsed = parseInt("Hello");
    if (isNaN(parsed)) {
        throw "Not a number";           // Генерируем ошибку
    }
    resolve(parsed);
});
myPromise.catch( function(error){
    console.log(error);
});
```

Здесь парсится в число случайная строка. И если результат парсинга не представляет число, то с помощью оператора `throw` генерируем ошибку. Это придет к завершению всей функции с ошибкой. И в итоге результат будет обработан функцией `catch`:
```
Выполнение асинхронной операции
Not a number
```

В этом случае функция обработчика получает сообщение об оошибке, который указывается после оператора `throw`.

Данная ситуация может показаться искуственной, так как нам нет смысла генерировать в коде выше ошибку с помощью `throw`, поскольку в этом случае мы также можем передать сообщение об ошибке в функцию `reject`:
```js
if (isNaN(parsed)) {
    reject("Not a number");
}
```

Однако данный оператор может применяться во внешней функции, которую мы вызываем в коде:
```js
function getNumber(str){
    const parsed = parseInt(str);
    if (isNaN(parsed)) throw "Not a number";            // Генерируем ошибку
    else return parsed;
}
const myPromise = new Promise(function(resolve){
    console.log("Выполнение асинхронной операции");
    const result = getNumber("hello");
    resolve(result);
});
myPromise.catch( function(error){
    console.log(error);
});
```

Здесь парсинг строки в число вынесен во внешнюю функцию — `getNumber`, однако при вызове этой функции в промисе, также из оператора `throw` возникнет ошибка. И соответственно будет выполняться функция `catch()`, где произойдет обработка ошибки.

##### try..catch
Как и в общем случае, операции, которые могут генерировать ошибку, можно помещать в конструкцию `try..catch`, а при возникновении исключения в блоке `catch` вызывать функцию `reject()`:
```js
const myPromise = new Promise(function(resolve, reject){
    try{
        console.log("Выполнение асинхронной операции");
        getSomeWork();      // вызов не существующей функции
        resolve("Hello world!");
    }
    catch(err){
        reject(`Произошла ошибка: ${err.message}`);
    }
});
myPromise.catch( function(error){
    console.log(error);
});
```

Консольный вывод:
```
Выполнение асинхронной операции
Произошла ошибка: getSomeWork is not defined
```

#### Обработка ошибки с помощью функции then
Кроме функции `catch` для получения информации об ошибке и ее обработки также можно использовать функцию **`then()`** — ее второй параметр представляет обработчик ошибки, который в качестве параметра получает переданное из функции `reject` значение:
```js
promise
  .then(function(value){
    // получение значения
  },
  function(error){
    // обработка ошибки
  });
```

Второй параметр функции `then()` представляет функцию обработчика ошибок. С помощью параметра `error` в функции-обработчика мы можем получить переданное в `reject()` значение, либо информацию о возникшей ошибке.

Рассмотрим следуюший пример:
```js
function generateNumber(str){
    return new Promise(function(resolve, reject){
        const parsed = parseInt(str);
        if (isNaN(parsed))  reject("значение не является числом")
        else resolve(parsed);
    })
    .then(function(value){ console.log("Результат операции:", value);},
        function(error){ console.log("Возникла ошибка:", error);});
}

generateNumber("23");
generateNumber("hello");
```

В данном случае для того, чтобы в промис можно было передать разные данные, он определен как возващаемый результат функции `generateNumber()`. То есть в данном случае консольный вывод будет следующим:
```
Результат операции: 23
Возникла ошибка: значение не является числом
```

### Очистка

#### Метод finally

По аналогии с блоком `finally` из обычного `try {...} catch {...}`, у промисов также есть метод `finally`.

Вызов `.finally(f)` похож на `.then(f, f)`, в том смысле, что `f` выполнится в любом случае, когда промис завершится: успешно или с ошибкой.

Идея `finally` состоит в том, чтобы настроить обработчик для выполнения очистки/доведения после завершения предыдущих операций.

Например, остановка индикаторов загрузки, закрытие больше не нужных соединений и т.д.

Думайте об этом как о завершении вечеринки. Независимо от того, была ли вечеринка хорошей или плохой, сколько на ней было друзей, нам все равно нужно (или, по крайней мере, мы должны) сделать уборку после нее.

Код может выглядеть следующим образом:
```js
new Promise((resolve, reject) => {
  /* сделать что-то, что займёт время, и после вызвать resolve или может reject */
})
  // выполнится, когда промис завершится, независимо от того, успешно или нет
  .finally(() => остановить индикатор загрузки)
  // таким образом, индикатор загрузки всегда останавливается, прежде чем мы продолжим
  .then(result => показать результат, err => показать ошибку)
```

Обратите внимание, что `finally(f)` – это не совсем псевдоним `then(f,f)`, как можно было подумать.[^promise-basics]

#### Особенности finally
Есть важные различия:

1. Обработчик, вызываемый из `finally`, не имеет аргументов. В `finally` мы не знаем, как был завершён промис. И это нормально, потому что обычно наша задача – выполнить «общие» завершающие процедуры.

    Пожалуйста, взгляните на приведенный выше пример: как вы можете видеть, обработчик `finally` не имеет аргументов, а результат промиса обрабатывается в следующем обработчике.

2. Обработчик `finally` «пропускает» результат или ошибку дальше, к последующим обработчикам.

    Например, здесь результат проходит через `finally` к `then`:

    ```js
    new Promise((resolve, reject) => {
      setTimeout(() => resolve("value"), 2000);
    })
      .finally(() => alert("Промис завершён")) // срабатывает первым
      .then(result => alert(result)); // <-- .then показывает "value"
    ```

    Как вы можете видеть, значение возвращаемое первым промисом, передается через `finally` к следующему `then`.

    Это очень удобно, потому что `finally` не предназначен для обработки результата промиса. Как уже было сказано, это место для проведения общей очистки, независимо от того, каков был результат.

    А здесь ошибка из промиса проходит через `finally` к `catch`:
    ```js
    new Promise((resolve, reject) => {
      throw new Error("error");
    })
      .finally(() => alert("Промис завершён")) // срабатывает первым
      .catch(err => alert(err));  // <-- .catch показывает ошибку
    ```

3. Обработчик `finally` также не должен ничего возвращать. Если это так, то возвращаемое значение молча игнорируется.

    Единственным исключением из этого правила является случай, когда обработчик `finally` выдает ошибку. Затем эта ошибка передается следующему обработчику вместо любого предыдущего результата.

Подведем итог:

- Обработчик `finally` не получает результат предыдущего обработчика (у него нет аргументов). Вместо этого этот результат передается следующему подходящему обработчику.
- Если обработчик `finally` возвращает что-то, это игнорируется.
- Когда `finally` выдает ошибку, выполнение переходит к ближайшему обработчику ошибок.

Эти функции полезны и заставляют все работать правильно, если мы используем `finally` так, как предполагается: для общих процедур очистки.

!!! info "На завершённых промисах обработчики запускаются сразу"
    Если промис в состоянии ожидания, обработчики в `.then/catch/finally` будут ждать его.

    Иногда может случиться так, что промис уже выполнен, когда мы добавляем к нему обработчик.

    В таком случае эти обработчики просто запускаются немедленно:
    ```js
    // при создании промиса он сразу переводится в состояние "успешно завершён"
    let promise = new Promise(resolve => resolve("готово!"));

    promise.then(alert); // готово! (выведется сразу)
    ```

#### Пример: loadScript
Теперь рассмотрим несколько практических примеров того, как промисы могут облегчить нам написание асинхронного кода.

У нас есть функция `loadScript` для загрузки скрипта из предыдущих разделов.

Давайте вспомним, как выглядел вариант с колбэками:
```js
function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;

  script.onload = () => callback(null, script);
  script.onerror = () => callback(new Error(`Ошибка загрузки скрипта ${src}`));

  document.head.append(script);
}
```

Теперь перепишем её, используя `Promise`.

Новой функции `loadScript` более не нужен аргумент `callback`. Вместо этого она будет создавать и возвращать объект `Promise`, который перейдет в состояние «успешно завершён», когда загрузка закончится. Внешний код может добавлять обработчики («подписчиков»), используя `.then`:
```js
function loadScript(src) {
  return new Promise(function(resolve, reject) {
    let script = document.createElement('script');
    script.src = src;

    script.onload = () => resolve(script);
    script.onerror = () => reject(new Error(`Ошибка загрузки скрипта ${src}`));

    document.head.append(script);
  });
}
```

Применение:
```js
let promise = loadScript("https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js");

promise.then(
  script => alert(`${script.src} загружен!`),
  error => alert(`Ошибка: ${error.message}`)
);

promise.then(script => alert('Ещё один обработчик...'));
```

Сразу заметно несколько преимуществ перед подходом с использованием колбэков:

Промисы | Колбэки
-- | --
Промисы позволяют делать вещи в естественном порядке. Сперва мы запускаем `loadScript(script)`, и затем (`.then`) мы пишем, что делать с результатом. |	У нас должна быть функция `callback` на момент вызова `loadScript(script, callback)`. Другими словами, нам нужно знать что делать с результатом до того, как вызовется `loadScript`.
Мы можем вызывать `.then` у `Promise` столько раз, сколько захотим. Каждый раз мы добавляем нового «фаната», новую функцию-подписчика в «список подписок». Больше об этом в следующем разделе (Цепочка промисов). |	Колбэк может быть только один.

Таким образом, промисы позволяют улучшить порядок кода и дают нам гибкость. Но это далеко не всё. Мы узнаем ещё много полезного в последующих разделах.

#### Задачи

##### Можно ли "перевыполнить" промис?
Что выведет код ниже?

```js
let promise = new Promise(function(resolve, reject) {
  resolve(1);

  setTimeout(() => resolve(2), 1000);
});

promise.then(alert);
```

<details>
<summary>Ответ</summary>

Вывод будет: `1`.

Второй вызов `resolve` будет проигнорирован, поскольку учитывается только первый вызов `reject`/`resolve`. Все последующие вызовы – игнорируются.

</details>

##### Задержка на промисах
Встроенная функция `setTimeout` использует колбэк-функции. Создайте альтернативу, использующую промисы.

Функция `delay(ms)` должна возвращать промис, который перейдёт в состояние «выполнен» через `ms` миллисекунд, так чтобы мы могли добавить к нему `.then`:
```js
function delay(ms) {
  // ваш код
}

delay(3000).then(() => alert('выполнилось через 3 секунды'));
```

<details>
<summary>Решение</summary>

```js
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

delay(3000).then(() => alert('выполнилось через 3 секунды'));
```

Заметьте, что `resolve` вызывается без аргументов. Мы не возвращаем из `delay` ничего, просто гарантируем задержку.

</details>

##### Анимация круга с помощью промиса
Перепишите функцию `showCircle`, написанную в задании [Анимация круга с помощью колбэка](https://learn.javascript.ru/task/animate-circle-callback) таким образом, чтобы она возвращала промис, вместо того чтобы принимать в аргументы функцию-callback.

Новое использование:
```js
showCircle(150, 150, 100).then(div => {
  div.classList.add('message-ball');
  div.append("Hello, world!");
});
```

Возьмите решение из [Анимация круга с помощью колбэка](https://learn.javascript.ru/task/animate-circle-callback) в качестве основы.


<details>
<summary>Решение</summary>

[Код решения](../src/16_async/promise-animation.html)

</details>

### Цепочка промисов
Давайте вернёмся к ситуации из раздела "Введение: колбэки": у нас есть последовательность асинхронных задач, которые должны быть выполнены одна за другой. Например, речь может идти о загрузке скриптов. Как же грамотно реализовать это в коде?

Промисы предоставляют несколько способов решения подобной задачи.

В этом разделе мы разберём цепочку промисов.

Она выглядит вот так:
```js
new Promise(function(resolve, reject) {

  setTimeout(() => resolve(1), 1000); // (*)

}).then(function(result) { // (**)

  alert(result); // 1
  return result * 2;

}).then(function(result) { // (***)

  alert(result); // 2
  return result * 2;

}).then(function(result) {

  alert(result); // 4
  return result * 2;

});
```

Идея состоит в том, что результат первого промиса передаётся по цепочке обработчиков `.then`.

Поток выполнения такой:

1. Начальный промис успешно выполняется через 1 секунду `(*)`,
2. Затем вызывается обработчик в `.then (**)`.
3. Возвращаемое им значение передаётся дальше в следующий обработчик `.then (***)`
4. …и так далее.

В итоге результат передаётся по цепочке обработчиков, и мы видим несколько `alert` подряд, которые выводят: `1` → `2` → `4`.

![Promise then chain](../svg/promise-then-chain.svg)

Всё это работает, потому что вызов `promise.then` тоже возвращает промис, так что мы можем вызвать на нём следующий `.then`.

Когда обработчик возвращает какое-то значение, то оно становится результатом выполнения соответствующего промиса и передаётся в следующий `.then`.

**Классическая ошибка новичков: технически возможно добавить много обработчиков `.then` к единственному промису. Но это не цепочка.**

Например:
```js
let promise = new Promise(function(resolve, reject) {
  setTimeout(() => resolve(1), 1000);
});

promise.then(function(result) {
  alert(result); // 1
  return result * 2;
});

promise.then(function(result) {
  alert(result); // 1
  return result * 2;
});

promise.then(function(result) {
  alert(result); // 1
  return result * 2;
});
```

Мы добавили несколько обработчиков к одному промису. Они не передают друг другу результаты своего выполнения, а действуют независимо.

Вот картина происходящего (сравните это с изображением цепочки промисов выше):

![Promise then many](../svg/promise-then-many.svg)

Все обработчики `.then` на одном и том же промисе получают одно и то же значение – результат выполнения того же самого промиса. Таким образом, в коде выше все `alert` показывают одно и то же: `1`.

На практике весьма редко требуется назначать несколько обработчиков одному промису. А вот цепочка промисов используется куда чаще.[^promise-chaining]

#### Возвращаем промисы
Обработчик `handler`, переданный в `.then(handler)`, может вернуть промис.

В этом случае дальнейшие обработчики ожидают, пока он выполнится, и затем получают его результат.

Например:
```js
new Promise(function(resolve, reject) {

  setTimeout(() => resolve(1), 1000);

}).then(function(result) {

  alert(result); // 1

  return new Promise((resolve, reject) => { // (*)
    setTimeout(() => resolve(result * 2), 1000);
  });

}).then(function(result) { // (**)

  alert(result); // 2

  return new Promise((resolve, reject) => {
    setTimeout(() => resolve(result * 2), 1000);
  });

}).then(function(result) {

  alert(result); // 4

});
```

Здесь первый `.then` показывает `1` и возвращает новый промис `new Promise(…)` в строке `(*)`. Через одну секунду этот промис успешно выполняется, и его результат (аргумент в `resolve`, то есть `result * 2`) передаётся обработчику в следующем `.then`. Он находится в строке `(**)`, показывает `2` и делает то же самое.

Таким образом, как и в предыдущем примере, выводятся 1 → 2 → 4, но сейчас между вызовами `alert` существует пауза в 1 секунду.

Возвращая промисы, мы можем строить цепочки из асинхронных действий.

#### Создание цепочек промисов
Таким образом, одним из примуществом промисов является то, что они позволяют создавать цепочки промисов. Так, ранее мы рассмотрели применение методов **`then()`** и **`catch()`** для получения и обработки результатов и ошибок асинхронной операции. При выполнении эти методы генерируют новый объект **`Promise`**, для которого мы также можем вызвать методы `then()` и `catch()`, и, таким образом, построить цепочку промисов. Благодаря этому мы можем обрабатывать подряд несколько асинхронных операций — одна за другой.[^17.4]

```js
promise.then(..).then(..).then(..)
```

Возвращаемое значение из функции-обработчика в методе **`then()`** передается в последующий вызов метода `then()` в цепочке:
```js
const helloPromise = new Promise(function(resolve){
        resolve("Hello");
})

const worldPromise = helloPromise.then(function(value){
        // возвращаем новое значение
        return value + " World";
});
const metanitPromise = worldPromise.then(function(value){
        // возвращаем новое значение
        return value + " from METANIT.COM";
});
metanitPromise.then(function(finalValue){
        // получаем финальное значение
        console.log(finalValue);    // Hello World from METANIT.COM
});
```

Здесь для большей ясности весь процесс раздел на раздельные промисы: `helloPromise`, `worldPromise` и `metanitPromise`.

![Цепочка промисов Promise в JavaScript](../img/promise1.png)

Рассмотрим поэтапно.

1. Сначала создается промис `helloPromise`:

    ```js
    const helloPromise = new Promise(function(resolve){
        resolve("Hello");
    });
    ```

    В асинхронной операции с помощью вызова `resolve("Hello")` промис переводится в состояние `fulfilled`, то есть выполнение операции успешно завершено. А во вне передается значение "Hello".

2. Далее у промиса `helloPromise` вызывается метод **`then()`**:

    ```js
    const worldPromise = helloPromise.then(function(value){
            // возвращаем новое значение
            return value + " World";
    });
    ```

    В качестве значения параметра `value` функция обработчика получает строку "Hello" и затем возвращает строку "Hello World". Эту строка затем можно будет получить через метод `then()` нового промиса, который генерируется вызовом `helloPromise.then()` и который называется здесь `worldPromise`.

3. Затем аналогичным образом у промиса `worldPromise` вызывается метод **`then()`**:

    ```js
    const metanitPromise = worldPromise.then(function(value){
            // возвращаем новое значение
            return value + " from METANIT.COM";
    });
    ```

    В качестве значения параметра `value` функция обработчика получает строку "Hello World" и затем возвращает строку "Hello World from METANIT.COM". Вызов `worldPromise.then()` возвращает новый промис `metanitPromise`.

4. На последним этапе у промиса `metanitPromise` вызывается метод **`then()`**:

    ```js
    metanitPromise.then(function(finalValue){
        console.log(finalValue);    // Hello World from METANIT.COM
    });
    ```

    Здесь через параметр `finalValue` получаем финальное значение — строку "Hello World from METANIT.COM" и выводим на консоль. После этого цепочка завершена.

Для большей краткости и наглядности мы можем упростить цепочку:
```js
new Promise(resolve => resolve("Hello"))
.then(value => value + " World")
.then(value => value + " from METANIT.COM")
.then(finalValue => console.log(finalValue));
```

#### Пример: loadScript
Давайте используем возможность создание цепочек промисов вместе с промисифицированной функцией `loadScript`, созданной нами до этого, чтобы загружать скрипты по очереди, последовательно:
```js
loadScript("/article/promise-chaining/one.js")
  .then(function(script) {
    return loadScript("/article/promise-chaining/two.js");
  })
  .then(function(script) {
    return loadScript("/article/promise-chaining/three.js");
  })
  .then(function(script) {
    // вызовем функции, объявленные в загружаемых скриптах,
    // чтобы показать, что они действительно загрузились
    one();
    two();
    three();
  });
```

Этот же код можно переписать немного компактнее, используя стрелочные функции:
```js
loadScript("/article/promise-chaining/one.js")
  .then(script => loadScript("/article/promise-chaining/two.js"))
  .then(script => loadScript("/article/promise-chaining/three.js"))
  .then(script => {
    // скрипты загружены, мы можем использовать объявленные в них функции
    one();
    two();
    three();
  });
```

Здесь каждый вызов `loadScript` возвращает промис, и следующий обработчик в .then срабатывает, только когда этот промис завершается. Затем инициируется загрузка следующего скрипта и так далее. Таким образом, скрипты загружаются один за другим.

Мы можем добавить и другие асинхронные действия в цепочку. Обратите внимание, что наш код всё ещё «плоский», он «растёт» вниз, а не вправо. Нет никаких признаков «адской пирамиды вызовов».

Технически мы бы могли добавлять `.then` напрямую к каждому вызову `loadScript`, вот так:
```js
loadScript("/article/promise-chaining/one.js").then(script1 => {
  loadScript("/article/promise-chaining/two.js").then(script2 => {
    loadScript("/article/promise-chaining/three.js").then(script3 => {
      // эта функция имеет доступ к переменным script1, script2 и script3
      one();
      two();
      three();
    });
  });
});
```

Этот код делает то же самое: последовательно загружает 3 скрипта. Но он «растёт вправо», так что возникает такая же проблема, как и с колбэками.

Разработчики, которые не так давно начали использовать промисы, иногда не знают про цепочки и пишут код именно так, как показано выше. В целом, использование цепочек промисов предпочтительнее.

Иногда всё же приемлемо добавлять `.then` напрямую, чтобы вложенная в него функция имела доступ к внешней области видимости. В примере выше самая глубоко вложенная функция обратного вызова имеет доступ ко всем переменным `script1`, `script2`, `script3`. Но это скорее исключение, чем правило.

!!! info "Thenable"
    Если быть более точными, обработчик может возвращать не именно промис, а любой объект, содержащий метод `.then`, такие объекты называют «thenable», и этот объект будет обработан как промис.

    Смысл в том, что сторонние библиотеки могут создавать свои собственные совместимые с промисами объекты. Они могут иметь свои наборы методов и при этом быть совместимыми со встроенными промисами, так как реализуют метод `.then`.

    Вот пример такого объекта:
    ```js
    class Thenable {
      constructor(num) {
        this.num = num;
      }
      then(resolve, reject) {
        alert(resolve); // function() { native code }
        // будет успешно выполнено с аргументом this.num*2 через 1 секунду
        setTimeout(() => resolve(this.num * 2), 1000); // (**)
      }
    }

    new Promise(resolve => resolve(1))
      .then(result => {
        return new Thenable(result); // (*)
      })
      .then(alert); // показывает 2 через 1000мс
    ```

    JavaScript проверяет объект, возвращаемый из обработчика `.then` в строке `(*)`: если у него имеется метод `then`, который можно вызвать, то этот метод вызывается, и в него передаются как аргументы встроенные функции `resolve` и `reject`, вызов одной из которых потом ожидается. В примере выше происходит вызов `resolve(2)` через 1 секунду `(**)`. Затем результат передаётся дальше по цепочке.

    Это позволяет добавлять в цепочки промисов пользовательские объекты, не заставляя их наследовать от `Promise`.

#### Более сложный пример: fetch
Во фронтенд-разработке промисы часто используются, чтобы делать запросы по сети. Давайте рассмотрим один такой пример.

Мы будем использовать метод fetch, чтобы подгрузить информацию о пользователях с удалённого сервера. Этот метод имеет много опциональных параметров, разобранных в соответствующих разделах, но базовый синтаксис весьма прост:
```js
let promise = fetch(url);
```

Этот код запрашивает по сети `url` и возвращает промис. Промис успешно выполняется и в свою очередь возвращает объект `response` после того, как удалённый сервер присылает заголовки ответа, но *до того, как весь ответ сервера полностью загружен*.

Чтобы прочитать полный ответ, надо вызвать метод `response.text()`: он тоже возвращает промис, который выполняется, когда данные полностью загружены с удалённого сервера, и возвращает эти данные.

Код ниже запрашивает файл *user.json* и загружает его содержимое с сервера:
```js
fetch('/article/promise-chaining/user.json')
  // .then в коде ниже выполняется, когда удалённый сервер отвечает
  .then(function(response) {
    // response.text() возвращает новый промис,
    // который выполняется и возвращает полный ответ сервера,
    // когда он загрузится
    return response.text();
  })
  .then(function(text) {
    // ...и здесь содержимое полученного файла
    alert(text); // {"name": "iliakan", isAdmin: true}
  });
```

Есть также метод `response.json()`, который читает данные в формате JSON. Он больше подходит для нашего примера, так что давайте использовать его.

Мы также применим стрелочные функции для более компактной записи кода:
```js
// то же самое, что и раньше, только теперь response.json() читает данные в формате JSON
fetch('/article/promise-chaining/user.json')
  .then(response => response.json())
  .then(user => alert(user.name)); // iliakan, получили имя пользователя
```

Теперь давайте что-нибудь сделаем с полученными данными о пользователе.

Например, мы можем послать запрос на GitHub, чтобы загрузить данные из профиля пользователя и показать его аватар:
```js
// Запрашиваем user.json
fetch('/article/promise-chaining/user.json')
  // Загружаем данные в формате json
  .then(response => response.json())
  // Делаем запрос к GitHub
  .then(user => fetch(`https://api.github.com/users/${user.name}`))
  // Загружаем ответ в формате json
  .then(response => response.json())
  // Показываем аватар (githubUser.avatar_url) в течение 3 секунд (возможно, с анимацией)
  .then(githubUser => {
    let img = document.createElement('img');
    img.src = githubUser.avatar_url;
    img.className = "promise-avatar-example";
    document.body.append(img);

    setTimeout(() => img.remove(), 3000); // (*)
  });
```

Код работает, детали реализации отражены в комментариях. Однако в нём есть одна потенциальная проблема, с которой часто сталкиваются новички.

Посмотрите на строку `(*)`: как мы можем предпринять какие-то действия *после* того, как аватар был показан и удалён? Например, мы бы хотели показывать форму редактирования пользователя или что-то ещё. Сейчас это невозможно.

Чтобы сделать наш код расширяемым, нам нужно возвращать ещё один промис, который выполняется после того, как завершается показ аватара.

Примерно так:
```js
fetch('/article/promise-chaining/user.json')
  .then(response => response.json())
  .then(user => fetch(`https://api.github.com/users/${user.name}`))
  .then(response => response.json())
  .then(githubUser => new Promise(function(resolve, reject) { // (*)
    let img = document.createElement('img');
    img.src = githubUser.avatar_url;
    img.className = "promise-avatar-example";
    document.body.append(img);

    setTimeout(() => {
      img.remove();
      resolve(githubUser); // (**)
    }, 3000);
  }))
  // срабатывает через 3 секунды
  .then(githubUser => alert(`Закончили показ ${githubUser.name}`));
```

То есть, обработчик `.then` в строке `(*)` будет возвращать `new Promise`, который перейдёт в состояние «выполнен» только после того, как в `setTimeout (**)` будет вызвана `resolve(githubUser)`.

Соответственно, следующий по цепочке `.then` будет ждать этого.

Как правило, все асинхронные действия должны возвращать промис.

Это позволяет планировать после него какие-то дополнительные действия. Даже если эта возможность не нужна прямо сейчас, она может понадобиться в будущем.

И, наконец, давайте разобьём написанный код на отдельные функции, пригодные для повторного использования:
```js
function loadJson(url) {
  return fetch(url)
    .then(response => response.json());
}

function loadGithubUser(name) {
  return fetch(`https://api.github.com/users/${name}`)
    .then(response => response.json());
}

function showAvatar(githubUser) {
  return new Promise(function(resolve, reject) {
    let img = document.createElement('img');
    img.src = githubUser.avatar_url;
    img.className = "promise-avatar-example";
    document.body.append(img);

    setTimeout(() => {
      img.remove();
      resolve(githubUser);
    }, 3000);
  });
}

// Используем их:
loadJson('/article/promise-chaining/user.json')
  .then(user => loadGithubUser(user.name))
  .then(showAvatar)
  .then(githubUser => alert(`Показ аватара ${githubUser.name} завершён`));
  // ...
```

#### Итого
Если обработчик в `.then` (или в `catch`/`finally`, без разницы) возвращает промис, последующие элементы цепочки ждут, пока этот промис выполнится. Когда это происходит, результат его выполнения (или ошибка) передаётся дальше.

Вот полная картина происходящего:

![Promise handler](../svg/promise-handler-variants.svg)

#### Задачи

##### Промисы: сравните then и catch
Являются ли фрагменты кода ниже эквивалентными? Другими словами, ведут ли они себя одинаково во всех обстоятельствах, для всех переданных им обработчиков?

```js
promise.then(f1).catch(f2);
```

Против:
```js
promise.then(f1, f2);
```

<details>
<summary>Решение</summary>

Короткий ответ: **нет, они не эквивалентны**:

Разница в том, что если ошибка произойдёт в `f1`, то она будет обработана в `.catch` в этом примере:
```js
promise
  .then(f1)
  .catch(f2);
```

…но не в этом:
```js
promise
  .then(f1, f2);
```

Ошибка передаётся по цепочке, но во втором примере нет продолжения цепочки после `f1`.

Другими словами, `.then` передаёт результат или ошибку следующему блоку `.then/catch`. Так как в первом примере в цепочке далее имеется блок `catch`, а во втором – нет, то ошибка в нём останется необработанной.

</details>

#### Обработка ошибок
Цепочки промисов отлично подходят для перехвата ошибок. Если промис завершается с ошибкой, то управление переходит в ближайший обработчик ошибок. На практике это очень удобно.[^promise-error-handling]

Для обработки ошибок в цепочке в конце добавляется метод **`catch()`**, который также возвращет объект `Promise`. Рассмотрим на простом примере:
```js
function generateNumber(str){
    return new Promise((resolve, reject) => {
        const parsed = parseInt(str);
        if (isNaN(parsed)) reject("Not a number");
        else resolve(parsed);
    });
};
function printNumber(str){
    generateNumber(str)
        .then(value => console.log(value))
        .catch(error => console.log(error));
}
printNumber("rty"); // Not a number
printNumber("3");   // 3
```

В данном случае функция `generateNumber()` возвращает промис, в котором получаем извне некоторое значение, пытаемся конвертировать его в число. В функции `printNumber()` вызываем эту функцию и у полученного промиса создаем небольшую цепочку из методов `then()` и `catch()`.

Если конвертация строки в число в промисе прошла успешно, то распарсенное число передается в функцию `resolve()`:
```js
else resolve(parsed)
```

В этом случае при получении этого результата срабатывает метод **`then()`**, который в данном случае выводит полученное значение на консоль:
```js
.then(value => console.log(value))
```

Метод **`catch()`** при отстутствии ошибок не выполняется.

Однако если передаеваемое значение невозможно конвертировать в число, соответственно в промисе выполняется вызов
```js
if (isNaN(parsed)) reject("Not a number");
```

В этом случае метод `then()` игнорируется, и выполнение переходит к вызову
```js
.catch(error => console.log(error));
```

Например, в представленном ниже примере для `fetch` указана неправильная ссылка (сайт не существует), и `.catch` перехватывает ошибку:
```js
fetch('https://no-such-server.blabla') // ошибка
  .then(response => response.json())
  .catch(err => alert(err)) // TypeError: failed to fetch (текст может отличаться)
```

Как видно, `.catch` не обязательно должен быть сразу после ошибки, он может быть далее, после одного или даже нескольких `.then`

Или, может быть, с сервером всё в порядке, но в ответе мы получим некорректный JSON. Самый лёгкий путь перехватить все ошибки – это добавить `.catch` в конец цепочки:
```js
fetch('/article/promise-chaining/user.json')
  .then(response => response.json())
  .then(user => fetch(`https://api.github.com/users/${user.name}`))
  .then(response => response.json())
  .then(githubUser => new Promise((resolve, reject) => {
    let img = document.createElement('img');
    img.src = githubUser.avatar_url;
    img.className = "promise-avatar-example";
    document.body.append(img);

    setTimeout(() => {
      img.remove();
      resolve(githubUser);
    }, 3000);
  }))
  .catch(error => alert(error.message));
```

Если все в порядке, то такой `.catch` вообще не выполнится. Но если любой из промисов будет отклонён (проблемы с сетью или некорректная json-строка, или что угодно другое), то ошибка будет перехвачена.[^promise-error-handling]

##### Неявный try…catch
Вокруг функции промиса и обработчиков находится «невидимый `try..catch`». Если происходит исключение, то оно перехватывается, и промис считается отклонённым с этой ошибкой.

Например, этот код:
```js
new Promise((resolve, reject) => {
  throw new Error("Ошибка!");
}).catch(alert); // Error: Ошибка!
```

…Работает так же, как и этот:
```js
new Promise((resolve, reject) => {
  reject(new Error("Ошибка!"));
}).catch(alert); // Error: Ошибка!
```

«Невидимый `try..catch`» вокруг промиса автоматически перехватывает ошибку и превращает её в отклонённый промис.

Это работает не только в функции промиса, но и в обработчиках. Если мы бросим ошибку (`throw`) из обработчика (`.then`), то промис будет считаться отклонённым, и управление перейдёт к ближайшему обработчику ошибок.

Пример:
```js
new Promise((resolve, reject) => {
  resolve("ок");
}).then((result) => {
  throw new Error("Ошибка!"); // генерируем ошибку
}).catch(alert); // Error: Ошибка!
```

Это происходит для всех ошибок, не только для тех, которые вызваны оператором `throw`. Например, программная ошибка:
```js
new Promise((resolve, reject) => {
  resolve("ок");
}).then((result) => {
  blabla(); // нет такой функции
}).catch(alert); // ReferenceError: blabla is not defined
```

Финальный `.catch` перехватывает как промисы, в которых вызван `reject`, так и случайные ошибки в обработчиках.[^promise-error-handling]

##### Обработка ошибок в цепочке промисов
Теперь усложним цепочку. Пусть у нас в цепочке выполняется сразу несколько промисов:
```js
function generateNumber(str){
    return new Promise((resolve, reject) => {
        const parsed = parseInt(str);
        if (isNaN(parsed)) reject("Not a number");
        else resolve(parsed);
    });
};
function printNumber(str){
    generateNumber(str)
        .then(value => {
            if (value===4) throw "Несчастливое число";
            return value * value;
        })
        .then(finalValue => console.log(`Result: ${finalValue}`))
        .catch(error => console.error(error));
}
printNumber("rty"); // Not a number
printNumber("3");   // Result: 9
printNumber("4");   // Несчастливое число
printNumber("5");   // Result: 25
```

Здесь для простоты весь код вынесен в функцию `generateNumber()`, которая создает цепочку промисов. В этой цепочке промисов также получаем извне некоторое значение, пытаемся конвертировать его в число, и затем вычисляем его квадрат и выводит на консоль. В конце которой находится метод `catch()`. В этот метод передается обработчик ощибки, который получает ошибку и выводит ее на консоль. В итоге если в цепочке промисов на одном из этапов генерируется ошибка (в силу внутренней работы кода, например, при генерации ошибки с помощью оператора `throw`, либо при вызове функции `reject()`), то все последующие вызовы метода `then()`, которые содержат только обработку значения, игнорируются, и выполнение цепочки переходит к методу `catch()`.

Для примера вызываем функцию `printNumber()`, передавая в нее различные исходные данные. Например, при выполнении вызова
```js
printNumber("rty"); // Not a number
```

##### Возвращение Promise из catch
При этом стоит отметить, что, поскольку `catch()` возвращает объект `Promise`, то далее также можно продолжить цепочку:
```js
function generateNumber(str){
    return new Promise((resolve, reject) => {
        const parsed = parseInt(str);
        if (isNaN(parsed)) reject("Not a number");
        else resolve(parsed);
    });
};
function printNumber(str){
    generateNumber(str)
        .then(value => value * value)
        .then(value => console.log(`Result: ${value}`))
        .catch(error => console.error(error))
        .then(() => console.log("Work has been done"));
}
printNumber("3");
// Result: 9
// Work has been done
```

Причем метод `then()` после `catch()` будет вызываться, даже если не произошло ошибок и сам метод `catch()` не выполнялся.

И мы даже можем из функции-обработчика ошибки в `catch()` также можем передавать некоторое значение и получать через последующий метод `then()`:
```js
function generateNumber(str){
    return new Promise((resolve, reject) => {
        const parsed = parseInt(str);
        if (isNaN(parsed)) reject("Not a number");
        else resolve(parsed);
    });
};
function printNumber(str){
    generateNumber(str)
        .then(value => value * value)
        .then(value => console.log(`Result: ${value}`))
        .catch(error => {
            console.log(error);
            return 0;
        })
        .then(value => console.log("Status code:", value));
}
printNumber("ert3");    // Not a number
                        // Status code: 0
```

##### Пробрасывание ошибок
Как мы уже заметили, `.catch` ведёт себя как `try..catch`. Мы можем иметь столько обработчиков `.then`, сколько мы хотим, и затем использовать один `.catch` в конце, чтобы перехватить ошибки из всех обработчиков.

В обычном `try..catch` мы можем проанализировать ошибку и повторно пробросить дальше, если не можем её обработать. То же самое возможно для промисов.

Если мы пробросим (`throw`) ошибку внутри блока `.catch`, то управление перейдёт к следующему ближайшему обработчику ошибок. А если мы обработаем ошибку и завершим работу обработчика нормально, то продолжит работу ближайший успешный обработчик `.then`.

В примере ниже `.catch` успешно обрабатывает ошибку:
```js
// the execution: catch -> then
new Promise((resolve, reject) => {

  throw new Error("Ошибка!");

}).catch(function(error) {

  alert("Ошибка обработана, продолжить работу");

}).then(() => alert("Управление перейдёт в следующий then"));
```

Здесь блок `.catch` завершается нормально. Поэтому вызывается следующий успешный обработчик `.then`.

В примере ниже мы видим другую ситуацию с блоком `.catch`. Обработчик `(*)` перехватывает ошибку и не может обработать её (например, он знает как обработать только `URIError`), поэтому ошибка пробрасывается далее:
```js
// the execution: catch -> catch -> then
new Promise((resolve, reject) => {

  throw new Error("Ошибка!");

}).catch(function(error) { // (*)

  if (error instanceof URIError) {
    // обрабатываем ошибку
  } else {
    alert("Не могу обработать ошибку");

    throw error; // пробрасывает эту или другую ошибку в следующий catch
  }

}).then(function() {
  /* не выполнится */
}).catch(error => { // (**)

  alert(`Неизвестная ошибка: ${error}`);
  // ничего не возвращаем => выполнение продолжается в нормальном режиме

});
```

Управление переходит от первого блока `.catch (*)` к следующему `(**)`, вниз по цепочке.[^promise-error-handling]

#### Необработанные ошибки
Что произойдёт, если ошибка не будет обработана? Например, мы просто забыли добавить `.catch` в конец цепочки, как здесь:
```js
new Promise(function() {
  noSuchFunction(); // Ошибка (нет такой функции)
})
  .then(() => {
    // обработчики .then, один или более
  }); // без .catch в самом конце!
```

В случае ошибки выполнение должно перейти к ближайшему обработчику ошибок. Но в примере выше нет никакого обработчика. Поэтому ошибка как бы «застревает», её некому обработать.

На практике, как и при обычных необработанных ошибках в коде, это означает, что что-то пошло сильно не так.

Что происходит, когда обычная ошибка не перехвачена `try..catch`? Скрипт умирает с сообщением в консоли. Похожее происходит и в случае необработанной ошибки промиса.

JavaScript-движок отслеживает такие ситуации и генерирует в этом случае глобальную ошибку. Вы можете увидеть её в консоли, если запустите пример выше.

В браузере мы можем поймать такие ошибки, используя событие `unhandledrejection`:
```js
window.addEventListener('unhandledrejection', function(event) {
  // объект события имеет два специальных свойства:
  alert(event.promise); // [object Promise] - промис, который сгенерировал ошибку
  alert(event.reason); // Error: Ошибка! - объект ошибки, которая не была обработана
});

new Promise(function() {
  throw new Error("Ошибка!");
}); // нет обработчика ошибок
```

Это событие является частью [стандарта HTML](https://html.spec.whatwg.org/multipage/webappapis.html#unhandled-promise-rejections).

Если происходит ошибка, и отсутствует её обработчик, то генерируется событие `unhandledrejection`, и соответствующий объект `event` содержит информацию об ошибке.

Обычно такие ошибки неустранимы, поэтому лучше всего – информировать пользователя о проблеме и, возможно, отправить информацию об ошибке на сервер.

В не-браузерных средах, таких как Node.js, есть другие способы отслеживания необработанных ошибок.[^promise-error-handling]

#### Метод finally
Кроме методов `then()` и `catch()` объект `Promise` для обработка результата также предоставляет метод **`finally()`**. Этот метод выполняется в конце цепочки промисов вне зависимости произошла ошибка или выполнение промиса прошло успешно.

В качестве параметра метод принимает функцию, которая выполняет некоторые финальные действия по обработке работы промиса:
```js
function generateNumber(str){
    return new Promise((resolve, reject) => {
        const parsed = parseInt(str);
        if (isNaN(parsed)) reject("Not a number");
        else resolve(parsed);
    });
};
function printNumber(str){
    generateNumber(str)
    .then(value => console.log(value))
    .catch(error => console.log(error))
    .finally(() => console.log("End"));
}

printNumber("3");
printNumber("triuy");
```

Здесь мы два раза обращаемся к промису, возвращаемому функцией `generateNumber`. В одном случае строка удачно сконвертируется в число, в другом же — произойдет ошибка. Однако вне зависимости от отсутствия или наличия ошибки в обоих случаях будет выполняться метод `finally()`, который выведет на консоль строку "End".

Метод `finally()` возвращает объект `Promise`, поэтому после него можно продолжить продолжить цепочку:
```js
function generateNumber(str){
    return new Promise((resolve, reject) => {
        const parsed = parseInt(str);
        if (isNaN(parsed)) reject("Not a number");
        else resolve(parsed);
    });
};
function printNumber(str){
    generateNumber(str)
    .then(value => console.log(value))
    .catch(error => console.log(error))
    .finally(() => console.log("Выполнение промиса завершено"))
    .then(() => console.log("Промис все еще работает"));
}
printNumber("3");
```

Консольный вывод:
```
3
Выполнение промиса завершено
Промис все еще работает
```

Стоит отметить что в метод `then()` также можно передать данные. Но эти данные передаются не из метода `finally()`, а из предыдущего метода `then()` или `catch()`:
```js
function generateNumber(str){
    return new Promise((resolve, reject) => {
        const parsed = parseInt(str);
        if (isNaN(parsed)) reject("Not a number");
        else resolve(parsed);
    });
};
function printNumber(str){
    generateNumber(str)
    .then(value => {
        console.log(value);
        return "hello from then";
    })
    .catch(error => {
        console.log(error);
        return "hello from catch";
    })
    .finally(() => {
        console.log("End");
        return "hello from finally";
    })
    .then(message => console.log(message));
}
printNumber("3");
```

```
3
End
hello from then
```

#### Итого
- `.catch` перехватывает все виды ошибок в промисах: будь то вызов `reject()` или ошибка, брошенная в обработчике при помощи `throw`.
- `.then` также перехватывает ошибки таким же образом, если задан второй аргумент (который является обработчиком ошибок).
- Необходимо размещать `.catch` там, где мы хотим обработать ошибки и знаем, как это сделать. Обработчик может проанализировать ошибку (могут быть полезны пользовательские классы ошибок) и пробросить её, если ничего не знает о ней (возможно, это программная ошибка).
- Можно и совсем не использовать `.catch`, если нет нормального способа восстановиться после ошибки.
- В любом случае нам следует использовать обработчик события `unhandledrejection` (для браузеров и аналог для других окружений), чтобы отслеживать необработанные ошибки и информировать о них пользователя (и, возможно, наш сервер), благодаря чему наше приложение никогда не будет «просто умирать».

#### Задачи

##### Ошибка в setTimeout
Что вы думаете? Выполнится ли `.catch`? Поясните свой ответ.

```js
new Promise(function(resolve, reject) {
  setTimeout(() => {
    throw new Error("Whoops!");
  }, 1000);
}).catch(alert);
```

<details>
<summary>Ответ</summary>

Ответ: **нет, не выполнится**:
```js
new Promise(function(resolve, reject) {
  setTimeout(() => {
    throw new Error("Whoops!");
  }, 1000);
}).catch(alert);
```

Как было сказано в главе, здесь присутствует «скрытый `try..catch`» вокруг кода функции. Поэтому обрабатываются все синхронные ошибки.

В данном примере ошибка генерируется не по ходу выполнения кода, а позже. Поэтому промис не может обработать её.

</details>

### Promise API
В классе `Promise` есть 6 статических методов. Давайте познакомимся с ними.[^promise-api]

Функции **`Promise.all()`**, **`Promise.allSettled()`** и **`Promise.race()`** позволяют сгруппировать выполнение нескольких промисов.[^17.5]

#### Promise.all
Допустим, нам нужно запустить множество промисов параллельно и дождаться, пока все они выполнятся.

Например, параллельно загрузить несколько файлов и обработать результат, когда он готов.

Для этого как раз и пригодится `Promise.all`.[^promise-api]

Функция **`Promise.all()`** возвращает единый объект **`Promise`**, который объединяет набор промисов.

Синтаксис:
```js
let promise = Promise.all(iterable);
```

Метод `Promise.all` принимает массив промисов (может принимать любой перебираемый объект, но обычно используется массив) и возвращает новый промис.

Новый промис завершится, когда завершится весь переданный список промисов, и его результатом будет массив их результатов.

Например, `Promise.all`, представленный ниже, выполнится спустя 3 секунды, его результатом будет массив `[1, 2, 3]`:
```js
Promise.all([
  new Promise(resolve => setTimeout(() => resolve(1), 3000)), // 1
  new Promise(resolve => setTimeout(() => resolve(2), 2000)), // 2
  new Promise(resolve => setTimeout(() => resolve(3), 1000))  // 3
]).then(alert); // когда все промисы выполнятся, результат будет 1,2,3
// каждый промис даёт элемент массива
```

Обратите внимание, что порядок элементов массива в точности соответствует порядку исходных промисов. Даже если первый промис будет выполняться дольше всех, его результат всё равно будет первым в массиве.[^promise-api]

Рассмотрим следуюший код:
```js
const promise1 = new Promise((resolve,reject) => {
    setTimeout(resolve, 1000, "Hello");
});
const promise2 = new Promise((resolve,reject) => {
    setTimeout(resolve, 500, "World");
});
promise1.then(value => console.log(value));  // Hello
promise2.then(value => console.log(value));  // World
```

Здесь определено два промиса. Асинхронная операция первого промиса выполняется через 1000 миллисекунд, действие второго промиса выполняется через 500 миллисекунд. Оба этих промиса выполняются независимо друг от друга. Консольный вывод:
```
World
Hello
```

Функция `Promise.all()` позволяет объединить несколько промисов и выполнять их параллельно, но как единое целое. В качестве параметра функция принимает набор промисов:
```js
Promise.all([промис1, промис2, ... прромисN]);
```

Возвращаемым результатом функции является новый объект **`Promise`**.

Теперь изменим предыдущий пример, использовав функцию `Promise.all()`:
```js
const promise1 = new Promise((resolve,reject) => {
    setTimeout(resolve, 1000, "Hello");
});
const promise2 = new Promise((resolve,reject) => {
    setTimeout(resolve, 500, "World");
});
Promise.all([promise1, promise2])
    .then(values => {
                const [promise1data, promise2data] = values;
                console.log(promise1data, promise2data);    // Hello World
});
```

Теперь данные обоих промисов возвращаются вместе и доступны в методе `then()` в виде массива `values`. Консольный вывод:
```
Hello World
```

Часто применяемый трюк – пропустить массив данных через map-функцию, которая для каждого элемента создаст задачу-промис, и затем обернуть получившийся массив в `Promise.all`.

Например, если у нас есть массив ссылок, то мы можем загрузить их вот так:
```js
let urls = [
  'https://api.github.com/users/iliakan',
  'https://api.github.com/users/remy',
  'https://api.github.com/users/jeresig'
];

// Преобразуем каждый URL в промис, возвращённый fetch
let requests = urls.map(url => fetch(url));

// Promise.all будет ожидать выполнения всех промисов
Promise.all(requests)
  .then(responses => responses.forEach(
    response => alert(`${response.url}: ${response.status}`)
  ));
```

А вот пример побольше, с получением информации о пользователях GitHub по их логинам из массива (мы могли бы получать массив товаров по их идентификаторам, логика та же):
```js
let names = ['iliakan', 'remy', 'jeresig'];

let requests = names.map(name => fetch(`https://api.github.com/users/${name}`));

Promise.all(requests)
  .then(responses => {
    // все промисы успешно завершены
    for(let response of responses) {
      alert(`${response.url}: ${response.status}`); // покажет 200 для каждой ссылки
    }

    return responses;
  })
  // преобразовать массив ответов response в response.json(),
  // чтобы прочитать содержимое каждого
  .then(responses => Promise.all(responses.map(r => r.json())))
  // все JSON-ответы обработаны, users - массив с результатами
  .then(users => users.forEach(user => alert(user.name)));
```

Значения всех промисов возвращаются только если все они завершились успешно. Но если в асинхронной операции хотя бы одного промиса возникнет ошибка в силу внутренней логики или из-за вызова функции `reject()`, то все промисы перейдут в состояние `rejected`, соответственно:
```js
const promise1 = new Promise((resolve,reject) => {
    reject("Непредвиденная ошибка");
    setTimeout(resolve, 500, "Hello");
});
const promise2 = new Promise((resolve,reject) => {
    setTimeout(resolve, 1000, "World");
});

Promise.all([promise1, promise2])
    .then(values => {
                const [promise1data, promise2data] = values;
                console.log(promise1data, promise2data);
})
.catch(error => console.log(error)); // Непредвиденная ошибка
```

В данном случае мы явным образом переводим переводим первый промис в состояние `rejected`, соответственно в это состояние переводятся все промисы, переданные в функцию `Promise.all()`. И далее через метод `catch()`, как и в общем случае, мы можем обработать возникшую ошибку.

**Если любой из промисов завершится с ошибкой, то промис, возвращённый `Promise.all`, немедленно завершается с этой ошибкой.**

Например:
```js
Promise.all([
  new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("Ошибка!")), 2000)),
  new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
]).catch(alert); // Error: Ошибка!
```

Здесь второй промис завершится с ошибкой через 2 секунды. Это приведёт к немедленной ошибке в `Promise.all`, так что выполнится `.catch`: ошибка этого промиса становится ошибкой всего `Promise.all`.

!!! warning "В случае ошибки, остальные результаты игнорируются"
    Если один промис завершается с ошибкой, то весь `Promise.all` завершается с ней, полностью забывая про остальные промисы в списке. Их результаты игнорируются.

    Например, если сделано несколько вызовов `fetch`, как в примере выше, и один не прошёл, то остальные будут всё ещё выполняться, но `Promise.all` за ними уже не смотрит. Скорее всего, они так или иначе завершатся, но их результаты будут проигнорированы.

    `Promise.all` ничего не делает для их отмены, так как в промисах вообще нет концепции «отмены». В разделе о Fetch, касающемся прерывания запроса, будет рассмотрен `AbortController`, который помогает с этим, но он не является частью Promise API.

!!! info "`Promise.all(iterable)` разрешает передавать не-промисы в `iterable` (перебираемом объекте)"
    Обычно, `Promise.all(...)` принимает перебираемый объект промисов (чаще всего массив). Но если любой из этих объектов не является промисом, он передаётся в итоговый массив «как есть».

    Например, здесь результат: `[1, 2, 3]`

    ```js
    Promise.all([
      new Promise((resolve, reject) => {
        setTimeout(() => resolve(1), 1000)
      }),
      2,
      3
    ]).then(alert); // 1, 2, 3
    ```

    Таким образом, мы можем передавать уже готовые значения, которые не являются промисами, в `Promise.all`, иногда это бывает удобно.

#### Promise.allSettled

`Promise.all` завершается с ошибкой, если она возникает в любом из переданных промисов. Это подходит для ситуаций «всё или ничего», когда нам нужны *все* результаты для продолжения:
```js
Promise.all([
  fetch('/template.html'),
  fetch('/style.css'),
  fetch('/data.json')
]).then(render); // методу render нужны результаты всех fetch
```

В отличие от `Promise.all`, еще одна функция — **`Promise.allSettled()`** —  ждет завершения всех переданных промисов, независимо от их успеха или неудачи.

Синтаксис:
```js
let promise = Promise.allSettled(iterable);
```

Также, как и `Promise.all()`, этот метод принимает набор промисов и выполняет их как единое целое, но возвращает объект со статусом и результатом промиса:
```js
const promise1 = new Promise((resolve,reject) => {
    reject("Непредвиденная ошибка");
    setTimeout(resolve, 500, "Hello");
});
const promise2 = new Promise((resolve,reject) => {
    setTimeout(resolve, 1000, "World");
});

Promise.allSettled([promise1, promise2])
    .then(values => {
        const [promise1data, promise2data] = values;
        console.log(promise1data);  // {status: "rejected", reason: "Непредвиденная ошибка"}
        console.log(promise2data);  // {status: "fulfilled", value: "World"}
});
```

При этом при возникновении ошибки в одном из промисов (как в случае выше с первым промисом) функция также передается результаты в метод `then()`, который следует дальше в цепочке. Каждый результат представляет объект. Первое свойство этого объекта — `status` описывает статус или состояние промиса. Если произошла ошибка, статус `rejected`, а второе свойство представляет объект ошибки. Если промис успешно завершил выполнение, то статус `fulfilled`, а второе свойство — `value` хранит результат промиса.

Таким образом, метод `Promise.allSettled` всегда ждёт завершения всех промисов. В массиве результатов будет

- `{status:"fulfilled", value:результат}` для успешных завершений,
- `{status:"rejected", reason:ошибка}` для ошибок.

Например, мы хотели бы загрузить информацию о множестве пользователей. Даже если в каком-то запросе ошибка, нас всё равно интересуют остальные.

Используем для этого `Promise.allSettled`:
```js
let urls = [
  'https://api.github.com/users/iliakan',
  'https://api.github.com/users/remy',
  'https://no-such-url'
];

Promise.allSettled(urls.map(url => fetch(url)))
  .then(results => { // (*)
    results.forEach((result, num) => {
      if (result.status == "fulfilled") {
        alert(`${urls[num]}: ${result.value.status}`);
      }
      if (result.status == "rejected") {
        alert(`${urls[num]}: ${result.reason}`);
      }
    });
  });
```

Массив `results` в строке `(*)` будет таким:
```js
[
  {status: 'fulfilled', value: ...объект ответа...},
  {status: 'fulfilled', value: ...объект ответа...},
  {status: 'rejected', reason: ...объект ошибки...}
]
```

То есть, для каждого промиса у нас есть его статус и значение/ошибка.

Это идеально для сценариев, когда нужно обработать все результаты, даже если некоторые запросы провалились:
```js
Promise.allSettled([
  fetch('/template.html'),
  fetch('/style.css'),
  fetch('/data.json')
]).then(results => {
  results.forEach((result, index) => {
    if (result.status === 'fulfilled') {
      console.log(`Файл ${index} загружен:`, result.value);
    } else {
      console.error(`Файл ${index} не загрузился:`, result.reason);
    }
  });
  // Можно продолжить работу с доступными данными
});
```

**Когда использовать**
- **Нужны все результаты**: когда провал одного запроса не должен ломать всю логику.
​
- **Мониторинг задач**: проверка статуса множества асинхронных операций.

- **Робастные приложения**: graceful degradation при сбоях отдельных компонентов.

*Сравнение с `Promise.all`*

| Характеристика        | `Promise.all`      | `Promise.allSettled`                      |
| --------------------- | ---------------- | --------------------------------------- |
| Завершение при ошибке | Да, сразу        | Нет, ждет все                           |
| Результат при ошибке  | reject с ошибкой | Массив со всеми статусами freecodecamp​ |
| Подходит для          | "Всё или ничего" | Частичная обработка                     |

!!! warning "Новая возможность"
    Эта возможность была добавлена в язык недавно. Метод поддерживается во всех современных браузерах и Node.js 12.9.0+. В старых браузерах может понадобиться полифил.

##### Полифил
Если браузер не поддерживает `Promise.allSettled`, для него легко сделать полифил:
```js
if(!Promise.allSettled) {
  Promise.allSettled = function(promises) {
    return Promise.all(promises.map(p => Promise.resolve(p).then(value => ({
      status: 'fulfilled',
      value: value
    }), error => ({
      status: 'rejected',
      reason: error
    }))));
  };
}
```

В этом коде `promises.map` берёт аргументы, превращает их в промисы (на всякий случай) и добавляет каждому обработчик `.then`.

Этот обработчик превращает успешный результат `value` в `{state:'fulfilled', value: value}`, а ошибку `error` в `{state:'rejected', reason: error}`. Это как раз и есть формат результатов `Promise.allSettled`.

Затем мы можем использовать `Promise.allSettled`, чтобы получить результаты всех промисов, даже если при выполнении какого-то возникнет ошибка.

#### Promise.race
Метод очень похож на `Promise.all`, но ждёт только первый *выполненный* промис, из которого берёт результат (или ошибку).

Синтаксис:
```js
let promise = Promise.race(iterable);
```

Функция **`Promise.race()`** также принимает несколько промисов, только возвращает первый завершенный промис (вне зависимости завершился от успешно или с ошибкой):
```js
const promise1 = new Promise((resolve) => {
    setTimeout(resolve, 500, "Hello");
});
const promise2 = new Promise((resolve) => {
    setTimeout(resolve, 1000, "World");
});
Promise.race([promise1, promise2])
    .then(value => console.log(value))       // Hello
    .catch(error => console.log(error));
```

В данном случае первым выполненным будет промис `promise1`. Поэтому в метод `then(value => console.log(value))` в качестве `value` будет передана строка "Hello".

Например, тут результат будет `1`:
```js
Promise.race([
  new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("Ошибка!")), 2000)),
  new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
]).then(alert); // 1
```

Быстрее всех выполнился первый промис, он и дал результат. После этого остальные промисы игнорируются.[^promise-api]

#### Promise.any
Метод очень похож на `Promise.race`, но ждёт только первый *успешно выполненный* промис, из которого берёт результат.

Если ни один из переданных промисов не завершится успешно, тогда возвращённый объект Promise будет отклонён с помощью `AggregateError` – специального объекта ошибок, который хранит все ошибки промисов в своём свойстве `errors`.

Синтаксис:
```js
let promise = Promise.any(iterable);
```

Например, здесь, результатом будет `1`:
```js
Promise.any([
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("Ошибка!")), 1000)),
  new Promise((resolve, reject) => setTimeout(() => resolve(1), 2000)),
  new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
]).then(alert); // 1
```

Первый промис в этом примере был самым быстрым, но он был отклонён, поэтому результатом стал второй. После того, как первый успешно выполненный промис «выиграет гонку», все дальнейшие результаты будут проигнорированы.

Вот пример, в котором все промисы отклоняются:
```js
Promise.any([
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("Ошибка!")), 1000)),
  new Promise((resolve, reject) => setTimeout(() => reject(new Error("Ещё одна ошибка!")), 2000))
]).catch(error => {
  console.log(error.constructor.name); // AggregateError
  console.log(error.errors[0]); // Error: Ошибка!
  console.log(error.errors[1]); // Error: Ещё одна ошибка!
});
```

Как вы можете видеть, объекты ошибок для отклонённых промисов доступны в свойстве `errors` объекта `AggregateError`.[^promise-api]

Таким образом, функция **`Promise.any()`** принимает несколько промисов и возвращает первый успешно завершившийся промис:
```js
const promise1 = new Promise((resolve, reject) => {
    reject("error in promise1");
    setTimeout(resolve, 500, "Hello");
});
const promise2 = new Promise((resolve) => {
    setTimeout(resolve, 1000, "World");
});
Promise.any([promise1, promise2])
    .then(value => console.log(value))       // World
    .catch(error => console.log(error));
```

В данном случае первым выполненным будет промис `promise1`, однако он завершается с ошибкой. Поэтому в метод `then(value => console.log(value))` в качестве `value` будет передана строка "World" — результат промиса `promise2`, который успешно завершается.


Может показаться, что `Promise.any()` делает то же самое, что и `Promise.race()`, однако эти функции отличаются в отношении того, как они работают с промисами, которые завершились с ошибкой. `Promise.race()` возвращает первый завершенный промис, вне зависимости завершился он с ошибкой или нет. А `Promise.any()` возвращает первый успешно завершенный промис (если такой имеется). Если же все промисы завершились с ошибкой, то генерируется исключение типа **`AggregateError`**:
```js
const promise1 = new Promise((resolve, reject) => {
    reject("error in promise1");
    setTimeout(resolve, 500, "Hello");
});
const promise2 = new Promise((resolve, reject) => {
    reject("error in promise2");
    setTimeout(resolve, 1000, "World");
});
Promise.any([promise1, promise2])
    .then(value => console.log(value))
    .catch(error => console.log(error)); // AggregateError: All promises were rejected
```

С помощью свойства **`errors`** типа `AggregateError` можно получить в виде массива все ошибки, которые возникли в промисах:
```js
const promise1 = new Promise((resolve, reject) => {
    reject("error in promise1");
    setTimeout(resolve, 500, "Hello");
});
const promise2 = new Promise((resolve, reject) => {
    reject("error in promise2");
    setTimeout(resolve, 1000, "World");
});
Promise.any([promise1, promise2])
    .then(value => console.log(value))
    .catch(e => console.log(e.errors));  // ["error in promise1", "error in promise2"]
```

#### Сравнение методов
Таким обарзом все четыре метода работают с наборами промисов, но имеют разные цели по ожиданию результата и обработке ошибок.

`Promise.all`:

- **Что делает**: ждет выполнения всех промисов и возвращает массив их значений в том же порядке.

- **Ошибка**: если любой промис отклоняется, возвращаемый промис тоже отклоняется сразу с причиной первого отклонения.

- **Типичная цель**: получить совокупный результат множества зависимых асинхронных задач.

`Promise.allSettled`

- **Что делает**: ждет завершения всех промисов (как бы они ни завершились) и возвращает массив объектов статуса для каждого промиса: `{ status: "fulfilled", value }` или `{ status: "rejected", reason }`.

- **Ошибка**: не reject’ится никогда (даже если некоторые промисы отклоняются).

- **Типичная цель**: узнать результаты всех задач и обработать ошибки отдельно.

`Promise.race`

- **Что делает**: возвращает результат самого первого промиса, который «расселится» (разрешится или отклонится).

- **Ошибка**: если первый завершившийся промис отклонится, итог будет отклонением с той же причиной.

- **Типичная цель**: получить первый доступный результат, без ожидания остальных.

`Promise.any`

- **Что делает**: возвращает результат первого промиса, который успешно разрешится.

- **Ошибка**: если все промисы отклоняются, возвращает агрегированную ошибку (включает причины отклонений всех промисов).

- **Типичная цель**: продолжать работу при наличии хотя бы одного успешного варианта, игнорируя остальные ошибки.

Ключевые различия на практике

- **Надежность к ошибкам**: `all` и `race` чувствительны к отказу промиса (`all` отвергнется при любой ошибке; `race` — если первый завершится ошибкой). `allSettled` и any более устойчивые к отдельным сбоям: `allSettled` никогда не отклонится, а any дождется хотя бы одного успеха или выдаст агрегированную ошибку.

- **Формат возвращаемых данных**: `all` возвращает массив значений; `allSettled` возвращает массив объектов статуса; `race` и `any` возвращают один результат (или исключение).

- **Контекст использования**: выбирайте по целям обработки —

    - если нужны все результаты и их последовательность: `all`;

    - если нужны только статусы всех задач, независимо от ошибок: `allSettled`;

    - если нужна супербыстрая готовность к первому завершению: `race`;

    - если нужна первая удачная альтернатива среди многих: `any`.

Пример сценариев

- Загрузить несколько файлов и продолжать только после всех загрузок: использовать `allSettled` и затем пройтись по каждому результату.

- Выполнить несколько независимых API-запросов и продолжить, даже если один вернул ошибку, но нужны остальные данные: `allSettled`.

- Нужно получить первый ответ из нескольких клонов сервиса: `race`.

- Нужно получить сразу все ответы, и если хоть один потерпел неудачу — показать ошибку всей операции: `all`.

- Нужно получить первую успешную копию данных из нескольких резервных источников: `any`.

*Сравнение методов `Promise`*

| Метод              | Поведение при выполнении            | Обработка ошибок                      | Возвращаемый результат                          | Типичное применение                         |
| ------------------ | ----------------------------------- | ------------------------------------- | ----------------------------------------------- | ------------------------------------------- |
| `Promise.all`        | Ждет завершения всех промисов       | Reject при первой ошибке              | Массив значений в порядке промисов dev​         | Все результаты нужны, любая ошибка критична |
| `Promise.allSettled` | Ждет завершения всех (успех/ошибка) | Никогда не reject, возвращает статусы | Массив объектов {status, value/reason} calmops​ | Проверить статусы всех задач независимо     |
| `Promise.race`       | Первый завершившийся промис         | Reject если первый — ошибка           | Значение/ошибка первого промиса dev​            | Самый быстрый результат (таймауты, лидеры)  |
| `Promise.any`        | Первый успешно завершившийся промис | Reject только если все отклонены      | Значение первого успеха calmops​                | Первый рабочий вариант из альтернатив       |

#### Promise.resolve/reject
Методы `Promise.resolve` и `Promise.reject` редко используются в современном коде, так как синтаксис `async`/`await` (мы рассмотрим его чуть позже) делает их, в общем-то, не нужными.

Мы рассмотрим их здесь для полноты картины, а также для тех, кто по каким-то причинам не может использовать `async`/`await`.

##### Promise.resolve
- `Promise.resolve(value)` создаёт успешно выполненный промис с результатом `value`.

То же самое, что:
```js
let promise = new Promise(resolve => resolve(value));
```

Этот метод используют для совместимости: когда ожидается, что функция возвратит именно промис.

Например, функция `loadCached` ниже загружает URL и запоминает (кеширует) его содержимое. При будущих вызовах с тем же URL он тут же читает предыдущее содержимое из кеша, но использует `Promise.resolve`, чтобы сделать из него промис, для того, чтобы возвращаемое значение всегда было промисом:
```js
let cache = new Map();

function loadCached(url) {
  if (cache.has(url)) {
    return Promise.resolve(cache.get(url)); // (*)
  }

  return fetch(url)
    .then(response => response.text())
    .then(text => {
      cache.set(url,text);
      return text;
    });
}
```

Мы можем писать `loadCached(url).then(…)`, потому что функция `loadCached` всегда возвращает промис. Мы всегда можем использовать `.then` после `loadCached`. Это и есть цель использования `Promise.resolve` в строке `(*)`.

##### Promise.reject
- `Promise.reject(error)` создаёт промис, завершённый с ошибкой `error`.

То же самое, что:
```js
let promise = new Promise((resolve, reject) => reject(error));
```

На практике этот метод почти никогда не используется.

#### Итого
Мы ознакомились с шестью статическими методами класса `Promise`:

1. `Promise.all(promises)` – ожидает выполнения всех промисов и возвращает массив с результатами. Если любой из указанных промисов вернёт ошибку, то результатом работы `Promise.all` будет эта ошибка, результаты остальных промисов будут игнорироваться.
2. `Promise.allSettled(promises)` (добавлен недавно) – ждёт, пока все промисы завершатся и возвращает их результаты в виде массива с объектами, у каждого объекта два свойства:
   - `status: "fulfilled"`, если выполнен успешно или `"rejected"`, если ошибка,
   - `value` – результат, если успешно или `reason` – ошибка, если нет.
3. `Promise.race(promises)` – ожидает первый *выполненный* промис, который становится его результатом, остальные игнорируются.
4. `Promise.any(promises)` (добавлен недавно) – ожидает первый *успешно выполненный* промис, который становится его результатом, остальные игнорируются. Если все переданные промисы отклонены, `AggregateError` становится ошибкой `Promise.any`.
5. `Promise.resolve(value)` – возвращает успешно выполнившийся промис с результатом `value`.
6. `Promise.reject(error)` – возвращает промис с ошибкой `error`.

Из всех перечисленных методов, самый часто используемый – это, пожалуй, `Promise.all`.[^promise-api]

### Промисификация
Промисификация – это длинное слово для простого преобразования. Мы берём функцию, которая принимает колбэк и меняем её, чтобы она вместо этого возвращала промис.

Такие преобразования часто необходимы в реальной жизни, так как многие функции и библиотеки основаны на колбэках, а использование промисов более удобно, поэтому есть смысл «промисифицировать» их.[^promisify]

Например, у нас есть `loadScript(src, callback)` из раздела о коллбэках.

```js
function loadScript(src, callback) {
  let script = document.createElement('script');
  script.src = src;

  script.onload = () => callback(null, script);
  script.onerror = () => callback(new Error(`Ошибка загрузки скрипта ${src}`));

  document.head.append(script);
}

// использование:
// loadScript('path/script.js', (err, script) => {...})
```

Давайте промисифицируем её. Новая функция `loadScriptPromise(src)` будет делать то же самое, но будет принимать только `src` (не `callback`) и возвращать промис.

```js
let loadScriptPromise = function(src) {
  return new Promise((resolve, reject) => {
    loadScript(src, (err, script) => {
      if (err) reject(err)
      else resolve(script);
    });
  })
}

// использование:
// loadScriptPromise('path/script.js').then(...)
```

Теперь `loadScriptPromise` хорошо вписывается в код, основанный на промисах.

Как видно, она передаёт всю работу исходной функции `loadScript`, предоставляя ей колбэк, по вызову которого происходит `resolve`/`reject` промиса.

На практике нам, скорее всего, понадобится промисифицировать не одну функцию, поэтому имеет смысл сделать для этого специальную «функцию-помощник».

Мы назовём её `promisify(f)` – она принимает функцию для промисификации `f` и возвращает функцию-обёртку.

Эта функция-обёртка делает то же самое, что и код выше: возвращает промис и передаёт вызов оригинальной `f`, отслеживая результат в своём колбэке:
```js
function promisify(f) {
  return function (...args) { // возвращает функцию-обёртку
    return new Promise((resolve, reject) => {
      function callback(err, result) { // наш специальный колбэк для f
        if (err) {
          reject(err);
        } else {
          resolve(result);
        }
      }

      args.push(callback); // добавляем колбэк в конец аргументов f

      f.call(this, ...args); // вызываем оригинальную функцию
    });
  };
};

// использование:
let loadScriptPromise = promisify(loadScript);
loadScriptPromise(...).then(...);
```

Здесь мы предполагаем, что исходная функция ожидает колбэк с двумя аргументами `(err, result)`. Это то, с чем мы чаще всего сталкиваемся. Тогда наш колбэк – в правильном формате, и `promisify` отлично работает для такого случая.

Но что, если исходная `f` ожидает колбэк с большим количеством аргументов `callback(err, res1, res2, ...)`?

Ниже описана улучшенная функция `promisify`: при вызове `promisify(f, true)` результатом промиса будет массив результатов `[res1, res2, ...]`:
```js
// promisify(f, true), чтобы получить массив результатов
function promisify(f, manyArgs = false) {
  return function (...args) {
    return new Promise((resolve, reject) => {
      function callback(err, ...results) { // наш специальный колбэк для f
        if (err) {
          reject(err);
        } else {
          // делаем resolve для всех results колбэка, если задано manyArgs
          resolve(manyArgs ? results : results[0]);
        }
      }

      args.push(callback);

      f.call(this, ...args);
    });
  };
};

// использование:
f = promisify(f, true);
f(...).then(arrayOfResults => ..., err => ...)
```

Для более экзотических форматов колбэка, например без `err: callback(result)`, мы можем промисифицировать функции без помощника, «вручную».

Также существуют модули с более гибкой промисификацией, например, [es6-promisify](https://github.com/digitaldesignlabs/es6-promisify) или встроенная функция `util.promisify` в Node.js.

!!! info "На заметку:"
    Промисификация – это отличный подход, особенно, если вы будете использовать `async`/`await` (см. следующий раздел об Async/await) но она не является тотальной заменой любых колбэков.

    Помните, промис может иметь только один результат, но колбэк технически может вызываться сколько угодно раз.

    Поэтому промисификация используется для функций, которые вызывают колбэк только один раз. Последующие вызовы колбэка будут проигнорированы.

## Async/await

### Async и await
Внедение стандарта ES2017 в JavaScript привнесло два новых оператора: **`async`** и **`await`**, который призваны упростить работу с промисами.

Оператор **`async`** определяет асинхронную функцию, в которой, как предполагается, будет выполняться одна или несколько асинхронных задач:
```js
async function название_функции(){
    // асинхронные операции
}
```

Внутри асинхронной функции мы можем применить оператор **`await`**. Он ставится перед вызовом асинхронной операции, которая представляет объект `Promise`:
```js
async function название_функции(){

    await асинхронная_операция();
}
```

Оператор **`await`** приостанавливает выполнение асинхронной функции, пока асинхронная операция (объект `Promise`) не возвратит результат.

Стоит учитывать, что оператор **`await`** может использоваться только внутри функции, к которой применяется оператор **`async`**.

Сначала рассмотрим самый простейший пример с использованием `Promise`:
```js
function sum(x, y){
    return new Promise(function(resolve){
        const result = x + y;
        resolve(result);
    });
}
sum(5, 3).then(function(value){
    console.log("Результат асинхронной операции:", value);
}); // Результат асинхронной операции: 8
```

В данной случае функция `sum()` представляет асинхронную задачу. Она принимает два числа и возвращает объект `Promise`, в котором выполняется сложение этих чисел. Результат сложения передается в функцию `resolve()`. И далее в методе `then()` мы можем получить этот результат и выполнить с ним различные действия.

Теперь перепишем этот пример с использованием **`async`**/**`await`**:
```js
function sum(x, y){
    return new Promise(function(resolve){
        const result = x + y;
        resolve(result);
    });
}
// сокращенный вариант
// function sum(x, y){ return Promise.resolve(x + y);}


async function calculate(){
    const value = await sum(5, 3);
    console.log("Результат асинхронной операции:", value);
}
calculate();    // Результат асинхронной операции: 8
```

Здесь мы определили асинхронную функцию `calculate()`, к которой применяется **`async`**:
```js
async function calculate(){
```

Внутри функции вызывается асинхронная операция `sum()`, которой передаются некоторые значения. Причем к этой функции применяется оператор **`await`**. Благодаря оператору `await` больше нет надобности вызывать у промиса метод **`then()`**. А результат, который возвращает `Promise`, мы можем получить напрямую из вызова функции `sum` и, например, присвоить константе или переменной:
```js
const value = await sum(5, 3);
```

Затем мы можем вызвать функцию `calculate()` как обычную функции и тем самым выполнить все ее действия.

```js
calculate();
```

Стоит отметить, что для функции, которая определена со словом **`async`** неявно создается объект `Promise`. Поэтому ее также можно использовать как промис:
```js
function sum(x, y){
    return new Promise(function(resolve){
        const result = x + y;
        resolve(result);
    });
}

async function calculate(){
    const result = await sum(5, 3);
    return result;
}
calculate().then(value=> console.log("Результат асинхронной операции:", value));
```

#### Выполнение последовательности асинхронных операций
Асинхронная функция может содержать множество асинхронных операций, к которым применяется оператор **`await`**. В этом случае все асинхронные операции будут выполняться последовательно:
```js
function sum(x, y){
    return new Promise(function(resolve){
        const result = x + y;
        resolve(result);
    });
}

async function calculate(){
    const value1 = await sum(5, 3);
    console.log("Результат 1 асинхронной операции:", value1);
    const value2 = await sum(6, 4);
    console.log("Результат 2 асинхронной операции:", value2);
    const value3 = await sum(7, 5);
    console.log("Результат 3 асинхронной операции:", value3);
}
calculate();
// Результат 1 асинхронной операции: 8
// Результат 2 асинхронной операции: 10
// Результат 3 асинхронной операции: 12
```

#### Обработка ошибок
Для обработки ошибок, которые могут возникнуть в процессе вызова асинхронной операции применяется конструкция **`try..catch..finally`**.

Например, возьмем следующий код с использованием `Promise`:
```js
function square(str){
    return new Promise((resolve, reject) => {
        const n = parseInt(str);
        if (isNaN(n)) reject("Not a number");
        else resolve(n * n);
    });
};
function calculate(str){

    square(str)
        .then(value => console.log("Result: ", value))
        .catch(error => console.log(error));
}

calculate("g8");    // Not a number
calculate("4");     // Result:  16
```

Функция `square()` получает некоторое значение, в промисе это значение преобразуется в число. И при удачном преобразовании из промиса возвращается квадра числа. Если переданное значение не является числом, то возвращаем ошибку.

При вызове функции `square()` с помощью метода **`catch()`** можно обработать возникшую ошибку.

Теперь перепишем пример с использованием **`async/await`**:
```js
function square(str){
    return new Promise((resolve, reject) => {
        const n = parseInt(str);
        if (isNaN(n)) reject("Not a number");
        else resolve(n * n);
    })
};

async function calculate(str){

    try{
        const value = await square(str);
        console.log("Result: ", value);
    }
    catch(error){
        console.log(error);
    }
}

calculate("g8");    // Not a number
calculate("4");     // Result:  16
```

Вызов асинхронной операции помещается в блок **`try`**, соответственно в блоке **`catch`** можно получить возникшую ошибку и обработать ее.[^17.6]

### Асинхронные итераторы

Асинхронные итераторы объединяют возможности итераторов и операторов **`async`** и **`await`**. Асинхронные итераторы прежде всего предназначены для обращения к источникам данных данных, которые используют асинхронный API. Это могут быть какие-нибудь данные, которые загружаются по части, например, по сети, из файловой системы или из базы данных.

Из статьи про итераторы мы должны помнить, что интератор предоставляет метод **`next()`**, который возвращает объект с двумя свойствами: **`{ value, done }`**. Свойство `value` хранит некоторое значение, которое, например, можно получить в цикле `for..of` при переборе объекта. А свойство `done` указывает, завершен ли перебор объектов. Если это свойство равно `false`, значит, итератор еще не завершил перебор объектов, и есть еще доступные объекты. Если свойство равно `true`, то перебор закончен, и в наборе больше нет доступных для перебора объектов.

Асинхронный итератор похож на обычный синхронный за тем исключением, что его метод **`next()`** возвращает объект **`Promise`**. А из промиса, в свою очередь, возвращается объект **`{ value, done }`**.[^17.7]

#### Цикл for-await-of
Для получения данных с помощью асинхронных итераторов применяется цикл **`for-await-of`**:
```js
for await (variable of iterable) {
  // действия
}
```

В цикле **`for-await-of`** после оператора **`of`** идет некоторый набор данных, который можно перебрать по элементам. Это может асинхронный источник данных, но также может быть и синхронный источник данных, как массивы или, например, встроенные объекты `String`, `Map`, `Set` и т.д.

Стоит отметить, что данная форма цикла может использоваться только в функциях, определенных с оператором **`async`**.

Рассмотрим простейший пример, где в качестве источника данных выступает обычный массив:
```js
const dataSource = ["Tom", "Sam", "Bob"];
async function readData(){
    for await (const item of dataSource) {
        console.log(item);
    }
}
readData();
// Tom
// Sam
// Bob
```

Здесь в цикле происходит перебор массива `dataSource`. При выполнении цикла для источника данных (в данном случае для массива) с помощью метода `[Symbol.asyncIterator]()` неявно создается асинхронный итератор. И при каждом обращении к очередному элементу в этом источнике данных неявно из итератора возвращается объект `Promise`, из которого и получаем текущий элемент массива.

#### Создание асинхронного итератора
В примере выше асинхронный итератор создавался неявно. Но мы также можем его определить явно. Например, определим асинхронный итератор, который возвращает элементы массива:
```js
const generatePerson = {
  [Symbol.asyncIterator]() {
    return {
      index: 0,
      people: ["Tom", "Sam", "Bob"],
      next() {
        if (this.index < this.people.length) {
          return Promise.resolve({ value: this.people[this.index++], done: false });
        }

        return Promise.resolve({ done: true });
      }
    };
  }
};
```

Итак, здесь определен объект **`generatePerson`**, в котором реализован только один метод — **`[Symbol.asyncIterator]()`**, который по сути и представляет асинхронный итератор. Реализация асинхронного итератора (как и в случае с синхронным итератором) позволяет сделать объект generatePerson перебираемым.

Основные моменты асинхронного итератора:

- Асинхронный итератор реализуется методом **`[Symbol.asyncIterator]()`**, который возвращает объект.

- Возвращаемый объект итератора имеет метод **`next()`**, который возвращает объект **`Promise`**.

- Объект **`Promise`**, в свою очередь, возвращает объект с двумя свойстами **`{ value, done }`**. Свойство `value` собственно хранит некоторое значение. А свойство `done` указывает, завершен ли перебор и соответственно, есть ли в наборе доступные для перебора объекты. Если свойство `done` равно `true` (перебор закончен, и доступных для перебора объектов больше нет), то нет смысла указывать свойство `value`.

В данном случае итератор реализует простую задачу — возвращает очереднего пользователя. Для хранения пользователей в объекте итератора определен массив `people`, а для хранения индекса текущего элемента массива определена переменная `index`.

```js
index: 0,
people: ["Tom", "Sam", "Bob"],
```

В методе **`next()`** возвращаем объект `Promise`. Если текущий индекс меньше длины массивы (то есть в массиве еще имеются для перебора элементы), то возвращаем `Promise`, в котором возвращаем элемент массива по текущему индексу:
```js
return Promise.resolve({ value: this.people[this.index++], done: false });
```

Если все элементы массива уже получены, то возвращаем `Promise` с объектом `{ done: true }`:
```js
return Promise.resolve({ done: true });
```

Где значение `done: true` будет указывать внешнему коду, что все значения итератора уже получены.

Теперь посмотрим, как мы можем получить из итератора данные.

Как и с обычным итератором, мы можем обратиться к самому асинхронному итератору:
```js
generatePerson[Symbol.asyncIterator](); // получаем асинхронный итератор
```

И вызвать явным образом его метод **`next()`**:
```js
generatePerson[Symbol.asyncIterator]().next(); // Promise
```

Этот метод возвращает Promise, у котоого можно вызвать метод **`then()`** и обработать его значение:
```js
generatePerson[Symbol.asyncIterator]()
    .next()
    .then((data)=>console.log(data));    // {value: "Tom", done: false}
```

Полученный из промиса объект представляет объект `{value, done}`, у которого через свойство `value` можно получить собственно значение:
```js
generatePerson[Symbol.asyncIterator]()
    .next()
    .then((data)=>console.log(data.value));  // Tom
```

Поскольку метод `next()` возвращает `Promise`, то мы можем использовать оператор `await` для получения значений:
```js
async function printPeople(){
    const peopleIterator = generatePerson[Symbol.asyncIterator]();

    while(!(personData = await peopleIterator.next()).done){
        console.log(personData.value);
    }
}
printPeople();
```

Здесь в асинхронной функции цикле `while` с помощью оператора `await` последовательно получаем из итератора один за другим объекты `Promise`, из которых извлекаем данные, пока не достигнем конца данных итератора.

Однако для перебора объекта асинхронного итератора гораздо проще использовать выше рассмотренный цикл **`for-await-of`**:
```js
const generatePerson = {
  [Symbol.asyncIterator]() {
    return {
      index: 0,
      people: ["Tom", "Sam", "Bob"],
      next() {
        if (this.index < this.people.length) {
          return Promise.resolve({ value: this.people[this.index++], done: false });
        }
        return Promise.resolve({ done: true });
      }
    };
  }
};
async function printPeople(){
    for await (const person of generatePerson) {
        console.log(person);
   }
}
printPeople();
```

Поскольку объект **generatePerson** реализует метод **`[Symbol.asyncIterator]()`**, то мы его можем перебрать с помощью цикла **`for-await-of`**. Соответственно при каждом обращении в цикле метод `next()` будет возращать промис с очередным элементом из массива `people`. И в итоге мы получим следующий консольный вывод:
```
Tom
Sam
Bob
```

Стоит отметить, что мы НЕ можем использовать для перебора объекта с асинхронным итератором обычный цикл **`for-of`**.

Еще один простейший пример — получение чисел:
```js
const generateNumber = {
  [Symbol.asyncIterator]() {
    return {
      current: 0,
      end: 10,
      next() {
        if (this.current <= this.end) {
          return Promise.resolve({ value: this.current++, done: false });
        }
        return Promise.resolve({ done: true });
      }
    };
  }
};
async function printNumbers(){
    for await (const n of generateNumber) {
        console.log(n);
   }
}
printNumbers();
```

Здесь асинхронный итератор объекта `generateNumber` возвращает числа от 0 до 10.

### Асинхронные генераторы
Асинхронные итераторы открывают нам путь к созданию асинхронных генераторов. Асинхронные генераторы позволяют нам использовать оператор **`await`** и получать и возвращать данные асинхронным образом.[^17.8]

Для определения асинхронного генератора перед функцией генератора ставится оператор **`async`**
```js
async function* название_функции_генератора(){

    yield возвращаемое_значение;
}
```

Рассмотрим простейший генератор:
```js
async function* generatePersonAsync(){
    yield "Tom";
}
```

Здесь определен асинхронный генератор `generatePersonAsync`, в котором возвращается одно значение — строка "Tom".

Особенностью асинхронного генератора является то, что при обращении к его методу **`next()`** возвращается объект `Promise`. А полученный объект `Promise`, в свою очередь, возвращает объект с двумя свойствами `{ value, done }`, где `value` собственно хранит возвращаемое значение, а `done` указывает, доступны ли в генераторе еще данные.

Например, возьмем выше определенный асинхронный генератор:
```js
async function* generatePersonAsync(){
    yield "Tom";
}
const personGenerator = generatePersonAsync();
personGenerator.next(); // Promise
```

Здесь с помощью метода `next()` получаем промис. Далее через метод `then()` мы можем получить из промиса объект:
```js
const personGenerator = generatePersonAsync();
personGenerator.next()
    .then(data => console.log(data));    // {value: "Tom", done: false}
```

И при обращении к свойству `value` полученного из промиса получить сами данные:
```js
const personGenerator = generatePersonAsync();
personGenerator.next()
    .then(data => console.log(data.value));  // Tom
```

С помощью оператора **`await`** из метода `next()` генератора мы можем получить данные:
```js
async function* generatePersonAsync(){
    yield "Tom";
    yield "Sam";
    yield "Bob";
}
async function printPeopleAsync(){
    const personGenerator = generatePersonAsync();
    while(!(person = await personGenerator.next()).done){
        console.log(person.value);
    }
}

printPeopleAsync();
```

Консольный вывод:
```
Tom
Sam
Bob
```

Поскольку асинхронный генератор представляет асинхронный итератор, то данные генератора также можно получить через цикл **`for-await-of`**:
```js
async function* generatePersonAsync(){
    yield "Tom";
    yield "Sam";
    yield "Bob";
}
async function printPeopleAsync(){
    const personGenerator = generatePersonAsync();
    for await(person of personGenerator){
        console.log(person);
    }
}

printPeopleAsync();
// Tom
// Sam
// Bob
```

#### await в асинхронных генераторах
Главным преимуществом асинхронным генераторов является то, что мы можем использовать в них оператор **`await`** и соответственно получать данные из источников данных, которые используют асинхронный API.

```js
async function* generatePersonAsync(people){
    for(const person of people)
        yield await new Promise(resolve => setTimeout(() => resolve(person), 2000));
}
async function printPeopleAsync(people){
    for await (const item of generatePersonAsync(people)) {
        console.log(item);
    }
}
printPeopleAsync(["Tom", "Sam", "Bob"]);
```

Здесь для имитации получения данных из асинхронного источника данных применяется промис, который через 2000 секуд возвращает один из элементов массива, который передается в функцию генератора:
```js
yield await new Promise(resolve => setTimeout(() => resolve(person), 2000));
```

## Источники информации
[^17.9]: [Асинхронные функции и коллбеки](https://metanit.com/web/javascript/17.9.php)
[^17.1]: [Введение в промисы](https://metanit.com/web/javascript/17.1.php)
[^callbacks]: [Введение: колбэки](https://learn.javascript.ru/callbacks)
[^17.2]: [Получение результата операции в Promise](https://metanit.com/web/javascript/17.2.php)
[^promise-basics]: [Промисы](https://learn.javascript.ru/promise-basics)
[^17.3]: [Обработка ошибок в Promise](https://metanit.com/web/javascript/17.3.php)
[^17.4]: [Создание цепочек промисов](https://metanit.com/web/javascript/17.4.php)
[^17.5]: [Функции Promise.all, Promise.allSettled, Promise.any и Promise.race](https://metanit.com/web/javascript/17.5.php)
[^promise-chaining]: [Цепочка промисов](https://learn.javascript.ru/promise-chaining)
[^17.6]: [Async и await](https://metanit.com/web/javascript/17.6.php)
[^17.7]: [Асинхронные итераторы](https://metanit.com/web/javascript/17.7.php)
[^promise-error-handling]: [Промисы: обработка ошибок](https://learn.javascript.ru/promise-error-handling)
[^17.8]: [Асинхронные генераторы](https://metanit.com/web/javascript/17.8.php)
[^promise-api]: [Promise API](https://learn.javascript.ru/promise-api)
[^promisify]: [Промисификация](https://learn.javascript.ru/promisify)
