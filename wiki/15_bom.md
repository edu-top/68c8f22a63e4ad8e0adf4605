<link href="../styles.css" rel="stylesheet" />

# Объектная модель браузера

- [Browser Object Model и объект window](#browser-object-model-и-объект-window)
  - [Объект window](#объект-window)
  - [Свойства window](#свойства-window)
  - [Компоненты браузера](#компоненты-браузера)
  - [Свойство screen](#свойство-screen)
- [Диалоговые окна и поиск на странице](#диалоговые-окна-и-поиск-на-странице)
  - [alert](#alert)
  - [confirm](#confirm)
  - [prompt](#prompt)
  - [find](#find)
  - [print](#print)
- [Открытие, закрытие и позиционирование окон](#открытие-закрытие-и-позиционирование-окон)
  - [Блокировка попапов](#блокировка-попапов)
  - [Открытие окон](#открытие-окон)
  - [Пример: минималистичное окно](#пример-минималистичное-окно)
  - [Доступ к попапу из основного окна](#доступ-к-попапу-из-основного-окна)
  - [Доступ к открывшему окну из попапа](#доступ-к-открывшему-окну-из-попапа)
  - [Закрытие окна](#закрытие-окна)
  - [Управление позицией и размером окна](#управление-позицией-и-размером-окна)
  - [Прокрутка окна](#прокрутка-окна)
  - [Установка и потеря фокуса](#установка-и-потеря-фокуса)
  - [Итого](#итого)
- [История браузера. History API](#история-браузера-history-api)
  - [Событие popstate](#событие-popstate)
  - [Перемещение по одностраничному сайту](#перемещение-по-одностраничному-сайту)
    - [Наивная реализация](#наивная-реализация)
    - [Исправленная версия](#исправленная-версия)
- [Объект location](#объект-location)
  - [Управление адресом](#управление-адресом)
- [Объект navigator](#объект-navigator)
- [Планирование вызовов](#планирование-вызовов)
  - [Функция setTimeout](#функция-settimeout)
    - [Параметры таймера](#параметры-таймера)
    - [Отмена через clearTimeout](#отмена-через-cleartimeout)
  - [Функция setInterval](#функция-setinterval)
  - [Вложенный setTimeout](#вложенный-settimeout)
  - [Утечки памяти](#утечки-памяти)
    - [setTimeout с нулевой задержкой](#settimeout-с-нулевой-задержкой)
  - [Точность задержки](#точность-задержки)
  - [Итого](#итого-1)
  - [Задачи](#задачи)
    - [Вывод каждую секунду](#вывод-каждую-секунду)
    - [Что покажет setTimeout?](#что-покажет-settimeout)
  - [requestAnimationFrame()](#requestanimationframe)
- [Заключение](#заключение)
- [Практика](#практика)
  - [Практическая работа. Реализация одностраничного веб-приложения](#практическая-работа-реализация-одностраничного-веб-приложения)
    - [Задание](#задание)
  - [Практическая работа. Оптимизация клиентской маршрутизации](#практическая-работа-оптимизация-клиентской-маршрутизации)
- [Источники информации](#источники-информации)

## Browser Object Model и объект window
*[BOM]: Browser Object Model

Большое значение в JavaScript имеет работа с веб-браузером и теми объектами, которые он предоставляет. Например, использование объектов браузера позволяет манипулировать элементами html, которые имеются на странице, или взаимодействовать с пользователем.

Все объекты, через которые JavaScript взаимодействует с браузером, описываются таким понятием как **Browser Object Model** (Объектная Модель Браузера).

Browser Object Model можно представить в виде следующей схемы:

![Browser Object Model in JavaScript](../img/bom.png)

В вершине находится главный объект — объект **`window`**, который представляет глобальный объект (фактически представляет собой браузер). Этот объект в свою очередь включает ряд других объектов, в частности, объект **`document`**, который представляет отдельную веб-страницу, отображаемую в браузере.[^7.1]

### Объект window
Объект **`window`** представляет собой окно веб-браузера, в котором размещаются веб-страницы. **`window`** является глобальным объектом, поэтому при доступе к его свойствам и методам необязательно использовать его имя. Например, объект **`window`** имеет метод **`alert()`**, который отображает окно сообщения. Но нам необязательно писать:
```js
window.alert("Привет мир!");
```

`window` можно не использовать:
```js
alert("Привет мир!");
```

Но так как данный объект глобальный, то это накладывает некоторые ограничения. Например:
```js
var alert = function(message){

    console.log("Сообщение: ", message);
};
window.alert("Привет мир!");
```

С помощью `var` здесь определяется глобальная переменная `alert`. Все объявляемые в программе глобальные переменные или функции автоматически добавляются к объекту `window`. И поскольку название новой функции будет совпадать с названием метода `alert()`, то произойдет переопределение этого метода в объекте `window` новой функцией.

И если мы объявим в программе какую-нибудь глобальную переменную, то она нам доступна как свойство в объекте `window`:
```js
var message = "hello";
console.log(window.message);
```

### Свойства window
С помощью свойств объекта `window` можно получить различную информацию об окне браузера. В частности, для определения положения окна применяются следующие свойства:

- **`innerHeight`**: содержит высоту окна, в том числе горизонтальные полосы прокрутки

- **`innerWidth`**: содержит ширину окна, в том числе вертикальные полосы прокрутки

- **`outerHeight`**: содержит высоту окна браузера, в том числе все полосы прокрутки браузера

- **`outerWidth`**: содержит ширину окна браузера, в том числе все полосы прокрутки браузера

- **`pageXOffset`**: псевдоним для `window.scrollX`

- **`pageYOffset`**: псевдоним для `window.scrollY`

- **`screenX`**: содержит позицию окна браузера по оси X, то есть расстояние от окна браузера до левого края экрана

- **`screenY`**: содержит позицию окна браузера по оси X, то есть расстояние от окна браузера до верхнего края экрана

- **`scrollX`**: содержит количество пикселей веб-страницы, прокрученных по горизонтали

- **`scrollY`**: содержит количество пикселей веб-страницы, прокрученных по вертикали

Например, получим положение окна:
```js
console.log(window.innerHeight);
console.log(window.innerWidth);
console.log(window.screenX);
console.log(window.screenY);
```

### Компоненты браузера
Окно браузера обычно состоит из различных компонентов. В зависимости от конкретного браузера и персональных настроек набор конкретных компонентов может отличаться. Но в общем случае типовое окно браузера выглядит следующим образом:

![панели и компоненты веб-браузера в JavaScript](../img/browser3.png)

Помимо собственно области содержимого, в которой отображается веб-страница, веб-браузер имеет еще ряд компонентов:

- адресная строка для ввода URL-адреса или поискового запроса (*Address Bar*)

- строка состояния (*Status Bar*), которая указывает, загружена ли веб-страница или находится в процессе загрузки

- строка меню (*Menu Bar*)

- панель инструментов (*ToolBar*)

- некоторая "личная" / "персональная" панель, которая, например, содержит закладки (*Personal Bar*)

- полосы прокрутки, которые отображают горизонтальное и вертикальное положение (*Horizontal/Vertical ScrollBar*)

Объект **`window`** имеет ограниченные возможности для взаимодействия с этими компонентами, в частности, для проверки наличия этих компонентов объект `window` имеет ряд свойств:

- **`locationbar`**: содержит объект, который указывает, отображается адресная строка или нет

- **`menubar`**: указывает, отображается ли панель меню или нет

- **`personalbar`**: указывает, отображается ли персональная панель (например, панель закладок) или нет

- **`scrollbars`**: указывает, отображаются ли полосы прокрутки или нет

- **`statusbar`**: указывает, отображается строка состояния или нет

- **`toolbar`**: указывает, отображается ли панель инструментов или нет

Например, узнаем отображается ли персональная панель:
```js
console.log(window.personalbar); // BarProp {visible: true} или BarProp {visible: false}
```

Свойство возвратит объект `BarProp`, в котором свойство `visible` собственно и указывает, отображается панель или нет.

### Свойство screen
Для получения информации об экране также применяется свойство **`screen`** объекта `window`. Это свойство представляет объект типа **`Screen`** со следующими свойствами:

- **`availTop`**: указывает на высоту фиксированных компонентов, которые примыкают к верхней стороне браузера, например, различных верхних панелей

- **`availLeft`**: указывает на ширину фиксированных компонентов, которые примыкают к левой стороне браузера, например, различных левых панелей

- **`availHeight`**: содержит максимально доступную высоту в пикселях минус высоту верхних и нижних панелей

- **`availWidth`**: содержит максимально доступную ширину в пикселях минус ширину левых и правых панелей

- **`colorDepth`**: содержит глубину цвета экрана

- **`height`**: содержит высоту экрана в пикселях

- **`orientation`**: содержит объект типа `ScreenOrientation`, который предоставляет информацию об ориентации устройства

- **`pixelDepth`**: содержит глубину пикселя экрана

- **`width`**: содержит ширину экрана в пикселях

![свойство screen в window JavaScript](../img/screen.png)

Пример использования
```js
console.log(screen.availTop);       // 25
console.log(screen.availLeft);      // 0
console.log(screen.availHeight);    // 695
console.log(screen.availWidth);     // 1280
console.log(screen.width);          // 1280
console.log(screen.height);         // 800
console.log(screen.pixelDepth);     // 24
console.log(screen.colorDepth);     // 24
```

## Диалоговые окна и поиск на странице
Для взаимодействия с пользователем в объекте **`window`** определен ряд методов, которые позволяют создавать диалоговые окна или взаимодействуют с содержимым окна:

- **`alert()`**: выводит окно с сообщением

- **`confirm()`**: отображает окно с сообщением, в котором пользователь должен подтвердить действие двух кнопок OK и Отмена

- **`prompt()`**: позволяет с помощью диалогового окна запрашивать у пользователя какие-либо данные

- **`print()`**: отображает диалоговое окно для вывода страницы на печать

- **`find()`**: позволяет найти на странице определенный текст[^7.2]

Если штатного функционала недостаточно, то похожие пользовательские диалоги (например, для поддержки двух и более вариантов) можно сделать в виде кастомных модальных окон через DOM-создание элементов и обработчики событий, например с кнопками "Да", "Нет", "Отмена" и т.д.

### alert
Например, с помощью метода **`alert()`** по нажатию на кнопку выведем окно с сообщением:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <button id="btn">Click</button>
    <script>
        const btn = document.getElementById("btn");
        btn.addEventListener("click", ()=>{
            alert("Hello world");   // отображаем всплывающее окно при нажатии на кнопку
        });
    </script>
</body>
</html>
```

![функция alert в JavaScript](../img/browser4.png)

### confirm
Метод **`confirm()`** отображает окно с сообщением, в котором пользователь должен подтвердить действие двух кнопок OK и Отмена. В зависимости от выбора пользователя метод возвращает `true` (если пользователь нажал OK) или `false` (если пользователь нажал кнопку Отмены):
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
<button id="btn">Click</button>
<script>
const btn = document.getElementById("btn");
btn.addEventListener("click", ()=>{
    const result = confirm("Завершить выполнение программы?");
    if(result===true)
        console.log("Работа программы завершена");
    else
        console.log("Программа продолжает работать");
});
</script>
</body>
</html>
```

![Функция confirm в JavaScript](../img/confirm.png)

### prompt
Метод **`prompt()`** позволяет с помощью диалогового окна запрашивать у пользователя какие-либо данные. Данный метод возвращает введенное пользователем значение. Например, запросим на странице имя пользователя:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <button id="btn">Click</button>
    <script>
        const btn = document.getElementById("btn");
        btn.addEventListener("click", ()=>{
            const name = prompt("Введите свое имя:");
            console.log("Ваше имя: ", name)
        });
    </script>
</body>
</html>
```

Если пользователь откажется вводить значение и нажмет на кнопку отмены, то метод возвратит значение `null`.

![Функция prompt в JavaScript](../img/prompt.png)

### find
Метод **`find()`** позволяет найти на странице текст, который передает в метод через параметр. Метод возвращает `true`, если текст найден, и `false`, если текст не найден. Например:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <input id="key" name="key" />
    <button id="btn">Find</button>
    <div>
    <p>— Ах, виноват-с, Петр Николаич! Я буду тихо, — сказал секретарь и продолжал полушёпотом: — Ну-с, а закусить, душа моя Григорий Саввич, тоже нужно умеючи. Надо знать, чем закусывать. Самая лучшая закуска, ежели желаете знать, селедка. Съели вы ее кусочек с лучком и с горчичным соусом, сейчас же, благодетель мой, пока еще чувствуете в животе искры, кушайте икру саму по себе или, ежели желаете, с лимончиком, потом простой редьки с солью, потом опять селедки, но всего лучше, благодетель, рыжики соленые, ежели их изрезать мелко, как икру, и, понимаете ли, с луком, с прованским маслом... объедение! Но налимья печенка — это трагедия!</p>
    <p>— М-да... — согласился почетный мировой, жмуря глаза. — Для закуски хороши также, того... душоные белые грибы...</p>
    </div>
    <script>
        const btn = document.getElementById("btn");
        const keyField = document.getElementById("key");
        btn.addEventListener("click", ()=>{
            const result = find(keyField.value);    // ищем введенное в поле слово
            console.log(result);
        });
    </script>
</body>
</html>
```

В данном случае по нажатию на кнопку ищем на странице введенный в текстовое поле текст. Если текст найден, то он выделяется.

![Функция find и поиск на странице в JavaScript](../img/find.png)

### print
Метод **`print()`** отображает диалоговое сообщение для вывода страницы на печать:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <button id="btn">Print</button>
    <p>Hello World</p>
    <script>
        const btn = document.getElementById("btn");
        const keyField = document.getElementById("key");
        btn.addEventListener("click", ()=>{
            print();    // выводим текущую страницу на печать
        });
    </script>
</body>
</html>
```

В зависимости от браузера окно печати может выглядеть различным образом. Например, вид в Google Chrome:

![Функция print и вывод страницы на печать в JavaScript](../img/print.png)

## Открытие, закрытие и позиционирование окон

Всплывающее окно («попап» – от англ. Popup window) – один из древнейших способов показать пользователю ещё один документ.[^popup-windows]

Достаточно запустить:
```js
window.open('https://example.com/')
```

… и откроется новое окно с указанным URL. Большинство современных браузеров по умолчанию будут открывать новую вкладку вместо отдельного окна.

Попапы существуют с доисторических времён. Они были придуманы для отображения нового контента поверх открытого главного окна. Но с тех пор появились другие способы сделать это: JavaScript может загрузить содержимое вызовом `fetch` и показать его в тут же созданном `<div>`, так что попапы используются не каждый день.

Кроме того, попапы не очень хороши для мобильных устройств, которые не умеют показывать несколько окон одновременно.

Однако, для некоторых задач попапы ещё используются, например для OAuth-авторизации (вход через Google/Facebook/…), так как:

1. Попап – это отдельное окно со своим JavaScript-окружением. Так что открытие попапа со стороннего, не доверенного сайта вполне безопасно
2. Открыть попап очень просто.
3. Попап может производить навигацию (менять URL) и отсылать сообщения в основное окно.

### Блокировка попапов
В прошлом злонамеренные сайты заваливали посетителей всплывающими окнами. Такие страницы могли открывать сотни попапов с рекламой. Поэтому теперь большинство браузеров пытаются заблокировать всплывающие окна, чтобы защитить пользователя.

**Всплывающее окно блокируется в том случае, если вызов `window.open` произошёл не в результате действия посетителя (например, события `onclick`).**

Например:
```js
// попап заблокирован
window.open('https://javascript.info');

// попап будет показан
button.onclick = () => {
  window.open('https://javascript.info');
};
```

Таким образом браузеры могут защитить пользователя от появления нежелательных попапов, при этом не отключая попапы полностью.[^popup-windows]

### Открытие окон

Язык JavaScript позволят программно управлять окнами веб-браузера. Для этого объект **`window`** предоставляет ряд методов. Так, метод **`open()`** открывает определенный ресурс в новом окне или вкладке браузера. Стоит учитывать, что подобное действие лучше выполнять по действию пользователя, например, по нажатию на кнопку, потому что в ином случае браузеры могут заблокировать подобные окна. Например, определим следующую страницу:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <button onclick="openWindow()">Click</button>
    <script>
        function openWindow(){
            window.open("https://microsoft.com");
        }
    </script>
</body>
</html>
```

Здесь на веб-странице определена кнопка — элемент `button`. У кнопки установлен атрибут **`onclick`**, который указывает на функцию javascript, которая будет выполняться по нажатию этой кнопки.

В коде javascript определена функция `openWindow()`, которая выполняется по нажатию на кнопку. В этой функции выполняется функция **`window.open()`**, в которую в качестве первого параметра передается адрес — в данном случае "https://microsoft.com". И по нажатию на кнопку будет открываться в новой вкладке страницы "https://microsoft.com".

![window.open в javascript](../img/browser1.png)

Синтаксис открытия нового окна:
```js
window.open(url, name, params);
```

- `url`

    URL для загрузки в новом окне — адрес страницы (`https://example.com` или `about:blank`).

- `name`

    Имя нового окна. У каждого окна есть свойство `window.name`, в котором можно задавать, какое окно использовать для попапа. Таким образом, если уже существует окно с заданным именем – указанный в параметрах URL откроется в нем, в противном случае откроется новое окно.

    - `"_self"`, `"_blank"`, `"_parent"`, `"_top"` — специальные имена

    - *`"myWindow"`* — произвольное имя, повторное открытие в то же окно

- `params`

    Строка параметров для нового окна. Содержит настройки, разделённые запятыми. Важно помнить, что в данной строке не должно быть пробелов. Например `width=200,height=100`.

Таким образом, метод `open()` принимает ряд параметров:
```js
open();
open(url);
open(url, name);
open(url, name, params);
```

В качестве первого параметра — **`url`** передается путь к ресурсу.

Второй параметр — **`name`** передается путь к ресурсу. Распространенные значения:

- **`_self`**: страница открывается в текущей вкладке

- **`_blank`**: страница открывается в новой вкладке или в отдельном окне

Например, открытие адреса в той же вкладке:
```js
window.open("https://example.com", "_self");
```

Третий параметр позволяет установить набор стилевых характеристик окна. Каждая стилевая характеристика определяется в виде наборов `name=value`, где `name` — название стилевой характеристики, а `value` — ее значение. Друг от друга стилевые характеристики отделены запятой.

Параметры в строке `params`:

- Позиция окна (численное значение):

    Координаты верхнего левого угла нового окна на экране:
    - `left` / `screenX`: координата X относительно начала экрана в пикселях. Например, `left=0`.
    - `top` / `screenY`: координата Y относительно начала экрана в пикселях. Например, `top=0`.

    Существует ограничение: новое окно не может быть позиционировано вне видимой области экрана.

    Ширина и высота нового окна:

    - `width` / `innerWidth`: ширина окна в пикселях. Например, `width=640`.
    - `height` / `innerHeight`: высота окна в пикселях. Например, `height=480`.

    Существуют ограничения на минимальную высоту и ширину, которые делают невозможным создание невидимого окна.

- Панели окна (значения `yes`/`no`):
    - `menubar` – позволяет отобразить или скрыть меню браузера в новом окне (указывает, будет ли отображаться панель меню). Например, `menubar=yes`.
    - `toolbar` – позволяет отобразить или скрыть панель навигации браузера (кнопки вперёд, назад, перезагрузки страницы) нового окна, т.е. указывает, будет ли отображаться панель инструментов. Например, `toolbar=yes`.
    - `location` – позволяет отобразить или скрыть адресную строку нового окна (указывает, будет ли отображаться адресная строка). Например, `location=yes`. Firefox и IE не позволяют скрывать эту панель по умолчанию. 
    - `status` – позволяет отобразить или скрыть строку состояния (указывает, будет ли отображаться строка состояния). Например, `status=yes`. Как и с адресной строкой, большинство браузеров будут принудительно показывать её.
    - `resizable` – позволяет отключить возможность изменения размера нового окна. Не рекомендуется.
    - `scrollbars` – позволяет отключить полосы прокрутки для нового окна (указывает, будет ли окно иметь полосы прокрутки). Например, `scrollbars=yes`. Не рекомендуется.

    Данные параметры в качестве значений могут принимать `yes` и `no`, вместо которых также можно использовать `1` и `0` соответственно

Помимо этого существует некоторое количество не кроссбраузерных значений, которые обычно не используются. Найти примеры таких свойств можно [по ссылке](https://developer.mozilla.org/en/DOM/window.open). В частности, можно (но не рекомендуется) использовать следующие характеристики:

- `popup`: указывает, будет ли открываться страница в отдельном всплывающем окне. Для этого может принимать такие значения, как `yes`, `1` или `true`. Например:

```js
window.open("https://example.com", "_blank", "popup=yes");
```

![всплывающие окна и window.open в javascript](../img/browser2.png)

Пример применения нескольких параметров:
```js
window.open("https://example.com", "_blank", "width=600,height=400,left=500,top=200");
```

Стоит отметить, что функция возвращает ссылку на окно, и с помощью этой ссылки мы можем управлять окном.

Также стоит отметить, что через свойство **`opener`** окна можно получить ссылку на главное окно, из которого было открыто текущее.

### Пример: минималистичное окно
Давайте откроем окно с минимальным набором настроек, просто чтобы посмотреть, какие из них браузер позволит отключить:
```js
let params = `scrollbars=no,resizable=no,status=no,location=no,toolbar=no,menubar=no,
width=0,height=0,left=-1000,top=-1000`;

open('/', 'test', params);
```

В этом примере большинство настроек заблокированы и само окно находится за пределами видимой области экрана. Посмотрим, что получится в результате. Большинство браузеров «исправит» странные значения – как, например, нулевые `width`/`height` и отрицательные `left`/`top`. Например, Chrome установит высоту и ширину такого окна равной высоте и ширине экрана, так что попап будет занимать весь экран.

Давайте исправим значения и зададим нормальные координаты (`left` и `top`) и значения размеров окна (`width` и `height`):
```js
let params = `scrollbars=no,resizable=no,status=no,location=no,toolbar=no,menubar=no,
width=600,height=300,left=100,top=100`;

open('/', 'test', params);
```

Большинство браузеров выведет окно с заданными нами настройками.

Правила для опущенных параметров:

- Если третий аргумент при вызове `open` отсутствует или он пустой, будут использованы настройки окна по умолчанию.
- Если строка параметров передана, но некоторые параметры `yes`/`no` пропущены, то считается, что указано `no`, так что соответствующие возможности будут отключены, если на это нет ограничений со стороны браузера. Поэтому при задании параметров убедитесь, что вы явно указали все необходимые `yes`.
- Если координаты `left`/`top` не заданы, браузер попытается открыть новое окно рядом с предыдущим открытым окном.
- Если не заданы размеры окна `width`/`height`, браузер откроет новое окно с теми же размерами, что и предыдущее открытое окно.

### Доступ к попапу из основного окна
Вызов `open` возвращает ссылку на новое окно. Эта ссылка может быть использована для управления свойствами окна, например, изменения положения и др.

Например, здесь мы генерируем содержимое попапа из JavaScript:
```js
let newWin = window.open("about:blank", "hello", "width=200,height=200");

newWin.document.write("Hello, world!");
```

А здесь содержимое окна модифицируется после загрузки:
```js
let newWindow = open('/', 'example', 'width=300,height=300')
newWindow.focus();

alert(newWindow.location.href); // (*) about:blank, загрузка ещё не началась

newWindow.onload = function() {
  let html = `<div style="font-size:30px">Добро пожаловать!</div>`;
  newWindow.document.body.insertAdjacentHTML('afterbegin', html);
};
```

Обратите внимание: сразу после `window.open` новое окно ещё не загружено. Это демонстрируется в строке `(*)`. Так что нужно ждать `onload`, чтобы его изменить. Или же поставить обработчик `DOMContentLoaded` на `newWin.document`.

!!! warning "Политика одного источника"
    Окна имеют свободный доступ к содержимому друг друга только если они с одного источника (у них совпадают домен, протокол и порт (protocol://domain:port).

    Иначе, например, если основное окно с *site.com*, а попап с *gmail.com*, это невозможно по соображениям пользовательской безопасности. Детали изложены в разделе "Общение между окнами".[^popup-windows]

### Доступ к открывшему окну из попапа
Попап также может обратиться к открывшему его окну по ссылке `window.opener`. Она равна `null` для всех окон, кроме попапов.

Если вы запустите код ниже, то он заменит содержимое открывшего (текущего) окна на «Тест»:
```js
let newWin = window.open("about:blank", "hello", "width=200,height=200");

newWin.document.write(
  "<script>window.opener.document.body.innerHTML = 'Тест'<\/script>"
);
```

Так что связь между окнами двусторонняя: главное окно и попап имеют ссылки друг на друга.[^popup-windows]

### Закрытие окна
С помощью метода **`close()`** можно закрыть окно.

- Чтобы закрыть окно: *`win`*.**`close()`**

- Для проверки, закрыто ли окно: *`win`*.**`closed`**.

Технически метод `close()` доступен для любого окна, но `window.close()` будет игнорироваться большинством браузеров, если `window` не было создано с помощью `window.open()`. Так что он сработает только для попапов.

Если окно закрыто, то его свойство `closed` имеет значение `true`. Таким образом можно легко проверить, закрыт ли попап (или главное окно) или все ещё открыт. Пользователь может закрыть его в любой момент, и наш код должен учитывать эту возможность.

Этот код откроет и затем закроет окно:
```js
let newWindow = open('/', 'example', 'width=300,height=300');

newWindow.onload = function() {
  newWindow.close();
  alert(newWindow.closed); // true
};
```

Еще пример:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Example</title>
</head>
<body>
<button onclick="openWindow()">Open</button>
<button onclick="closeWindow()">Close</button>
<script>
let exampleWindow = null;

function openWindow(){
    if(!exampleWindow || exampleWindow.closed){  // если окно не открыто
        exampleWindow = window.open("https://example.com", "_blank", "width=600,height=400,left=500,top=200,popup=yes");
   }
}
function closeWindow(){
    exampleWindow?.close(); // если окно открыто, то закрываем его
    exampleWindow = null;
}
</script>
</body>
</html>
```

Здесь определены две кнопки для открытия и закрытия окна. Ссылка на само окно помещается в переменную `exampleWindow`, которая изначально равна `null`. По нажатию на первую кнопку вызывается функция `openWindow()`. В этой функции проверяем, что `exampleWindow` не равен `null` и что окно не закрыто (`exampleWindow.closed` не равно `false`). Вторая проверка необходима на случай, если окно будет закрыто нажатием на крестик в самом окне (в этом случае `closed=true`). И если окно не открыто, открываем его.

По нажатию на вторую кнопку у объекта `metanitWindow` вызываем метод `close` и устанавливаем переменную в `null`.

### Управление позицией и размером окна
Для управления/изменения позиции и размера окна объект `window` предоставляет ряд методов:

- *`win`*.**`moveBy(x, y)`**: перемещает данное окно браузера относительно текущей позиции по горизонтали и вертикали на указанное количество пикселей (на `x` пикселей вправо и `y` пикселей вниз). Первый параметр определяет перемещение по горизонтали, второй параметр - перемещение по вертикали в пикселях. Допустимы отрицательные значения (для перемещения окна влево и вверх).

- *`win`***`moveTo(x, y)`**: перемещает текущее окно браузера по горизонтали и вертикали в указанное положение — на координаты экрана `(x,y)`. Первый параметр определяет положение по горизонтали, второй параметр — положение по вертикали в пикселях.

- *`win`*.**`resizeBy(width, height)`**: масштабирует текущее окно браузера по горизонтали и вертикали на указанное количество пикселей. Позволяет изменить размер окна на указанные значения `width`/`height` относительно текущего размера. Первый параметр определяет значение масштабирования по горизонтали, второй параметр — значение масштабирования по вертикали. Допустимы отрицательные значения.

- *`win`*.**`resizeTo(width, height)`**: масштабирует текущее окно браузера по горизонтали и вертикали до заданного размера. Позволяет изменить размер окна до указанных значений. Первый параметр определяет ширину, второй параметр — высоту.

Также существует событие `window.onresize`.

!!! warning "Только попапы"
    Чтобы предотвратить возможные злоупотребления, браузер обычно блокирует эти методы. Они гарантированно работают только с попапами, которые мы открыли сами и у которых нет дополнительных вкладок.

Методы перемещения и изменения размера окна не работают для свернутых и развёрнутых на весь экран окон.

!!! warning "Нельзя свернуть/развернуть окно"
    Методами JavaScript нельзя свернуть или развернуть («максимизировать») окно на весь экран. За это отвечают функции уровня операционной системы, и они скрыты от фронтенд-разработчиков.

Примеры управления позицией и размерами окна:
```js
// сдвигаем окно браузера на 200 пикселей по горизонтали и на 100 пикселей по вертикали
window.moveBy(200, 100);
// Помещаем окно браузера на позицию с координатами (200, 150)
window.moveTo(200, 150);
// Увеличиваем окно браузера на 200 пиксей в ширину и 100 пикселей в высоту
window.resizeBy(200, 100);
// Сжимаем окно браузера на 200 пиксей в ширину и 100 пикселей в высоту
window.resizeBy(-200, -100);
// Прокручиваем контент окна на 100 пикселей по горизонтали и 200 пикселей по вертикали
window.scrollBy(100, 200);
// Прокручиваем содержимое браузера до позиции (100, 200)
window.scrollTo(100, 200);
```

Но стоит отметить, что на уровне браузера могут действовать ограничения на позиционирование и изменения размера окон, если окна загружают ресурсы с разных доменов.

Например, с помощью метода **`moveTo()`** переместим окно на новую позицию:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Example</title>
</head>
<body>
<button onclick="openWindow()">Open</button>
<button onclick="moveWindow()">Move</button>
<script>
let testWindow = null;

// открываем окно
function openWindow(){
    testWindow = window.open("test.html", "_blank", "width=600,height=400,left=200,top=200");
}
// сдвигаем окно
function moveWindow(){
    testWindow.moveTo(500,400);
}
</script>
</body>
</html>
```

В данном случае по нажатию на кнопку `Open` открываем окно, а по нажатию на кнопку `Move` перемещаем его на позицию с координатами `x=500, y=400` относительно левого верхнего угла экрана.[^7.7]

### Прокрутка окна
Мы уже говорили о прокрутке окна в разделе, посвященном размерам и прокрутке окна. Методы прокрутки для всплывающих окон аналогичны:

- *`win`*.**`scroll(x, y)`**: прокручивает содержимое окна до указанной позиции. Первый параметр указывает положение по горизонтали, второй параметр — положение по вертикали.

- *`win`*.**`scrollBy(x, y)`**: прокручивает содержимое окна на указанный коэффициент (на `x` пикселей вправо и `y` пикселей вниз относительно текущей прокрутки). Первый параметр определяет коэффициент прокрутки по горизонтали, второй параметр определяет коэффициент прокрутки по вертикали. Допустимы отрицательные значения.

- *`win`*.**`scrollTo(x, y)`**: прокручивает содержимое окна до указанной позиции. Позволяет прокрутить окно до заданных координат `(x,y)`. Первый параметр указывает положение по горизонтали, второй параметр — положение по вертикали.

Помимо методов окна, аналогичные методы прокрутки доступны для отдельных элементов DOM (элементов с `overflow: scroll/auto`), таких как `div`, `iframe` или контейнеры с прокруткой.

- *`elem`*.**`scrollIntoView(top = true)`**: позволяет прокрутить окно так, чтобы `elem` для `elem.scrollIntoView(false)` появился вверху (по умолчанию) или внизу.

> **Важно**: `scrollIntoView()` влияет на **окно или ближайший прокручиваемый предок**, а не сам элемент. Остальные методы прокручивают **содержимое самого элемента**.

Также существует событие `window.onscroll`.

Примеры управления прокрутой окна:
```js
window.scrollBy(100, 200);
// Прокручиваем содержимое браузера до позиции (100, 200)
window.scrollTo(100, 200);
```

`scroll()` и `scrollTo()` — это идентичные методы в JavaScript для прокрутки окна браузера (или элемента) к абсолютным координатам. Между ними нет никакой разницы по функционалу, аргументам или поведению.

Наличие двух по сути одинаковых методов обусловлено историческими причинами: `scroll()` — более старый метод, `scrollTo()` — современный стандарт.
Браузеры поддерживают оба для обратной совместимости.

Рекомендуется использовать метод `scrollTo()` как более читаемый и стандартизированный.

### Установка и потеря фокуса
Теоретически, установить попап в фокус можно с помощью метода `window.focus()`, а убрать из фокуса – с помощью `window.blur()`. Также существуют события `focus`/`blur`, которые позволяют отследить, когда фокус переводится на какое-то другое окно.

Раньше на «плохих» сайтах эти методы могли становиться средством манипуляции. Например:
```js
window.onblur = () => window.focus();
```

Когда пользователь пытается перевести фокус на другое окно, этот код возвращает фокус назад. Таким образом, фокус как бы «блокируется» в попапе, который не нужен пользователю.

Из-за этого в браузерах и появились ограничения, которые препятствуют такого рода поведению фокуса. Эти ограничения нужны для защиты пользователя от назойливой рекламы и «плохих» страниц, и их работа различается в зависимости от конкретного браузера.

Например, мобильный браузер обычно полностью игнорирует такие вызовы метода `window.focus()`. Также фокусировка не работает, когда попап открыт в отдельной вкладке (в отличие от открытия в отдельном окне).

Но всё-таки иногда методы фокусировки бывают полезны. Например:

- Когда мы открываем попап, может быть хорошей идеей запустить для него `newWindow.focus()`. Для некоторых комбинаций браузера и операционной системы это устранит неоднозначность – заметит ли пользователь это новое окно.
- Если нужно отследить, когда посетитель использует веб-приложение, можно отслеживать `window.onfocus`/`onblur`. Это позволит ставить на паузу и продолжать выполнение анимаций и других интерактивных действий на странице. При этом важно помнить, что `blur` означает, что окно больше не в фокусе, но пользователь может по-прежнему видеть его.[^popup-windows]

### Итого
Всплывающие окна используются нечасто. Ведь загрузить новую информацию можно динамически, а показать – в элементе `<div>`, расположенным над страницей (`z-index`). Ещё одна альтернатива – тег `<iframe>`.

Если мы открываем попап, хорошей практикой будет предупредить пользователя об этом. Иконка открывающегося окошка на ссылке поможет посетителю понять, что происходит и не потерять оба окна из поля зрения.

- Новое окно можно открыть с помощью вызова `open(url, name, params)`. Этот метод возвращает ссылку на это новое окно.
- По умолчанию браузеры блокируют вызовы `open`, выполненные не в результате действий пользователя. Обычно браузеры показывают предупреждение, так что пользователь всё-таки может разрешить вызов этого метода.
- Вместо попапа открывается вкладка, если в вызове `open` не указаны его размеры.
- У попапа есть доступ к породившему его окну через свойство `window.opener`.
- Если основное окно и попап имеют один домен и протокол, то они свободно могут читать и изменять друг друга. В противном случае, они могут только изменять положение друг друга и взаимодействовать с помощью сообщений.

Чтобы закрыть попап: метод `close()`. Также попап может закрыть и пользователь (как и любое другое окно). После закрытия окна свойство `window.closed` имеет значение `true`.

- Методы `focus()` и `blur()` позволяют установить или убрать фокус с попапа. Но работают не всегда.
- События `focus` и `blur` позволяют отследить получение и потерю фокуса новым окном. Но, пожалуйста, не забывайте, что окно может остаться видимым и после `blur`.[^popup-windows]

## История браузера. History API
При навигации между страницами браузер сохраняет всю историю о переходах в специальном стеке, который называется **history stack**. И каждый раз, когда браузер загружает новую веб-страницу или переходит по ссылке на веб-странице, браузер по умолчанию создает новую запись в истории просмотров. В коде JavaScript историю можно получить через свойство **`history`** объекта `window`. Данное свойство представляет тип **`History`**.[^7.3]

Объект **`History`** для взаимодействия с историей просмотров предоставляет ряд методов и свойств:

- Свойство **`length`** возвращает количество записей в истории просмотров

    ```js
    console.log("В истории ", history.length, " записей");
    ```

- Свойство **`state`** возвращает текущую запись из истории просмотров. По умолчанию при загрузке первой страницы в браузере это свойство равно `null`

    ```js
    console.log(history.state);
    ```

- Метод **`back()`** переходит к прошлой записи в истории просмотров, аналогично нажатию на кнопку Назад/Back в браузере

    ```js
    history.back(); // перемещение назад к прошлой странице
    ```

- Метод **`forward()`** переходит к следующей просмотренной странице, аналогично нажатию на кнопку Вперед/Next в браузере

    ```js
    history.forward(); // перемещение вперед к следующей странице
    ```

- Метод **`go()`** позволяет перемещаться вперед и назад по истории на определенное число страниц. Методу передается приращение, начиная с текущей веб-страницы. Например, значение -1 приводит к открытию предыдущей веб-страницы, а значение 1 вызывает открытие следующей веб-страницы. Если передается значение, для которого в истории нет соответствующей веб-страницы, этот метод ничего не делает. Если же метод вызывается без значения или со значением 0, текущая веб-страница перезагружается

    ```js
    history.go(-2);     // переход на 2 страницы назад
    history.go(2);      // переход на 2 страницы вперед
    history.go(0);      // перезагружаем текущую страницу
    ```

- Метод **`pushState()`** программно добавляет новую запись в историю просмотров. Он принимает три параметра:

    ```js
    history.pushState(state, title[, url])
    ```

  - Параметр `state` представляет добавляемый объект в историю просмотров. В качестве такого объекта состояния может быть чем угодно

  - Параметр `title` устанавливает заголовок. Стоит отметить, что браузеры могут игнорировать этот параметр

  - Параметр `url` представляет URL-адрес новой записи в истории. Является необязательным. Однако если используется, этот адрес url в этом параметре должен относиться к тому же домену, что и текущая страница. Браузер может устанавливать этот адрес в качестве текущего.

    Простейший пример
    ```js
    const state = { url: "/", title: "Home", description: "Home Page" };
    // history.pushState(state, state.title);               // без url
    history.pushState(state, state.title, state.url);       // с url
    console.log(state);  // {url: "/", title: "Home", description: "Home Page"}
    ```

- Метод **`replaceState()`** программно заменяет текущую запись в истории просмотров на новую. Он принимает те же три параметра:

    ```js
    history.replaceState(state, title, [url])
    ```

    Простейший пример
    ```js
    const state = { url: "home", title: "Home", decription: "Home Page" };
    history.replaceState(state, state.title, state.url);
    ```

### Событие popstate
Каждый раз, когда текущая запись в истории посещений меняется (например, при нажатии на кнопку "Назад" в браузере), срабатывает событие **`popstate`**. Соответственно если мы хотим обрабатывать перемещение по истории просмотров с помощью кнопок браузера Назад/Вперед, то нам надо обрабатывать данное событие.

Для обработки события **`popstate`** в обработчик события передается объект события типа **`PopStateEvent`**. В этом объекте свойство `state` указывает на запись, удаленную из истории просмотров:
```js
window.addEventListener("popstate", (event) => {
    console.log(event.state);       // получаем старое состояние
});
```

### Перемещение по одностраничному сайту

#### Наивная реализация
В качестве отправной точки можно использовать hash-based навигацию, позволяющую реализовать простейшую навигацию для одностраничного приложения. Определим простейший одностраничный сайт в виде следующей веб-страницы ***index.html***:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>SPA</title>
</head>
<body>
<nav><a href="#home">Home</a> | <a href="#about">About</a> | <a href="#contacts">Contacts</a></nav>
<h1 id="content"></h1>
<script>
// Контейнер, в который загружаем контент
const contentElement = document.getElementById("content");
// Объект, который содержит содержимое для различных страниц
const pages = {
    home: { content: "Home Page", url: "#home"},
    about: { content: "About Page", url: "#about"  },
    contacts: { content: "Contact Page", url: "#contacts"}
};
// Обработчик нажатия на ссылки
function handleClick(event){
    // получаем адрес перехода
    const url = event.target.getAttribute("href");
    // получаем имя страницы, которая совпадает с адресом перехода
    const pageName = url.split("#").pop();
    // получаем страницу из объекта pages
    const page = pages[pageName];

    contentElement.textContent = page.content;
}
const links = document.getElementsByTagName("a");
for (let i = 0; i < links.length; i++) {
    links[i].addEventListener("click", handleClick, true);
}
// по умолчанию загружаем Home Page
contentElement.textContent = pages.home.content;
</script>
</body>
</html>
```

Итак, изначально на странице у нас три ссылки, нажимая на которые, мы будем переходить на условные страницы:
```html
<nav><a href="#home">Home</a> | <a href="#about">About</a> | <a href="#contacts">Contacts</a></nav>
```

Для простоты предположим, что контекст условных страниц будет состоять из одного заголовка и будет загружаться в соответствующий элемент на странице:
```html
<h1 id="content"></h1>
```

В коде JavaScript мы будем ссылаться на этот элемент через константу `contentElement`

В коде JavaScript определяем код условных страниц в виде объекта pages:
```js
const pages = {
    home: { content: "Home Page", url: "#home" },
    about: { content: "About Page", url: "#about" },
    contacts: { content: "Contact Page", url: "#contacts" }
};
```

Каждый объект однотипен: содержит свойство `content`, которое представляет содержимое условной страницы, и свойство `url` — адрес страницы. Но тут важная условность — для простоты названия этих страниц — `home`/`about`/`contacts` совпадают с адресами ссылок. Можно было бы отвязать названия, но это привело бы к увеличению логики в сугубо демонстрационном примере.

Для обработки нажатия ссылок определяется функция `handleClick`, в которую передается объект события. И из этого объекта события через `event.target` мы можем получить нажатую ссылку и ее данные. Так, в начале получаем адрес ссылки и название страницы (которое равно адресу без начального слеша):
```js
// получаем адрес перехода
const url = event.target.getAttribute("href");
// получаем имя страницы, которая совпадает с адресом перехода
const pageName = url.split("#").pop();
// получаем страницу из объекта pages
const page = pages[pageName];
```

Получив нужную страницу, смотрим, какая ссылка нажата. При запросе адреса устанавливаем в качестве заголовка содержимое (свойство `content`) текущей страницы:
```js
contentElement.textContent = page.content;
```

Данное наивное решение хотя и отличается простотой реализации, но в то же время имеет несколько существенных недостатков. Основные проблемы:

1. **Кнопки браузера сломаны**: при навигации по кнопкам происходит смена URL, но содержимое страницы никак не меняется.

    Home → About → "Назад" → [остается About, должно быть Home]

    **Причина**: Нет `hashchange` обработчика для восстановления состояния.

    2. **Нет автоматического роутинга**

    Прямая ссылка site.com/#about → всегда показывает Home

    **Причина**: JS не реагирует на изменения хэша из адресной строки.

3. **`event.preventDefault()` отсутствует**

    ```js
    function handleClick(event){
        // ❌ Браузер прыгает к якорю #home!
        contentElement.textContent = page.content;
        // return event.preventDefault(); ← ОТСУТСТВУЕТ
    }
    ```

    **Результат**: страница дёргается к несуществующим якорям.

4. **Уродливые URL** (`#about`)

   - ❌ `site.com/#about` — выглядит как якорь, не страница
   - ❌ Плохо для SEO
   - ❌ Неловко для шаринга

5. **Нет обработки <kbd>F5</kbd>/прямых ссылок**

   1. Пользователь: "Посмотри #about"
   2. Друг открывает → видит Home 😞

#### Исправленная версия

Для исправления необходимо внести следующие минимальные дополнения:
```js
// ✅ 1. preventDefault()
function handleClick(event){
    event.preventDefault(); // ОСТАВЛЯЕМ!
    const pageName = event.target.href.split("#").pop();
    contentElement.textContent = pages[pageName].content;
}

// ✅ 2. hashchange для кнопок браузера
window.addEventListener('hashchange', () => {
    const pageName = location.hash.split("#").pop() || 'home';
    contentElement.textContent = pages[pageName]?.content || pages.home.content;
});

// ✅ 3. Инициализация по текущему хэшу
const pageName = location.hash.split("#").pop() || 'home';
contentElement.textContent = pages[pageName]?.content || pages.home.content;
```

Для удобства лучше написать отдельную универсальную функцию маршрутизации:
```js
function route() {
    const pageName = location.hash.slice(1) || 'home';
    const page = pages[pageName] || pages.home;
    contentElement.textContent = page.content;
}
```

В качестве примера применения History API определим простейший одностраничный сайт в виде следующей веб-страницы ***index.html***:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
<nav><a href="#home">Home</a> | <a href="#about">About</a> | <a href="#contacts">Contacts</a></nav>
<h1 id="content"></h1>
<script>
// Контейнер, в который загружаем контент
const contentElement = document.getElementById("content");
// Объект, который содержит содержимое для различных страниц
const pages = {
    home: { content: "Home Page", url: "#home"},
    about: { content: "About Page", url: "#about"  },
    contacts: { content: "Contact Page", url: "#contacts"}
};
// Обработчик нажатия на ссылки
function handleClick(event){
    // получаем адрес перехода
    const url = event.target.getAttribute("href");
    // получаем имя страницы, которая совпадает с адресом перехода
    const pageName = url.split("#").pop();
    // получаем страницу из объекта pages
    const page = pages[pageName];
    // если текущий адрес совпадает с запрошенным, то игнорируем переход
    if(history.state.url != url) {
        contentElement.textContent = page.content;
        // добавляем в историю
        history.pushState(page,  // объект state
            event.target.textContent,   // Title
            event.target.href           // URL
        );
        document.title = event.target.textContent; // если браузер не устанавливает заголовок
    }
    return event.preventDefault();
}
// устанавливаем обработчик для извлечения состояния в History API
window.addEventListener("popstate", (event) => {
    if(event.state)       // если  есть состояние
        contentElement.textContent = event.state.content;   // получаем старое состояние
});
// устанавливаем обработчик нажатия для кнопок
const links = document.getElementsByTagName("a");
for (let i = 0; i < links.length; i++) {
    links[i].addEventListener("click", handleClick, true);
}
// по умолчанию загружаем Home Page
contentElement.textContent = pages.home.content;
history.pushState(pages.home, "Home", pages.home.url);
</script>
</body>
</html>
```

Итак, изначально на странице у нас три ссылки, нажимая на которые, мы будем переходить на условные страницы:
```html
<nav><a href="#home">Home</a> | <a href="#about">About</a> | <a href="#contacts">Contacts</a></nav>
```

Для простоты предположим, что контекст условных страниц будет состоять из одного заголовка и будет загружаться в соответствующий элемент на странице:
```html
<h1 id="content"></h1>
```

В коде JavaScript мы будем ссылаться на этот элемент через константу `contentElement`

В коде JavaScript определяем код условных страниц в виде объекта pages:
```js
const pages = {
    home: { content: "Home Page", url: "#home" },
    about: { content: "About Page", url: "#about" },
    contacts: { content: "Contact Page", url: "#contacts" }
};
```

Каждый объект однотипен: содержит свойство `content`, которое представляет содержимое условной страницы, и свойство `url` — адрес страницы. Собственно состояние `history.state` будет представлять один из этих объектов. Но тут важная условность — для простоты названия этих страниц — `home`/`about`/`contacts` совпадают с адресами ссылок. Можно было бы отвязать названия, но это привело бы к увеличению логики в сугубо демонстрационном примере.

Для обработки нажатия ссылок определяется функция `handleClick`, в которую передается объект события. И из этого объекта события через `event.target` мы можем получить нажатую ссылку и ее данные. Так, в начале получаем адрес ссылки и название страницы (которое равно адресу без начального слеша):
```js
// получаем адрес перехода
const url = event.target.getAttribute("href");
// получаем имя страницы, которая совпадает с адресом перехода
const pageName = url.split("#").pop();
// получаем страницу из объекта pages
const page = pages[pageName];
```

Получив нужную страницу, смотрим, какая ссылка нажата. Например, мы не хотим, чтобы находясь на определенной странице, пользователь заново загружал данные этой страницы, повторно нажимая на одну и ту же ссылку. И для этой цели берем в истории просмотров текущее состояние и проверяем его свойство `url`. Если текущее состояние (по сути текущая страница) имеет тот же адрес `url`, который запрошен, то нет смысла заново перезагружать содержимое страницы:
```js
if(history.state.url != url) {
```

Если запрошен адрес, отличный от текущего, то устанавливаем в качестве заголовка содержимое (свойство `content`) текущей страницы и добавляем запись в историю просмотров:
```js
contentElement.textContent = page.content;
// добавляем в историю
history.pushState(page,  // объект state
    event.target.textContent,   // Title
    event.target.href           // URL
);
document.title = event.target.textContent; // если браузер не устанавливает заголовок
```

Поскольку браузеры могут не устанавливать автоматически заголовок, то устанавливаем его вручную с помощью свойства `document.title`. Таким образом, в истории просмотров появится запись о переходе по ссылке.

Следует отметить, что в реальном приложении, как правило, подобные условные страницы определяются в отдельных файлах и подгружаются через AJAX.

Для обработки переходов с помощью кнопок браузера Назад/Вперед устанавливаем обработчик для события `popstate`:
```js
window.addEventListener("popstate", (event) => {
    if(event.state)       // если  есть состояние
        contentElement.textContent = event.state.content;   // получаем старое состояние
});
```

Здесь получаем извлеченное состояние из истории просмотров (`event.state`) и с помощью его свойства `content` устанавливаем содержимое заголовка.

В конце устанавливаем обработчик нажатия для кнопок:
```js
const links = document.getElementsByTagName("a");
for (let i = 0; i < links.length; i++) {
    links[i].addEventListener("click", handleClick, true);
}
```

И по умолчанию устанавливаем в качестве текущей условной страницы объект `home` из объекта `pages`, добавляя при этом соответствующую запись в историю просмотров:
```js
contentElement.textContent = pages.home.content;
history.pushState(pages.home, "Home", pages.home.url);
```

Кинем веб-страницу в браузер и мы сможем переходить по ссылкам как по отдельным страницам:

![Хранение состояния страниц в History API в JavaScript](../img/history1.png)

History API используется здесь для создания плавной одностраничной навигации (SPA-подобного опыта) без перезагрузки страницы. Маршруты не запишутся автоматически при `preventDefault()`, так как код перехватывает клики по ссылкам и блокирует стандартное поведение браузера.

Код вручную управляет историей браузера через `history.pushState()` по нескольным причинам:

- **Предотвращение стандартной навигации**: `event.preventDefault()` в `handleClick()` блокирует переход по `href="#"`, иначе страница просто прыгала бы к якорям без смены контента.

- **Ручное обновление контента**: Вместо загрузки новой страницы код динамически меняет `textContent` элемента `#content` на нужный текст из объекта `pages`.

- **Поддержка кнопки "Назад"**: Без `pushState()` при нажатии "Назад"/"Вперед" или по `popstate` контент не восстановится — обработчик `popstate` берет данные из `event.state.content`, который сохраняется вручную.

Также вместо символов хеша `#` для опредения ссылки (то есть индентификаторов фрагмента) также можно использовать слеши `/`, что, к примеру, будет лучше для индексации страницы поисковиками. Так, пример выше мы можем переписать следующим образом:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <nav><a href="/home">Home</a> | <a href="/about">About</a> | <a href="/contacts">Contacts</a></nav>
    <h1 id="content"></h1>
    <script>
        // Контейнер, в который загружаем контент
        const contentElement = document.getElementById("content");
        // Объект, который содержит содержимое для различных страниц
        const pages = {
            home: { content: "Home Page", url: "/home" },
            about: { content: "About Page", url: "/about" },
            contacts: { content: "Contact Page", url: "/contacts" }
        };
        // Обработчик нажатия на ссылки
        function handleClick(event){
            // получаем адрес перехода
            const url = event.target.getAttribute("href");
            // получаем имя страницы, которая совпадает с адресом перехода
            const pageName = url.split("/").pop();
            // получаем страницу из объекта pages
            const page = pages[pageName];
            // если текущий адрес совпадает с запрошенным, то игнорируем переход
            if(history.state.url != url) {
                contentElement.textContent = page.content;
                // добавляем в историю
                history.pushState(page,  // объект state
                    event.target.textContent,   // Title
                    event.target.href           // URL
                );
                document.title = event.target.textContent; // если браузер не устанавливает заголовок
            }
            return event.preventDefault();
        }
        // устанавливаем обработчик для извлечения состояния в History API
        window.addEventListener("popstate", (event) => {
            if(event.state)       // если  есть состояние
                contentElement.textContent = event.state.content;   // получаем старое состояние
        });
        // устанавливаем обработчик нажатия для кнопок
        const links = document.getElementsByTagName("a");
        for (let i = 0; i < links.length; i++) {
            links[i].addEventListener("click", handleClick, true);
        }
        // по умолчанию загружаем Home Page
        contentElement.textContent = pages.home.content;
        history.pushState(pages.home, "Home", pages.home.url);
    </script>
</body>
</html>
```

Но в этом случае страница должна располагаться на веб-сервере:

![History API в JavaScript](../img/history2.png)

## Объект location
Объект **`location`** содержит информацию о расположении текущей веб-страницы: URL, информацию о сервере, номер порта, протокол. С помощью свойств объекта мы можем получить эту информацию:[^7.4]

- **`href`**: полный адрес URL веб-страницы

- **`origin`**: общая схема запроса

- **`protocol`**: протокол (включая двоеточие), например, `http:` или `https:`

- **`host`**: хост, например, `localhost.com`. Если адрес URL содержит номер порта, то порт также входит в хост, например, `localhost.com:8080`

- **`hostname`**: домен, аналогичен хосту, только не включает порт, например, `localhost.com`

- **`port`**: порт, используемый ресурсом

- **`pathname`**: путь к ресурсу — та часть адреса, которая идет после хоста после слеша /

- **`hash`**: идентификатор фрагмента — та часть адреса, которая идет после символа решетки `#` (при его наличии)

- **`search`**: строка запроса — та часть адреса, которая идет после знака вопроса `?` (при его наличии)

- **`username`**: имя пользователя, которое указано в адресе. Например, в адресе https://tom:qwerty5@localhost.com это подстрока "tom"

- **`password`**: пароль, который указан в адресе. Например, в адресе «https://tom:qwerty5@localhost.com это подстрока "qwerty5"

В общем случае формат адреса URL выглядит следующим образом:
```
protocol//username:password@hostname:port/path?search#hash
```

Например, пусть есть следующая веб-страница *index.html*:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
  <title>DevPM</title>
</head>
<body>
<script>
    console.log("href:", location.href);
    console.log("path:", location.pathname);
    console.log("origin:", location.origin);
    console.log("protocol:", location.protocol);
    console.log("port:", location.port);
    console.log("host:", location.host);
    console.log("hostname", location.hostname);
    console.log("hash:", location.hash);
    console.log("search:", location.search);
</script>
</body>
</html>
```

Пусть она лежит на локальном веб-сервере, и к ней мы обращаемся с помощью адреса http://localhost:8080/index.html?name=tom&age=39#userinfo:

![Объект location в JavaScript](../img/location.png)

### Управление адресом
Также объект `location` предоставляет ряд методов, которые можно использовать для управления адресом веб-страницы:

- **`assign(url)`**: загружает ресурс, который находится по пути `url`

- **`reload(forcedReload)`**: перезагружает текущую веб-страницу. Параметр `forcedReload` указывает, надо ли использовать кэш браузера. Если параметр равен `true`, то кэш не используется

- **`replace(url)`**: заменяет текущую веб-станицу другим ресурсом, который находится по пути `url`. В отличие от метода `assign`, который также загружает веб-станицу с другого ресурса, метод `replace` не сохраняет предыдущую веб-страницу в стеке истории переходов `history`, поэтому мы не сможем вызвать метод `history.back()` для перехода к ней.

Для перенаправления на другой ресурс мы можем использовать как свойства, так и методы `location`:
```js
location = "http://google.com";
// аналогично
// location.href = "http://google.com";
// location.assign("http://google.com");
```

Переход на другой локальный ресурс:
```js
location.replace("index.html");
```

Например, выполним переход на странице по нажатию на кнопку:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <input type="url" id="url" />
    <button id="btn">Click</button>
    <script>
        const btn = document.getElementById("btn");
        btn.addEventListener("click", () => {
            const url = document.getElementById("url").value;
            location.assign(url);
        });
    </script>
</body>
</html>
```

Здесь по нажатию на кнопку выполняется переход по адресу, который введен в текстовое поле `url`.

Переход с помощью метода **`replace()`** производится аналогично:
```js
const btn = document.getElementById("btn");
btn.addEventListener("click", () => {
    const url = document.getElementById("url").value;
    location.replace(url);
});
```

Перезагрузка страницы:
```js
const btn = document.getElementById("btn");
btn.addEventListener("click", () => {
    const url = document.getElementById("url").value;
    location.reload(true);
});
```

## Объект navigator
С помощью свойства **`navigator`** объекта `window` можно получить информацию о браузере и операционной системе, в которой браузер запущен. Это свойство представляет объект типа **`Navigator`**, которое определяет ряд свойств и методов. Основные свойства:

- **`appCodeName`**: содержит внутреннее кодовое имя текущего браузера (не стоит полагаться на это свойство, так как обычно оно возвращает Mozilla).

- **`appName`**: содержит официальное имя текущего браузера (ненадежно, поскольку каждый браузер выводит значение Netscape).

- **`appVersion`**: содержит номер версии текущего браузера (ненадежно).

- **`battery`**: представляет объект типа `BatteryManager`, который позволяет применять Battery Status API для взаимодействия со статусом батареи.

- **`cookieEnabled`**: содержит информацию о том, включены файлы cookie или нет.

- **`geolocation`**: представляет объект типа `Geolocation`, который позволяет применять Geolocation API для работы с геолокацией.

- **`language`**: содержит строку, указывающую предпочтительный язык пользователя. Обычно этот язык также используется в интерфейсе соответствующего браузера. Если предпочтительный язык не может быть определен, это свойство содержит значение `null`.

- **`languages`**: содержит список строк, указывающих предпочтительные языки пользователя, причем наиболее предпочтительный язык находится в первой позиции (что соответствует языку из свойства `language`).

- **`mimeTypes`**: содержит список типов MIME, поддерживаемых браузером.

- **`onLine`**: логическое значение, указывающее, подключен ли браузер к интернету или нет.

- **`platform`**: содержит информацию об используемой операционной системе (ненадежно).

- **`plugins`**: содержит список плагинов, поддерживаемых браузером.

- **`product`**: содержит название продукта текущего браузера. Однако в целях обратной совместимости в каждом браузере возвращается значение `Gecko`.

- **`productSub`**: содержит вложенную метку текущего браузера (20030107 или 20100101).

- **`serviceWorker`**: представляет объект `ServiceWorkerContainer`, который позволяет работать с API Service Worker.

- **`userAgent`**: содержит строку, идентифицирующую используемый браузер (тоже ненадежно).

- **`vendor`**: содержит информацию о производителе браузера (одно из значений "Apple Computer, Inc.", "Google Inc." или пустая строка).

- **`vendorSub`**: предназначен для получения дополнительной информации о производителе браузера, но всегда содержит пустую строку.

Стоит отметить, что объект `Navigator` имеет кучу свойств для определения типа браузера, однако ни одно из них нельзя считать надежным. Если раньше нередко применялось свойство `userAgent` для идентификации браузера, то теперь это свойство для двух разных браузеров может возвращать одинаковые значения. Поэтому также не может считаться надежным.[^7.5]

Применение некоторых свойств на примере браузера Google Chrome на платформе MacOS Intel х86-64:
```js
console.log(navigator.appCodeName); // Mozilla
console.log(navigator.appName);     // Netscape
console.log(navigator.appVersion);  // 5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36
console.log(navigator.product);     // Gecko
console.log(navigator.productSub);  // 20030107
console.log(navigator.vendor);      // Google Inc.
console.log(navigator.vendorSub);   // [ пустая строка ]
console.log(navigator.userAgent);   // Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/118.0.0.0 Safari/537.36
console.log(navigator.platform);    // MacIntel
console.log(navigator.languages);   // список поддерживаемых языков
console.log(navigator.plugins);     // список поддерживаемых плагинов
```

## Планирование вызовов
Мы можем вызвать функцию не в данный момент, а позже, через заданный интервал времени. Это называется «планирование вызова».

Для выполнения действий через определенные промежутки времени в объекте **`window`** предусмотрены функции таймеров. Есть два типа таймеров: одни выполняются только один раз, а другие постоянно через промежуток времени.[^7.6]

Для этого существуют два метода:

- `setTimeout` позволяет вызвать функцию один раз через определённый интервал времени.
- `setInterval` позволяет вызывать функцию регулярно, повторяя вызов через определённый интервал времени.

Эти методы не являются частью спецификации JavaScript. Но большинство сред выполнения JS-кода имеют внутренний планировщик и предоставляют доступ к этим методам. В частности, они поддерживаются во всех браузерах и Node.js.[^settimeout-setinterval]

### Функция setTimeout
Для одноразового выполнения действий через промежуток времени предназначена функция **`setTimeout()`**. Она может принимать два параметра:
```js
const timerId = setTimeout(someFunction, period)
```

Параметр `period` указывает на период в миллисекундах, через который будет выполняться функция из параметра `someFunction`. А в качестве результата функция возвращает `id` таймера.

```js
function printMessage() { console.log("Hello world");}
setTimeout(printMessage, 5000);
```

В данном случае через 5 секунд после загрузки страницы произойдет срабатывание функции `printMessage`.

Для остановки таймера применяется функция **`clearTimeout()`**, в которую передается `id` таймера:
```js
function printMessage() { console.log("Hello world");}
const timerId = setTimeout(printMessage, 5000);
clearTimeout(timerId);
```

#### Параметры таймера

Полный синтаксис:
```js
let timerId = setTimeout(func|code, [delay], [arg1], [arg2], ...);
```

Параметры:

- `func`|`code`

    Функция или строка кода для выполнения. Обычно это функция. По историческим причинам можно передать и строку кода, но это не рекомендуется.

- `delay`

    Задержка перед запуском в миллисекундах (1000 мс = 1 с). Значение по умолчанию – `0`.

- `arg1`, `arg2`…

    Аргументы, передаваемые в функцию

Например, данный код вызывает `sayHi()` спустя одну секунду:
```js
function sayHi() {
  alert('Привет');
}

setTimeout(sayHi, 1000);
```

С аргументами:
```js
function sayHi(phrase, who) {
  alert( phrase + ', ' + who );
}

setTimeout(sayHi, 1000, "Привет", "Джон"); // Привет, Джон
```

Если первый аргумент является строкой, то JavaScript создаст из неё функцию.

Это также будет работать:
```js
setTimeout("alert('Привет')", 1000);
```

Но использование строк не рекомендуется. Вместо этого используйте функции. Например, так:
```js
setTimeout(() => alert('Привет'), 1000);
```

!!! info "Передавайте функцию, но не запускайте её"
    Начинающие разработчики иногда ошибаются, добавляя скобки `()` после функции:
    ```js
    // неправильно!
    setTimeout(sayHi(), 1000);
    ```

    Это не работает, потому что `setTimeout` ожидает ссылку на функцию. Здесь `sayHi()` запускает выполнение функции, и результат выполнения отправляется в `setTimeout`. В нашем случае результатом выполнения `sayHi()` является `undefined` (так как функция ничего не возвращает), поэтому ничего не планируется.

#### Отмена через clearTimeout
Вызов `setTimeout` возвращает «идентификатор таймера» `timerId`, который можно использовать для отмены дальнейшего выполнения.

Синтаксис для отмены:
```js
let timerId = setTimeout(...);
clearTimeout(timerId);
```

В коде ниже планируем вызов функции и затем отменяем его (просто передумали). В результате ничего не происходит:
```js
let timerId = setTimeout(() => alert("ничего не происходит"), 1000);
alert(timerId); // идентификатор таймера

clearTimeout(timerId);
alert(timerId); // тот же идентификатор (не принимает значение null после отмены)
```

Как мы видим из вывода `alert`, в браузере идентификатором таймера является число. В других средах это может быть что-то ещё. Например, Node.js возвращает объект таймера с дополнительными методами.

Повторим, что нет единой спецификации на эти методы, поэтому такое поведение является нормальным.

Для браузеров таймеры описаны в [разделе таймеров](https://www.w3.org/TR/html5/webappapis.html#timers) стандарта HTML5.

### Функция setInterval
Функции **`setInterval()`** и **`clearInterval()`** работают аналогично функциям `setTimeout()` и `clearTimeout()` с той лишь разницей, что **`setInterval()`** постоянно выполняет определенную функцию через промежуток времени.

Метод `setInterval` имеет такой же синтаксис как `setTimeout`:
```js
let timerId = setInterval(func|code, [delay], [arg1], [arg2], ...);
```

Все аргументы имеют такое же значение. Но отличие этого метода от `setTimeout` в том, что функция запускается не один раз, а периодически через указанный интервал времени.[^settimeout-setinterval]

Например, напишем небольшую программу для вывода текущего времени:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <div id="timer"></div>
    <script>
        const timer = document.getElementById("timer");
        function updateTime() {
            const now = new Date();
            timer.textContent = `${now.getHours()}:${now.getMinutes()}:${now.getSeconds()}`;
        }
        setInterval(updateTime, 1000);
    </script>
</body>
</html>
```

Здесь через каждую секунду (1000 миллисекунд) вызывается функция `updateTime()`, которая обновляет содержимое поля `<div id="timer">`, устанавливая в качестве его текста текущее время.

Чтобы остановить дальнейшее выполнение функции, необходимо вызвать `clearInterval(timerId)`.

Следующий пример выводит сообщение каждые 2 секунды. Через 5 секунд вывод прекращается:
```js
// повторить с интервалом 2 секунды
let timerId = setInterval(() => alert('tick'), 2000);

// остановить вывод через 5 секунд
setTimeout(() => { clearInterval(timerId); alert('stop'); }, 5000);
```

!!! info "Во время показа `alert` время тоже идёт"
    В большинстве браузеров, включая Chrome и Firefox, внутренний счётчик продолжает тикать во время показа `alert`/`confirm`/`prompt`. Дело в том, что функции `alert()`, `confirm()` и `prompt()` замораживают только интерфейс (мышь, клавиатура, прокрутка), но не останавливают JavaScript и таймеры. Поэтому `setInterval` продолжает считать время фоном.

    Так что если запустить код выше и подождать с закрытием `alert` 2 секунды и более, то следующий `alert` будет показан сразу, как только будет закрыт предыдущий. Интервал времени между сообщениями `alert` будет короче, чем 2 секунды.

    **Отсюда правило**: никогда не использовать `alert`/`confirm`/`prompt` в production-коде с таймерами. Лучше заменить на `<dialog>` или кастомные модалки.

**Альтернативы блокирующим диалогам**:

1. Современные модальные окна

    ```js
    // Не блокирует таймеры!
    showModal('Сообщение');
    setInterval(tick, 1000); // Работает нормально
    ```

2. Остановка таймера вручную

    ```js
    function safeAlert(msg, intervalId) {
    clearInterval(intervalId);
    alert(msg);
    // Перезапуск после закрытия
    setTimeout(() => {
        intervalId = setInterval(tick, 1000);
    }, 100);
    }
    ```

3. `requestAnimationFrame` вместо интервала

    ```js
    let lastTime = 0;
    function tick(currentTime) {
    if (currentTime - lastTime >= 2000) {
        alert('Тик!');
        lastTime = currentTime;
    }
    requestAnimationFrame(tick);
    }
    ```

### Вложенный setTimeout
Есть два способа запускать что-то регулярно.

Один из них `setInterval`. Другим является вложенный `setTimeout`. Например:
```js
/** вместо:
let timerId = setInterval(() => alert('tick'), 2000);
*/

let timerId = setTimeout(function tick() {
  alert('tick');
  timerId = setTimeout(tick, 2000); // (*)
}, 2000);
```

Метод `setTimeout` выше планирует следующий вызов прямо после окончания текущего `(*)`.

Вложенный `setTimeout` – более гибкий метод, чем `setInterval`. С его помощью последующий вызов может быть задан по-разному в зависимости от результатов предыдущего.

Например, необходимо написать сервис, который отправляет запрос для получения данных на сервер каждые 5 секунд, но если сервер перегружен, то необходимо увеличить интервал запросов до 10, 20, 40 секунд… Вот псевдокод:
```js
let delay = 5000;

let timerId = setTimeout(function request() {
  ...отправить запрос...

  if (ошибка запроса из-за перегрузки сервера) {
    // увеличить интервал для следующего запроса
    delay *= 2;
  }

  timerId = setTimeout(request, delay);

}, delay);
```

А если функции, которые мы планируем, ресурсоёмкие и требуют времени, то мы можем измерить время, затраченное на выполнение, и спланировать следующий вызов раньше или позже.

**Вложенный `setTimeout` позволяет задать задержку между выполнениями более точно, чем `setInterval`.**

Сравним два фрагмента кода. Первый использует `setInterval`:
```js
let i = 1;
setInterval(function() {
  func(i);
}, 100);
```

Второй использует вложенный `setTimeout`:
```js
let i = 1;
setTimeout(function run() {
  func(i);
  setTimeout(run, 100);
}, 100);
```

Для `setInterval` внутренний планировщик будет выполнять `func(i)` каждые 100 мс:

![SetInterval interval](../svg/setinterval-interval.svg)

Обратили внимание?

**Реальная задержка между вызовами `func` с помощью `setInterval` меньше, чем указано в коде!**

Это нормально, потому что время, затраченное на выполнение `func`, использует часть заданного интервала времени.

Вполне возможно, что выполнение `func` будет дольше, чем мы ожидали, и займёт более 100 мс.

В данном случае движок ждёт окончания выполнения `func` и затем проверяет планировщик и, если время истекло, немедленно запускает его снова.

В крайнем случае, если функция всегда выполняется дольше, чем задержка `delay`, то вызовы будут выполняться без задержек вообще.

Ниже представлено изображение, показывающее процесс работы рекурсивного `setTimeout`:

![SetTimeout interval](../svg/settimeout-interval.svg)

**Вложенный `setTimeout` гарантирует фиксированную задержку (здесь 100 мс).**

Это потому, что новый вызов планируется в конце предыдущего.

!!! info "Сборка мусора и колбэк `setTimeout`/`setInterval`"

    Когда функция передаётся в `setInterval`/`setTimeout`, на неё создаётся внутренняя ссылка и сохраняется в планировщике. Это предотвращает попадание функции в сборщик мусора, даже если на неё нет других ссылок.

    ```js
    // функция остаётся в памяти до тех пор, пока планировщик обращается к ней
    setTimeout(function() {...}, 100);
    ```

    Для `setInterval` функция остаётся в памяти до тех пор, пока не будет вызван `clearInterval`.

    Есть и побочный эффект. Функция ссылается на внешнее лексическое окружение, поэтому пока она существует, внешние переменные существуют тоже. Они могут занимать больше памяти, чем сама функция. Поэтому, если регулярный вызов функции больше не нужен, то лучше отменить его, даже если функция очень маленькая.

### Утечки памяти

Как работает удержание в памяти:
```js
function createTimer() {
  let bigData = new Array(1000000).fill('heavy'); // 1МБ!
  let counter = 0;

  const id = setInterval(() => {
    counter++;
    console.log(counter);
    // bigData и counter живы!
  }, 1000);

  return id;
}

const timerId = createTimer();
// bigData НЕ удалится — таймер держит замыкание!
```

Размер утечки памяти (memory leak):
1. Функция-таймер: ~1КБ
2. Замыкание (переменные): 1МБ+
3. `setInterval` держит ВСЁ лексическое окружение

❌ *Утечка памяти (плохо)*:
```js
let users = []; // Растёт бесконечно!

function loadUsers() {
  fetch('/api/users').then(data => {
    users.push(...data); // users живёт вечно!
  });
}

setInterval(loadUsers, 5000); // users = 10ГБ через месяц!
```

✅ *Правильная очистка*:
```js
function createSafeTimer() {
  let users = [];
  let counter = 0;

  const id = setInterval(() => {
    counter++;
    if (counter > 100) {
      clearInterval(id); // 🗑️ Освободить память!
      return;
    }
    console.log(`Users: ${users.length}`);
  }, 1000);

  return id; // Для внешней очистки
}
```

**Практические сценарии утечек**

1. Часы с состоянием

    ```js
    // Плохо
    let clockState = {hours: 0, users: heavyObject};
    setInterval(() => console.log(clockState), 1000);

    // Хорошо
    const id = setInterval(() => {
    const now = new Date(); // Локальные переменные!
    console.log(now.toLocaleTimeString());
    }, 1000);
    ```

2. Счётчики с DOM

    ```js
    // Утечка! element живёт вечно
    const element = document.querySelector('.counter');
    setInterval(() => element.textContent = counter++, 100);

    clearInterval(id); // Спасение!
    ```

**Лучшие практики**
1. Всегда возвращайте ID

    ```js
    function safeClock() {
    return setInterval(() => {
        // Локальные переменные только!
    }, 1000);
    }

    const clockId = safeClock();
    // Очистка через 1 час
    setTimeout(() => clearInterval(clockId), 3600000);
    ```

2. `WeakMap` для тяжёлых данных

    ```js
    const dataCache = new WeakMap();

    setInterval(() => {
    const heavy = getHeavyData();
    dataCache.set(someKey, heavy); // Автоочистка!
    }, 5000);
    ```

3. `requestAnimationFrame` вместо интервала

    ```js
    function gameLoop() {
    // Локальные переменные, нет утечек
    updateGame();
    requestAnimationFrame(gameLoop);
    }
    ```

**Отсюда правило**: каждый `setInterval`/`setTimeout` должен иметь план очистки. Проверяйте утечки в DevTools!

**Инструменты для отладки**:
- Chrome **DevTools** → **Memory** → **Heap Snapshot**.
- Ищем: `"(closure)"`, `"setInterval"`, `"setTimeout"`.

#### setTimeout с нулевой задержкой
Особый вариант использования: `setTimeout(func, 0)` или просто `setTimeout(func)`.

Это планирует вызов `func` настолько быстро, насколько это возможно. Но планировщик будет вызывать функцию только после завершения выполнения текущего кода.

Так вызов функции будет запланирован сразу после выполнения текущего кода.

Например, этот код выводит «Привет» и затем сразу «Мир»:
```js
setTimeout(() => alert("Мир"));

alert("Привет");
```

Первая строка помещает вызов в «календарь» через 0 мс. Но планировщик проверит «календарь» только после того, как текущий код завершится. Поэтому `"Привет"` выводится первым, а `"Мир"` – после него.

Есть и более продвинутые случаи использования нулевой задержки в браузерах, которые будут рассмотрены в разделе "Событийный цикл: микрозадачи и макрозадачи".

!!! info "Минимальная задержка вложенных таймеров в браузере"
    В браузере есть ограничение на то, как часто внутренние счётчики могут выполняться. В [стандарте HTML5](https://www.w3.org/TR/html5/webappapis.html#timers) говорится: «после пяти вложенных таймеров интервал должен составлять не менее четырёх миллисекунд.».

    Продемонстрируем в примере ниже, что это означает. Вызов `setTimeout` повторно вызывает себя через 0 мс. Каждый вызов запоминает реальное время от предыдущего вызова в массиве `times`. Какова реальная задержка? Посмотрим:
    ```js
    let start = Date.now();
    let times = [];

    setTimeout(function run() {
        times.push(Date.now() - start); // запоминаем задержку от предыдущего вызова

        if (start + 100 < Date.now()) alert(times); // показываем задержку через 100 мс
        else setTimeout(run); // если нужно ещё запланировать
    });

    // пример вывода:
    // 1,1,1,1,9,15,20,24,30,35,40,45,50,55,59,64,70,75,80,85,90,95,100
    ```

    Первый таймер запускается сразу (как и указано в спецификации), а затем задержка вступает в игру, и мы видим `9, 15, 20, 24...`.

    Аналогичное происходит при использовании `setInterval` вместо `setTimeout: setInterval(f)` запускает `f` несколько раз с нулевой задержкой, а затем с задержкой 4+ мс.

    Это ограничение существует давно, многие скрипты полагаются на него, поэтому оно сохраняется по историческим причинам.

    Этого ограничения нет в серверном JavaScript. Там есть и другие способы планирования асинхронных задач. Например, [setImmediate](https://nodejs.org/api/timers.html) для Node.js. Так что это ограничение относится только к браузерам.

### Точность задержки

Обратим внимание, что все методы планирования не гарантируют точную задержку.

Например, таймер в браузере может замедляться по многим причинам:

- Перегружен процессор.
- Вкладка браузера в фоновом режиме.
- Работа ноутбука от аккумулятора.

Всё это может увеличивать минимальный интервал срабатывания таймера (и минимальную задержку) до 300 или даже 1000 мс в зависимости от браузера и настроек производительности ОС.

⏱️ *Фактическая точность таймеров*

| Условие            | Chrome/Firefox | Safari | Минимальная задержка   |
| ------------------ | -------------- | ------ | ---------------------- |
| Активная вкладка   | ~4мс           | ~4мс   | `setTimeout`(fn, 0)      |
| Фоновая вкладка    | 1000мс!        | 300мс  | Chrome: 1сек throttled |
| Ноутбук на батарее | 300мс+         | 300мс  | Power throttling       |
| CPU 100%           | 16-100мс       | 16мс   | Очередь задач          |

*Демонстрация неточности*
```js
console.time('timer');
setTimeout(() => {
  console.timeEnd('timer'); // 4мс? 1000мс? 🤷‍♂️
}, 10);
```

**Причины замедления (по приоритету)**
1. Фоновые вкладки (главная причина)

   - Chrome: минимум 1000мс (throttling)
   - Firefox: 1000мс
   - Safari: 300мс

2. Энергосбережение

   - Ноутбук на батарее → таймеры замедляются
   - Chrome: `setTimeout(fn, 0)` → 300мс!

3. Перегруженный CPU

    `setTimeout(fn, 4)` + тяжёлый JS = задержка 100мс+

4. Мобильные устройства

   - iOS Safari: таймеры приостанавливаются при скролле
   - Android: энергосбережение агрессивнее

**Практические последствия**

❌ *Игра с плохим таймингом*
```js
// Лаги в фоне!
setInterval(() => player.move(), 16); // 60fps → 1fps
```

✅ *Корректный игровой цикл*
```js
let lastTime = 0;
function gameLoop(currentTime) {
  const delta = currentTime - lastTime; // Реальное время!
  player.move(delta * 0.016); // Независимо от лагов
  requestAnimationFrame(gameLoop);
}
```

**Решения для точного тайминга**
1. `performance.now()` для дельты

    ```js
    let last = performance.now();
    setInterval(() => {
    const now = performance.now();
    const delta = now - last; // Фактическое время
    update(delta);
    last = now;
    }, 16);
    ```

2. `requestAnimationFrame` (лучший выбор)

    ```js
    // Работает только в видимой вкладке, точный 60fps
    function loop(time) {
    update(time);
    requestAnimationFrame(loop);
    }
    ```

3. `setTimeout` в цепочку

    ```js
    function preciseInterval(callback, interval) {
    let expected = Date.now() + interval;
    setTimeout(() => {
        callback();
        preciseInterval(callback, interval);
    }, Math.max(0, expected - Date.now()));
    }
    ```

*Выбор таймера по задаче*

| Задача        | Таймер                | Точность |
| ------------- | --------------------- | -------- |
| Игры/анимация | `requestAnimationFrame` | 60fps 🔴   |
| Часы/UI       | `setInterval`           | ~100мс 🟡  |
| API polling   | `setInterval`           | 1сек+ 🟢   |
| Однократная   | `setTimeout`            | 4-1000мс |

**Правило**: Не полагайтесь на точность `setTimeout(0)`. Для игр — `requestAnimationFrame`. Для часов — дельта времени. Фоновые вкладки всегда лагают!

### Итого
- Методы `setInterval(func, delay, ...args)` и `setTimeout(func, delay, ...args)` позволяют выполнять `func` регулярно или только один раз после задержки `delay`, заданной в мс.
- Для отмены выполнения необходимо вызвать `clearInterval`/`clearTimeout` со значением, которое возвращают методы `setInterval`/`setTimeout`.
- Вложенный вызов `setTimeout` является более гибкой альтернативой `setInterval`. Также он позволяет более точно задать интервал между выполнениями.
- Планирование с нулевой задержкой `setTimeout(func,0)` или, что то же самое, `setTimeout(func)` используется для вызовов, которые должны быть исполнены как можно скорее, после завершения исполнения текущего кода.
- Браузер ограничивает 4-мя мс минимальную задержку между пятью и более вложенными вызовами `setTimeout`, а также для `setInterval`, начиная с 5-го вызова.

### Задачи

#### Вывод каждую секунду

Напишите функцию `printNumbers(from, to)`, которая выводит число каждую секунду, начиная от `from` и заканчивая `to`.

Сделайте два варианта решения.

1. Используя `setInterval`.
2. Используя рекурсивный `setTimeout`.

<details>
<summary>Решение</summary>

Используем `setInterval`:
```js
function printNumbers(from, to) {
  let current = from;

  let timerId = setInterval(function() {
    alert(current);
    if (current == to) {
      clearInterval(timerId);
    }
    current++;
  }, 1000);
}

// использование:
printNumbers(5, 10);
```

Используем рекурсивный `setTimeout`:
```js
function printNumbers(from, to) {
  let current = from;

  setTimeout(function go() {
    alert(current);
    if (current < to) {
      setTimeout(go, 1000);
    }
    current++;
  }, 1000);
}

// использование:
printNumbers(5, 10);
```

Заметим, что в обоих решениях есть начальная задержка перед первым выводом. Она составляет одну секунду (1000мс). Если мы хотим, чтобы функция запускалась сразу же, то надо добавить такой запуск вручную на отдельной строке, вот так:
```js
function printNumbers(from, to) {
  let current = from;

  function go() {
    alert(current);
    if (current == to) {
      clearInterval(timerId);
    }
    current++;
  }

  go();
  let timerId = setInterval(go, 1000);
}

printNumbers(5, 10);
```

</details>

#### Что покажет setTimeout?

В приведённом ниже коде запланирован вызов `setTimeout`, а затем выполняется сложное вычисление, для завершения которого требуется более 100 мс.

Когда будет выполнена запланированная функция?

1. После цикла.
2. Перед циклом.
3. В начале цикла.

Что покажет alert?

```js
let i = 0;

setTimeout(() => alert(i), 100); // ?

// предположим, что время выполнения этой функции >100 мс
for(let j = 0; j < 100000000; j++) {
  i++;
}
```

<details>
<summary>Решение</summary>

Любой вызов `setTimeout` будет выполнен только после того, как текущий код завершится.

Последним значением `i` будет: `100000000`.

```js
let i = 0;

setTimeout(() => alert(i), 100); // 100000000

// предположим, что время выполнения этой функции >100 мс
for(let j = 0; j < 100000000; j++) {
  i++;
}
```

</details>

### requestAnimationFrame()
**`requestAnimationFrame`** — это метод браузера для создания плавных анимаций, синхронизированных с частотой обновления экрана (обычно 60 FPS). Он вызывает переданную функцию перед следующей перерисовкой кадра, минимизируя нагрузку на процессор и предотвращая "дрожание" анимации.

Метод принимает callback-функцию с параметром времени (timestamp в миллисекундах) и опционально элемент для оптимизации:
```js
const id = window.requestAnimationFrame(callback, element);
```

Возвращает уникальный ID для отмены анимации с помощью `cancelAnimationFrame(id)`. В *`callback`* можно рекурсивно вызывать `requestAnimationFrame` для цикла.

*Простая анимация перемещения блока*:
```js
function animate(currentTime) {
  box.style.transform = `translateX(${currentTime / 10}px)`;
  if (currentTime < 3000) {
    requestAnimationFrame(animate);
  }
}
requestAnimationFrame(animate);
```

Здесь `currentTime` растет с каждым кадром; прогресс вычисляется на основе времени для независимости от FPS.

Для отмены анимации необходимо сохранять ID и вызвать `cancelAnimationFrame`:
```js
const id = requestAnimationFrame(animate);
cancelAnimationFrame(id);
```

Это полезно для паузы или очистки при откреплении (unmount) компонента.

Таким образом, метод **`requestAnimationFrame()`** действует аналогично `setInterval()` за тем исключением, что он больше заточен под анимации, работу с графикой и имеет ряд оптимизаций, которые улучшают его производительность.

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <style>
    #rect {
        margin: 100px;
        width: 100px;
        height: 100px;
        background: #50c878;
    }
    </style>
</head>
<body>
    <div id="rect"></div>
    <script>
        const square = document.getElementById("rect");
        let offset = 0;
        let step = 1;
        function moveRect() {
            if(offset  >=600) step = -1;
            if(offset  <=0) step = 1;
            offset +=step;
            square.style.marginLeft = offset + "px";
            window.requestAnimationFrame(moveRect);
        }
        window.requestAnimationFrame(moveRect);
    </script>
</body>
</html>
```

В метод `window.requestAnimationFrame()` передается функция, которая будет вызываться определенное количество раз (обычно 60) в секунду. В данном случае в этот метод передается функция `moveRect`, которая изменяет угол поворота блока на странице и затем обращается опять же к методу `window.requestAnimationFrame(moveRect)`.

В качестве возвращаемого результата метод `window.requestAnimationFrame()` возвращает уникальный `id`, который может потом использоваться для остановки анимации:
```js
// получаем id
const id = window.requestAnimationFrame(moveRect);

//  останавливаем анимацию
window.cancelAnimationFrame(id);
```

**Преимущества**
- **Автоматическая синхронизация с экраном**: анимация не работает в фоне или при скрытой вкладке.

- **Экономия ресурсов**: браузер оптимизирует вызовы, избегая лишних вычислений.

- **Плавность**: лучше `setInterval`/`setTimeout`, так как не зависит от фиксированных интервалов.

## Заключение
History API позволяет манипулировать стеком истории браузера без перезагрузки страницы, `location` предоставляет доступ к компонентам URL для навигации, а `navigator` содержит информацию о браузере и устройстве пользователя. Таймеры (`setTimeout`, `setInterval` и `requestAnimationFrame`) обеспечивают планирование задач и плавные анимации, синхронизированные с рендерингом. Вместе эти объекты BOM дают действенные инструменты для создания динамичных SPA-приложений с отзывчивым интерфейсом, оптимизируя производительность и UX без серверных запросов.

## Практика

### Практическая работа. Реализация одностраничного веб-приложения

#### Задание
Реализовать простейшее одностраничное приложение на базе hash-based маршрутизации.

Реализовать функционал подтверждения несохраненных изменений в разделах с формами (профиль пользователя).

1. Расширить классы маршрутов флагами наличия несохраненных изменений.
2. В компонентах навигационных ссылок реализовать подписку на событие щелчка мыши для того, чтобы блокировать стандартный безусловный переход по маршрутной ссылке для вызова навигационного метода маршрутизатора. Доступ к экземпляру маршрутизатора можно осуществлять через объект контекста (допустимо через глобальный объект).
3. Маршрутизатор должен проверять присутствие несохраненных данных, проверяя покидаемый маршрут. При наличии таковых следует запрашивать подтверждение пользователя, при отсутствии (а также подтверждении ухода от пользователя) — запускать смену маршрута.
4. Дополнительно выполнять аналогичную проверку при попытке закрытия вкладки/обновления страницы.
5. Реализовать открепление обработчиков для оптимизации управления памятью.

Реализация того или иного механизма отслеживания изменения данных в настоящей задаче остается на усмотрение разработчика.

### Практическая работа. Оптимизация клиентской маршрутизации
Провести оптимизацию маршрутизации в разработанном одностраничном приложении с целью улучшения пользовательского опыта и индексации поисковиками, для чего заменить модель клиентской маршрутизации с hash-based routing на history (slash-based) routing.

- заменить разделители маршрутов &mdash; хэши (`#`) на слеши (`/`);
- использовать HTML5 History API для поддержки обработки состояний, смены URL и браузерной навигации (кнопок Вперед/Назад);
- реализовать простейший сервер на node.js (express) для поддержки обновлений страницы (<kbd>F5</kbd>) и переходов по прямой ссылке.

Итоговое решение представить в виде файлов исходного кода.

## Источники информации
[^7.1]: [Browser Object Model и объект window](https://metanit.com/web/javascript/7.1.php)
[^7.2]: [Диалоговые окна и поиск на странице](https://metanit.com/web/javascript/7.2.php)
[^7.7]: [Открытие, закрытие и позиционирование окон](https://metanit.com/web/javascript/7.7.php)
[^7.3]: [История браузера. History API](https://metanit.com/web/javascript/7.3.php)
[^7.4]: [Объект location](https://metanit.com/web/javascript/7.4.php)
[^7.5]: [Объект navigator](https://metanit.com/web/javascript/7.5.php)
[^7.6]: [Таймеры](https://metanit.com/web/javascript/7.6.php)
[^settimeout-setinterval]: [Планирование: setTimeout и setInterval](https://learn.javascript.ru/settimeout-setinterval)
[^popup-windows]: [Открытие окон и методы window](https://learn.javascript.ru/popup-windows)
