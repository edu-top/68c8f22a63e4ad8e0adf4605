## События

- [События](#события)
  - [Введение в браузерные события](#введение-в-браузерные-события)
    - [Базовые события](#базовые-события)
  - [Обработчики событий](#обработчики-событий)
    - [Встроенные обработчики](#встроенные-обработчики)
    - [Свойства обработчиков событий](#свойства-обработчиков-событий)
    - [Доступ к элементу через this](#доступ-к-элементу-через-this)
    - [Частые ошибки](#частые-ошибки)
    - [Слушатели событий](#слушатели-событий)
  - [Передача данных в обработчик события](#передача-данных-в-обработчик-события)
    - [Объект события](#объект-события)
    - [Объект-обработчик: handleEvent](#объект-обработчик-handleevent)
    - [Получение текущего объекта](#получение-текущего-объекта)
    - [Итого](#итого)
    - [Задания](#задания)
      - [Скрыть элемент по нажатию кнопки](#скрыть-элемент-по-нажатию-кнопки)
      - [Спрятать себя](#спрятать-себя)
      - [Какой обработчик запустится?](#какой-обработчик-запустится)
      - [Передвиньте мяч по полю](#передвиньте-мяч-по-полю)
      - [Создать раскрывающееся меню](#создать-раскрывающееся-меню)
      - [Добавить кнопку закрытия](#добавить-кнопку-закрытия)
      - [Карусель](#карусель)
  - [События мыши](#события-мыши)
    - [MouseEvent](#mouseevent)
  - [События клавиатуры](#события-клавиатуры)
  - [Действия браузера по умолчанию](#действия-браузера-по-умолчанию)
    - [Остановка выполнения события](#остановка-выполнения-события)
    - [Возврат false из обработчика](#возврат-false-из-обработчика)
      - [Пример: меню](#пример-меню)
    - [Использование preventDefault()](#использование-preventdefault)
    - [Опция «passive» для обработчика](#опция-passive-для-обработчика)
    - [event.defaultPrevented](#eventdefaultprevented)
    - [Итого](#итого-1)
    - [Задачи](#задачи)
      - [Почему не работает return false?](#почему-не-работает-return-false)
      - [Поймайте переход по ссылке](#поймайте-переход-по-ссылке)
      - [Галерея изображений](#галерея-изображений)
  - [Распространение событий](#распространение-событий)
    - [Восходящие события](#восходящие-события)
      - [Всплытие](#всплытие)
      - [Прекращение всплытия](#прекращение-всплытия)
    - [Целевой элемент](#целевой-элемент)
    - [Нисходящие события](#нисходящие-события)
      - [Погружение](#погружение)
    - [Итого](#итого-2)
  - [Делегирование событий](#делегирование-событий)
    - [Применение делегирования: действия в разметке](#применение-делегирования-действия-в-разметке)
    - [Приём проектирования «поведение»](#приём-проектирования-поведение)
      - [Поведение: «Счётчик»](#поведение-счётчик)
      - [Поведение: «Переключатель» (Toggler)](#поведение-переключатель-toggler)
    - [Итого](#итого-3)
    - [Задачи](#задачи-1)
      - [Спрячьте сообщения с помощью делегирования](#спрячьте-сообщения-с-помощью-делегирования)
      - [Раскрывающееся дерево](#раскрывающееся-дерево)
      - [Сортируемая таблица](#сортируемая-таблица)
      - [Поведение "подсказка"](#поведение-подсказка)
  - [Программный вызов событий](#программный-вызов-событий)
    - [Конструктор Event](#конструктор-event)
    - [Метод dispatchEvent](#метод-dispatchevent)
    - [MouseEvent, KeyboardEvent и другие](#mouseevent-keyboardevent-и-другие)
  - [Определение своих событий](#определение-своих-событий)
    - [Пример всплытия](#пример-всплытия)
    - [CustomEvent](#customevent)
    - [event.preventDefault()](#eventpreventdefault)
    - [Вложенные события обрабатываются синхронно](#вложенные-события-обрабатываются-синхронно)
    - [Итого](#итого-4)
  - [Практическая работа. Обработка встроенных событий](#практическая-работа-обработка-встроенных-событий)
    - [Задания](#задания-1)
    - [Задания](#задания-2)
  - [Практическая работа. Управление событиями](#практическая-работа-управление-событиями)
  - [Практическая работа. Использование делегирования событий](#практическая-работа-использование-делегирования-событий)
    - [Задания](#задания-3)
    - [Дополнительные задания](#дополнительные-задания)
      - [Раскрывающееся дерево](#раскрывающееся-дерево-1)
  - [Практическая работа. Реализация поведения "подсказка"](#практическая-работа-реализация-поведения-подсказка)
    - [Задание](#задание)
  - [Источники информации](#источники-информации)

### Введение в браузерные события
Для взаимодействия с пользователем в JavaScript определен механизм событий. Событие – это сигнал от браузера о том, что что-то произошло. Все DOM-узлы подают такие сигналы (хотя события бывают и не только в DOM).[^introduction-browser-events] Например, когда пользователь нажимает кнопку, то возникает событие нажатия кнопки. Аналогично когда пользователь вводит в текстовое поле текст, возникает событие этого текстового поля. В коде JavaScript мы можем определить возникновение события и как-то его обработать.

Вкратце общий механизм выглядит следующим образом. Сначала собственно происходит событие, например, пользователь нажал на кнопку. Объект, который сгенерировал событие, еще называется <dfn title="эмиттер события">эмиттером</dfn>/<dfn title="эмитент события">эмитентом события</dfn>. После того как произошло событие, оно помещается в **очередь событий** (*event queue*), что гарантирует, что события, которые были сгенерированы первыми, также будут обработаны в первую очередь. Цикл событий (*event loop*) постоянно проверяет, есть ли новое событие в очереди событий, и если оно есть, соответствующее событие пересылается **обработчикам событий** (*event handler*). В JavaScript эти <dfn title="обработчик события">обработчики событий</dfn> представляют собой простые функции, которые позволяют отреагировать на возникшее событие. Подобный подход еще называют **событийным программированием** (*event-driven programming*).[^9.1]

![Событийный цикл в языке JavaScript](../img/event_loop.png)

Если для события не определено обработчиков, то для него выполняется действие, которое определено браузером по умолчанию.

В JavaScript есть следующие типы событий:

- События мыши (перемещение курсора, нажатие мыши и т.д.)

- События клавиатуры (нажатие или отпускание клавиши клавиатуры)

- События жизненного цикла элементов (например, событие загрузки веб-станицы)

- События элементов форм (нажатие кнопки на форме, выбор элемента в выпадающем списке и т.д.)

- События, возникающие при изменении элементов DOM

- События, возникающие при касании на сенсорных экранах

- События, возникающие при возникновении ошибок

Стоит отметить, что применение событий не ограничены только графическим интерфейсом, однако графический интерфейс — наиболее показательная сфера применения событий.

Рассмотрим простейшую обработку событий. Например, на веб-странице у нас есть следующий элемент `div`:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <div id="rect" onclick="console.log('Clicked!')" style="width:50px;height:50px;background-color:blue;"></div>
</body>
</html>
```

Здесь определен обычный блок `div`, который имеет атрибут **`onclick`**, который задает **обработчик события** нажатия на блок `div`. То есть, чтобы обработать какое-либо событие, нам надо определить для него обработчик. Обработчик представляет собой код на языке JavaScript. В данном случае обработчик просто выводит строку на консоль:
```js
console.log('Clicked!')
```

И при нажатии на блок мы сможем увидеть в консоли браузера соответствующее сообщение:

![Обработка событий в языке JavaScript](../img/events.png)

#### Базовые события
Вкратце перечислю основные события, которые мы можем использовать в JavaScript.

*События мыши*:

Событие | Описание | Объект события
-- | -- | --
`click` | возникает при нажатии указателем мыши на элемент, т.е. когда кликнули на элемент левой кнопкой мыши (на устройствах с сенсорными экранами оно происходит при касании) | `MouseEvent`
`dblclick` | возникает при двойном нажатии указателем мыши на элемент | `MouseEvent`
`contextmenu` | возникает при открытии контекстного меню, когда кликнули на элемент правой кнопкой мыши | `MouseEvent`
`mousedown` | возникает при нахождении указателя мыши на элементе, когда кнопка мыши находится в нажатом состоянии | `MouseEvent`
`mouseup` | возникает при нахождении указателя мыши на элементе во время отпускания кнопки мыши | `MouseEvent`
`mousemove` | возникает при прохождении указателя мыши над элементом во время ее движения | `MouseEvent`
`mouseover` | возникает при вхождении указателя мыши в границы элемента, когда мышь наводится на элемент | `MouseEvent`
`mouseout` | возникает, когда указатель мыши выходит за пределы элемента (покидает элемент) | `MouseEvent`
`mouseenter` | возникает при вхождении указателя мыши в границы элемента | `MouseEvent`
`mouseleave` | возникает, когда указатель мыши выходит за пределы элемента | `MouseEvent`

*События клавиатуры*:

Событие | Описание | Объект события
-- | -- | --
`keydown` | возникает при нажатии клавиши клавиатуры и длится, пока нажата клавиша | `KeyboardEvent`
`keyup` | возникает при отпускании клавиши клавиатуры | `KeyboardEvent`
`keypress` | возникает при нажатии клавиши клавиатуры, но после события `keydown` и до события `keyup`. | `KeyboardEvent`

*События элементов форм*:

Событие | Описание | Объект события
-- | -- | --
`input` | возникает при изменении текста в элементах `input` и `textarea` или в элемент с атрибутом `contenteditable` | `Event`
`change` | возникает при изменении значения в списках, флажках (`checkbox`) или радиокнопках | `Event`
`submit` | возникает при отправке формы | `Event`
`reset` | возникает при сбросе формы (через кнопку `reset`) | `Event`

*События фокусировки*:

Событие | Описание | Объект события
-- | -- | --
`focus` | возникает при получении элементом фокуса | `FocusEvent`
`blur` | возникает при потере элементом фокуса | `FocusEvent`
`focusin` | возникает при получении фокуса (в отличие от события `focus`, это событие поднимающееся. Про поднимающиеся и опускающиеся события далее) | `FocusEvent`
`focusout` | возникает при потере фокуса (это событие поднимающееся в отличие от события `blur`) | `FocusEvent`

*Общие события интерфейса*:

Событие | Описание | Объект события
-- | -- | --
`load` | возникает при загрузке веб-страницы | `UIEvent`
`unload` | возникает при выгрузке веб-страницы (например, когда запрошена страница по новому адресу) | `UIEvent`
`abort` | возникает при отмене загрузки ресурса | `UIEvent`
`Error` | возникает при генерации ошибки при загрузке страницы (например, ошибка в коде JavaScript) | `UIEvent`
`select` | возникает при выделении текст на странице | `UIEvent`
`resize` | возникает при изменении размеров окна браузера | `UIEvent`
`scroll` | возникает при прокрутке | `UIEvent`
`beforeunload` | возникает непосредственно перед выгрузкой страницы | `BeforeUnloadEvent`
`DOMContentLoaded` | возникает при полной загрузке дерева DOM, срабатывает когда HTML загружен и обработан, DOM документа полностью построен и доступен | `Event`
`cut` | возникает при вырезании текста из поля ввода (например, с помощью <kbd>Ctrl</kbd>+<kbd>X</kbd>) | `ClipboardEvent`
`copy` | возникает при копировании текста из поля ввода (например, с помощью <kbd>Ctrl</kbd>+<kbd>C</kbd>) | `ClipboardEvent`
`paste` | возникает при вставке текста в поле ввода (например, с помощью <kbd>Ctrl</kbd>+<kbd>V</kbd>) | `ClipboardEvent`
`select` | возникает при выделении текста в поле ввода | `ClipboardEvent`

*События мобильных устройств и других устройств с сенсорным экраном*:

Событие | Описание | Объект события
-- | -- | --
`orientationchange` | возникает при изменении ориентации устройства | `Event`
`deviceorientation` | возникает, когда появляются новые данные об ориентации устройства | `DeviceOrientationEvent`
`devicemotion` | возникает с регулярными интервалами и указывает на силу ускорения, действующую на конечное устройство | `DeviceMotionEvent`
`touchstart` | возникает при касании дисплея | `TouchEvent`
`touchend` | возникает, когда палец убран с дисплея (касание завершилось) | `TouchEvent`
`touchmove` | возникает при движении пальцем по сенсорному дисплею | `TouchEvent`
`touchcancel` | возникает при прерывании отслеживания касаний | `TouchEvent`

*События CSS-переходов*:

Событие | Описание | Объект события
-- | -- | --
`transitionstart` | возникает когда CSS-переход фактически начался (после задержки `transition-delay`) | `TransitionEvent`
`transitionrun` | возникает при создании CSS-перехода (до начала задержки `transition-delay`) | `TransitionEvent`
`transitionend` | возникает когда CSS-анимация завершена | `TransitionEvent`
`transitioncancel` | возникает при отмене CSS-перехода (например, при удалении свойства `transition` до завершения) | `TransitionEvent`

### Обработчики событий
Событию можно назначить <dfn title="обработчик события">обработчик</dfn>, то есть функцию, которая сработает, как только событие произошло. Если в коде JavaScript возникает событие, то его обрабатывает связанный с этим событием обработчик. Именно благодаря обработчикам JavaScript-код может реагировать на действия пользователя.

Есть несколько способов назначить событию обработчик. Сейчас мы их рассмотрим, начиная с самого простого, и разберем подробно, как определять обработчики событий.[^9.2]

#### Встроенные обработчики
Самый простой способ определения обработчиков событий — их установка в коде html. Обработчик может быть назначен прямо в разметке, в атрибуте, который называется `on`*`<событие>`*.

Например, чтобы назначить обработчик события `click` на элементе `input`, можно использовать атрибут `onclick`, вот так:
```html
<input value="Нажми меня" onclick="alert('Клик!')" type="button">
```

При клике мышкой на кнопке выполнится код, указанный в атрибуте `onclick`.

Это так называемые <dfn title="встроенный обработчик">встроенные обработчики</dfn> или inline-обработчики, которые определяются в коде элемента с помощью атрибутов. Подобные атрибуты начинаются с префикса **`on`**. Например, у многих html-элементов есть атрибут **`on`**`click`, который определяет обработчик нажатия элемента. Посмотрим на примере кнопки:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <button onclick="console.log('Clicked!')">Click Me</button>
</body>
</html>
```

С помощью атрибута `onclick="console.log('Clicked!')"` к кнопке прикрепляется обработчик ее нажатия. Этот обработчик состоит из одной инструкции JavaScript — `console.log("Clicked!")`, которая выводит сообщение на консоль. Таким образом, при нажатии на кнопку сработает событие нажатия, и будет выполняться обработчик из атрибута `onclick`:

![Обработка событий в языке JavaScript](../img/events2.png)

Обратите внимание, для содержимого атрибута `onclick` используются одинарные кавычки, так как сам атрибут находится в двойных. Если мы забудем об этом и поставим двойные кавычки внутри атрибута, вот так: `onclick="alert("Click!")"`, код не будет работать.

Можно даже определить несколько инструкций подобным образом:
```html
<button onclick="console.log('Hello');console.log('Clicked!')">Click Me</button>
```

Но, очевидно, что это не самый удобный способ. Вообще, атрибут HTML-тега – не самое удобное место для написания большого количества кода, поэтому лучше создать отдельную JavaScript-функцию и вызвать её там.

Вынесем все инструкции в отдельную функцию JavaScript, а атрибуту `onclick` передадим вызов этой функции:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <button onclick="btn_click()">Click Me</button>
    <script>
    let clicks = 0;     // счетчик нажатий
    function btn_click(){
        console.log("Clicked", ++clicks);
    }
    </script>
</body>
</html>
```

Теперь по нажатию кнопки будет вызываться функция `btn_click`, которая определена в коде JavaScript.

Следующий пример по клику запускает функцию `countRabbits()`:
```js
<script>
  function countRabbits() {
    for(let i=1; i<=3; i++) {
      alert("Кролик номер " + i);
    }
  }
</script>

<input type="button" onclick="countRabbits()" value="Считать кроликов!">
```

![Count rabbits](../img/count-rabbits.png)

Как мы помним, атрибут HTML-тега не чувствителен к регистру, поэтому `ONCLICK` будет работать так же, как `onClick` и `onCLICK`… Но, как правило, атрибуты пишут в нижнем регистре: `onclick`.[^introduction-browser-events]

Хотя этот подход прекрасно работает, но он имеет кучу недостатков:

- Код html смешивается с кодом JavaScript, в связи с чем становится труднее разрабатывать, отлаживать и поддерживать приложение

- Обработчики событий можно задать только для уже созданных на веб-странице элементов. Динамически создаваемые элементы в этом случае лишаются возможности обработки событий

- К элементу для одного события может быть прикреплен только один обработчик

- Нельзя удалить обработчик без изменения кода

#### Свойства обработчиков событий
Проблемы, которые возникают при использовании встроенных обработчиков, были призваны решить свойства обработчиков. Можно назначать обработчик, используя свойство DOM-элемента `on`*`<событие>`*.

К примеру, `elem.onclick`:
```html
<input id="elem" type="button" value="Нажми меня!">
<script>
  elem.onclick = function() {
    alert('Спасибо');
  };
</script>
```

![Browser events](../img/browser-events_01.png)

Подобно тому, как у html-элементов есть атрибуты для обработчиков, так и в коде javascript у элементов DOM мы можем получить свойства обработчиков, которые соответствуют атрибутам:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <button id="btn">Click Me</div>
    <script>
    let clicks = 0;     // счетчик нажатий
    function btn_click(){
        console.log("Clicked", ++clicks);
    }
    // устанавливаем обработчик нажатия для элемента с id="btn"
    document.getElementById("btn").onclick = btn_click;
    </script>
</body>
</html>
```

В итоге нам достаточно взять свойство **`onclick`** и присвоить ему функцию, используемую в качестве обработчика. За счет этого код html отделяется от кода javascript.

Если обработчик задан через атрибут, то браузер читает HTML-разметку, создаёт новую функцию из содержимого атрибута и записывает в свойство.

Этот способ, по сути, аналогичен предыдущему.

**Обработчик всегда хранится в свойстве DOM-объекта, а атрибут – лишь один из способов его инициализации.**

Эти два примера кода работают одинаково:
1. Только HTML:

    ```html
    <input type="button" onclick="alert('Клик!')" value="Кнопка">
    ```

    ![Browser events](../img/browser-events_02.png)

2. HTML + JS:

    ```html
    <input type="button" id="button" value="Кнопка">
    <script>
      button.onclick = function() {
        alert('Клик!');
      };
    </script>
    ```

    ![Browser events](../img/browser-events_03.png)

**Так как у элемента DOM может быть только одно свойство с именем `onclick`, то назначить более одного обработчика так нельзя.**

В примере ниже назначение через JavaScript перезапишет обработчик из атрибута:
```html
<input type="button" id="elem" onclick="alert('Было')" value="Нажми меня">
<script>
  elem.onclick = function() { // перезапишет существующий обработчик
    alert('Станет'); // выведется только это
  };
</script>
```

![Browser events](../img/browser-events_04.png)

Кстати, обработчиком можно назначить и уже существующую функцию:
```js
function sayThanks() {
  alert('Спасибо!');
}

elem.onclick = sayThanks;
```

Убрать обработчик можно назначением `elem.onclick = null`.

#### Доступ к элементу через this
Внутри обработчика события `this` ссылается на текущий элемент, то есть на тот, на котором, как говорят, «висит» (т.е. назначен) обработчик.

В коде ниже `button` выводит своё содержимое, используя `this.innerHTML`:
```html
<button onclick="alert(this.innerHTML)">Нажми меня</button>
```

![Browser events](../img/browser-events_05.png)

#### Частые ошибки
Если вы только начинаете работать с событиями, обратите внимание на следующие моменты.

- **Функция должна быть присвоена как `sayThanks`, а не `sayThanks()`**

  ```js
  // правильно
  button.onclick = sayThanks;

  // неправильно
  button.onclick = sayThanks();
  ```

  Если добавить скобки, то `sayThanks()` – это уже вызов функции, результат которого (равный `undefined`, так как функция ничего не возвращает) будет присвоен `onclick`. Так что это не будет работать.

  …А вот в разметке, в отличие от свойства, скобки нужны:
  ```html
  <input type="button" id="button" onclick="sayThanks()">
  ```

  Это различие просто объяснить. При создании обработчика браузером из атрибута, он автоматически создаёт функцию с *телом из значения атрибута*: `sayThanks()`.

  Так что разметка генерирует такое свойство:
  ```js
  button.onclick = function() {
    sayThanks(); // содержимое атрибута
  };
  ```

- **Используйте именно функции, а не строки**

  Назначение обработчика строкой `elem.onclick = "alert(1)"` также сработает. Это сделано из соображений совместимости, но делать так не рекомендуется.

- **Не используйте `setAttribute` для обработчиков**

  Такой вызов работать не будет:
  ```js
  // при нажатии на body будут ошибки,
  // атрибуты всегда строки, и функция станет строкой
  document.body.setAttribute('onclick', function() { alert(1) });
  ```

- **Регистр DOM-свойства имеет значение**

  Используйте `elem.onclick`, а не `elem.ONCLICK`, потому что DOM-свойства чувствительны к регистру.

#### Слушатели событий
Несмотря на то, что свойства обработчиков решают ряд проблем, которые связаны с использованием атрибутов, в то же время это также не оптимальный подход. Фундаментальный недостаток описанных выше способов назначения обработчика – невозможность повесить несколько обработчиков на одно событие. 

Например, одна часть кода хочет при клике на кнопку делать её подсвеченной, а другая – выдавать сообщение.

Мы хотим назначить два обработчика для этого. Но новое DOM-свойство перезапишет предыдущее:
```js
input.onclick = function() { alert(1); }
// ...
input.onclick = function() { alert(2); } // заменит предыдущий обработчик
```

Разработчики стандартов достаточно давно это поняли и предложили альтернативный способ назначения обработчиков при помощи специальных методов `addEventListener` и `removeEventListener`. Они свободны от указанного недостатка.

Таким образом, еще один способ установки обработчиков событий представляет использование слушателей.

Для работы со слушателями событий в JavaScript есть объект **`EventTarget`**, который определяет методы **`addEventListener()`** (для добавления слушателя) и **`removeEventListener()`** для удаления слушателя. И поскольку html-элементы DOM тоже являются объектами `EventTarget`, то они также имеют эти методы. Фактически слушатели представляют те же функции обработчиков.

Синтаксис добавления обработчика:
```js
element.addEventListener(event, handler, [options]);
```

- `event`: имя события, например "click";

- `handler`: ссылка на функцию-обработчик;

- `options`: дополнительный объект со свойствами:

  - `once`: если `true`, тогда обработчик будет автоматически удалён после выполнения.
  - `capture`: фаза, на которой должен сработать обработчик, подробнее об этом в разделе [Распространение событий](#распространение-событий). Так исторически сложилось, что `options` может быть `false`/`true`, это то же самое, что `{capture: false/true}`.
  - `passive`: если `true`, то указывает, что обработчик никогда не вызовет `preventDefault()`, подробнее об этом рассказано в разделе [Опция «passive» для обработчика](#опция-passive-для-обработчика).

Таким образом, метод `addEventListener()` принимает два основных параметра: название события без префикса `on` и функцию обработчика этого события. Например:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <button id="btn">Click Me</div>
    <script>
    let clicks = 0;     // счетчик нажатий
    function btn_click(){
        console.log("Clicked", ++clicks);
    }
    const btn = document.getElementById("btn");
    // прикрепляем обработчик события "click"
    btn.addEventListener("click", btn_click);
    </script>
</body>
</html>
```

То есть в данном случае опять же обрабатывается событие `click`.

Для удаления обработчика следует использовать `removeEventListener`:
```js
element.removeEventListener(event, handler, [options]);
```

Таким образом, удаление слушателя аналогично добавлению:
```js
rect.removeEventListener("click", btn_click);
```

!!! warning Удаление требует именно ту же функцию

    Для удаления нужно передать именно ту функцию-обработчик которая была назначена.

    Вот так не сработает:
    ```js
    elem.addEventListener( "click" , () => alert('Спасибо!'));
    // ....
    elem.removeEventListener( "click", () => alert('Спасибо!'));
    ```

    Обработчик не будет удалён, т.к. в `removeEventListener` передана не та же функция, а другая, с одинаковым кодом, но это не важно.

    Вот так правильно:
    ```js
    function handler() {
      alert( 'Спасибо!' );
    }

    input.addEventListener("click", handler);
    // ....
    input.removeEventListener("click", handler);
    ```

    Обратим внимание – если функцию обработчик не сохранить где-либо, мы не сможем её удалить. Нет метода, который позволяет получить из элемента обработчики событий, назначенные через `addEventListener`.

Метод `addEventListener` позволяет добавлять несколько обработчиков на одно событие одного элемента, например:
```html
<input id="elem" type="button" value="Нажми меня"/>

<script>
  function handler1() {
    alert('Спасибо!');
  };

  function handler2() {
    alert('Спасибо ещё раз!');
  }

  elem.onclick = () => alert("Привет");
  elem.addEventListener("click", handler1); // Спасибо!
  elem.addEventListener("click", handler2); // Спасибо ещё раз!
</script>
```

Как видно из примера выше, можно одновременно назначать обработчики и через DOM-свойство и через `addEventListener`. Однако, во избежание путаницы, рекомендуется выбрать один способ.

Таким образом, большим преимуществом использования слушателей является именно то, что мы можем установить для одного события несколько функций:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <button id="btn">Click Me</div>
    <script>
    let clicks = 0;     // счетчик нажатий
    function btn_click(){
        console.log("Clicked", ++clicks);
    }
    const btn = document.getElementById("btn");

    // прикрепляем первый обработчик события "click" в виде функции btn_click
    btn.addEventListener("click", btn_click);

    // прикрепляем второй обработчик события "click" в виде анонимной функции
    btn.addEventListener("click", function(){
        console.log("Button clicked!")
    });

    // прикрепляем третий обработчик события "click" в виде стрелочной функции
    btn.addEventListener("click", ()=>console.log("Element clicked!"));

    </script>
</body>
</html>
```

!!! warning Обработчики некоторых событий можно назначать только через `addEventListener`

    Существуют события, которые нельзя назначить через DOM-свойство, но можно через `addEventListener`.

    Например, таково событие `DOMContentLoaded`, которое срабатывает, когда завершена загрузка и построение DOM документа.

    ```js
    document.onDOMContentLoaded = function() {
      alert("DOM построен"); // не будет работать
    };
    ```

    ```js
    document.addEventListener("DOMContentLoaded", function() {
      alert("DOM построен"); // а вот так сработает
    });
    ```

    Так что `addEventListener` более универсален. Хотя заметим, что таких событий меньшинство, это скорее исключение, чем правило.

### Передача данных в обработчик события
Иногда возникает необходимость передать в обработчик некоторые данные. Чтобы хорошо обработать событие, могут понадобиться детали того, что произошло. Не просто «клик» или «нажатие клавиши», а также – какие координаты указателя мыши, какая клавиша нажата и так далее.

Если обработчики событий устанавливаются с помощью атрибутов элементов, то это сделать довольно просто. Например, передадим в обработчик нажатия кнопки текст, которые будет использоваться в обработчике:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <button id="btn" onclick="btn_click('Button Clicked')">Click Me</button>
    <script>
    // в обработчик передается текст
    function btn_click(text){
        console.log(text);  // выводим этот текст
    }
    </script>
</body>
</html>
```

Итак, здесь в обработчик кнопки передается некоторый текст:
```html
<button id="btn" onclick="btn_click('Button Clicked')">
```

В функции обработчика получаем этот текст и некоторым образом его используем, например, выводим на консоль:
```js
function btn_click(text){
    console.log(text);  // выводим этот текст
}
```

В данном случае в функцию обработчика передавалась строка, но в реальности, это может быть любой объект. Например, через значение **`this`** можно передать текущий объект, на котором возникает событие:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <button id="btn" onclick="btn_click(this)">Click Me</button>
    <script>
    let clicks = 0;     // счетчик нажатий
    // в обработчик передается ссылка на элемент кнопки
    function btn_click(btn){
        // изменяем текст кнопки
        btn.textContent = `Clicked ${++clicks}`;
    }
    </script>
</body>
</html>
```

Ключевое слово `this` указывает на текущий объект ссылки, на которую производится нажатие. И в коде обработчика мы можем получить этот объект и обратиться к его свойствам, например, к свойству textContent и таким образом изменить текст кнопки.

#### Объект события
Когда происходит событие, браузер создаёт *объект события*, записывает в него детали и передаёт его в качестве аргумента функции-обработчику. Пример ниже демонстрирует получение координат мыши из объекта события:
```html
<input type="button" value="Нажми меня" id="elem">

<script>
  elem.onclick = function(event) {
    // вывести тип события, элемент и координаты клика
    alert(event.type + " на " + event.currentTarget);
    alert("Координаты: " + event.clientX + ":" + event.clientY);
  };
</script>
```

Некоторые свойства объекта `event`:

- `event.type`: тип события, в данном случае "click";

- `event.currentTarget`: элемент, на котором сработал обработчик. Значение – обычно такое же, как и у `this`, но если обработчик является функцией-стрелкой или при помощи `bind` привязан другой объект в качестве `this`, то мы можем получить элемент из `event.currentTarget`.

- `event.clientX` / `event.clientY`: координаты курсора в момент клика относительно окна, для событий мыши.

Есть также и ряд других свойств, в зависимости от типа событий, которые мы разберём далее.[^introduction-browser-events]

!!! info "Объект события доступен и в HTML"

    При назначении обработчика в HTML, тоже можно использовать объект `event`, вот так:

    ```html
    <input type="button" onclick="alert(event.type)" value="Тип события">
    ```

    ![Browser events](../img/browser-events_06.png)

    Это возможно потому, что когда браузер из атрибута создаёт функцию-обработчик, то она выглядит так: `function(event) { alert(event.type) }`. То есть, её первый аргумент называется `"event"`, а тело взято из атрибута.

При обработке события браузер автоматически передает в функцию обработчика в качестве параметра объект **`Event`**, который инкапсулирует всю информацию о событии. И с помощью его свойств мы можем получить эту информацию:

- **`bubbles`**: возвращает `true`, если событие является восходящим. Например, если событие возникло на вложенном элементе, то оно может быть обработано на родительском элементе.

- **`cancelable`**: возвращает `true`, если можно отменить стандартную обработку события

- **`currentTarget`**: определяет элемент, к которому прикреплен обработчик события

- **`defaultPrevented`**: возвращает `true`, если был вызван у объекта `Event` метод `preventDefault()` (подробнее об этом в разделе [event.defaultPrevented](#eventdefaultprevented))

- **`eventPhase`**: хранит число, которое представляет стадию обработки события. Возможные значения:

  - `0` (`Event.NONE`)

  - `1` (`Event.CAPTURING_PHASE`)

  - `2` (`Event.AT_TARGET`)

  - `3` (`Event.BUBBLING_PHASE`)

- **`target`**: указывает на элемент, на котором было вызвано событие

- **`timeStamp`**: хранит время возникновения события

- **`type`**: указывает на имя события

- **`isTrusted`**: указывает, событие было сгенерировано элементами веб-страницы или кодом JavaScript

Например:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <button onclick="btn_click(event)">Click Me</button>
    <script>
    function btn_click(e){
        console.log(e);
    }
    </script>
</body>
</html>
```

При вызове функции-обработчика информация о событии доступна через объект `event`. Этот объект не определяется разработчиком, это просто аргумент функции обработчика, который хранит всю информацию о событии:
```html
<button onclick="btn_click(event)">
```

В коде JavaScript этот объект можно получить через параметр функции:
```js
function btn_click(e){
    console.log(e);
}
```

В данном случае просто выводим объект на консоль. Но естественно также можно было бы получить отдельную конкретную информацию о событии:
```js
function btn_click(e){
    console.log("Type:", e.type);       // Type: click
    console.log("Target:", e.target);   // Target: <button onclick=​"btn_click(event)​">​Click Me​</button>​
    console.log("Timestamp:", e.timeStamp);
}
```

Подобным образом мы можем получить объект события, если обработчик события прикрепляется через свойства элементов или через метод **`addEventListener()`**. Например, прикрепеление обработчика через свойство элемента:
```html
<button id="btn">Click Me</button>
<script>
function btn_click(e){
    console.log("Type:", e.type);
    console.log("Target:", e.target);
    console.log("Timestamp:", e.timeStamp);
}
// устанавливаем обработчик нажатия для элемента с id="btn"
document.getElementById("btn").onclick = btn_click;
</script>
```

Или прикрепеление обработчика с помощью метода `addEventListener`:
```html
<button id="btn">Click Me</button>
<script>
function btn_click(e){
    console.log("Type:", e.type);
    console.log("Target:", e.target);
    console.log("Timestamp:", e.timeStamp);
}
const btn = document.getElementById("btn");
// прикрепляем обработчик события "click"
btn.addEventListener("click", btn_click);
</script>
```

#### Объект-обработчик: handleEvent
Мы можем назначить обработчиком не только функцию, но и объект при помощи `addEventListener`. В этом случае, когда происходит событие, вызывается метод объекта `handleEvent`.

К примеру:
```html
<button id="elem">Нажми меня</button>

<script>
  elem.addEventListener('click', {
    handleEvent(event) {
      alert(event.type + " на " + event.currentTarget);
    }
  });
</script>
```

Как видим, если `addEventListener` получает объект в качестве обработчика, он вызывает `object.handleEvent(event)`, когда происходит событие.

Мы также можем использовать класс для этого:
```html
<button id="elem">Нажми меня</button>

<script>
  class Menu {
    handleEvent(event) {
      switch(event.type) {
        case 'mousedown':
          elem.innerHTML = "Нажата кнопка мыши";
          break;
        case 'mouseup':
          elem.innerHTML += "...и отжата.";
          break;
      }
    }
  }

  let menu = new Menu();
  elem.addEventListener('mousedown', menu);
  elem.addEventListener('mouseup', menu);
</script>
```

Здесь один и тот же объект обрабатывает оба события. Обратите внимание, мы должны явно назначить оба обработчика через `addEventListener`. Тогда объект `menu` будет получать события `mousedown` и `mouseup`, но не другие (не назначенные) типы событий.

Метод `handleEvent` не обязательно должен выполнять всю работу сам. Он может вызывать другие методы, которые заточены под обработку конкретных типов событий, вот так:
```html
<button id="elem">Нажми меня</button>

<script>
  class Menu {
    handleEvent(event) {
      // mousedown -> onMousedown
      let method = 'on' + event.type[0].toUpperCase() + event.type.slice(1);
      this[method]();
    }

    onMousedown() {
      elem.innerHTML = "Кнопка мыши нажата";
    }

    onMouseup() {
      elem.innerHTML += "...и отжата.";
    }
  }

  let menu = new Menu();
  elem.addEventListener('mousedown', menu);
  elem.addEventListener('mouseup', menu);
</script>
```

Теперь обработка событий разделена по методам, что упрощает поддержку кода.

#### Получение текущего объекта
Для получения текущего объекта, для которого обрабатыватся событие, внутри обработчика события мы можем использовать ключевое слово **`this`**:
```html
<button id="btn">Click Me</button>
<script>
const btn = document.getElementById("btn");
function btn_click(){
    console.log(this);  //  <button id="btn">Click Me</button>
}
btn.addEventListener("click", btn_click);
</script>
```

Здесь при обработке события `click` на кнопке объект `this` в функции `btn_click` будет представлять эту кнопку. Фактически в данном случае значения `this` и `event.target` были бы эквивалентны.[^9.3]
```js
function btn_click(e){
    console.log(this===e.target); // true
}
```

#### Итого
Есть три способа назначения обработчиков событий:

1. Атрибут HTML: `onclick="..."`.
2. DOM-свойство: `elem.onclick = function`.
3. Специальные методы: `elem.addEventListener(event, handler[, phase])` для добавления, `removeEventListener` для удаления.

HTML-атрибуты используются редко потому, что JavaScript в HTML-теге выглядит немного странно. К тому же много кода там не напишешь.

DOM-свойства вполне можно использовать, но мы не можем назначить больше одного обработчика на один тип события. Во многих случаях с этим ограничением можно мириться.

Последний способ самый гибкий, однако нужно писать больше всего кода. Есть несколько типов событий, которые работают только через него, например, `DOMContentLoaded`. Также `addEventListener` поддерживает объекты в качестве обработчиков событий. В этом случае вызывается метод объекта `handleEvent`.

Не важно, как вы назначаете обработчик – он получает объект события первым аргументом. Этот объект содержит подробности о том, что произошло.

В целом, события и обработчики в JavaScript обеспечивают реактивность веб-приложений, позволяя синхронизировать код с действиями пользователя и изменениями DOM.

Эта система лежит в основе интерактивных интерфейсов, от простых кнопок до сложных SPA, обеспечивая масштабируемость и отзывчивость.

Мы изучим больше о событиях и их типах в следующих главах.

#### Задания

##### Скрыть элемент по нажатию кнопки

Добавить JavaScript к кнопке `button`, чтобы при нажатии элемент `<div id="text">` исчезал.

![Task 1](../img/event-handlers-task_01.png)

<details>
<summary>Решение</summary>

[Исходный код](../src/11_events/hide-element.html)

</details>

##### Спрятать себя

Создайте кнопку, которая будет скрывать себя по нажатию. Например:

<input type="button" onclick="this.hidden=true" value="Нажмите, чтобы спрятать">

<details>
<summary><em>Решение</em></summary>

Можем использовать `this` в обработчике для доступа к самому элементу:
```html
<input type="button" onclick="this.hidden=true" value="Нажми, чтобы спрятать">
```

</details>

##### Какой обработчик запустится?

В переменной `button` находится кнопка. Изначально на ней нет обработчиков.

Который из обработчиков запустится? Что будет выведено при клике после выполнения кода?

```js
button.addEventListener("click", () => alert("1"));

button.removeEventListener("click", () => alert("1"));

button.onclick = () => alert(2);
```

<details>
<summary><em>Решение</em></summary>

Ответ: `1` и `2`.

Первый обработчик сработает, потому что он не был удалён методом `removeEventListener`. Чтобы удалить обработчик, необходимо передать именно ту функцию, которая была назначена в качестве обработчика. Несмотря на то, что код идентичен, в `removeEventListener` передаётся новая, другая функция.

Для того чтобы удалить функцию-обработчик, нужно где-то сохранить ссылку на неё, например:
```js
function handler() {
  alert(1);
}

button.addEventListener("click", handler);
button.removeEventListener("click", handler);
```

Обработчик `button.onclick` сработает независимо от `addEventListener`.

</details>

##### Передвиньте мяч по полю

Пусть мяч перемещается при клике на поле, туда, куда был клик, вот так:

![Task 1](../img/event-handlers-task_03.png)

![Ball](../svg/ball.svg)

![Field](../img/field.png)

[Исходный код](../samples/10_dom/ball-field.html)

Требования:

- Центр мяча должен совпадать с местом нажатия мыши (если это возможно без пересечения краёв поля);
- CSS-анимация желательна, но не обязательна;
- Мяч ни в коем случае не должен пересекать границы поля;
- При прокрутке страницы ничего не должно ломаться;

Заметки:

- Код должен уметь работать с различными размерами мяча и поля, не привязываться к каким-либо фиксированным значениям.
- Используйте свойства `event.clientX`/`event.clientY` для определения координат мыши при клике.

<details>
<summary><em>Решение</em></summary>

Сначала мы должны выбрать метод позиционирования мяча.

Мы не можем использовать `position:fixed`, поскольку прокрутка страницы будет перемещать мяч с поля.

Правильнее использовать `position:absolute`, и, чтобы сделать позиционирование действительно надёжным, сделаем само поле (`field`) позиционированным.

Тогда мяч будет позиционирован относительно поля:
```css
#field {
  width: 200px;
  height: 150px;
  position: relative;
}

#ball {
  position: absolute;
  left: 0; /* по отношению к ближайшему расположенному предку (поле) */
  top: 0;
  transition: 1s all; /* CSS-анимация для значений left/top делает передвижение мяча плавным */
}
```

Далее мы должны назначить корректные значения `ball.style.left/top`. Сейчас они содержат координаты относительно поля.

Картинка:

![Move ball coordinates](../svg/move-ball-coords.svg)

У нас есть значения `event.clientX/clientY` – координаты нажатия мышки относительно окна браузера;

Чтобы получить значение `left` для мяча после нажатия мышки относительно поля, мы должны из координаты нажатия мышки вычесть координату левого края поля и ширину границы:
```js
let left = event.clientX - fieldCoords.left - field.clientLeft;
```

Значение `ball.style.left` означает «левый край элемента» (мяча). И если мы назначим такой `left` для мяча, тогда его левая граница, а не центр, будет под курсором мыши.

Нам нужно сдвинуть мяч на половину его высоты вверх и половину его ширины влево, чтобы центр мяча точно совпадал с точкой нажатия мышки.

В итоге значение для `left` будет таким:
```js
let left = event.clientX - fieldCoords.left - field.clientLeft - ball.offsetWidth/2;
```

Вертикальная координата будет вычисляться по той же логике.

Следует помнить, что ширина и высота мяча должна быть известна в тот момент, когда мы получаем значение `ball.offsetWidth`. Это значение может задаваться в HTML или CSS.

[Код решения](../src/11_events/move-ball.html)

</details>

##### Создать раскрывающееся меню

Создать меню, которое по нажатию открывается либо закрывается:

![Collapsible menu](../img/collapsible-menu_01.png)

![Collapsible menu](../img/collapsible-menu_02.png)

P.S. HTML/CSS исходного документа можно и нужно менять.

<details>
<summary><em>Решение</em></summary>

**HTML/CSS**

Для начала создадим разметку HTML/CSS нашего меню.

Меню – это отдельный графический компонент на странице, так что его лучше вынести в отдельный DOM-элемент.

Список пунктов меню может быть представлен в виде списка `ul`/`li`.

Пример HTML-структуры:
```html
<div class="menu">
  <span class="title">Сладости (нажми меня)!</span>
  <ul>
    <li>Пирожное</li>
    <li>Пончик</li>
    <li>Мёд</li>
  </ul>
</div>
```

Для заголовка мы используем тег `<span>`, потому что `<div>`, как и любой блочный элемент, имеет скрытое свойство `display:block`, а значит, занимает ширину 100%.

Например:
```html
<div style="border: solid red 1px" onclick="alert(1)">Сладости (нажми меня)!</div>
```

![Task Solution](../img/task-5-solution-1.png)

Таким образом, если мы зададим обработчик события `onclick`, то он будет срабатывать по клику на всей ширине поля.

…тег `<span>` – строчный элемент, по умолчанию имеет свойство `display: inline`, который занимает ровно столько места, сколько занимает сам текст:
```html
<span style="border: solid red 1px" onclick="alert(1)">Сладости (нажми меня)!</span>
```

![Task Solution](../img/task-5-solution-2.png)

**Переключение меню**

Переключение меню должно менять стрелку и скрывать или показывать список элементов меню.

Все эти изменения прекрасно обрабатываются средствами CSS. Посредством JavaScript мы будем отмечать текущее состояние меню, добавляя или удаляя класс `.open`.

Без класса `.open` меню будет закрыто:
```css
.menu ul {
  margin: 0;
  list-style: none;
  padding-left: 20px;
  display: none;
}

.menu .title::before {
  content: '▶ ';
  font-size: 80%;
  color: green;
}
```

…А с ним (с классом `.open`) стрелка будет меняться, и список будет показываться:
```css
.menu.open .title::before {
  content: '▼ ';
}

.menu.open ul {
  display: block;
}
```

[Код решения](../src/11_events/expandable-menu.html)

</details>

##### Добавить кнопку закрытия

Есть список сообщений.

При помощи JavaScript для каждого сообщения добавьте в верхний правый угол кнопку закрытия.

Результат должен выглядеть, как показано здесь:

![Closing button](../img/closing-button.png)

<details>
<summary><em>Решение</em></summary>

Чтобы добавить кнопку закрытия, мы можем использовать либо `position:absolute` (и сделать плитку (`pane`) `position:relative`) либо `float:right`. Преимущество варианта с `float:right` в том, что кнопка закрытия никогда не перекроет текст, но вариант `position:absolute` даёт больше свободы для действий. В общем, выбор за вами.

Тогда для каждой плитки код может выглядеть следующим образом:
```js
pane.insertAdjacentHTML("afterbegin", '<button class="remove-button">[x]</button>');
```

Элемент `<button>` становится `pane.firstChild`, таким образом мы можем добавить на него обработчик события:
```js
pane.firstChild.onclick = () => pane.remove();
```

![Код решения](../src/11_events/add-closing-button.html)

</details>

##### Карусель

Создайте «Карусель» — ленту изображений, которую можно листать влево-вправо нажатием на стрелочки.

![Carousel](../img/smart-carousel.png)

В дальнейшем к ней можно будет добавить анимацию, динамическую подгрузку и другие возможности.

P.S. В этой задаче разработка структуры HTML/CSS составляет 90% решения.

<details>
<summary><em>Решение</em></summary>

Лента изображений в разметке должна быть представлена как список `ul`/`li` с картинками `<img>`.

Нужно расположить ленту внутри `<div>` фиксированного размера, так чтобы в один момент была видна только нужная часть списка:

![Carousel](../svg/carousel1.svg)

Чтобы список сделать горизонтальным, нам нужно применить CSS-свойство `display: inline-block` для `<li>`.

Для тега `<img>` мы также должны настроить `display`, поскольку по умолчанию он `inline`. Во всех элементах типа `inline` резервируется дополнительное место под «хвосты» символов. И чтобы его убрать, нам нужно прописать `display:block`.

Для «прокрутки» будем сдвигать `<ul>`. Это можно делать по-разному, например, назначением CSS-свойства `transform: translateX()` (лучше для производительности) или `margin-left`:

![Carousel](../svg/carousel2.svg)

У внешнего `<div>` фиксированная ширина, поэтому «лишние» изображения обрезаются.

Вся карусель – это самостоятельный «графический компонент» на странице, таким образом нам лучше его «обернуть» в отдельный `<div class="carousel">` и уже модифицировать стили внутри него.

[Код решения](../src/11_events/carousel.html)

</details>

### События мыши
Одну из наиболее часто используемых событий составляют события мыши:

- `click`: возникает при нажатии указателем мыши на элемент

- `dblclick`: возникает при двойном нажатии указателем мыши на элемент

- `contextmenu`: возникает при открытии контекстного меню (правой кнопкой мыши)

- `mousedown`: возникает при нахождении указателя мыши на элементе, когда кнопка мыши находится в нажатом состоянии

- `mouseup`: возникает при нахождении указателя мыши на элементе во время отпускания кнопки мыши

- `mousemove`: возникает при прохождении указателя мыши над элементом

- `mouseover`: возникает при вхождении указателя мыши в границы элемента

- `mouseout`: возникает, когда указатель мыши выходит за пределы элемента

- `mouseenter`: возникает при вхождении указателя мыши в границы элемента

- `mouseleave`: возникает, когда указатель мыши выходит за пределы элемента

Отдельно стоит сказать про разницу между последними четырьмя событиями. `mouseenter` и `mouseleave` срабатывают только тогда, когда пересекается внешний край соответствующего элемента. А события `mouseover` и `mouseout` также срабатывают, когда другой элемент находится внутри соответствующего элемента и курсор мыши перемещается во внутренний элемент (т.е. уходит от внешнего элемента) или покидает внутренний элемент (то есть перемещается на внешний элемент).

Например, обработаем события `mouseover` и `mouseout`:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>METANIT.COM</title>
    <style>
    #blueRect{
        width:100px;
        height:100px;
        background-color:blue;
    }
    </style>
</head>
<body>
<div id="blueRect"></div>

<script>
function setColor(e){
    if(e.type==="mouseover")
        e.target.style.backgroundColor = "red";
    else if(e.type==="mouseout")
        e.target.style.backgroundColor = "blue";
}
const blueRect = document.getElementById("blueRect");
blueRect.addEventListener("mouseover", setColor);
blueRect.addEventListener("mouseout", setColor);
</script>
</body>
</html>
```

Теперь при наведении указателя мыши на блок `blueRect` он будет окрашиваться в красный цвет, а при уходе указателя мыши — блок будет обратно окрашиваться в синий цвет.

#### MouseEvent
Объект `Event` является общим для всех событий. Однако для разных типов событий существуют также свои объекты событий, которые добавляют ряд своих свойств. Так, для работы с событиями указателя мыши определен объект **`MouseEvent`**, который добавляет следующие свойства:[^9.5]

- **`altKey`**: возвращает `true`, если была нажата клавиша `Alt` во время генерации события

- **`button`**: содержит номер нажатой кнопки мыши

- **`buttons`**: содержит номер, который представляет нажатую кнопку мыши. 1 обозначает левую кнопку мыши, 2 — правую кнопку мыши, 4 — колесо мыши или среднюю кнопку мыши, 8 — четвертую кнопку мыши, а 16 — пятую кнопку мыши. Если при срабатывании события было нажато несколько кнопок, это свойство содержат сумму соответствующих чисел.

- **`clientX`**: определяет координату Х окна браузера, на которой находился указатель мыши во время генерации события

- **`clientY`**: определяет координату Y окна браузера, на которой находился указатель мыши во время генерации события

- **`ctrlKey`**: возвращает `true`, если была нажата клавиша <kbd>Ctrl</kbd> во время генерации события

- **`movementX`**: содержит координату Х относительно предыдущей координаты X при последнем событии перемещения мыши

- **`movementY`**: содержит координату Y относительно предыдущей координаты Y при последнем событии перемещения мыши

- **`metaKey`**: возвращает `true`, если была нажата во время генерации события метаклавиша клавиатуры

- **`region`**: содержит идентификатор области или элемента, которая относится к событию

- **`relatedTarget`**: определяет вторичный источник возникновения события

- **`screenX`**: определяет координату Х относительно верхнего левого угла экрана монитора, на которой находился указатель мыши во время генерации события

- **`screenY`**: определяет координату Y относительно верхнего левого угла экрана монитора, на которой находился указатель мыши во время генерации события

- **`shiftKey`**: возвращает `true`, если была нажата клавиша <kbd>Shift</kbd> во время генерации события

Определим координаты клика:
```js
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <style>
    #blueRect{
        width:100px;
        height:100px;
        background-color:blue;
    }
    </style>
</head>
<body>
<div id="blueRect"></div>

<script>
function handleClick(e){
    console.log("screenX: " + e.screenX);
    console.log("screenY: " + e.screenY);
    console.log("clientX: " + e.clientX);
    console.log("clientY: " + e.clientY);
}
const blueRect = document.getElementById("blueRect");
blueRect.addEventListener("click", handleClick);
</script>
</body>
</html>
```

### События клавиатуры
Другим распространенным типом событий являются события клавиатуры.[^9.6]

- `keydown`: возникает при нажатии клавиши клавиатуры и длится, пока нажата клавиша

- `keyup`: возникает при отпускании клавиши клавиатуры

- `keypress`: возникает при нажатии клавиши клавиатуры, но после события `keydown` и до события `keyup`. Надо учитывать, что данное событие генерируется только для тех клавиш, которые формируют вывод в виде символов, например, при печати символов. Нажатия на остальные клавиши, например, на <kbd>Alt</kbd>, не учитываются.

Для работы с событиями клавиатуры определен объект **`KeyboardEvent`**, который добавляет к свойствам объекта `Event` ряд специфичных для клавиатуры свойств:

- **`altKey`**: возвращает `true`, если была нажата клавиша <kbd>Alt</kbd> во время генерации события

- **`key`**: возвращает символ нажатой клавиши, например, при нажатии на клавишу <kbd>T</kbd> это свойство будет содержать "T". А если нажата клавиша <kbd>Я</kbd>, то это свойство будет содержать "Я"

- **`code`**: возвращает строковое представление нажатой клавиши физической клавиатуры QWERTY, например, при нажатии на клавишу <kbd>T</kbd> это свойство будет содержать "KeyT", а при нажатии на клавишу <kbd>;</kbd> (точка запятой), то свойство возвратит "Semicolon".

  При использовании этого свойства следует учитывать ряд момент. Прежде всего используется клавиатура QWERTY. То есть мы переключим раскладку, к примеру, на русскоязычную и нажмем на клавишу <kbd>Я</kbd>, то значением будет "KeyZ" — на клавиатуре QWERTY клавиша <kbd>Z</kbd> представляет ту же клавишу, что и на русскоязычной раскладке <kbd>Я</kbd>

  Другой момент — учитывается именно физическая клавитура. Если нажата клавиша на виртуальной клавиатуре, то возвращаемое значение будет устанавливаться браузером исходя из того, какой клавише на физической клавиатуре соответствовало нажатие.

- **`ctrlKey`**: возвращает `true`, если была нажата клавиша <kbd>Ctrl</kbd> во время генерации события

- **`metaKey`**: возвращает `true`, если была нажата во время генерации события метаклавиша клавиатуры

- **`shiftKey`**: возвращает `true`, если была нажата клавиша <kbd>Shift</kbd> во время генерации события

Например, мы можем с помощью клавиш клавиатуры перемещать элемент на веб-странице:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>METANIT.COM</title>
    <style>
    #blueRect{
        width:100px;
        height:100px;
        background-color:blue;
    }
    </style>
</head>
<body>
<div id="blueRect"></div>

<script>
const blueRect = document.getElementById("blueRect");
// получаем стиль для blueRect
const blueRectStyle = window.getComputedStyle(blueRect);
// устанавливаем обработчик нажатия клавиши
window.addEventListener("keydown", moveRect);

function moveRect(e){
    const left = parseInt(blueRectStyle.marginLeft); //смещение от левого края
    const top = parseInt(blueRectStyle.marginTop);  // смещения от левой границы

    switch(e.key){

        case "ArrowLeft":  // если нажата клавиша влево
            if(left>0)
                blueRect.style.marginLeft = left - 10 + "px";
            break;
        case "ArrowUp":   // если нажата клавиша вверх
            if(top>0)
                blueRect.style.marginTop = top - 10 + "px";
            break;
        case "ArrowRight":   // если нажата клавиша вправо
            if(left < document.documentElement.clientWidth - 100)
                blueRect.style.marginLeft = left + 10 + "px";
            break;
        case "ArrowDown":   // если нажата клавиша вниз
            if(top < document.documentElement.clientHeight - 100)
                blueRect.style.marginTop = top + 10 + "px";
            break;
    }
}
</script>
</body>
</html>
```

В данном случае обрабатывается событие `keydown`, в обработчке которого управляем стилевыми свойствами элемента `blueRect`. Так как при прикреплении обработчика стиль элемента может быть не установлен, то явным образом вычисляем его с помощью метода `window.getComputedStyle()`:
```js
const blueRectStyle = window.getComputedStyle(blueRect);
```
В обработчике события из этого стиля выбираем значения свойств `marginLeft` и `marginTop`.

```js
const left = parseInt(blueRectStyle.marginLeft); //смещение от левого края
const top = parseInt(blueRectStyle.marginTop);  // смещения от левой границы
```

Затем м помощью свойства `e.key` получаем нажатую клавишу. Список кодов клавиш клавиатуры можно посмотреть на странице https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values.

Здесь нам интересуют четыре клавиши: вверх, вниз, влево, вправо. Им соответственно будут соответствовать названия "ArrowUp", "ArrowDown", "ArrowLeft" и "ArrowRight". Если одна из них нажата, производим действия: увеличение или уменьшение отступа элемента от верхней или левой границы. Ну и чтобы элемент не выходил за границы окна, проверяем предельные значения с помощью `document.documentElement.clientWidth` (ширина корневого элемента) и `document.documentElement.clientHeight` (высота корневого элемента).

Стоит отметить, что этот код не очень оптимален, поскольку для проверки значений нам приходится вычислять положение `blueRect` по горизонтали и вертикали. Плюс необходимо вычислять при каждом вызове обработчика проверяем правый (`document.documentElement.clientWidth - 100`) и нижний край (`document.documentElement.clientHeight - 100;`) области документа, чтобы `blueRect` не вышел за предел видимого пространства. В этом случае мы можем добавить дополнительные абстракции в виде текущих координат `blueRect` и положения правой и нижней границ видимой области. Так, изменим код JavaScript следующим образом:
```js
const blueRect = document.getElementById("blueRect");
const position = [20, 20];  // позиция blueRect

// перемещаем blueRect на позицию в position
function setPosition() {
    blueRect.style.marginLeft = position[0] + "px";
    blueRect.style.marginTop = position[1] + "px";
}

function init(){
    const rightLimit = document.documentElement.clientWidth - 100;  // правый край
    const bottomLimit = document.documentElement.clientHeight - 100;    // нижний край

    setPosition();  // устанавливаем начальную позицию для blueRect

    function moveRect(e){
        switch(e.key){

        case "ArrowLeft":  // если нажата клавиша влево
            if(position[0] > 0)
                position[0] = position[0] - 10;
            break;
        case "ArrowUp":   // если нажата клавиша вверх
            if(position[1] > 0)
                position[1] = position[1] - 10;
            break;
        case "ArrowRight":   // если нажата клавиша вправо
            if(position[0] < rightLimit)
                position[0] = position[0] + 10;
            break;
        case "ArrowDown":   // если нажата клавиша вниз
            if(position[1] < bottomLimit)
                position[1] = position[1] + 10;
            break;
        }
        setPosition();
    }
    window.addEventListener("keydown", moveRect);
}
//  при загрузке страницы выполняем функцию init
window.addEventListener("load", init);
```

Теперь координаты `blueRect` хранятся в массиве `position`, где первое значение — это отступ слева, а второе значение — отступ сверху. Чтобы по этим координатам установить реальную позицию `blueRect` на странице определена функция `setPosition`.

```js
const position = [20, 20];  // позиция blueRect

// перемещаем blueRect на позицию в position
function setPosition() {
    blueRect.style.marginLeft = position[0] + "px";
    blueRect.style.marginTop = position[1] + "px";
}
```

Прикрепляем к событию загрузки окна — **`load`** обработчик — функцию `init`:
```js
window.addEventListener("load", init);
```

В функции `init` определяем правый и нижний край для перемещения `blueRect`, а также устанавливаем его начальную позицию:
```js
const rightLimit = document.documentElement.clientWidth - 100;  // правый край
const bottomLimit = document.documentElement.clientHeight - 100;    // нижний край
setPosition();  // устанавливаем начальную позицию для blueRect
```

Далее определяем обработчик `moveRect`, в котором изменяем значения в массиве `position`:
```js
function moveRect(e){
    switch(e.key){

    case "ArrowLeft":  // если нажата клавиша влево
        if(position[0] > 0)
            position[0] = position[0] - 10;
        break;
    //............
    }
    setPosition();
}
```

И после всех изменений переустанавливаем позицию с помощью функции `setPosition`.

В конце прикрепляем обработчик к нажатию клавиши клавиатуры:
```js
window.addEventListener("keydown", moveRect);
```

### Действия браузера по умолчанию
Многие события автоматически влекут за собой действие браузера.

Например:

- Клик по ссылке инициирует переход на новый URL.
- Нажатие на кнопку «отправить» в форме – отсылку её на сервер.
- Зажатие кнопки мыши над текстом и её движение в таком состоянии – инициирует его выделение.

Если мы обрабатываем событие в JavaScript, то зачастую такое действие браузера нам не нужно. К счастью, его можно отменить.[^default-browser-action]

#### Остановка выполнения события
Есть два способа отменить действие браузера:

- Основной способ – это воспользоваться объектом event. Для отмены действия браузера существует стандартный метод `event.preventDefault()`.
- Если же обработчик назначен через `on`*`<событие>`* (не через `addEventListener`), то также можно вернуть `false` из обработчика.

В следующем примере при клике по ссылке переход не произойдёт:
```html
<a href="/" onclick="return false">Нажми здесь</a>
или
<a href="/" onclick="event.preventDefault()">здесь</a>
```

#### Возврат false из обработчика
Стоит отметить, что в некоторых случаях нам может потребоваться возвращать из обработчика значение `false`. Например, рассмотрим следующую программу:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <a id="link" href="https://example.com" onclick="return a_click(this)">example</a>
    <script>
    // в обработчик передается ссылка
    function a_click(anchor){
        // получаем адрес ссылки
        console.log(anchor.href);
        return false;   // запрещаем переадресацию
    }
    </script>
</body>
</html>
```

Здесь в атрибуте `onclick` ссылки — элемента `<a>` не просто вызывается обработчик события, а возвращается его результат:
```html
<a id="link" href="https://example.com" onclick="return a_click(this)">
```

Причем функция обработчика возвращает **`false`**:
```js
function a_click(anchor){
    console.log(anchor.href);
    return false;   // запрещаем переадресацию
}
```

Дело в том, что для некоторых обработчиков можно подтвердить или остановить обработку события. Например, нажатие на ссылку должно привести к переадресации. Но возвращая из обработчика **`false`**, мы можем остановить стандартный путь обработки события, и переадресации не будет. Если же возвращать значение `true`, то событие обрабатывается в стандартном порядке.

Если же мы вовсе уберем возвращении результата, то событие будет обрабатываться, как будто возвращается значение `true`:
```html
<a id="link" href="https://metanit.com" onclick="a_click(this)">Metanit.com</a>
<script>
function a_click(anchor){
    console.log(anchor.href);
}
</script>
```

!!! attention "Возврат `false` из обработчика – это исключение"

    Обычно значение, которое возвращает обработчик события, игнорируется.

    Единственное исключение – это `return false` из обработчика, назначенного через `on`*`<событие>`*.

    В других случаях `return` не нужен, он никак не обрабатывается.

##### Пример: меню
Рассмотрим меню для сайта, например:
```html
<ul id="menu" class="menu">
  <li><a href="/html">HTML</a></li>
  <li><a href="/javascript">JavaScript</a></li>
  <li><a href="/css">CSS</a></li>
</ul>
```

Данный пример при помощи CSS может выглядеть так:

![Browser default action](../img/browser-default-action_01.png)

В HTML-разметке все элементы меню являются не кнопками, а ссылками, то есть тегами `<a>`. В этом подходе есть некоторые преимущества, например:

- Некоторые посетители очень любят сочетание «правый клик – открыть в новом окне». Если мы будем использовать `<button>` или `<span>`, то данное сочетание работать не будет.
- Поисковые движки переходят по ссылкам `<a href="...">` при индексации.

Поэтому в разметке мы используем `<a>`. Но нам необходимо обрабатывать клики в JavaScript, а стандартное действие браузера (переход по ссылке) – отменить.

Например, вот так:
```js
menu.onclick = function(event) {
  if (event.target.nodeName != 'A') return;

  let href = event.target.getAttribute('href');
  alert( href ); // может быть подгрузка с сервера, генерация интерфейса и т.п.

  return false; // отменить действие браузера (переход по ссылке)
};
```

Если мы уберём `return false`, то после выполнения обработчика события браузер выполнит «действие по умолчанию» – переход по адресу из `href`. А это нам здесь не нужно, мы обрабатываем клик сами.

Кстати, использование здесь делегирования событий делает наше меню очень гибким. Мы можем добавить вложенные списки и стилизовать их с помощью CSS – обработчик не потребует изменений.

!!! info "События, вытекающие из других"

    Некоторые события естественным образом вытекают друг из друга. Если мы отменим первое событие, то последующие не возникнут.

    Например, событие `mousedown` для поля `<input>` приводит к фокусировке на нём и запускает событие `focus`. Если мы отменим событие `mousedown`, то фокусирования не произойдёт.

    В следующем примере попробуйте нажать на первом `<input>` – происходит событие `focus`. Но если вы нажимаете по второму элементу, то события `focus` не будет.

    ```html
    <input value="Фокус работает" onfocus="this.value=''">
    <input onmousedown="return false" onfocus="this.value=''" value="Кликни меня">
    ```

    ![Browser default action](../img/browser-default-action_03.png)

    Это потому, что отменено стандартное действие `mousedown`. Впрочем, фокусировка на элементе всё ещё возможна, если мы будем использовать другой способ. Например, нажатием клавиши <kbd>Tab</kbd> можно перейти от первого поля ввода ко второму. Но только не через клик мышью на элемент, это больше не работает.

#### Использование preventDefault()
С помощью метода **`preventDefault()`** объекта `Event` мы можем остановить дальнейшее выполнение события. В ряде случаев этот метод не играет большой роли. Однако в некоторых ситуаций он может быть полезен. Например, при нажатии на ссылку мы можем с помощью дополнительной обработки определить, надо ли переходить по ссылке или надо запретить переход. Или другой пример: пользователь отправляет данные формы, но в ходе обработки в обработчике события мы определили, что поля формы заполнены неправильно, и в этом случае мы также можем запретить отправку.

Например, остановим переход по ссылке:
```html
<a id="link" href="https://example.com">example.com</a>
<script>
function linkHandler(e){
    console.log("Link has been clicked");
    e.preventDefault();     // останавливаем переход по ссылке
}
const link = document.getElementById("link");
link.addEventListener("click", linkHandler);
</script>
```

Здесь по нажатию на ссылку будет срабатывать метод `linkHandler`. И, поскольку в этом методе с помощью вызова `e.preventDefault()` предупреждаем переход по ссылке, то перехода не будет. Данный подход, к примеру, часто используется при ajax-запросах, когда надо обработать нажатие на ссылку, но при этом не выполнять перехода на другой ресурс, а сделать к нему запрос из кода javascript без перезагрузки страницы.

#### Опция «passive» для обработчика
Необязательная опция `passive: true` для `addEventListener` сигнализирует браузеру, что обработчик не собирается выполнять `preventDefault()`.

Почему это может быть полезно?

Есть некоторые события, как `touchmove` на мобильных устройствах (когда пользователь перемещает палец по экрану), которое по умолчанию начинает прокрутку, но мы можем отменить это действие, используя `preventDefault()` в обработчике.

Поэтому, когда браузер обнаружит такое событие, он должен для начала запустить все обработчики и после, если `preventDefault` не вызывается нигде, он может начать прокрутку. Это может вызвать ненужные задержки в пользовательском интерфейсе.

Опция `passive: true` сообщает браузеру, что обработчик не собирается отменять прокрутку. Тогда браузер начинает её немедленно, обеспечивая максимально плавный интерфейс, параллельно обрабатывая событие.

Для некоторых браузеров (Firefox, Chrome) опция passive по умолчанию включена в `true` для таких событий, как `touchstart` и `touchmove`.

#### event.defaultPrevented
Свойство `event.defaultPrevented` установлено в `true`, если действие по умолчанию было предотвращено, и `false`, если нет.

Рассмотрим практическое применение этого свойства для улучшения архитектуры.

Помните, в главе Всплытие и погружение мы говорили о `event.stopPropagation()` и упоминали, что останавливать «всплытие» – плохо?

Иногда вместо этого мы можем использовать `event.defaultPrevented`, чтобы просигналить другим обработчикам, что событие обработано.

Давайте посмотрим практический пример.

По умолчанию браузер при событии `contextmenu` (клик правой кнопкой мыши) показывает контекстное меню со стандартными опциями. Мы можем отменить событие по умолчанию и показать своё меню, как здесь:
```html
<button>Правый клик вызывает контекстное меню браузера</button>

<button oncontextmenu="alert('Рисуем наше меню'); return false">
  Правый клик вызывает наше контекстное меню
</button>
```

![Browser default action](../img/browser-default-action_04.png)

Теперь в дополнение к этому контекстному меню реализуем контекстное меню для всего документа.

При правом клике должно показываться ближайшее контекстное меню.

```html
<p>Правый клик здесь вызывает контекстное меню документа</p>
<button id="elem">Правый клик здесь вызывает контекстное меню кнопки</button>

<script>
  elem.oncontextmenu = function(event) {
    event.preventDefault();
    alert("Контекстное меню кнопки");
  };

  document.oncontextmenu = function(event) {
    event.preventDefault();
    alert("Контекстное меню документа");
  };
</script>
```

![Browser default action](../img/browser-default-action_05.png)

Проблема заключается в том, что когда мы кликаем по элементу `elem`, то мы получаем два меню: контекстное меню для кнопки и (событие всплывает вверх) контекстное меню для документа.

Как это поправить? Одно из решений – это подумать: «Когда мы обрабатываем правый клик в обработчике на кнопке, остановим всплытие», и вызвать `event.stopPropagation()`:

```html
<p>Правый клик вызывает меню документа</p>
<button id="elem">Правый клик вызывает меню кнопки (добавлен event.stopPropagation)</button>

<script>
  elem.oncontextmenu = function(event) {
    event.preventDefault();
    event.stopPropagation();
    alert("Контекстное меню кнопки");
  };

  document.oncontextmenu = function(event) {
    event.preventDefault();
    alert("Контекстное меню документа");
  };
</script>
```

![Browser default action](../img/browser-default-action_06.png)

Теперь контекстное меню для кнопки работает как задумано. Но цена слишком высока. Мы навсегда запретили доступ к информации о правых кликах для любого внешнего кода, включая счётчики, которые могли бы собирать статистику, и т.п. Это слегка неразумно.

Альтернативным решением было бы проверить в обработчике `document`, было ли отменено действие по умолчанию. Если да, тогда событие было обработано, и нам не нужно на него реагировать.

```html
<p>Правый клик вызывает меню документа (добавлена проверка event.defaultPrevented)</p>
<button id="elem">Правый клик вызывает меню кнопки</button>

<script>
  elem.oncontextmenu = function(event) {
    event.preventDefault();
    alert("Контекстное меню кнопки");
  };

  document.oncontextmenu = function(event) {
    if (event.defaultPrevented) return;

    event.preventDefault();
    alert("Контекстное меню документа");
  };
</script>
```

![Browser default action](../img/browser-default-action_07.png)

Сейчас всё работает правильно. Если у нас есть вложенные элементы и каждый из них имеет контекстное меню, то код также будет работать. Просто убедитесь, что проверяете `event.defaultPrevented` в каждом обработчике `contextmenu`.

!!! info "event.stopPropagation() и event.preventDefault()"

    Как мы можем видеть, `event.stopPropagation()` и `event.preventDefault()` (также известный как `return false`) – это две разные функции. Они никак не связаны друг с другом.

!!! info "Архитектура вложенных контекстных меню"

    Есть также несколько альтернативных путей, чтобы реализовать вложенные контекстные меню. Одним из них является единый глобальный объект с обработчиком `document`.`oncontextmenu` и методами, позволяющими хранить в нём другие обработчики.

    Объект будет перехватывать любой клик правой кнопкой мыши, просматривать сохранённые обработчики и запускать соответствующий.

    Но при этом каждый фрагмент кода, которому требуется контекстное меню, должен знать об этом объекте и использовать его вместо собственного обработчика `contextmenu`.

#### Итого
Действий браузера по умолчанию достаточно много:

- `mousedown` – начинает выделять текст (если двигать мышкой).
- `click` на `<input type="checkbox">` – ставит или убирает галочку в `input`.
- `submit` – при нажатии на `<input type="submit">` или при нажатии клавиши <kbd>Enter</kbd> в форме данные отправляются на сервер.
- `keydown` – при нажатии клавиши в поле ввода появляется символ.
- `contextmenu` – при правом клике показывается контекстное меню браузера.
- …и многие другие…

Все эти действия можно отменить, если мы хотим обработать событие исключительно при помощи JavaScript.

Чтобы отменить действие браузера по умолчанию, используйте `event.preventDefault()` или `return false`. Второй метод работает, только если обработчик назначен через `on`*`<событие>`*.

Опция `passive: true` для `addEventListener` сообщает браузеру, что действие по умолчанию не будет отменено. Это очень полезно для некоторых событий на мобильных устройствах, таких как `touchstart` и `touchmove`, чтобы сообщить браузеру, что он не должен ожидать выполнения всех обработчиков, а ему следует сразу приступать к выполнению действия по умолчанию, например, к прокрутке.

Если событие по умолчанию отменено, то значение `event.defaultPrevented` становится `true`, иначе `false`.

!!! attention "Сохраняйте семантику, не злоупотребляйте"

    Технически, отменяя действия браузера по умолчанию и добавляя JavaScript, мы можем настроить поведение любого элемента. Например, мы можем заставить ссылку `<a>` работать как кнопку, а кнопку `<button>` вести себя как ссылка (перенаправлять на другой URL).

    Но нам следует сохранять семантическое значение HTML элементов. Например, не кнопки, а тег `<a>` должен применяться для переходов по ссылкам.

    Помимо того, что это «хорошо», это делает ваш HTML лучше с точки зрения доступности для людей с ограниченными возможностями и с особых устройств.

    Также, если мы рассматриваем пример с тегом `<a>`, то обратите внимание: браузер предоставляет возможность открывать ссылки в новом окне (кликая правой кнопкой мыши или используя другие возможности). И пользователям это нравится. Но если мы заменим ссылку кнопкой и стилизуем её как ссылку, используя CSS, то специфичные функции браузера для тега `<a>` всё равно работать не будут.

Действия браузера по умолчанию и методы `preventDefault()` с `stopPropagation()` составляют фундаментальный механизм управления событиями в веб-разработке. Браузер автоматически выполняет стандартные реакции на события — от отправки форм и переходов по ссылкам до прокрутки и выделения текста. `preventDefault()` позволяет отменить именно эти встроенные действия, сохраняя при этом распространение события по DOM-дереву, что критично для SPA-приложений, где нужно перехватывать навигацию без перезагрузки страницы. В то же время `stopPropagation()` блокирует всплытие события к родительским элементам, предотвращая нежелательные срабатывания обработчиков на контейнерах.

Правильное использование этих методов обеспечивает предсказуемое поведение интерфейса и улучшает UX. В вашем MathLab-приложении они идеально подходят для роутера: `preventDefault()` на ссылках `<nav-link>` отключает стандартный переход, а событие `routeChange` гарантирует синхронизацию состояния без конфликтов. Комбинируя их с кастомными событиями и веб-компонентами, вы создаете чистую, масштабируемую архитектуру, где каждый элемент отвечает за свою логику, а браузерные дефолты подчиняются вашей бизнес-логике.

#### Задачи

##### Почему не работает return false?

Почему в коде ниже `return false` не работает?

```html
<script>
  function handler() {
    alert( "..." );
    return false;
  }
</script>

<a href="https://w3.org" onclick="handler()">браузер откроет w3.org</a>
```

Браузер переходит по указанной ссылке, но нам этого не нужно.

Как поправить?

<details>
<summary><em>Решение</em></summary>

Когда браузер считывает атрибут `on*`, например `onclick`, он создаёт функцию-обработчик с содержимым этого атрибута в качестве тела функции.

Функция для `onclick="handler()"` будет:
```js
function(event) {
  handler() // содержимое onclick
}
```

Сейчас нам видно, что возвращаемое значение `handler()` не используется и не влияет на результат.

Исправить очень просто:
```html
<script>
  function handler() {
    alert("...");
    return false;
  }
</script>

<a href="https://w3.org" onclick="return handler()">w3.org</a>
```

Также мы можем использовать `event.preventDefault()`, например:
```html
<script>
  function handler(event) {
    alert("...");
    event.preventDefault();
  }
</script>

<a href="https://w3.org" onclick="handler(event)">w3.org</a>
```

</details>

##### Поймайте переход по ссылке

Сделайте так, чтобы при клике на ссылки внутри элемента `id="contents"` пользователю выводился вопрос о том, действительно ли он хочет покинуть страницу, и если он не хочет, то прерывать переход по ссылке.

Так это должно работать:

![Browser default actions](../img/browser-default-actions_task_02.png)

Детали:

- Содержимое `#contents` может быть загружено динамически и присвоено при помощи `innerHTML`. Так что найти все ссылки и поставить на них обработчики нельзя. Используйте делегирование.
- Содержимое может иметь вложенные теги, *в том числе внутри ссылок*, например, `<a href=".."><i>...</i></a>`.

<details>
<summary><em>Решение</em></summary>

Это – классическая задача на тему делегирования.

В реальной жизни мы можем перехватить событие и создать AJAX-запрос к серверу, который сохранит информацию о том, по какой ссылке ушёл посетитель. Или мы можем загрузить содержимое и отобразить его прямо на странице (если допустимо).

Всё, что нам необходимо, это поймать событие `contents.onclick` и использовать функцию confirm, чтобы задать вопрос пользователю. Хорошей идеей было бы использовать `link.getAttribute('href')` вместо `link.href` для ссылок. Смотрите решение в песочнице.

</details>

##### Галерея изображений

Создайте галерею изображений, в которой основное изображение изменяется при клике на уменьшенный вариант.

Например:

![Browser default actions](../img/browser-default-actions_task_03.png)

P.S. Используйте делегирование.

<details>
<summary><em>Решение</em></summary>

Решение состоит в том, чтобы добавить обработчик на контейнер `#thumbs` и отслеживать клики на ссылках. Если клик происходит по ссылке `<a>`, тогда меняем атрибут `src` элемента `#largeImg` на `href` уменьшенного изображения.

</details>

### Распространение событий
Давайте начнём с примера.

Этот обработчик для `<div>` сработает, если вы кликните по любому из вложенных тегов, будь то `<em>` или `<code>`:
```html
<div onclick="alert('Обработчик!')">
  <em>Если вы кликните на <code>EM</code>, сработает обработчик на <code>DIV</code></em>
</div>
```

![Event propagation](../img/bubbling_01.png)

Вам не кажется это странным? Почему же сработал обработчик на `<div>`, если клик произошёл на `<em>`?[^bubbling-and-capturing]

Когда мы нажимаем на какой-либо элемент на станице и генерируется событие нажатия, то это событие может распространяться от элемента к элементу. Например, если мы нажимаем на блок `div`, то также мы нажимаем и на элемент `body`, в котором блок `div` находится. То есть происходит **распространение события**.[^9.4]

Есть несколько форм распространения событий:

- **Восходящие**: событие распространяется вверх по дереву DOM от дочерних узлов к родительским

- **Нисходящие**: событие распространяется вниз по дереву DOM от родительских узлов к дочерним, пока не достигнет того элемента, на котором это событие и возникло

#### Восходящие события
Рассмотрим восходящие (`bubbling`) события, которые распространяются в верх по дереву DOM. Допустим, у нас есть следующая веб-страница:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
    <style>
    #blueRect{
        width:100px;
        height:100px;
        background-color:blue;
    }
    #redRect{
        width:50px;
        height:50px;
        background-color:red;
    }
    </style>
</head>
<body>
    <div id="blueRect">
        <div id="redRect"></div>
    </div>
    <script>
    const redRect = document.getElementById("redRect");
    redRect.addEventListener("click", () => console.log("Событие на redRect"));

    const blueRect = document.getElementById("blueRect");
    blueRect.addEventListener("click", ()=>console.log("Событие на blueRect"));

    document.body.addEventListener("click", () => console.log("Событие на body"));
    </script>
</body>
</html>
```

Если мы нажмем на вложенный (красный) `div`, то событие пойдет к родительскому элементу `div` и далее к элементу `body`:

![Восходящие события в JavaScript](../img/bubbling.png)

##### Всплытие
Принцип всплытия очень простой.

**Когда на элементе происходит событие, обработчики сначала срабатывают на нём, потом на его родителе, затем выше и так далее, вверх по цепочке предков.**

Например, есть 3 вложенных элемента `FORM` > `DIV` > `P` с обработчиком на каждом:
```html
<style>
  body * {
    margin: 10px;
    border: 1px solid blue;
  }
</style>

<form onclick="alert('form')">FORM
  <div onclick="alert('div')">DIV
    <p onclick="alert('p')">P</p>
  </div>
</form>
```

![Event propagation](../img/bubbling_02.png)

Клик по внутреннему `<p>` вызовет обработчик `onclick`:

1. Сначала на самом `<p>`.
2. Потом на внешнем `<div>`.
3. Затем на внешнем `<form>`.
4. И так далее вверх по цепочке до самого `document`.

![Event order bubbling](../svg/event-order-bubbling.svg)

Поэтому если кликнуть на `<p>`, то мы увидим три оповещения: `p` → `div` → `form`.

Этот процесс называется «всплытием», потому что события «всплывают» от внутреннего элемента вверх через родителей подобно тому, как всплывает пузырёк воздуха в воде.

!!! warning "*Почти* все события всплывают."

    Ключевое слово в этой фразе – «почти».

    Например, событие `focus` не всплывает. В дальнейшем мы увидим и другие примеры. Однако, стоит понимать, что это скорее исключение, чем правило, всё-таки большинство событий всплывают.

##### Прекращение всплытия
Надо сказать, что подобное поведение не всегда является желательным. И в этом случае мы можем остановить распространение событие с помощью метода **`stopPropagation()`** объекта `Event`:
```js
const redRect = document.getElementById("redRect");
redRect.addEventListener("click", function(e){
    console.log("Событие на redRect");
    e.stopPropagation();
});
```

И в результате нажатия событие будет обработано только обработчиком для `redRect`.

Всплытие идёт с «целевого» элемента прямо наверх. По умолчанию событие будет всплывать до элемента `<html>`, а затем до объекта `document`, а иногда даже до `window`, вызывая все обработчики на своём пути.

Но любой промежуточный обработчик может решить, что событие полностью обработано, и остановить всплытие.

Для этого нужно вызвать метод `event.stopPropagation()`.

Например, здесь при клике на кнопку `<button>` обработчик `body.onclick` не сработает:
```html
<body onclick="alert(`сюда всплытие не дойдёт`)">
  <button onclick="event.stopPropagation()">Кликни меня</button>
</body>
```

![Event propagation](../img/bubbling_03.png)

Правда, у `stopPropagation()` есть одна проблема — он приостанавливает дальнейшее выполнение **текущего** обработчика. Однако если для одного и того же события элемента прикреплены несколько обработчиков событий, то остальные обработчики **данного элемента** продолжат выполняться. И чтобы оставить также выполнение всех остальных обработчиков подобных образом можно вызывать метод **`stopImmediatePropagation`**
```js
const redRect = document.getElementById("redRect");
function handler1(e){
    console.log("handler1: Событие на redRect");
    e.stopImmediatePropagation();   // останавливаем также выполнение handler2
}
function handler2(e){
    console.log("handler2: Событие на redRect");
}
redRect.addEventListener("click", handler1);
redRect.addEventListener("click", handler2);
```

!!! info "event.stopImmediatePropagation()"

    Если у элемента есть несколько обработчиков на одно событие, то даже при прекращении всплытия все они будут выполнены.

    То есть, `event.stopPropagation()` препятствует продвижению события дальше, но на текущем элементе все обработчики будут вызваны.

    Для того, чтобы полностью остановить обработку, существует метод event.`stopImmediatePropagation()`. Он не только предотвращает всплытие, но и останавливает обработку событий на текущем элементе.

!!! warning "Не прекращайте всплытие без необходимости!"

Всплытие – это удобно. Не прекращайте его без явной нужды, очевидной и архитектурно прозрачной.

Зачастую прекращение всплытия через `event.stopPropagation()` имеет свои подводные камни, которые со временем могут стать проблемами.

Например:

1. Мы делаем вложенное меню. Каждое подменю обрабатывает клики на своих элементах и делает для них `stopPropagation`, чтобы не срабатывало внешнее меню.
2. Позже мы решили отслеживать все клики в окне для какой-то своей функциональности, к примеру, для статистики – где вообще у нас кликают люди. Некоторые системы аналитики так делают. Обычно используют `document.addEventListener('click'…)`, чтобы отлавливать все клики.
3. Наша аналитика не будет работать над областью, где клики прекращаются `stopPropagation`. Увы, получилась «мёртвая зона».

Зачастую нет никакой необходимости прекращать всплытие. Задача, которая, казалось бы, требует этого, может быть решена иначе. Например, с помощью создания своего уникального события, о том, как это делать, мы поговорим позже. Также мы можем записывать какую-то служебную информацию в объект `event` в одном обработчике, а читать в другом, таким образом мы можем сообщить обработчикам на родительских элементах информацию о том, что событие уже было как-то обработано.

#### Целевой элемент
Всегда можно узнать, на каком конкретно элементе произошло событие.

**Самый глубокий элемент, который вызывает событие, называется <dfn title="целевой элемент">целевым элементом</dfn>, и он доступен через `event.target`.**

Отличия от `this` (=`event.currentTarget`):

- `event.target` – это «целевой» элемент, на котором произошло событие, в процессе всплытия он неизменен.
- `this` – это «текущий» элемент, до которого дошло всплытие, на нём сейчас выполняется обработчик.

Например, если стоит только один обработчик `form.onclick`, то он «поймает» все клики внутри формы. Где бы ни был клик внутри – он всплывёт до элемента `<form>`, на котором сработает обработчик.

При этом внутри обработчика `form.onclick`:

- `this` (=`event.currentTarget`) всегда будет элемент `<form>`, так как обработчик сработал на ней.
- `event.target` будет содержать ссылку на конкретный элемент внутри формы, на котором произошёл клик.

Возможна и ситуация, когда `event.target` и `this` – один и тот же элемент, например, если клик был непосредственно на самом элементе `<form>`, а не на его подэлементе.

#### Нисходящие события
События также могут быть нисходящими (*capturing*). Для их использования в метод **`addEventListener()`** в качестве третьего необязательного параметра передается логическое значение `true` или `false`. Значение **`true`** указывает, что событие нисходящим. По умолчанию все события восходящие.

Возьмем ту же веб-станицу, только изменим ее код javascript:
```js
const redRect = document.getElementById("redRect");
redRect.addEventListener("click", function(){
    console.log("Событие на redRect");
}, true);

const blueRect = document.getElementById("blueRect");
blueRect.addEventListener("click", function(){
    console.log("Событие на blueRect");
}, true);

document.body.addEventListener("click", function(){
    console.log("Событие на body");
}, true);
```

Теперь события будут распространяться в обратном порядке:

![Нисходящие события в JavaScript](../img/capturing.png)

##### Погружение
Существует ещё одна фаза из жизненного цикла события – «погружение» (иногда её называют «перехват»). Она очень редко используется в реальном коде, однако тоже может быть полезной.

Стандарт **DOM Events** описывает 3 фазы прохода события:

1. Фаза погружения (capturing phase) – событие сначала идёт сверху вниз.
2. Фаза цели (target phase) – событие достигло целевого (исходного) элемента.
3. Фаза всплытия (bubbling stage) – событие начинает всплывать.

Картинка из спецификации демонстрирует, как это работает при клике по ячейке `<td>`, расположенной внутри таблицы:

![Event flow](../svg/eventflow.svg)

То есть при клике на `<td>` событие путешествует по цепочке родителей сначала вниз к элементу (погружается), затем оно достигает целевой элемент (фаза цели), а потом идёт наверх (всплытие), вызывая по пути обработчики.

**Ранее мы говорили только о всплытии, потому что другие стадии, как правило, не используются и проходят незаметно для нас.**

Обработчики, добавленные через `on`*`<event>`*-свойство или через HTML-атрибуты, или через `addEventListener(event, handler)` с двумя аргументами, ничего не знают о фазе погружения, а работают только на 2-ой и 3-ей фазах.

Чтобы поймать событие на стадии погружения, нужно использовать третий аргумент `capture` вот так:
```js
elem.addEventListener(..., {capture: true})
// или просто "true", как сокращение для {capture: true}
elem.addEventListener(..., true)
```

Существуют два варианта значений опции `capture`:

- Если аргумент `false` (по умолчанию), то событие будет поймано при всплытии.
- Если аргумент `true`, то событие будет перехвачено при погружении.

Обратите внимание, что хоть и формально существует 3 фазы, 2-ую фазу («фазу цели»: событие достигло элемента) нельзя обработать отдельно, при её достижении вызываются все обработчики: и на всплытие, и на погружение.

Давайте посмотрим и всплытие и погружение в действии:
```html
<style>
  body * {
    margin: 10px;
    border: 1px solid blue;
  }
</style>

<form>FORM
  <div>DIV
    <p>P</p>
  </div>
</form>

<script>
  for(let elem of document.querySelectorAll('*')) {
    elem.addEventListener("click", e => alert(`Погружение: ${elem.tagName}`), true);
    elem.addEventListener("click", e => alert(`Всплытие: ${elem.tagName}`));
  }
</script>
```

![Event propagation](../img/bubbling_04.png)

Здесь обработчики навешиваются на *каждый* элемент в документе, чтобы увидеть в каком порядке они вызываются по мере прохода события.

Если вы кликните по `<p>`, то последовательность следующая:

1. `HTML` → `BODY` → `FORM` → `DIV` (фаза погружения, первый обработчик)
2. `P` (фаза цели, срабатывают обработчики, установленные и на погружение и на всплытие, так что выведется два раза)
3. `DIV` → `FORM` → `BODY` → `HTML` (фаза всплытия, второй обработчик)

Существует свойство `event.eventPhase`, содержащее номер фазы, на которой событие было поймано. Но оно используется редко, мы обычно и так знаем об этом в обработчике.

!!! info "Чтобы убрать обработчик `removeEventListener`, нужна та же фаза"

    Если мы добавили обработчик как `addEventListener(..., true)`, то мы должны передать то же значение аргумента capture в `removeEventListener(..., true)`, когда снимаем обработчик.

!!! info "На каждой фазе разные обработчики на одном элементе срабатывают в порядке назначения"

    Если у нас несколько обработчиков одного события, назначенных `addEventListener` на один элемент, в рамках одной фазы, то их порядок срабатывания – тот же, в котором они установлены:
    ```js
    elem.addEventListener("click", e => alert(1)); // всегда сработает перед следующим
    elem.addEventListener("click", e => alert(2));
    ```

#### Итого
При наступлении события – самый глубоко вложенный элемент, на котором оно произошло, помечается как «целевой» (`event.target`).

- Затем событие сначала двигается вниз от корня документа к `event.target`, по пути вызывая обработчики, поставленные через `addEventListener(...., true)`, где `true` – это сокращение для `{capture: true}`.
- Далее обработчики вызываются на целевом элементе.
- Далее событие двигается от `event.target` вверх к корню документа, по пути вызывая обработчики, поставленные через `on`*`<event>`* и `addEventListener` без третьего аргумента или с третьим аргументом равным `false`.

Каждый обработчик имеет доступ к свойствам события `event`:

- `event.target` – самый глубокий элемент, на котором произошло событие.
- `event.currentTarget` (=`this`) – элемент, на котором в данный момент сработал обработчик (тот, на котором «висит» конкретный обработчик)
- `event.eventPhase` – на какой фазе он сработал (погружение=1, фаза цели=2, всплытие=3).

Любой обработчик может остановить событие вызовом `event.stopPropagation()`, но делать это не рекомендуется, так как в дальнейшем это событие может понадобиться, иногда для самых неожиданных вещей.

В современной разработке стадия погружения используется очень редко, обычно события обрабатываются во время всплытия. И в этом есть логика.

В реальном мире, когда происходит чрезвычайная ситуация, местные службы реагируют первыми. Они знают лучше всех местность, в которой это произошло, и другие детали. Вышестоящие инстанции подключаются уже после этого и при необходимости.

То же самое справедливо для обработчиков событий. Код, который «навесил» обработчик на конкретный элемент, знает максимум деталей об элементе и его предназначении. Например, обработчик на определённом `<td>` скорее всего подходит только для этого конкретного `<td>`, он знает все о нём, поэтому он должен отработать первым. Далее имеет смысл передать обработку события родителю – он тоже понимает, что происходит, но уже менее детально, далее – выше, и так далее, до самого объекта `document`, обработчик на котором реализовывает самую общую функциональность уровня документа.

Всплытие и погружение являются основой для «делегирования событий» – очень мощного приёма обработки событий. Его мы изучим в следующей главе.[^bubbling-and-capturing]

### Делегирование событий
Всплытие и перехват событий позволяет реализовать один из самых важных приёмов разработки – *делегирование*.[^event-delegation]

Идея в том, что если у нас есть много элементов, события на которых нужно обрабатывать похожим образом, то вместо того, чтобы назначать обработчик каждому, мы ставим один обработчик на их общего предка.

Из него можно получить целевой элемент `event.target`, понять на каком именно потомке произошло событие и обработать его.

Рассмотрим пример – [диаграмму Ба-Гуа](https://ru.wikipedia.org/wiki/%D0%92%D0%BE%D1%81%D0%B5%D0%BC%D1%8C_%D1%82%D1%80%D0%B8%D0%B3%D1%80%D0%B0%D0%BC%D0%BC). Это таблица, отражающая древнюю китайскую философию.

Вот она:

![Bagua](../img/bagua.png)

Её HTML (схематично):
```html
<table>
  <tr>
    <th colspan="3">Квадрат <em>Bagua</em>: Направление, Элемент, Цвет, Значение</th>
  </tr>
  <tr>
    <td>...<strong>Северо-Запад</strong>...</td>
    <td>...</td>
    <td>...</td>
  </tr>
  <tr>...ещё 2 строки такого же вида...</tr>
  <tr>...ещё 2 строки такого же вида...</tr>
</table>
```

В этой таблице всего 9 ячеек, но могло бы быть и 99, и даже 9999, не важно.

**Наша задача – реализовать подсветку ячейки `<td>` при клике.**

Вместо того, чтобы назначать обработчик `onclick` для каждой ячейки `<td>` (их может быть очень много) – мы повесим «единый» обработчик на элемент `<table>`.

Он будет использовать `event.target`, чтобы получить элемент, на котором произошло событие, и подсветить его.

Код будет таким:
```js
let selectedTd;

table.onclick = function(event) {
  let target = event.target; // где был клик?

  if (target.tagName != 'TD') return; // не на TD? тогда не интересует

  highlight(target); // подсветить TD
};

function highlight(td) {
  if (selectedTd) { // убрать существующую подсветку, если есть
    selectedTd.classList.remove('highlight');
  }
  selectedTd = td;
  selectedTd.classList.add('highlight'); // подсветить новый td
}
```

Такому коду нет разницы, сколько ячеек в таблице. Мы можем добавлять, удалять `<td>` из таблицы динамически в любое время, и подсветка будет стабильно работать.

Однако, у текущей версии кода есть недостаток.

Клик может быть не на теге `<td>`, а внутри него.

В нашем случае, если взглянуть на HTML-код таблицы внимательно, видно, что ячейка `<td>` содержит вложенные теги, например `<strong>`:
```html
<td>
  <strong>Северо-Запад</strong>
  ...
</td>
```

Естественно, если клик произойдёт на элементе `<strong>`, то он станет значением `event.target`.

![Bagua bubble](../svg/bagua-bubble.svg)

Внутри обработчика `table.onclick` мы должны по `event.target` разобраться, был клик внутри `<td>` или нет.

Вот улучшенный код:
```js
table.onclick = function(event) {
  let td = event.target.closest('td'); // (1)

  if (!td) return; // (2)

  if (!table.contains(td)) return; // (3)

  highlight(td); // (4)
};
```

Разберём пример:

1. Метод `elem.closest(selector)` возвращает ближайшего предка, соответствующего селектору. В данном случае нам нужен `<td>`, находящийся выше по дереву от исходного элемента.
2. Если `event.target` не содержится внутри элемента `<td>`, то вызов вернёт `null`, и ничего не произойдёт.
3. Если таблицы вложенные, `event.target` может содержать элемент `<td>`, находящийся вне текущей таблицы. В таких случаях мы должны проверить, действительно ли это `<td>` *нашей таблицы*.
4. И если это так, то подсвечиваем его.

В итоге мы получили короткий код подсветки, быстрый и эффективный, которому совершенно не важно, сколько всего в таблице `<td>`.

#### Применение делегирования: действия в разметке
Есть и другие применения делегирования.

Например, нам нужно сделать меню с разными кнопками: «Сохранить (save)», «Загрузить (load)», «Поиск (search)» и т.д. И есть объект с соответствующими методами `save`, `load`, `search`… Как их состыковать?

Первое, что может прийти в голову – это найти каждую кнопку и назначить ей свой обработчик среди методов объекта. Но существует более элегантное решение. Мы можем добавить один обработчик для всего меню и атрибуты `data-action` для каждой кнопки в соответствии с методами, которые они вызывают:
```html
<button data-action="save">Нажмите, чтобы Сохранить</button>
```

Обработчик считывает содержимое атрибута и выполняет метод. Взгляните на рабочий пример:
```html
<div id="menu">
  <button data-action="save">Сохранить</button>
  <button data-action="load">Загрузить</button>
  <button data-action="search">Поиск</button>
</div>

<script>
  class Menu {
    constructor(elem) {
      elem.onclick = this.onClick.bind(this); // (*)
    }

    save() {
      alert('сохраняю');
    }

    load() {
      alert('загружаю');
    }

    search() {
      alert('ищу');
    }

    onClick(event) {
      let action = event.target.dataset.action;
      if (action) {
        this[action]();
      }
    }
  }

  new Menu(menu);
</script>
```

![Event delegation](../img/event-delegation_01.png)

Обратите внимание, что метод `this.onClick` в строке, отмеченной звёздочкой `(*)`, привязывается к контексту текущего объекта `this`. Это важно, т.к. иначе `this` внутри него будет ссылаться на DOM-элемент (`elem`), а не на объект `Menu`, и `this[action]` будет не тем, что нам нужно.

Так что же даёт нам здесь делегирование?

- Не нужно писать код, чтобы присвоить обработчик каждой кнопке. Достаточно просто создать один метод и поместить его в разметку.
- Структура HTML становится по-настоящему гибкой. Мы можем добавлять/удалять кнопки в любое время.

Мы также можем использовать классы `.action-save`, `.action-load`, но подход с использованием атрибутов `data-action` является более семантичным. Их можно использовать и для стилизации в правилах CSS.

#### Приём проектирования «поведение»
Делегирование событий можно использовать для добавления элементам «поведения» (behavior), *декларативно* задавая хитрые обработчики установкой специальных HTML-атрибутов и классов.

Приём проектирования «поведение» состоит из двух частей:

1. Элементу ставится пользовательский атрибут, описывающий его поведение.
2. При помощи делегирования ставится обработчик на документ, который ловит все клики (или другие события) и, если элемент имеет нужный атрибут, производит соответствующее действие.

##### Поведение: «Счётчик»
Например, здесь HTML-атрибут `data-counter` добавляет кнопкам поведение: «увеличить значение при клике»:
```html
Счётчик: <input type="button" value="1" data-counter>
Ещё счётчик: <input type="button" value="2" data-counter>

<script>
  document.addEventListener('click', function(event) {

    if (event.target.dataset.counter != undefined) { // если есть атрибут...
      event.target.value++;
    }

  });
</script>
```

![Event delegation](../img/event-delegation_02.png)

Если нажать на кнопку – значение увеличится. Конечно, нам важны не счётчики, а общий подход, который здесь продемонстрирован.

Элементов с атрибутом `data-counter` может быть сколько угодно. Новые могут добавляться в HTML-код в любой момент. При помощи делегирования мы фактически добавили новый «псевдостандартный» атрибут в HTML, который добавляет элементу новую возможность («поведение»).

!!! warning Всегда используйте метод `addEventListener` для обработчиков на уровне документа

    Когда мы устанавливаем обработчик событий на объект `document`, мы всегда должны использовать метод `addEventListener`, а не `document.on<событие>`, т.к. в случае последнего могут возникать конфликты: новые обработчики будут перезаписывать уже существующие.

    Для реального проекта совершенно нормально иметь много обработчиков на элементе document, установленных из разных частей кода.

##### Поведение: «Переключатель» (Toggler)
Ещё один пример поведения. Сделаем так, что при клике на элемент с атрибутом `data-toggle-id` будет скрываться/показываться элемент с заданным `id`:
```html
<button data-toggle-id="subscribe-mail">
  Показать форму подписки
</button>

<form id="subscribe-mail" hidden>
  Ваша почта: <input type="email">
</form>

<script>
  document.addEventListener('click', function(event) {
    let id = event.target.dataset.toggleId;
    if (!id) return;

    let elem = document.getElementById(id);

    elem.hidden = !elem.hidden;
  });
</script>
```

![Event delegation](../img/event-delegation_03.png)

Ещё раз подчеркнём, что мы сделали. Теперь для того, чтобы добавить скрытие-раскрытие любому элементу, даже не надо знать JavaScript, можно просто написать атрибут `data-toggle-id`.

Это бывает очень удобно – не нужно писать JavaScript-код для каждого элемента, который должен так себя вести. Просто используем поведение. Обработчики на уровне документа сделают это возможным для элемента в любом месте страницы.

Мы можем комбинировать несколько вариантов поведения на одном элементе.

Шаблон «поведение» может служить альтернативой для фрагментов JS-кода в вёрстке.

#### Итого
Делегирование событий – это здорово! Пожалуй, это один из самых полезных приёмов для работы с DOM.

Он часто используется, если есть много элементов, обработка которых очень схожа, но не только для этого.

Алгоритм:

1. Вешаем обработчик на контейнер.
2. В обработчике проверяем исходный элемент `event.target`.
3. Если событие произошло внутри нужного нам элемента, то обрабатываем его.
Зачем использовать:

Зачем использовать:

- Упрощает процесс инициализации и экономит память: не нужно вешать много обработчиков.
- Меньше кода: при добавлении и удалении элементов не нужно ставить или снимать обработчики.
- Удобство изменений DOM: можно массово добавлять или удалять элементы путём изменения `innerHTML` и ему подобных.

Конечно, у делегирования событий есть свои ограничения:

- Во-первых, событие должно всплывать. Некоторые события этого не делают. Также, низкоуровневые обработчики не должны вызывать `event.stopPropagation()`.
- Во-вторых, делегирование создаёт дополнительную нагрузку на браузер, ведь обработчик запускается, когда событие происходит в любом месте контейнера, не обязательно на элементах, которые нам интересны. Но обычно эта нагрузка настолько пустяковая, что её даже не стоит принимать во внимание.

#### Задачи

##### Спрячьте сообщения с помощью делегирования

Дан список сообщений с кнопками для удаления `[x]`. Заставьте кнопки работать.

В результате должно работать вот так:

![Hide messages](../img/hide-messages.png)

P.S. Используйте делегирование событий. Должен быть лишь один обработчик на элементе-контейнере для всего.

<details>
<summary>Решение</summary>

[Код решения](../src/11_events/hide-messages.html)

</details>

##### Раскрывающееся дерево

Создайте дерево, которое по клику на заголовок скрывает-показывает потомков:

![](../img/expanding-tree.png)

Требования:

- Использовать только один обработчик событий (применить делегирование)
- Клик вне текста заголовка (на пустом месте) ничего делать не должен.

<details>
<summary>Решение</summary>

Решение состоит из двух шагов:

1. Оборачиваем текст каждого заголовка дерева в элемент `<span>`. Затем мы можем добавить стили CSS на `:hover` и обрабатывать клики только на тексте, т.к. ширина элемента `<span>` в точности совпадает с шириной текста.
2. Устанавливаем обработчик на корневой узел дерева `tree` и ловим клики на элементах `<span>`, содержащих заголовки.

[Код решения](../src/11_events/expanding-tree.html)

</details>

##### Сортируемая таблица

Сделать таблицу сортируемой: при клике на элемент `<th>` строки таблицы должны сортироваться по соответствующему столбцу.

Каждый элемент `<th>` имеет атрибут `data-type`:
```html
<table id="grid">
  <thead>
    <tr>
      <th data-type="number">Возраст</th>
      <th data-type="string">Имя</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>5</td>
      <td>Вася</td>
    </tr>
    <tr>
      <td>10</td>
      <td>Петя</td>
    </tr>
    ...
  </tbody>
</table>
```

В примере выше первый столбец содержит числа, а второй – строки. Функция сортировки должна это учитывать, ведь числа сортируются иначе, чем строки.

Сортировка должна поддерживать только типы `"string"` и `"number"`.

Работающий пример:

![Sorting table example](../img/sorting-table-example.png)

P.S. Таблица может быть большой, с любым числом строк и столбцов.

<details>
<summary>Решение</summary>

[Код решения](../src/11_events/sortable-table.html)

</details>

##### Поведение "подсказка"

Напишите JS-код, реализующий поведение «подсказка».

При наведении мыши на элемент с атрибутом `data-tooltip`, над ним должна показываться подсказка и скрываться при переходе на другой элемент.

Пример HTML с подсказками:
```html
<button data-tooltip="эта подсказка длиннее, чем элемент">Короткая кнопка</button>
<button data-tooltip="HTML<br>подсказка">Ещё кнопка</button>
```

Иллюстрация результата:

![Tooltip](../img/tooltip_01.png)

В этой задаче мы полагаем, что во всех элементах с атрибутом `data-tooltip` только текст. То есть, в них нет вложенных тегов (пока).

Детали оформления:

1. Отступ от подсказки до элемента с `data-tooltip` должен быть 5px по высоте.
2. Подсказка должна быть, по возможности, посередине элемента.
3. Подсказка не должна вылезать за границы экрана, в том числе если страница частично прокручена, если нельзя показать сверху – показывать снизу элемента.
4. Текст подсказки брать из значения атрибута `data-tooltip`. Это может быть произвольный HTML.
5. В один момент может быть показана только одна подсказка.

Иллюстрация поведения:

![Tooltip](../img/tooltip_02.png)

![Tooltip](../img/tooltip_03.png)

![Tooltip](../img/tooltip_04.png)

![Tooltip](../img/tooltip_05.png)

Для решения понадобятся два события:

- `mouseover` срабатывает, когда указатель мыши заходит на элемент.
- `mouseout` срабатывает, когда указатель мыши уходит с элемента.

Применить делегирование событий: установить оба обработчика на элемент `document`, чтобы отслеживать «заход» и «уход» курсора на элементы с атрибутом `data-tooltip` и управлять подсказками с их же помощью.

После реализации такого поведения люди, даже не знакомые с JavaScript должны иметь возможность добавлять подсказки к элементам.

P.S. В один момент может быть показана только одна подсказка.

<details>
<summary>Решение</summary>

[Код решения](../src/11_events/data-tooltip.html)

</details>

### Программный вызов событий
События могут возникать не только в следствие действий пользователя на веб-странице. События также можно генерировать программно.

Чтобы программно вызвать событие, у элемента на веб-странице можно вызвать метод `dispatchEvent()`, в который передается экземпляр объекта `Event` (либо его производные типа `MouseEvent` или `KeybordEvent`).

```js
const event = new Event(имя_события, config);   //  определяем объект события
element.dispatchEvent(event);   //   вызываем событие для элемента element
```

Первый аргумент, передаваемый конструктору `Event`, представляет собой строку — тип события. Дополнительно в качестве второго параметра можно передать объект конфигурации. В частности, с помощью объекта конфигурации можно определить следующие свойства:

- `cancelable`: можно ли событие отменить (если `true`, то отменяемое событие, `false` — неотменяемое)

- `bubbles`: должно ли событие быть восходящим (если `true`, то восходящее)


Например, программно нажмем на ссылку:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <a id="link" href="https://example.com">example</a>
    <script>
    const link = document.getElementById("link");   // получаем ссылку
    const event = new MouseEvent("click");
    link.dispatchEvent(event);
    </script>
</body>
</html>
```

Нажатие на ссылку представляет событие мыши "click", поэтому определяем объект события типа `MouseEvent`:
```js
const event = new MouseEvent("click");
```

Затем вызываем событие для элемента `link`:
```js
link.dispatchEvent(event);
```

В итоге произойдет переход по ссылке уже при загрузке страницы.

И как в общем случае, это событие также можно обработать:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <a id="link" href="https://example.com">example</a>
    <script>
    const link = document.getElementById("link");

    link.addEventListener("click", (e)=>{
        console.log("Link has been clicked");
        e.preventDefault();     // предупреждаем переход
    });

    const event = new MouseEvent("click", {cancelable:true});
    link.dispatchEvent(event);
    </script>
</body>
</html>
```

Чтобы выполнение события можно было остановить, в конструктор `MouseEvent` в качестве второго параметра передаем конфигурационных объект с одним свойством: `cancelable:true` указывает, что можно остановить обработку события. Благодаря этому в обработчике события "click" можно вызвать метод `e.preventDefault()`.[^9.7]

#### Конструктор Event
Встроенные классы для событий формируют иерархию аналогично классам для DOM-элементов. Её корнем является встроенный класс `Event`.

Событие встроенного класса `Event` можно создать так:
```js
let event = new Event(type[, options]);
```

Где:

- `type` – тип события, строка, например "click" или же любой придуманный нами – "my-event".
- `options` – объект с тремя необязательными свойствами:
  - `bubbles: true/false` – если `true`, тогда событие всплывает.
  - `cancelable: true/false` – если `true`, тогда можно отменить действие по умолчанию. Позже мы разберём, что это значит для пользовательских событий.
  - `composed: true/false` – если `true`, тогда событие будет всплывать наружу за пределы Shadow DOM. Позже мы разберём это в разделе Веб-компоненты.

По умолчанию все три свойства установлены в `false`: `{bubbles: false, cancelable: false, composed: false}`.[^dispatch-events]

#### Метод dispatchEvent
После того, как объект события создан, мы должны запустить его на элементе, вызвав метод `elem.dispatchEvent(event)`.

Затем обработчики отреагируют на него, как будто это обычное браузерное событие. Если при создании указан флаг `bubbles`, то оно будет всплывать.

В примере ниже событие `click` инициируется JavaScript-кодом так, как будто кликнули по кнопке:
```html
<button id="elem" onclick="alert('Клик!');">Автоклик</button>

<script>
  let event = new Event("click");
  elem.dispatchEvent(event);
</script>
```

!!! info "event.isTrusted"

    Можно легко отличить «настоящее» событие от сгенерированного кодом.

    Свойство `event.isTrusted` принимает значение `true` для событий, порождаемых реальными действиями пользователя, и `false` для генерируемых кодом.

#### MouseEvent, KeyboardEvent и другие
Для некоторых конкретных типов событий есть свои специфические конструкторы. Вот небольшой список конструкторов для различных событий пользовательского интерфейса, которые можно найти в спецификации [UI Event](https://www.w3.org/TR/uievents):

- `UIEvent`
- `FocusEvent`
- `MouseEvent`
- `WheelEvent`
- `KeyboardEvent`
…

Стоит использовать их вместо new `Event`, если мы хотим создавать такие события. К примеру, `new MouseEvent("click")`.

Специфический конструктор позволяет указать стандартные свойства для данного типа события.

Например, `clientX/clientY` для события мыши:
```js
let event = new MouseEvent("click", {
  bubbles: true,
  cancelable: true,
  clientX: 100,
  clientY: 100
});

alert(event.clientX); // 100
```
Обратите внимание: этого нельзя было бы сделать с обычным конструктором `Event`.

Давайте проверим:
```js
let event = new Event("click", {
  bubbles: true, // только свойства bubbles и cancelable
  cancelable: true, // работают в конструкторе Event
  clientX: 100,
  clientY: 100
});

alert(event.clientX); // undefined, неизвестное свойство проигнорировано!
```

Впрочем, использование конкретного конструктора не является обязательным, можно обойтись `Event`, а свойства записать в объект отдельно, после создания, вот так: `event.clientX=100`. Здесь это скорее вопрос удобства и желания следовать правилам. События, которые генерирует браузер, всегда имеют правильный тип.

Полный список свойств по типам событий вы найдёте в спецификации, например, [MouseEvent](https://www.w3.org/TR/uievents/#mouseevent).[^dispatch-events]

### Определение своих событий
Возможность программной генерации событий открывает нам путь к созданию кастомных событий — мы можем определять и вызывать произвольные события.[^9.8]

Можно не только назначать обработчики, но и генерировать события из JavaScript-кода.

Пользовательские события могут быть использованы при создании графических компонентов. Например, корневой элемент нашего меню, реализованного при помощи JavaScript, может генерировать события, относящиеся к этому меню: `open` (меню раскрыто), `select` (выбран пункт меню) и т.п. А другой код может слушать эти события и узнавать, что происходит с меню.

Можно генерировать не только совершенно новые, придуманные нами события, но и встроенные, такие как `click`, `mousedown` и другие. Это бывает полезно для автоматического тестирования.[^dispatch-events]

Например, у нас есть функция-конструктор `Account`, которая принимает количество денег и создает условный денежный счет:
```js
function Account(money) {
    _money = money;
    this.pay=function(sum){
        if(_money >= sum){
            _money -= sum;
            console.log(_money);
        }
    }
}
```

В переменной `_money` хранится текущее количество денег на счете. С помощью функции pay условно тратим определенную сумму, если баланс позволяет. Но, допустим, нам надо как-то извещать систему, что произошло списание со счета. С одно стороны, мы могли бы это делать непосредственно в методе `pay` — вызывать в методе `console.log()` и выводить на консоль какой-то текст. Но на момент написания этого кода мы можем быть не уверены, какой именно текст надо выводить на консоль. А может быть потребуется и не на консоль, а в окне браузере. Или посылать извещение на определенный сетевой ресурс. А может наша функция-конструктор будет использоваться в Node.js, где может потребоваться какая-то другая обработка. Да и использовать нашу функцию-конструктор могут совсем другие разработчики, у которых может быть собственно понимание того, что надо делать при списании средств. В любом случае мы сталкиваемся с многовариантностью, но во всех этих ситуация главное, что нам надо сделать — уведомить систему, что произошло списание средств. И охватить все эти ситуации нам поможет определение собственных событий.

Для определения кастомных событий мы можем применять конструктор **`Event`**, в который передается название события. Так, рассмотрим следующую программу:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <button id="btn">Pay</button>
    <script>
    const button = document.getElementById("btn");
    const myAcc = new Account(100); // условный денежный счет
    // устанавливаем обработчик события payment для всего документа
    document.addEventListener("payment", ()=>console.log("Payment succeeded!"));

    // по нажатию на кнопку выполняем метод pay
    button.addEventListener("click", ()=>myAcc.pay(50));
    // конструктор объекта счета
    function Account(money) {
        _money = money;
        this.pay=function(sum){
            if(_money >= sum){
                _money -= sum;
                console.log(_money);

                const event = new Event("payment"); // определяем объект события
                document.dispatchEvent(event);      // генерируем событие для всего документа
            }
        }
    }
    </script>
</body>
</html>
```

Основные моменты. В методе `pay` создаем объект `Event`, которое будет представлять событие "payment" (не важно, что такого события изначально не существует, мы сами его создаем). Затем генерируем это событие:
```js
const event = new Event("payment"); // определяем объект события
document.dispatchEvent(event);      // генерируем событие для всего документа
```

Стоит отметить, что событие генерируется для всего документа: **`document`**.`dispatchEvent(event)`, но это может быть любой конкретный элемент веб-страницы.

Чтобы обработать это событие, подписываемся на него:
```js
document.addEventListener("payment", ()=>console.log("Payment succeeded!"));
```

Опять же подписка на событие производится для всего документа. Обработчик события просто выводит строку на консоль.

По нажатию на кнопку вызываем метод pay объекта myAcc и тем самым генерируем событие "payment" (если на счете достаточно средств).

Для тестирования понажимаем на кнопку:

![Создание своих событий в JavaScript](../img/customevent1.png)

Также, как и в общем случае, мы можем получить объект подобное события в обработчике:
```js
// получаем через параметр e объект события
document.addEventListener("payment", (e)=>{
    console.log(e.type);                //  payment
    console.log("Payment succeeded!");
});
```

#### Пример всплытия
Мы можем создать всплывающее событие с именем `"hello"` и поймать его на `document`.

Всё, что нужно сделать – это установить флаг `bubbles` в `true`:
```html
<h1 id="elem">Привет из кода!</h1>

<script>
  // ловим на document...
  document.addEventListener("hello", function(event) { // (1)
    alert("Привет от " + event.target.tagName); // Привет от H1
  });

  // ...запуск события на элементе!
  let event = new Event("hello", {bubbles: true}); // (2)
  elem.dispatchEvent(event);

  // обработчик на document сработает и выведет сообщение.

</script>
```

Обратите внимание:

1. Мы должны использовать `addEventListener` для наших собственных событий, т.к. `on<event>`-свойства существуют только для встроенных событий, то есть `document.onhello` не сработает.
2. Мы обязаны передать флаг `bubbles:true`, иначе наше событие не будет всплывать.

Механизм всплытия идентичен как для встроенного события (`click`), так и для пользовательского события (`hello`). Также одинакова работа фаз всплытия и погружения.[^dispatch-events]

#### CustomEvent
Однако тип `Event` хотя и может использоваться, но не очень подходит для определения кастомных событий. Например, что, если мы хотим передать в обработчик события какую-то дополнительную информацию — сумму списания, текущий баланс или что-то еще?

Для генерации событий совершенно новых типов, таких как "hello", следует использовать конструктор `new CustomEvent`. Технически `CustomEvent` абсолютно идентичен `Event` за исключением одной небольшой детали.

У второго аргумента-объекта есть дополнительное свойство `detail`, в котором можно указывать информацию для передачи в событие.

Например:
```html
<h1 id="elem">Привет для Васи!</h1>

<script>
  // дополнительная информация приходит в обработчик вместе с событием
  elem.addEventListener("hello", function(event) {
    alert(event.detail.name);
  });

  elem.dispatchEvent(new CustomEvent("hello", {
    detail: { name: "Вася" }
  }));
</script>
```

Таким образом, для подобных случаев лучше использовать тип **`CustomEvent`**. Так, изменим код JavaScript следующим образом:
```js
const button = document.getElementById("btn");
document.addEventListener("payment", (e)=>{
    console.log("Payment succeeded!");
    console.log("Payment Sum:", e.detail.paymentSum);   // получаем данные события
    console.log("Current balance:", e.detail.balance);
});

const myAcc = new Account(100);
// по нажатию на кнопку выполняем метод pay
button.addEventListener("click", ()=>myAcc.pay(50));

function Account(money) {
    _money = money;
    this.pay=function(sum){
        if(_money >= sum){
            _money -= sum;
            // определяем объект события
            const event = new CustomEvent("payment", {
                detail:{                //  передаем в CustomEvent данные о событии
                    paymentSum: sum,
                    balance: _money
                }
            });
            document.dispatchEvent(event);      // генерируем событие для всего документа
        }
    }
}
```


В `CustomEvent` в качестве второго параметра передается конфигурационный объект, который имеет свойство **`detail`**. Это свойство в свою очередь представляет объект с произвольным набором свойств. В данном случае мы определяем в нем свойства `paymentSum` и `balance` и передаем этим свойствам интересующие нас значения:
```js
const event = new CustomEvent("payment", {
    detail:{
        paymentSum: sum,
        balance: _money
    }
});
```

Свойство `detail` может содержать любые данные. Надо сказать, что никто не мешает и в обычное `new Event` записать любые свойства. Но `CustomEvent` предоставляет специальное поле `detail` во избежание конфликтов с другими свойствами события.

Кроме того, класс события описывает, что это за событие, и если оно не браузерное, а пользовательское, то лучше использовать `CustomEvent`, чтобы явно об этом сказать.

Далее передаем объект `CustomEvent` (как и `Event`) в `dispatchEvent` и тем самым генерируем событие:
```js
document.dispatchEvent(event);
```

При обработке события мы можем получить переданные данные через свойство `detail`:
```js
document.addEventListener("payment", (e)=>{
    console.log("Payment succeeded!");
    console.log("Payment Sum:", e.detail.paymentSum);   // получаем данные события
    console.log("Current balance:", e.detail.balance);
});
```

Пример консольного вывода при первом нажатии кнопки:
```
Payment succeeded!
Payment Sum: 50
Current balance: 50
```

Подобным образом можно определять и другие события. Например, определим еще одно событие на случай, если средств недостаточно для совершения платежа:
```js
const button = document.getElementById("btn");
document.addEventListener("payment_success", (e)=>{
    console.log("Payment succeeded!");
    console.log("Payment Sum:", e.detail.paymentSum);
    console.log("Current balance:", e.detail.balance);
});
document.addEventListener("payment_fail", (e)=>{
    console.error("Payment failed");
    console.error("Current balance:", e.detail.balance, "Requested Sum: ", e.detail.paymentSum);
});
const myAcc = new Account(100);
button.addEventListener("click", ()=>myAcc.pay(50));

function Account(money) {
    _money = money;
    this.pay=function(sum){
        const data = {
            paymentSum: sum,
            balance: _money
        };
        if(_money >= sum){
            _money -= sum;

            const event = new CustomEvent("payment_success", {
                detail: data
            });
            document.dispatchEvent(event);
        }
        else{
            const event = new CustomEvent("payment_fail", {
                detail: data
            });
            document.dispatchEvent(event);
        }
    }
}
```

Теперь, если средстd достаточно на счете генерируется событие "payment_success", а если недостаточно — то "payment_fail". И для каждого из этих событий определяем свой обработчик.

консольный вывод программы (при трех нажатиях на кнопку):
```
Payment succeeded!
Payment Sum: 50
Current balance: 100
Payment succeeded!
Payment Sum: 50
Current balance: 50
Payment failed
Current balance: 0 Requested Sum:  50
```

#### event.preventDefault()
Для многих браузерных событий есть «действия по умолчанию», такие как переход по ссылке, выделение и т.п.

Для новых, пользовательских событий браузерных действий, конечно, нет, но код, который генерирует такое событие, может предусматривать какие-то свои действия после события.

Вызов `event.preventDefault()` является возможностью для обработчика события сообщить в сгенерировавший событие код, что эти действия надо отменить.

Тогда вызов `elem.dispatchEvent(event)` возвратит `false`. И код, сгенерировавший событие, узнает, что продолжать не нужно.

Посмотрим практический пример – прячущегося кролика (могло бы быть скрывающееся меню или что-то ещё).

Ниже вы можете видеть кролика `#rabbit` и функцию `hide()`, которая при вызове генерирует на нём событие `"hide"`, уведомляя всех интересующихся, что кролик собирается спрятаться.

Любой обработчик может узнать об этом, подписавшись на событие `hide` через `rabbit.addEventListener('hide',...)` и, при желании, отменить действие по умолчанию через `event.preventDefault()`. Тогда кролик не исчезнет:
```html
<pre id="rabbit">
  |\   /|
   \|_|/
   /. .\
  =\_Y_/=
   {>o<}
</pre>
<button onclick="hide()">Hide()</button>

<script>
  // hide() будет вызван при щелчке на кнопке
  function hide() {
    let event = new CustomEvent("hide", {
      cancelable: true // без этого флага preventDefault не сработает
    });
    if (!rabbit.dispatchEvent(event)) {
      alert('Действие отменено обработчиком');
    } else {
      rabbit.hidden = true;
    }
  }

  rabbit.addEventListener('hide', function(event) {
    if (confirm("Вызвать preventDefault?")) {
      event.preventDefault();
    }
  });
</script>
```

![Dispatch event](../img/dispatch-events_01.png)

Обратите внимание: событие должно содержать флаг `cancelable: true`. Иначе, вызов `event.preventDefault()` будет проигнорирован.

#### Вложенные события обрабатываются синхронно
Обычно события обрабатываются асинхронно. То есть, если браузер обрабатывает `onclick` и в процессе этого произойдёт новое событие, то оно ждёт, пока закончится обработка `onclick`.

Исключением является ситуация, когда событие инициировано из обработчика другого события.

Тогда управление сначала переходит в обработчик вложенного события и уже после этого возвращается назад.

В примере ниже событие `menu-open` обрабатывается синхронно во время обработки `onclick`:
```html
<button id="menu">Меню (нажми меня)</button>

<script>
  menu.onclick = function() {
    alert(1);

    // alert("вложенное событие")
    menu.dispatchEvent(new CustomEvent("menu-open", {
      bubbles: true
    }));

    alert(2);
  };

  document.addEventListener('menu-open', () => alert('вложенное событие'))
</script>
```

![Dispatch event](../img/dispatch-events_02.png)

Порядок вывода: 1 → вложенное событие → 2.

Обратите внимание, что вложенное событие `menu-open` успевает всплыть и запустить обработчик на `document`. Обработка вложенного события полностью завершается до того, как управление возвращается во внешний код (`onclick`).

Это справедливо не только для `dispatchEvent`, но и для других ситуаций. JavaScript в обработчике события может вызвать другие методы, которые приведут к другим событиям – они тоже обрабатываются синхронно.

Если нам это не подходит, то мы можем либо поместить `dispatchEvent` (или любой другой код, инициирующий события) в конец обработчика `onclick`, либо, если это неудобно, можно обернуть генерацию события в `setTimeout` с нулевой задержкой:
```html
<button id="menu">Меню (нажми меня)</button>

<script>
  menu.onclick = function() {
    alert(1);

    // alert(2)
    setTimeout(() => menu.dispatchEvent(new CustomEvent("menu-open", {
      bubbles: true
    })));

    alert(2);
  };

  document.addEventListener('menu-open', () => alert('вложенное событие'))
</script>
```

Теперь `dispatchEvent` запускается асинхронно после исполнения текущего кода, включая `menu.onclick`, поэтому обработчики полностью независимы.

Новый порядок вывода: 1 → 2 → вложенное событие.

#### Итого
Чтобы сгенерировать событие из кода, вначале надо создать объект события.

Базовый конструктор `Event(name, options)` принимает обязательное имя события и `options` – объект с двумя свойствами:

- `bubbles: true` чтобы событие всплывало.
- `cancelable: true` если мы хотим, чтобы `event.preventDefault()` работал.

Особые конструкторы встроенных событий `MouseEvent`, `KeyboardEvent` и другие принимают специфичные для каждого конкретного типа событий свойства. Например, `clientX` для событий мыши.

Для пользовательских событий стоит применять конструктор `CustomEvent`. У него есть дополнительная опция `detail`, с помощью которой можно передавать информацию в объекте события. После чего все обработчики смогут получить к ней доступ через `event.detail`.

Несмотря на техническую возможность генерировать встроенные браузерные события типа `click` или `keydown`, пользоваться ей стоит с большой осторожностью.

Весьма часто, когда разработчик хочет сгенерировать встроенное событие – это вызвано «кривой» архитектурой кода.

Как правило, генерация встроенных событий полезна в следующих случаях:

- Либо как явный и грубый хак, чтобы заставить работать сторонние библиотеки, в которых не предусмотрены другие средства взаимодействия.
- Либо для автоматического тестирования, чтобы скриптом «нажать на кнопку» и посмотреть, произошло ли нужное действие.

Пользовательские события со своими именами часто создают для улучшения архитектуры, чтобы сообщить о том, что происходит внутри наших меню, слайдеров, каруселей и т.д.[^dispatch-events]

### Практическая работа. Обработка встроенных событий

#### Задания
Создать виртуальную страницу (раздел веб-приложения с отдельным маршрутом) администратора для управления пользовательскими записями. На странице представить перечень зарегистрированных пользователей с возможностями управления.

1. Перечень должен быть выполнен в виде блочного списка (карточек) и содержать базовую информацию о пользователе.
2. Каждый элемент перечня должен содержать аватарку (изображение профиля) пользователя.
3. Реализовать минификацию (сворачивание и разворачивание деталей) элементов списка.
4. Каждый элемент списка должен быть доступен для удаления.
5. Реализовать установку и удаление слушателей событий списка для контроля утечек памяти.

Разработанный функционал оформить в виде отдельного модуля.

#### Задания

1. **Скрыть элемент по нажатию кнопки**

    Добавить JavaScript к кнопке `button`, чтобы при нажатии элемент `<div id="text">` исчезал.

    ![Task 1](../img/event-handlers-task_01.png)

2. **Спрятать себя**

    Создайте кнопку, которая будет скрывать себя по нажатию. Например:

    <input type="button" onclick="this.hidden=true" value="Нажмите, чтобы спрятать">

3. **Какой обработчик запустится?**

    В переменной `button` находится кнопка. Изначально на ней нет обработчиков.

    Который из обработчиков запустится? Что будет выведено при клике после выполнения кода?

    ```js
    button.addEventListener("click", () => alert("1"));

    button.removeEventListener("click", () => alert("1"));

    button.onclick = () => alert(2);
    ```

4. **Передвиньте мяч по полю**

    Пусть мяч перемещается при клике на поле, туда, куда был клик, вот так:

    ![Task 1](../img/event-handlers-task_03.png)

    Требования:

    - Центр мяча должен совпадать с местом нажатия мыши (если это возможно без пересечения краёв поля);
    - CSS-анимация желательна, но не обязательна;
    - Мяч ни в коем случае не должен пересекать границы поля;
    - При прокрутке страницы ничего не должно ломаться;

    Заметки:

    - Код должен уметь работать с различными размерами мяча и поля, не привязываться к каким-либо фиксированным значениям.
    - Используйте свойства `event.clientX/event.clientY` для определения координат мыши при клике.

5. **Создать раскрывающееся меню**

    Создать меню, которое по нажатию открывается либо закрывается:

    ![Collapsible menu](../img/collapsible-menu_01.png)

    ![Collapsible menu](../img/collapsible-menu_02.png)

    P.S. HTML/CSS исходного документа можно и нужно менять.

6. **Добавить кнопку закрытия**

    Есть список сообщений.

    При помощи JavaScript для каждого сообщения добавьте в верхний правый угол кнопку закрытия.

    Результат должен выглядеть, как показано здесь:

    ![Closing button](../img/closing-button.png)

7. **Карусель**

    Создайте «Карусель» –- ленту изображений, которую можно листать влево-вправо нажатием на стрелочки.

    ![Carousel](../img/smart-carousel.png)

    В дальнейшем к ней можно будет добавить анимацию, динамическую подгрузку и другие возможности.

    P.S. В этой задаче разработка структуры HTML/CSS составляет 90% решения.

### Практическая работа. Управление событиями
Реализовать функционал подтверждения несохраненных изменений в разделах с формами (профиль пользователя).

1. Расширить классы маршрутов флагами наличия несохраненных изменений.
2. В компонентах навигационных ссылок реализовать подписку на событие щелчка мыши для того, чтобы блокировать стандартный безусловный переход по маршрутной ссылке для вызова навигационного метода маршрутизатора. Доступ к экземпляру маршрутизатора можно осуществлять через объект контекста (допустимо через глобальный объект).
3. Маршрутизатор должен проверять присутствие несохраненных данных, проверяя покидаемый маршрут. При наличии таковых следует запрашивать подтверждение пользователя, при отсутствии (а также подтверждении ухода от пользователя) — запускать смену маршрута.
4. Дополнительно выполнять аналогичную проверку при попытке закрытия вкладки/обновления страницы.
5. Реализовать открепление обработчиков для оптимизации управления памятью.

Реализация того или иного механизма отслеживания изменения данных в настоящей задаче остается на усмотрение разработчика.

Доступ к экземпляру маршрутизатора из маршрутных ссылок можно организовать через глобальный объект:
```js
// Launch router
const router = new Router(document.getElementById('app'), routes);
router.start();
window.router = router;
```

Но лучше сделать простой «контейнерный» слой вокруг маршрутизатора, и уже тем более не пытаться напрямую прокинуть его в каждый `<nav-link>` вручную. Это позволит не загрязнять глобальную область видимости.

**Базовая идея** — создаётся объект‑контейнер (или контекст), который:

- хранит единственный экземпляр `Router`;

- даёт метод `getRouter()` любому коду/компоненту, который его импортирует;

- не использует глобальный объект `window` для хранения `router`.

Так компоненты получают доступ к одному и тому же экземпляру без глобалей.

Создается модуль, например *router-context.js*:
```js
// router-context.js
let routerInstance = null;

export function setRouter(router) {
  routerInstance = router;
}

export function getRouter() {
  return routerInstance;
}
```

В точке входа, где создаётся маршрутизатор:
```js
const router = new Router(document.getElementById('app'), routes);
setRouter(router);
router.start();
```

Теперь внутри `NavLink` можно импортировать `getRouter()` и работать с конкретным экземпляром:
```js
// NavLink.js
import { getRouter } from "../path/to/router-context.js";

export default class NavLink extends HTMLElement {
  #href = '';
  #onClick = null;

  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this.handleRouteChange = this.handleRouteChange.bind(this);
  }

  // ... #disableLink, #enableLink, стили как у тебя ...

  #render() {
    const text = this.textContent;
    this.shadowRoot.innerHTML = `
      <style>/* твои стили */</style>
      <a href="${this.#href}">${text}</a>
    `;

    const link = this.shadowRoot.querySelector('a');
    if (link) {
      this.#onClick = async (event) => {
        event.preventDefault();
        const path = this.#href.slice(1); // 'login', 'profile', ...

        const router = getRouter();
        if (!router) {
          // fallback: если по какой-то причине контекст ещё не инициализирован
          location.hash = `#${path}`;
          return;
        }

        // управляем навигацией через роутер, который сам решает,
        // можно ли менять hash (canLeave, guard и т.п.)
        await router.navigate(path);
      };

      link.addEventListener('click', this.#onClick);
    }
  }

  connectedCallback() {
    this.#href = this.getAttribute('href') || '#';
    this.#render();
    this.#subscribeToRouteChanges();
  }

  disconnectedCallback() {
    const link = this.shadowRoot.querySelector('a');
    if (link && this.#onClick) {
      link.removeEventListener('click', this.#onClick);
    }
    this.#unsubscribeToRouteChanges();
  }

  // handleRouteChange как у тебя
}
```

Для ликвидации привязки маршрутной ссылки к экземпляру маршрутизатора переделать вызов метода перехода (`requestNavigation`) на генерацию события `requestNavigation` класса `NavigationEvent`, отслеживаемого маршрутизатором.

**Что это даёт**
- Один объект `Router` создаётся там, где и должен — в «корне» приложения.

- Компоненты `<nav-link>` получают к нему доступ не через `window.router`, а через модульный контекст.

- Навигация всегда идёт через `router.navigate(path)`, а он уже решает:

  - спрашивать ли `canLeave` у текущего маршрута;

  - менять ли `location.hash`;

  - рендерить ли новый маршрут.

Если необходимо ещё более строгая инверсия зависимостей, можно сделать `<nav-menu>` родителем, который принимает `router` через свойство и пробрасывает его детям через кастомное событие, но для модульного SPA простой контекст‑модуль обычно достаточно чистое и удобное решение.

### Практическая работа. Использование делегирования событий

!!! Использование data-атрибутов.

#### Задания
Создать виртуальную страницу (раздел веб-приложения с отдельным маршрутом) администратора для управления пользовательскими записями. На странице представить перечень зарегистрированных пользователей с переключателями вида (карточки/таблица).

1. Список пользователей должен быть выполнен в виде карточек и содержать базовую информацию о пользователе с кнопками для удаления `[x]`. Для работы кнопок удаления использовать делегирование событий. Должен быть лишь один обработчик на элементе-контейнере для всего.
2. Таблица пользователей должна поддерживать сортировку: при клике на элемент `<th>` строки таблицы должны сортироваться по соответствующему столбцу. Каждый элемент `<th>` снабдить атрибутом `data-type`. Функция сортировки должна учитывать тип столбца для корректной сортировки (числа сортируюся иначе, чем строки). Сортировка должна поддерживать только типы `string` и `number`. Таблица должна быть масштабируемой (содержать любое число строк и столбцов), для чего необходимо использовать делегирование событий.

#### Дополнительные задания

##### Раскрывающееся дерево
Создайте дерево, которое по клику на заголовок скрывает-показывает потомков:

Требования:

- Использовать только один обработчик событий (применить делегирование)
- Клик вне текста заголовка (на пустом месте) ничего делать не должен.

![Expanding tree](../img/expanding-tree.png)

### Практическая работа. Реализация поведения "подсказка"

#### Задание
Напишите JS-код, реализующий поведение «подсказка».

При наведении мыши на элемент с атрибутом `data-tooltip`, над ним должна показываться подсказка и скрываться при переходе на другой элемент.

Пример HTML с подсказками:
```html
<button data-tooltip="эта подсказка длиннее, чем элемент">Короткая кнопка</button>
<button data-tooltip="HTML<br>подсказка">Ещё кнопка</button>
```

Иллюстрация результата:

![Tooltip](../img/tooltip_01.png)

Детали оформления:

1. Отступ от подсказки до элемента с `data-tooltip` должен быть 5px по высоте.
2. Подсказка должна быть, по возможности, посередине элемента.
3. Подсказка не должна вылезать за границы экрана, в том числе если страница частично прокручена, если нельзя показать сверху – показывать снизу элемента.
4. Текст подсказки брать из значения атрибута `data-tooltip`. Это может быть произвольный HTML.
5. В один момент может быть показана только одна подсказка.

Иллюстрация поведения:

![Tooltip](../img/tooltip_02.png)

![Tooltip](../img/tooltip_03.png)

![Tooltip](../img/tooltip_04.png)

![Tooltip](../img/tooltip_05.png)

Для решения понадобятся два события:

- `mouseover` срабатывает, когда указатель мыши заходит на элемент.
- `mouseout` срабатывает, когда указатель мыши уходит с элемента.

Применить делегирование событий: установить оба обработчика на элемент `document`, чтобы отслеживать «заход» и «уход» курсора на элементы с атрибутом `data-tooltip` и управлять подсказками с их же помощью.

Допустимо считать, что во всех элементах с атрибутом `data-tooltip` должен использоваться только текст, без вложенных тегов.

После реализации такого поведения люди, даже не знакомые с JavaScript должны иметь возможность добавлять подсказки к элементам.

### Источники информации
[^9.1]: [Введение в обработку событий](https://metanit.com/web/javascript/9.1.php)
[^9.2]: [Обработчики событий](https://metanit.com/web/javascript/9.2.php)
[^9.3]: [Передача данных в обработчик события. Объект Event](https://metanit.com/web/javascript/9.3.php)
[^9.4]: [Распространение событий](https://metanit.com/web/javascript/9.4.php)
[^9.7]: [Программный вызов событий](https://metanit.com/web/javascript/9.7.php)
[^9.8]: [Определение своих событий](https://metanit.com/web/javascript/9.8.php)
[^dispatch-events]: [Генерация пользовательских событий](https://learn.javascript.ru/dispatch-events)
[^bubbling-and-capturing]: [Всплытие и погружение](https://learn.javascript.ru/bubbling-and-capturing)
[^event-delegation]: [Делегирование событий](https://learn.javascript.ru/event-delegation)
[^9.5]: [События мыши](https://metanit.com/web/javascript/9.5.php)
[^9.6]: [События клавиатуры](https://metanit.com/web/javascript/9.6.php)
[^introduction-browser-events]: [Введение в браузерные события](https://learn.javascript.ru/introduction-browser-events)
[^default-browser-action]: [Действия браузера по умолчанию](https://learn.javascript.ru/default-browser-action)
