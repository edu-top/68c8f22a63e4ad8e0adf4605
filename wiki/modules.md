## Модули

- [Модули](#модули)
  - [Введение в модули](#введение-в-модули)
    - [Определение модуля. Экспорт.](#определение-модуля-экспорт)
    - [Подключение модуля. Импорт](#подключение-модуля-импорт)
    - [Загрузка модулей](#загрузка-модулей)
  - [Импорт модуля](#импорт-модуля)
  - [Источники информации](#источники-информации)

### Введение в модули
Модули позволяют организовать функционал в отдельные блоки, которые затем можно использовать в других приложениях.[^19.1]

Отличие модулей от обычных скриптов:

- Для загрузки модулей применяется политика CORS. Это значит, что мы не можем просто кинуть в браузер html-страницу, которая подключает модуль. Модуль загружается с использованием протокола http/https. То есть страница html, которая загружает модуль, должна располагаться на каком-нибудь веб-сервере.

- Модули всегда выполняются в режиме **strict mode**.

- Модули по умолчанию загружаются асинхронно.

- Модули загружаются и выполняются только один раз.

- Модули позволяют использовать выражения **`await`** верхнего уровня без определения и вызова асинхронной функции.

- Модули могут имортировать функционал из других модулей и, в свою очередь, экспортировать свою функциональность в другие модули.

- Модули выполняются не в глобальном контексте, а в своей собственной области видимости. То есть переменные, константы, функции, классы и т.д., определенные внутри модуля, не доступны извне, пока они не будут явным образом экспортированы. А чтобы другой модуль мог их использовать, он должен их импортировать.

Если файл содержит выражения **`import`** или **`export`**, он рассматривается как модуль. Так, Чтобы сделать из простого скрипта модуль, достаточно добавить в файл:
```js
export {};
```

#### Определение модуля. Экспорт.
Определим простейший модуль. Для этого создадим файл *message.js*, в котором определим следующий код:
```js
export function sayHello() {
  console.log("Hello METANIT.COM");
}
```

Здесь определена обычная функция `sayHello()`, которая выводит некоторое сообщение на консоль. Но она определена с ключевым словом **`export`**, а это значит, что данный файл представляет модуль, а функцию `sayHello()` можно импортировать в другие модули.

#### Подключение модуля. Импорт
Теперь подключим эту функцию в другой файл. Для этого возьмем файл ***main.js***:
```js
import {sayHello} from "./message.js";
sayHello();
```

Для подключения функционала из другого модуля применяется ключевое слово **`import`**, после которого идут названия подключаемых компонентов. Все подключаемые из модуля компоненты помещаются в фигурные скобки: `import {sayHello}` — в данном случае подключается функция `sayHello`.

Затем после оператора **`from`** указывается модуль, из которого идет импорт. В данном случае указываем "./message.js". В данном случае предполагается что оба модуля — *main.js* и *message.js* — будут находиться в одной папке.

#### Загрузка модулей
Для загрузки модулей определим в папке со скомпилированными файлами веб-страницу *index.html*:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>METANIT.COM</title>
</head>
<body>
<script type="module" src="main.js"></script>
</body>
</html>
```

Для загрузки главного модуля приложения — *main.js* — определяется элемент `<script>`, у которого устанавливается атрибут `type="module"`.

Загрузка модулей производится через AJAX, поэтому скомпилированные модули должны быть размещены на веб-сервере. То есть у нас не получится просто кинуть страницу в веб-браузер и загрузить на нее модули. Такая веб-страница должна быть размещена на веб-сервере. Поэтому прежде всего надо определиться с веб-сервером. Веб-сервер может быть любым. В данном случае воспользуемся самым простым вариантом — Node.js. Но опять же вместо node.js это может быть любая другая технология сервера — php, asp.net, python и т.д. либо какой-то определенный веб-сервер типа Apache или IIS.

Итак, создадим в папке с файлами модулей файл сервера. Пусть он будет называться ***server.js*** и будет иметь следующий код:
```js
const http = require("http");
const fs = require("fs");

http.createServer(function(request, response){

    // получаем путь после слеша
    let filePath = request.url.substring(1);
    if(filePath == "") filePath = "index.html";
    fs.readFile(filePath, function(error, data){

        if(error){
            response.statusCode = 404;
            response.end("Resourse not found!");
        }
        else{
            if(filePath.endsWith(".js")) response.setHeader("Content-Type", "text/javascript");
            response.end(data);
        }
    });
}).listen(3000, function(){
    console.log("Server started at 3000");
});
```

Это самый примитивный сервер, который отдает пользователю статические файлы. Для создания сервера применяется функция `http.createServer()`, а для считывания и отправки файлов — функция `fs.readFile()`. Если имя файла не указано, то отправляется файл *index.html*. Сервер будет запускаться по адресу http://localhost:3000/

Стоит отметить, что при отправке модулей js нам надо устанавливать mime-тип отправляемого контента в "text/javascript":
```js
if(filePath.endsWith(".js")) response.setHeader("Content-Type", "text/javascript");
```

Структура финального проекта:

![Определение модулей JavaScript](../img/module2.png)

Теперь запустим сервер с помощью команды
```js
node server.js
```

![Загрузка модулей ES2015 в JavaScript и Node.js](../img/module1.png)

После запуска сервера мы можем перейти в браузере по адресу http://localhost:3000, нам отобразится страница, а в консоли браузера мы сможем увидеть результат работы модуля *main.js*:

![Загрузка и выполнение модулей в JavaScript и Node.js](../img/module3.png)

### Импорт модуля
Для импорта одного модуля в другом модуле достаточно прописать оператор `import` и передать ему путь к импортируемому модулю:
```js
import "путь_к_модулю";
```

Например, пусть у нас будет следующий модуль ***message.js***
```js
const messageText = "Hello METANIT.COM";
console.log(messageText);
```

Фактически этот модуль выглядит как обычный скрипт, который определяет переменную и выводит ее значение на консоль с помощью функции `console.log()`.

И определим в той же папке файл ***main.js***, в котором подключим выше определенный модуль ***message.js***:
```js
import "./message.js";
```

Здесь мы просто испортируем модуль *message.js*. В данном случае предполагается что оба модуля — *main.js* и *message.js* будут находиться в одной папке, поэтому при импорте указан путь "./message.js", где "./" указывает на ту же папку, где расположен файл *main.js*.

![Определение модулей JavaScript](../img/module2.png)

Пусть у нас есть html-страница ***index.html***, на которой подключается файл ***main.js***:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>METANIT.COM</title>
</head>
<body>
<script type="module" src="main.js"></script>
</body>
</html>
```

В итоге при выполнении страницы в браузере в его консоли мы увидим результат работы компонентов подключенного модуля:
```
Hello METANIT.COM
```

При таком подключении будут выполняться все вызовы функций модуля *message.js*, однако все определенные и не экспортируемые компоненты в этом модуле из вне будут недоступны. Так, мы не можем в модуле *main.js* написать так:
```js
import "./message.js";

console.log(messageText);   // Ошибка ReferenceError: messageText is not defined
```

Хотя мы и подключили модуль *message.js*, но его переменная `messageText` нам недоступна. Так как она не экспортируется, и соответветственно здесь мы ее не можем импортировать и использовать.

Такой способ импорта может показаться бессмысленным. Тем не менее мы можем воспользоваться преимуществами модуля, например, возможностью использовать выражения **`await`** без определения асинхронных функций. Например, изменим модуль ***message.js*** следующим образом:
```js
const sum = (x, y)=>Promise.resolve(x + y);

const value = await sum(5, 3);
console.log("Результат асинхронной операции:", value);
```

Для простоты здесь определена константа `sum`, которая представляет промис для вычисления суммы двух чисел. И модуль позволяет использовать нам выражения **`await`** верхнего уровня для получения результата из промиса без определения и вызова асинхронной функции.[^19.2]

### Источники информации
[^19.1]: [Введение в модули](https://metanit.com/web/javascript/19.1.php)
[^19.2]: [Импорт модуля](https://metanit.com/web/javascript/19.2.php)
