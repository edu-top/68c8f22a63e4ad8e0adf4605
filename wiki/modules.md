## Модули

- [Модули](#модули)
  - [Введение в модули](#введение-в-модули)
    - [Определение модуля. Экспорт.](#определение-модуля-экспорт)
    - [Подключение модуля. Импорт](#подключение-модуля-импорт)
    - [Загрузка модулей](#загрузка-модулей)
  - [Импорт модуля](#импорт-модуля)
  - [Экспорт и импорт компонентов модулей](#экспорт-и-импорт-компонентов-модулей)
    - [Именной экспорт компонентов модуля](#именной-экспорт-компонентов-модуля)
    - [Именной импорт компонентов модуля](#именной-импорт-компонентов-модуля)
    - [Импорт всего модуля](#импорт-всего-модуля)
  - [Экспорт и импорт по умолчанию](#экспорт-и-импорт-по-умолчанию)
    - [Совместный экспорт/импорт отдельных компонентов и компонентов по умолчанию](#совместный-экспортимпорт-отдельных-компонентов-и-компонентов-по-умолчанию)
    - [Экспорт и импорт по умолчанию всего модуля](#экспорт-и-импорт-по-умолчанию-всего-модуля)
  - [Использование псевдонимов при экспорте и импорте](#использование-псевдонимов-при-экспорте-и-импорте)
    - [Псевдонимы в экспорте](#псевдонимы-в-экспорте)
    - [Псевдонимы при импорте](#псевдонимы-при-импорте)
  - [Источники информации](#источники-информации)

### Введение в модули
Модули позволяют организовать функционал в отдельные блоки, которые затем можно использовать в других приложениях.[^19.1]

Отличие модулей от обычных скриптов:

- Для загрузки модулей применяется политика CORS. Это значит, что мы не можем просто кинуть в браузер html-страницу, которая подключает модуль. Модуль загружается с использованием протокола http/https. То есть страница html, которая загружает модуль, должна располагаться на каком-нибудь веб-сервере.

- Модули всегда выполняются в режиме **strict mode**.

- Модули по умолчанию загружаются асинхронно.

- Модули загружаются и выполняются только один раз.

- Модули позволяют использовать выражения **`await`** верхнего уровня без определения и вызова асинхронной функции.

- Модули могут имортировать функционал из других модулей и, в свою очередь, экспортировать свою функциональность в другие модули.

- Модули выполняются не в глобальном контексте, а в своей собственной области видимости. То есть переменные, константы, функции, классы и т.д., определенные внутри модуля, не доступны извне, пока они не будут явным образом экспортированы. А чтобы другой модуль мог их использовать, он должен их импортировать.

Если файл содержит выражения **`import`** или **`export`**, он рассматривается как модуль. Так, Чтобы сделать из простого скрипта модуль, достаточно добавить в файл:
```js
export {};
```

#### Определение модуля. Экспорт.
Определим простейший модуль. Для этого создадим файл *message.js*, в котором определим следующий код:
```js
export function sayHello() {
  console.log("Hello METANIT.COM");
}
```

Здесь определена обычная функция `sayHello()`, которая выводит некоторое сообщение на консоль. Но она определена с ключевым словом **`export`**, а это значит, что данный файл представляет модуль, а функцию `sayHello()` можно импортировать в другие модули.

#### Подключение модуля. Импорт
Теперь подключим эту функцию в другой файл. Для этого возьмем файл ***main.js***:
```js
import {sayHello} from "./message.js";
sayHello();
```

Для подключения функционала из другого модуля применяется ключевое слово **`import`**, после которого идут названия подключаемых компонентов. Все подключаемые из модуля компоненты помещаются в фигурные скобки: `import {sayHello}` — в данном случае подключается функция `sayHello`.

Затем после оператора **`from`** указывается модуль, из которого идет импорт. В данном случае указываем "./message.js". В данном случае предполагается что оба модуля — *main.js* и *message.js* — будут находиться в одной папке.

#### Загрузка модулей
Для загрузки модулей определим в папке со скомпилированными файлами веб-страницу *index.html*:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>METANIT.COM</title>
</head>
<body>
<script type="module" src="main.js"></script>
</body>
</html>
```

Для загрузки главного модуля приложения — *main.js* — определяется элемент `<script>`, у которого устанавливается атрибут `type="module"`.

Загрузка модулей производится через AJAX, поэтому скомпилированные модули должны быть размещены на веб-сервере. То есть у нас не получится просто кинуть страницу в веб-браузер и загрузить на нее модули. Такая веб-страница должна быть размещена на веб-сервере. Поэтому прежде всего надо определиться с веб-сервером. Веб-сервер может быть любым. В данном случае воспользуемся самым простым вариантом — Node.js. Но опять же вместо node.js это может быть любая другая технология сервера — php, asp.net, python и т.д. либо какой-то определенный веб-сервер типа Apache или IIS.

Итак, создадим в папке с файлами модулей файл сервера. Пусть он будет называться ***server.js*** и будет иметь следующий код:
```js
const http = require("http");
const fs = require("fs");

http.createServer(function(request, response){

    // получаем путь после слеша
    let filePath = request.url.substring(1);
    if(filePath == "") filePath = "index.html";
    fs.readFile(filePath, function(error, data){

        if(error){
            response.statusCode = 404;
            response.end("Resourse not found!");
        }
        else{
            if(filePath.endsWith(".js")) response.setHeader("Content-Type", "text/javascript");
            response.end(data);
        }
    });
}).listen(3000, function(){
    console.log("Server started at 3000");
});
```

Это самый примитивный сервер, который отдает пользователю статические файлы. Для создания сервера применяется функция `http.createServer()`, а для считывания и отправки файлов — функция `fs.readFile()`. Если имя файла не указано, то отправляется файл *index.html*. Сервер будет запускаться по адресу http://localhost:3000/

Стоит отметить, что при отправке модулей js нам надо устанавливать mime-тип отправляемого контента в "text/javascript":
```js
if(filePath.endsWith(".js")) response.setHeader("Content-Type", "text/javascript");
```

Структура финального проекта:

![Определение модулей JavaScript](../img/module2.png)

Теперь запустим сервер с помощью команды
```js
node server.js
```

![Загрузка модулей ES2015 в JavaScript и Node.js](../img/module1.png)

После запуска сервера мы можем перейти в браузере по адресу http://localhost:3000, нам отобразится страница, а в консоли браузера мы сможем увидеть результат работы модуля *main.js*:

![Загрузка и выполнение модулей в JavaScript и Node.js](../img/module3.png)

### Импорт модуля
Для импорта одного модуля в другом модуле достаточно прописать оператор `import` и передать ему путь к импортируемому модулю:
```js
import "путь_к_модулю";
```

Например, пусть у нас будет следующий модуль ***message.js***
```js
const messageText = "Hello METANIT.COM";
console.log(messageText);
```

Фактически этот модуль выглядит как обычный скрипт, который определяет переменную и выводит ее значение на консоль с помощью функции `console.log()`.

И определим в той же папке файл ***main.js***, в котором подключим выше определенный модуль ***message.js***:
```js
import "./message.js";
```

Здесь мы просто испортируем модуль *message.js*. В данном случае предполагается что оба модуля — *main.js* и *message.js* будут находиться в одной папке, поэтому при импорте указан путь "./message.js", где "./" указывает на ту же папку, где расположен файл *main.js*.

![Определение модулей JavaScript](../img/module2.png)

Пусть у нас есть html-страница ***index.html***, на которой подключается файл ***main.js***:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>METANIT.COM</title>
</head>
<body>
<script type="module" src="main.js"></script>
</body>
</html>
```

В итоге при выполнении страницы в браузере в его консоли мы увидим результат работы компонентов подключенного модуля:
```
Hello METANIT.COM
```

При таком подключении будут выполняться все вызовы функций модуля *message.js*, однако все определенные и не экспортируемые компоненты в этом модуле из вне будут недоступны. Так, мы не можем в модуле *main.js* написать так:
```js
import "./message.js";

console.log(messageText);   // Ошибка ReferenceError: messageText is not defined
```

Хотя мы и подключили модуль *message.js*, но его переменная `messageText` нам недоступна. Так как она не экспортируется, и соответветственно здесь мы ее не можем импортировать и использовать.

Такой способ импорта может показаться бессмысленным. Тем не менее мы можем воспользоваться преимуществами модуля, например, возможностью использовать выражения **`await`** без определения асинхронных функций. Например, изменим модуль ***message.js*** следующим образом:
```js
const sum = (x, y)=>Promise.resolve(x + y);

const value = await sum(5, 3);
console.log("Результат асинхронной операции:", value);
```

Для простоты здесь определена константа `sum`, которая представляет промис для вычисления суммы двух чисел. И модуль позволяет использовать нам выражения **`await`** верхнего уровня для получения результата из промиса без определения и вызова асинхронной функции.[^19.2]

### Экспорт и импорт компонентов модулей

#### Именной экспорт компонентов модуля
Для того, чтобы какие-то компоненты модуля (переменные/константы/функции/классы) модуля можно было подключить и использовать в другом модулей, их надо экспортировать. Мы можем экспортировать какждый компонент по отдельности. Для этого перед определением компонента указывается ключевое слово `export`. Например, пусть у нас будет следующий модуль ***message.js***
```js
// экспорт переменной
export let welcome = "Welcome";
// экспорт константы
export const hello = "Hello";

// экспорт функции
export function sayHello() {
  console.log("Hello METANIT.COM");
}

// экспорт класса
export class Messenger {
    send(text){
        console.log("Sending message:", text);
    }
}
```

Здесь экспортируются переменная `welcome`, константа `hello`, функция `sayHello()` и класс `Messenger`. Стоит отметить, что нам необязательно экспортировать все компоненты модуля, какие-то компоненты мы можем не экспортировать и использовать только внутри этого модуля.

В качестве альтернативы мы могли бы экспортировать все компоненты вместе виде списка:
```js
let welcome = "Welcome";
const hello = "Hello";

function sayHello() {
  console.log("Hello METANIT.COM");
}

class Messenger {
    send(text){
        console.log("Sending message:", text);
    }
}

export {welcome, hello, sayHello, Messenger}
```

В данном случае оба способа экспорта будут эквивалентны.

#### Именной импорт компонентов модуля
Все имортируемые компоненты мы можем подключить по отдельности. Для этого после оператора **`import`** в фигурных скобках указываются названия подключаемых компонентов-переменных/констант/функций/функций. Затем после оператора **`from`** указывается модуль, из которого идет импорт.

```js
import {компонент1, компонент2, ... компонентN} from "путь_к_модулю";
```

Например, импортируем в модуле ***main.js*** экспортируемые компоненты модуля ***message.js***:
```js
import {sayHello, welcome, Messenger} from "./message.js";

sayHello();

const telegram = new Messenger();
telegram.send(welcome);
```

Итак, здесь подключаются из модуля *message.js* переменная `welcome`, функция `sayHello()` и класс `Messenger`. При этом нам необязательно подключать все компоненты модуля. Мы можем подключить только те компоненты, которые нам непосредственно нужны и которые мы собираемся использовать.

В итоге при выполнении страницы в браузере в его консоли мы увидим результат работы компонентов подключенного модуля *main.js*:
```
Hello METANIT.COM
Sending message: Welcome
```

#### Импорт всего модуля
Если в подключаемом модуля очень много компонентов, и мы собираемся использовать все возможности модуля, то перечислять все подключаемые компоненты может быть утомительно. В этом случае мы можем подключить весь функционал модуля в виде:
```js
import * as псевдоним_модуля from "модуль";
```

После оператора `import` идет знак звездочки, который указывает, что надо подключить все экспортируемые компоненты. А после оператора **`as`** идет псевдоним модуля, с которым будет сопоставляться подключаемый модуль.

Например, подключим в файле ***main.js*** весь модуль ***message.js***
```js
import * as MessageModule from "./message.js";

MessageModule.sayHello();

const telegram = new MessageModule.Messenger();
telegram.send(MessageModule.welcome);
```

В даном случае подключаемый модуль *message.js* сопоставляется с идентификатором `MessageModule`. В качестве псевдонима модуля может выстуать произвольное название. И далее мы можем обращаться ко всем экспортируемым компонентам модуля через псевдним модуля, например, обращении к функции `sayHello`: `MessageModule.sayHello()`.[^19.3]

### Экспорт и импорт по умолчанию
При экспорте мы можем указать компонент, который будет экспортироваться по умолчанию с помощью оператора **`default`**. Например, определим следующий модуль ***message.js***:
```js
export default function sayHello() {
  console.log("Hello from sayHello function");
}
```

Чтобы сделать экспорт по умолчанию, после оператора **`export`** указывается оператор **`default`**.

Теперь импортируем эту функцию в модуле ***main.js***:
```js
import sayHello from "./message.js";

sayHello();
```

Для импорта компонента по умолчанию достаточно после оператора **`import`** прописать имя этого компонента.

Преимущество экспорта по умолчанию заключается в том, что при импорте модуль не нужно знать, как экспортируемый компонент называется внутри модуля.

#### Совместный экспорт/импорт отдельных компонентов и компонентов по умолчанию
Модуль может одновременно экспортировать отдельные компоненты и компонент по умолчанию:
```js
export let welcome = "Welcome";
export const hello = "Hello";

export default function sayHello() {
  console.log("Hello METANIT.COM");
}

export class Messenger {
    send(text){
        console.log("Sending message:", text);
    }
}
```

Здесь экспортируются все компоненты, однако только функция `sayHello` экспортируется по умолчанию. Это определение модуля также эквивалентно следующему определению, где компоненты экспортируются через список:
```js
let welcome = "Welcome";
const hello = "Hello";

function sayHello() {
  console.log("Hello METANIT.COM");
}

class Messenger {
    send(text){
        console.log("Sending message:", text);
    }
}

export {welcome, hello, sayHello as default, Messenger}
```

При импорте такого модуля, все компоненты, за исключением компонента по умолчанию, необходимо импортировать по отдельности:
```js
import sayHello, {welcome, Messenger} from "./message.js";

sayHello();

const telegram = new Messenger();
telegram.send(welcome);
```

#### Экспорт и импорт по умолчанию всего модуля
Стоит учитывать, что при экспорте по умолчанию мы можем только один раз использовать оператор **`default`**. Мы не можем по отдельности экспортировать по умолчанию сразу два компонента. Однако мы можем экспортировать по умолчанию сразу набор компонентов как единое целое. Например, определим следующий модуль ***message.js***:
```js
let welcome = "Welcome";
const hello = "Hello";

function sayHello() {
  console.log("Hello METANIT.COM");
}

class Messenger {
    send(text){
        console.log("Sending message:", text);
    }
}

export default {welcome, hello, sayHello, Messenger}
```

Теперь импортируем функционал модуля *message.js* в модуле *main.js*:
```js
import MessageModule from "./message.js";

MessageModule.sayHello();

const telegram = new MessageModule.Messenger();
telegram.send(MessageModule.welcome);
```

В данном случае весь экспортированный список компонентов будет сопоставляться с названием `MessageModule`, которое фактически будет представлять модуль. И далее через этот идентификатор можно обратиться к конкреному компоненту, используя имя компонента: `MessageModule.sayHello();`.[^19.4]

### Использование псевдонимов при экспорте и импорте
С помощью оператора **`as`** экспортируемым/импортируемым компонентам модуля можно назначить псевдоним. Затем для использования подобных компонентов применяется не их непосредственное имя, а их псевдоним.

#### Псевдонимы в экспорте
Определим следующий модуль ***message.js***:
```js
let welcome = "Welcome";
const hello = "Hello";

function sayHello() {
  console.log("Hello METANIT.COM");
}

class Messenger {
    send(text){
        console.log("Sending message:", text);
    }
}

export {welcome as simpleMessage, hello, sayHello as printMessage, Messenger}
```

Здесь все компоненты модуля экспортируются в виде списка, в котором можно определить для компонента псевдним в виде:
```js
компонент as псевдним
```

Так, для константы `welcome` определен псевдним `simpleMessage`, а для функции `sayHello` определен псевдним `printMessage()`.

В этом случае при импорте модуля *message.js* данные компоненты будут доступны через свои псевднимы:
```js
import {simpleMessage, printMessage, Messenger} from "./message.js";

printMessage();

const telegram = new Messenger();
telegram.send(simpleMessage);
```

#### Псевдонимы при импорте
Подобным образом можно указать псевдонимы и при импорте. Это может быть актуально, если имя импортируемого компонента довольно велико, и мы хотим установить для него более краткий псевдоним. Вторая причина: в модуле уже есть компоненты с таким именем, и чтобы избежать двойственности для одноименных компонентов подключаемого модуля установливаются псевдонимы. Третья причина — мы хотим дать компонентам более описательные выразительные имена.

Рассмотрим небольшой пример:
```js
import {simpleMessage as messageText, printMessage as printHello, Messenger} from "./message.js";

const printMessage = ()=>console.log("Hello from main module");

printHello();
printMessage();

const telegram = new Messenger();
telegram.send(messageText);
```

Здесь в модуле импортируемой константе `simpleMessage` назначается псевдним `messageText`: `simpleMessage as messageText`.

Кроме того, здесь определена функция `printMessage()`. Однако из модуля также импортируется компонент с таким же именем. И чтобы избежать двойственности, импортируемому компоненту назначается псевдним `printHello`: `printMessage as printHello`.

Далее для обращения к импортированным компонентам с псевднимами используются их псевдонимы.[^19.5]

### Источники информации
[^19.1]: [Введение в модули](https://metanit.com/web/javascript/19.1.php)
[^19.2]: [Импорт модуля](https://metanit.com/web/javascript/19.2.php)
[^19.3]: [Экспорт и импорт компонентов модулей](https://metanit.com/web/javascript/19.3.php)
[^19.4]: [Экспорт и импорт по умолчанию](https://metanit.com/web/javascript/19.4.php)
[^19.5]: [Использование псевдонимов при экспорте и импорте](https://metanit.com/web/javascript/19.5.php)
