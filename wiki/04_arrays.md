## Массивы

- [Массивы](#массивы)
  - [Введение в массивы](#введение-в-массивы)
  - [Многомерные массивы](#многомерные-массивы)
  - [Создание массива и объект Array](#создание-массива-и-объект-array)
    - [Создание массива](#создание-массива)
    - [Array.from](#arrayfrom)
    - [length](#length)
  - [Массивы и spread-оператор](#массивы-и-spread-оператор)
    - [Объединение массивов](#объединение-массивов)
    - [Передача аргументов функции](#передача-аргументов-функции)
    - [Копирование массивов](#копирование-массивов)
  - [Операции с массивами](#операции-с-массивами)
    - [Добавление данных](#добавление-данных)
      - [push()](#push)
      - [unshift()](#unshift)
      - [Добавление данных по определенному индексу](#добавление-данных-по-определенному-индексу)
    - [Удаление данных](#удаление-данных)
      - [pop()](#pop)
      - [shift()](#shift)
      - [Удаление элемента по индексу. splice()](#удаление-элемента-по-индексу-splice)
    - [Замена элементов](#замена-элементов)
    - [Копирование массива](#копирование-массива)
      - [slice()](#slice)
      - [copyWithin](#copywithin)
    - [Получение элементов вне диапазона. toSpliced](#получение-элементов-вне-диапазона-tospliced)
    - [concat()](#concat)
    - [join()](#join)
    - [sort() и toSorted](#sort-и-tosorted)
    - [reverse() и toReversed()](#reverse-и-toreversed)
    - [Поиск индекса элемента](#поиск-индекса-элемента)
    - [Проверка наличия элемента](#проверка-наличия-элемента)
    - [every()](#every)
    - [some()](#some)
    - [filter()](#filter)
    - [Перебор элементов с помощью forEach()](#перебор-элементов-с-помощью-foreach)
    - [Трансформация массива и map()](#трансформация-массива-и-map)
    - [Поиск в массиве](#поиск-в-массиве)
    - [Метод flat и преобразование массива](#метод-flat-и-преобразование-массива)
    - [with](#with)
    - [reduce](#reduce)
    - [Комбинация методов](#комбинация-методов)
  - [Наследование массивов](#наследование-массивов)
    - [Переопределение методов](#переопределение-методов)
  - [Практическая работа. Работа с массивами](#практическая-работа-работа-с-массивами)
    - [Дополнительные задачи](#дополнительные-задачи)
  - [Источники информации](#источники-информации)

### Введение в массивы
Для работы с наборами данных предназначены массивы. Для создания массива применяются квадратные скобки **`[]`**. Внутри квадратных скобок определяются элементы массива. (Далее в отдельной главе, посвященной массивам, мы рассмотрим дополнительные способы создания массивов и вцелом более подробно работу с массивами).

Простейшее определение массива:
```js
const myArray = [];
```

В данном случае мы создаем массив, который называется `myArray`. Он пустой, поскольку внутри квадратных скобок не определено ни одного элемента. Но можно также добавить в него начальные данные:
```js
const people = ["Tom", "Alice", "Sam"];
console.log(people);    // ["Tom", "Alice", "Sam"];
```

В этом случае в массиве myArray будет три элемента. Графически его можно представить так:

Индекс | Элемент
-- | --
0 | Tom
1 | Alice
2 | Sam

Для обращения к отдельным элементам массива используются индексы. Отсчет начинается с нуля, то есть первый элемент будет иметь индекс 0, а последний — 2:
```js
const people = ["Tom", "Alice", "Sam"];
console.log(people[0]); // Tom
const person3 = people[2]; // Sam
console.log(person3); // Sam
```

Если мы попробуем обратиться к элементу по индексу больше размера массива, то мы получим `undefined`:
```js
const people = ["Tom", "Alice", "Sam"];
console.log(people[7]); // undefined
```

Также по индексу осуществляется установка значений для элементов массива:
```js
const people = ["Tom", "Alice", "Sam"];
console.log(people[0]); // Tom
people[0] = "Bob";
console.log(people[0]); // Bob
```

Причем в отличие от других языков, как C# или Java, можно установить элемент, который изначально не установлен:
```js
const people = ["Tom", "Alice", "Sam"];
console.log(people[7]); // undefined - в массиве только три элемента
people[7] = "Bob";
console.log(people[7]); // Bob
```

Также стоит отметить, что в отличие от ряда языков программирования в JavaScript массивы не являются строго типизированными, один массив может хранить данные разных типов:
```js
const objects = ["Tom", 12, true, 3.14, false];
console.log(objects);
```

### Многомерные массивы
Массивы могут быть одномерными и многомерными. Каждый элемент в многомерном массиве может представлять собой отдельный массив. Выше мы рассматривали одномерный массив, теперь создадим многомерный массив:
```js
const numbers1 = [0, 1, 2, 3, 4, 5 ]; // одномерный массив
const numbers2 = [[0, 1, 2], [3, 4, 5] ]; // двумерный массив
```

Визуально оба массива можно представить следующим образом:

**Одномерный массив `numbers1`**

<table border=1>
  <tr>
  <td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td>
  </tr>
</table>

**Двухмерный массив `numbers2`**

<table border=1>
  <tr>
  <td>0</td><td>1</td><td>2</td>
  </tr>
  <tr>
  <td>3</td><td>4</td><td>5</td>
  </tr>
</table>

Поскольку массив `numbers2` двухмерный, он представляет собой простую таблицу. Каждый его элемент может представлять отдельный массив.

Рассмотрим еще один двумерный массив:
```js
const people = [
        ["Tom", 25, false],
        ["Bill", 38, true],
        ["Alice", 21, false]
];

console.log(people[0]); // ["Tom", 25, false]
console.log(people[1]); // ["Bill", 38, true]
```

Массив `people` можно представить в виде следующей таблицы:

<table border=1>
  <tr>
  <td>Tom</td><td>25</td><td>false</td>
  </tr>
  <tr>
  <td>Bill</td><td>38</td><td>true</td>
  </tr>
  <tr>
  <td>Alice</td><td>21</td><td>false</td>
  </tr>
</table>

Чтобы получить отдельный элемент массива, также используется индекс:
```js
const tomInfo = people[0];
```

Только теперь переменная `tomInfo` будет представлять массив. Чтобы получить элемент внутри вложенного массива, нам надо использовать его вторую размерность:
```js
console.log("Имя: ", people[0][0]); // Tom
console.log("Возраст: ", people[0][1]); // 25
```

То есть если визуально двумерный массив мы можем представить в виде таблицы, то элемент `people[0][1]` будет ссылаться на ячейку таблицы, которая находится на пересечении первой строки и второго столбца (первая размерность — 0 — строка, вторая размерность — 1 — столбец).

Также мы можем выполнить присвоение:
```js
const people = [
        ["Tom", 25, false],
        ["Bill", 38, true],
        ["Alice", 21, false]
];
people[0][1] = 56; // присваиваем отдельное значение
console.log(people[0][1]); // 56

people[1] = ["Bob", 29, false]; // присваиваем массив
console.log(people[1][0]); // Bob
```

При создании многомерных массивов мы не ограничены только двумерными, но также можем использовать массивы больших размерностей:[^2.5]
```js
const numbers = [];
numbers[0] = []; // теперь numbers - двумерный массив
numbers[0][0]=[]; // теперь numbers - трехмерный массив
numbers[0][0][0] = 5; // первый элемент трехмерного массива равен 5
console.log(numbers[0][0][0]);
```

### Создание массива и объект Array
Для хранения набора данных в языке JavaScript предназначены массивы. Массивы в JavaScript представлены объектом **`Array`**. Объект **`Array`** предоставляет ряд свойств и методов, с помощью которых мы можем управлять массивом и его элементами.

#### Создание массива
Можно создать пустой массив, используя квадратные скобки или конструктор `Array`:
```js
const users = new Array();
const people = [];

console.log(users); // Array[0]
console.log(people); // Array[0]
```

Можно сразу же инициализировать массив некоторым количеством элементов:
```js
const users = new Array("Tom", "Bill", "Alice");
const people = ["Sam", "John", "Kate"];

console.log(users); // ["Tom", "Bill", "Alice"]
console.log(people); // ["Sam", "John", "Kate"]
```

Можно определить массив и по ходу определять в него новые элементы:
```js
const users = [];
users[1] = "Tom";
users[2] = "Kate";
console.log(users[1]); // "Tom"
console.log(users[0]); // undefined
```

При этом не важно, что по умолчанию массив создается с нулевой длиной. С помощью индексов мы можем подставить на конкретный индекс в массиве тот или иной элемент.

Еще один способ инициализации массивов представляет метод **`Array.of()`** — он принимает элементы и инициизирует ими массив:
```js
const people = Array.of("Tom", "Bob", "Sam");
console.log(people); // ["Tom", "Bob", "Sam"]
```

#### Array.from
И еще один способ представляет функция **`Array.from()`**. Она имеет много вариантов, рассмотрим самые распространенные:
```js
Array.from(arrayLike)
Array.from(arrayLike, function mapFn(element) { ... })
Array.from(arrayLike, function mapFn(element, index) { ... })
```

В качестве первого параметра — `arrayLike` функция принимает некий объект, который, условно говоря, "похож на массив", то есть может быть представлен в виде набора элементов. Это может быть и другой массив, это может быть и строка, которая по сути предоставляет набор символов. Вообщем какой-то набор элементов, который можно преобразовать в массив. Кроме того, это может и некий объект, в котором определено свойство `length`. Например:
```js
const array = Array.from("Hello");
console.log(array); // ["H", "e", "l", "l", "o"]
```

В данном случае в функцию передается строка и возвращается массив, каждый элемент которого предоставляет один из символов этой строки.

В качестве второго параметра передается функция преобразования, которая через первый параметр получает текущий элемент набора и возвращает некоторый результат его трансформации. Например:
```js
const numbers = [1, 2, 3, 4];
const array = Array.from(numbers, n => n * n);
console.log(array); // [1, 4, 9, 16]
```

В данном случае в функцию `Array.from()` передается массив чисел. Второй параметр — функция (в данном случае в ее роли выступает лямбда-выражение) запускается для каждого числа из этого массива и получает это число через параметр `n`. В самом лямбда-выражении возвращаем квадрат этого числа. В итоге `Array.from()` возвратит новый массив, в котором будут квадраты чисел из массива numbers.

И еще одна версия функции `Array.from()` в качестве второго параметра принимает функцию преобразования, в которую кроме элемента из перебираемого набора передается и индекс этого элемента:
```js
Array.from(arrayLike, function mapFn(element, index) { ... })
```

Используем эту версию и передадим в функцию объект со свойством `length`:
```js
const array = Array.from({length:3}, (element, index) => {
    console.log(element);   // undefined
    return index;
});
console.log(array); // [0, 1, 2]
```

Здесь в функцию передается объект, у которого свойство `length` равно 3. Для функции `Array.from` это будет сигналом, в возвращаемом массиве должно быть три элемента. При этом неважно, что функция преобразования из второго параметра принимает элемент набора (параметр `element`) — в данном случае он будет всегда `undefined`, тем не менее значение `length:3` будет указателем, что возвращаемый массив будет иметь три элемента с соответственно индексами от 0 до 2. И через второй параметр функции преобразования — параметр `index` мы можем и получить текущий индекс элемента.

Тем не менее мы можем передать объект, где в качестве названий свойств применяются индексы. В этом случае объект превратится в массивоподобный объект, который можно перебрать:
```js
const array = Array.from({length:3, "0": "Tom", "1": "Sam", "2": "Bob"}, (element) => {
    console.log(element);
    return element;
});
console.log(array); // ["Tom", "Sam", "Bob"]
```

#### length
Чтобы узнать длину массива, используется свойство `length`:
```js
const fruit = [];
fruit[0] = "яблоки";
fruit[1] = "груши";
fruit[2] = "сливы";

console.log("В массиве fruit ", fruit.length, " элемента");
for(let i=0; i < fruit.length; i++)
    console.log(fruit[i]);
```

По факту длиной массива будет индекс последнего элемента с добавлением единицы. Например:
```js
const users = []; // в массиве 0 элементов
users[0] = "Tom";
users[1] = "Kate";
users[4] = "Sam";
for(let i=0; i<users.length;i++)
    console.log(users[i]);
```

Вывод браузера:
```
Tom
Kate
undefined
undefined
Sam
```

Несмотря на то, что для индексов 2 и 3 мы не добавляли элементов, но длиной массива в данном случае будет число 5. Просто элементы с индексами 2 и 3 будут иметь значение `undefined`.

### Массивы и spread-оператор
**spread-оператор** (оператор **`...`**) позволяет разложить массив на отдельные значения. Для этого перед массивом ставится многоточие:
```js
...массив
```

Простейший пример:
```js
const users = ["Tom", "Sam", "Bob"];
console.log(...users);  // Tom Sam Bob
```

И, применяя этот оператор, мы можем наполнить один массив значениями из другого массива:
```js
const users = ["Tom", "Sam", "Bob"];
console.log(users);     //  ["Tom", "Sam", "Bob"]
const people1 = [...users];
const people2 = new Array(...users);
const people3 = Array.of(...users);
console.log(people1);     //  ["Tom", "Sam", "Bob"]
console.log(people2);     //  ["Tom", "Sam", "Bob"]
console.log(people3);     //  ["Tom", "Sam", "Bob"]
```

#### Объединение массивов
С помощью spread-оператора можно при создания нового массива передать ему значения сразу нескольких массивов. Например:
```js
const men = ["Tom", "Sam", "Bob"];
const women = ["Kate", "Alice", "Mary"];
const people = [...men, "Alex", ...women];

console.log(people);     //  ["Tom", "Sam", "Bob", "Alex", "Kate", "Alice", "Mary"]
```

В данном случае в массив `people` передаются значения из массивов `men`, `women`, и, кроме того, мы можем дополнительно передать отдельные значения, которые не входят в эти массивы.

#### Передача аргументов функции
Подобным образом можно передавать из массива значения параметрам функции:
```js
const people = ["Tom", "Sam", "Bob"];

function print(first, second, third){
    console.log(first);
    console.log(second);
    console.log(third);
}
print(...people);
// Tom
// Sam
// Bob
```

В данном случае функция `print()` принимает три параметра. Операция `...people` при вызове функции позволяет разложить массив `people` на отдельные значения, которые передаются параметрам этой функции.

Стоит отметить, что это не то же самое, что передать при вызове функции массив:
```js
print(people);
```

В этом случае весь массив будет передан первому параметру функции — параметру `first`, а остальные будут иметь значение `undefined`.

Еще один пример передачи параметрам значений из массива:
```js
function sum(a, b, c){
    const d = a + b + c;
    console.log(d);
}
sum(1, 2, 3);
const nums = [4, 5, 6];
sum(...nums);
```

Во втором случае в функцию передается числа из массива nums. Но чтобы передавался не просто массив, как одно значение, а именно числа из этого массива, применяется spread-оператор (многоточие `...`).

Если количество параметров функции меньше количества элементов массива, то оставшие элементы массива просто будут отброшены. Если количество параметров больше количества элементов массива, то параметры, которым не досталось значений, получат значение `undefined`:
```js
const people1 = ["Tom", "Sam", "Bob", "Mike"];
const people2 = ["Alex", "Bill"];
function print(first, second, third){
    console.log(`${first}, ${second}, ${third}`);
}
print(...people1);  // Tom, Sam, Bob
print(...people2);  // Alex, Bill, undefined
```

#### Копирование массивов
spread-оператор предоставляет самый простой способ скопировать элементы одного массива в другой. Однако тут надо соблюдать осторожность. Рассмотрим пример:
```js
const people = ["Sam", "Tom", "Bob"];
const employees = [...people];
employees[0] = "Dan";
console.log(employees);     // ["Dan", "Tom", "Bob"]
console.log(people);        //  ["Sam", "Tom", "Bob"]
```

Здесь создаются два массива. При этом массиву `employees` передаются элементы массива `people`. Далее мы меняем первый элемент массива `employees`. И по консольному выводу мы можем увидеть, что изменение одного массива не повлияло на другой массив.

Однако что будет, если мы скопируем массив объектов:
```js
const people = [{name:"Sam"}, {name:"Tom"}, {name:"Bob"}];
const employees = [...people];
//employees[0] = {name: "Dan"};
employees[0].name = "Dan";
console.log(employees);     //  [{name:"Dan"}, {name:"Tom"}, {name:"Bob"}]
console.log(people);        //  [{name:"Dan"}, {name:"Tom"}, {name:"Bob"}]
```

Теперь массив `people` предоставляет массив объектов, где каждый объект имеет одно свойство — `name`. Далее мы изменяем значение свойства name у первого элемента.

И консольный вывод нам покажет, что изменение одного массива привело к изменению второго массива. Поскольку объекты — представляют ссылочный тип, и при копировании в новый массив передается не копия объекта (как в случае со строками), а сам объект. Поэтому первый элемент одного массива и первый элемент второго массива фактически будет представлять один и тот же объект.

Однако мы можем полностью заменить элемент одного массива на другой объект, и тогда элемент второго массива по прежнему будет хранить ссылку на старый объект и будет не зависеть от первого массива:
```js
const people = [{name:"Sam"}, {name:"Tom"}, {name:"Bob"}];
const employees = [...people];
employees[0] = {name: "Dan"};
console.log(employees);     //  [{name:"Dan"}, {name:"Tom"}, {name:"Bob"}]
console.log(people);        //  [{name:"Sam"}, {name:"Tom"}, {name:"Bob"}]
```

В данном случае первый элемент массива `employees` заменяется на ссылку на новый объект, а первый элемент массива `people` по прежнему хранит ссылку на старый объект.[^5.6]

### Операции с массивами
Язык JavaScript предоставлет богатые возможности для работы с массивами, которые реализуются с помощью методов объекта `Array`:

- **`concat()`**: объединяет элементы двух массивов в один массив

- **`copyWithin()`**: копирует элементы внутри массива

- **`every()`**: проверяет, все ли элементы соответствуют определенному условию

- **`filter()`**: фильтрует элементы массива

- **`find()`**: возвращает первый элемент массива, который соответствует некоторому условию

- **`findLast()`**: возвращает последний элемент, который соответствует условию

- **`findIndex()`**: возвращает индекс первого элемента массива, который соответствует некоторому условию

- **`findLastIndex()`**: возвращает индекс последнего элемента, который соответствует условию

- **`flat()`**: упрощает структуру вложенных элементов массива.

- **`forEach()`**: применяет определенную функцию к каждому элементу массива

- **`includes()`**: проверяет, есть ли в массиве значение

- **`indexOf()`**: возвращают индекс первого включения элемента в массиве.

- **`join()`**: объединяет элементы массива в строку

- **`lastIndexOf()`**: возвращают индекс последнего включения элемента в массиве.

- **`map()`**: преобразует каждый элемент массива в другое значение на основе функции преобразования (проекция элементов)

- **`pop()`**: удаление элемента с конца массива

- **`push()`**: добавление элемента в конец массива

- **`reduce()`**: объединяет элементы массива в одно значение

- **`reverse()`**: располагает элементы массива в обратном порядке

- **`shift()`**: удаляет первый элемент массива

- **`slice()`**: копирует отдельные элементы из массива

- **`splice()`**: добавляет и удаляет элементы с определенной позиции в массиве

- **`some()`**: проверяет, соответствует ли хотя бы один элемент условию.

- **`sort()`**: сортирует массив

- **`toReversed()`**: получение копии массива с обратным порядком элементов

- **`toSorted()`**: получение отсортированной копии массива

- **`toSpliced()`**: получение элементов вне диапазона

- **`unshift()`**: добавляет новый элемент в начало массива

- **`with()`**: создание копии массива с измененными элементами

Рассмотрим применение этих методов

#### Добавление данных

##### push()
Метод **`push()`** добавляет элемент в конец массива:
```js
const people = [];
people.push("Tom");
people.push("Sam");
people.push("Bob","Mike");

console.log("В массиве people элементов: ", people.length);
console.log(people); // ["Tom", "Sam", "Bob", "Mike"]
```

##### unshift()
Метод **`unshift()`** добавляет новый элемент в начало массива:
```js
const people = ["Bob"];

people.unshift("Alice");
console.log(people);    // ["Alice", "Bob"]

people.unshift("Tom", "Sam");
console.log(people);    // ["Tom", "Sam", "Alice", "Bob"]
```

##### Добавление данных по определенному индексу
Метод **`splice`** позволяет вставить элементы на определенную позицию. Первый аргумент представляет индекс в массиве, по которому надо добавить новые элементы. Второй аргумент представляет количество элементов, которые необходимо удалить(! этот метод также применяется для удаления). Для добавления для этого аргумента устанавливается значение 0. Все остальные аргументы представляют элементы, которые необходимо добавить в массив:
```js
const people = ["Tom", "Sam", "Bob"];
people.splice(1, 0, "Alice");  // добавляем элемент "Alice" по индексу 1
console.log(people);         // ["Tom", "Alice", "Sam", "Bob"]
```

В данном случае добавляем элемент "Alice" по индексу 1.

Также можно добавляеть набор элементов, начиная с определенного индекса:
```js
const people = ["Tom", "Sam", "Bob"];
people.splice(1, 0, "Alice", "Alex", "Kate");  // добавляем элемент "Alice" по индексу 1
console.log(people);         // ["Tom", "Alice", "Alex", "Kate", "Sam", "Bob"]
```

#### Удаление данных

##### pop()
Метод **`pop()`** удаляет последний элемент из массива:
```js
const people = ["Tom", "Sam", "Bob", "Mike"];

const lastPerson = people.pop(); // извлекаем из массива последний элемент
console.log(lastPerson );   // Mike
console.log(people);    // ["Tom", "Sam", "Bob"]
```

В качестве результата метод **`pop`** возвращает удаленный элемент.

##### shift()
Метод `shift()` извлекает и удаляет первый элемент из массива:
```js
const people = ["Tom", "Sam", "Bob", "Mike"];

const first = people.shift(); // извлекаем из массива первый элемент
console.log(first); // Tom
console.log(people);    // ["Sam", "Bob", "Mike"]
```

##### Удаление элемента по индексу. splice()
Метод `splice()` также удаляет элементы с определенного индекса. Например, удаление элементов с третьего индекса:
```js
const people = ["Tom", "Sam", "Bill", "Alice", "Kate"];
const deleted = people.splice(3);
console.log(deleted);       // [ "Alice", "Kate" ]
console.log(people);         // [ "Tom", "Sam", "Bill" ]
```

Метод `splice` возвращает удаленные элементы в виде нового массива.

В данном случае удаление идет с начала массива. Если передать отрицательный индекс, то удаление будет производиться с конца массива. Например, удалим последний элемент:
```js
const people = ["Tom", "Sam", "Bill", "Alice", "Kate"];
const deleted = people.splice(-1);
console.log(deleted);       // [ "Kate" ]
console.log(people);         // ["Tom", "Sam", "Bill", "Alice"]
```

Дополнительная версия метода позволяет задать количество элементов для удаления. Например, удалим с первого индекса три элемента:
```js
const people = ["Tom", "Sam", "Bill", "Alice", "Kate"];
const deleted = people.splice(1, 3);
console.log(deleted);       // ["Sam", "Bill", "Alice"]
console.log(people);         // ["Tom", "Kate"]
```

#### Замена элементов
Метод `splice()` позволяет как добавлять, так и удалять элементы. Мы можем сочетать две эти возможности для замены одних элементов массива на другие. Например:
```js
const people = ["Tom", "Sam", "Bob", "Alice", "Kate"];
const deleted = people.splice(1, 3, "Alex", "Mike");
console.log(deleted);       // ["Sam", "Bob", "Alice"]
console.log(people);         // ["Tom", "Alex", "Mike", "Kate"]
```

Здесь удаляем с индекса 1 (первый параметр `splice`) 3 элемента (второй параметр `splice`) и вместо них вставляет два элемента — "Alex" и "Mike".

#### Копирование массива

##### slice()
Копирование массива может быть поверхностным или неглубоким (shallow copy) и глубоким (deep copy).

При неглубоком копировании достаточно присвоить переменной значение другой переменной, которая хранит массив:
```js
const users = ["Tom", "Sam", "Bill"];
console.log(users);     //  ["Tom", "Sam", "Bill"]
const people = users;       //  неглубокое копирование

people[1] = "Mike";     //  изменяем второй элемент
console.log(users);     //  ["Tom", "Mike", "Bill"]
```

В данном случае переменная `people` после копирования будет указывать на тот же массив, что и переменная `users`. Поэтому при изменении элементов в `people`, изменятся элементы и в `users`, так как фактически это один и тот же массив.

Такое поведение не всегда является желательным. Например, мы хотим, чтобы после копирования переменные указывали на отдельные массивы. И в этом случае можно использовать глубокое копирование с помощью метода **`slice()`**:
```js
const users = ["Tom", "Sam", "Bill"];
console.log(users);             //  ["Tom", "Sam", "Bill"]
const people = users.slice();       //  глубокое копирование

people[1] = "Mike";             //  изменяем второй элемент
console.log(users);             //  ["Tom", "Sam", "Bill"]
console.log(people);            //  ["Tom", "Mike", "Bill"]
```

В данном случае после копирования переменные будут указывать на разные массивы, и мы сможем изменять их отдельно друг от друга.

Но тут стоит отметить, что то же самое копирование по сути можно выполнить и с помощью spread-оператора **`...`**:
```js
const users = ["Tom", "Sam", "Bill"];
console.log(users);     //  ["Tom", "Sam", "Bill"]
const people = [...users];

people[1] = "Mike";     //  изменяем второй элемент
console.log(users);     //  ["Tom", "Sam", "Bill"]
console.log(people);     //  ["Tom", "Mike", "Bill"]
```

Также метод `slice()` позволяет скопировать часть массива. Для этого он принимает два параметра:
```js
slice(начальный_индекс, конечный_индекс)
```

Первый параметр указывает на начальный индекс элемента, с которого которые используются для выборки значений из массива. А второй параметр — конечный индекс, по который надо выполнить копирование.

Если указан только начальный индекс, и он положительный, то копирование выполняется с этого индекса до конца массива:
```js
const users = ["Tom", "Sam", "Bill", "Alice", "Kate"];
const people = users.slice(2);  // со второго индекса до конца
console.log(people);        // ["Bill", "Alice", "Kate"]
```

Если также указан только начальный индекс, но он отрицательный, индекс отсчитывается с конца массива, а копирование выполняется с конца массива до этого индекса:
```js
const users = ["Tom", "Sam", "Bill", "Alice", "Kate"];
const people = users.slice(-2);  // до второго индекса с конца
console.log(people);        // ["Alice", "Kate"]
```

Второй параметр позволяет ограничить выборку копируемых элементов. Например, выберем в новый массив элементы, начиная с 1 индекса по индекс 4 не включая:
```js
const users = ["Tom", "Sam", "Bill", "Alice", "Kate"];
const people = users.slice(1, 4);
console.log(people);        // ["Sam", "Bill", "Alice"]
```

И поскольку индексация массивов начинается с нуля, то в новом массиве окажутся второй, третий и четвертый элемент.

Второй параметр также может быть отрицательным. В этом случае второй индекс отсчитывается с конца:
```js
const users = ["Tom", "Sam", "Bill", "Alice", "Kate"];
const people = users.slice(2, -1);  // с индекса 2 по индекс 1 с конца
console.log(people);        // ["Bill", "Alice"]
```

##### copyWithin
Метод **`copyWithin()`** позволяет копировать элементы внутри массива. Он принимает три параметра:
```js
copyWithin(index1,  // позиция, в которую вставляются копируемые элементы
            index2,  // начальная позиция, с которой будут копироваться элементы
            index3   // конечная позиция, до которой будут копироваться элементы
)
```

Пример применения:
```js
const users = ["Tom", "Sam", "Bob", "Alice", "Kate"];
const people = users.copyWithin(1, 3, 5);  // элементы с индекса 3 по индекс 4 (два элемента)
                                            // копируются по индексу 1
console.log(people);    // ["Tom", "Alice", "Kate", "Alice", "Kate"]
```

#### Получение элементов вне диапазона. toSpliced
Но, возможно, мы просто хотим получить элементы вне определенного диапазона без изменения текущего массива. В этом случае мы можем использовать метод **`toSpliced()`**. Этот метод возвращает массив из элементов, которые располагаются **вне** диапазона:
```js
const people = ["Tom", "Sam", "Bill", "Alice", "Kate"];
const range = people.toSpliced(1, 3);
console.log(range);       // ["Tom", "Kate"]
console.log(people);         // ["Tom", "Sam", "Bill", "Alice", "Kate"]
```

#### concat()
Метод `concat()` служит для объединения массивов. В качестве результата он возвращает объединенный массив:
```js
const men = ["Tom", "Sam", "Bob"];
const women = ["Alice", "Kate"];
const people = men.concat(women);
console.log(people);         // ["Tom", "Sam", "Bob", "Alice", "Kate"]
```

#### join()
Метод `join()` объединяет все элементы массива в одну строку, используя определенный разделитель, который передается через параметр:
```js
const people = ["Tom", "Sam", "Bob"];

const peopleToString = people.join("; ");
console.log(peopleToString);         // Tom; Sam; Bob
```

В метод `join()` передается разделитель между элементами массива. В данном случае в качестве разделителя будет использоваться точка с запятой и пробел ("; ").

#### sort() и toSorted
Метод **`sort()`** сортирует массив по возрастанию:
```js
const people = ["Tom", "Sam", "Bob"];

people.sort();
console.log(people);         // ["Bob", "Sam", "Tom"]
```

Стоит отметить, что по умолчанию метод `sort()` рассматривает элементы массива как строки и сортирует их в алфавитном порядке. Что может привести к неожиданным результатам, например:
```js
const numbers = [200, 15, 5, 35];

numbers.sort();
console.log(numbers);         // [15, 200, 35, 5]
```

Здесь мы хотим отсортировать массив чисел, но результат может нас обескуражить: `[15, 200, 35, 5]`. В этом случае мы можем настроить метод, передав в него функцию сортировки. Логику функции сортировки мы определяем сами:
```js
const numbers = [200, 15, 5, 35];

numbers.sort( (a, b) =>  a - b);
console.log(numbers);         // [5, 15, 35, 200]
```

Функция сортировки получает два рядом расположенных элемента массива. Она возвращает отрицательное число, если первый элемент должен находится перед вторым элементом. Если первый элемент должен располагаться после второго, то возвращается положительное число. Если элементы равны, возвращается 0.

JavaScript также предоставляет метод **`toSorted()`**, которая возвращает отсортированные элементы в виде нового массива, не изменяя текущий массив:
```js
const numbers = [200, 15, 5, 35];

const sorted = numbers.toSorted();
console.log(sorted);         // [15, 200, 35, 5]
```

По умолчанию метод `toSorted()` также сортирует в алфавитном порядке. Но также можно передать в метод функцию сравнения элементов:
```js
const numbers = [200, 15, 5, 35];
const sorted = numbers.toSorted( (a, b) =>  a - b);
console.log(sorted);         // [5, 15, 35, 200]
```

#### reverse() и toReversed()
Метод **`reverse()`** меняет порядок элементов в массиве на обратный:
```js
const people = ["Tom", "Sam", "Bob"];

people.reverse();
console.log(people);         // ["Bob", "Sam", "Tom"]
```

Метод **`toReversed()`** также меняет порядок элементов на обратный, но возвращает их в виде нового массива без изменения текущего:
```js
const people = ["Tom", "Sam", "Bob"];

const reversed = people.toReversed();
console.log(people);         // ["Tom", "Sam", "Bob"]
console.log(reversed);         // ["Bob", "Sam", "Tom"]
```

#### Поиск индекса элемента
Методы **`indexOf()`** и **`lastIndexOf()`** возвращают индекс первого и последнего включения элемента в массиве. Например:
```js
const people = ["Tom", "Sam", "Bob", "Tom", "Alice", "Sam"];

const firstIndex = people.indexOf("Tom");
const lastIndex = people.lastIndexOf("Tom");
const otherIndex = people.indexOf("Mike");
console.log(firstIndex); // 0
console.log(lastIndex);  // 3
console.log(otherIndex); // -1
```

`firstIndex` имеет значение 0, так как первое включение строки "Tom" в массиве приходится на индекс 0, а последнее на индекс 3.

Если же элемент отсутствует в массиве, то в этом случае методы `indexOf()` и `lastIndexOf()` возвращают значение -1.

#### Проверка наличия элемента
Метод **`includes()`** проверяет, есть ли в массиве значение, переданное в метод через параметр. Если такое значение есть, то метод возвращает `true`, если значения в массиве нет, то возвращается `false`. Например:
```js
const people = ["Tom", "Sam", "Bob", "Tom", "Alice", "Sam"];

console.log(people.includes("Tom"));    // true - Tom есть в массиве
console.log(people.includes("Kate"))    // false - Kate нет в массиве
```

В качестве второго параметра метод **`includes()`** принимает индекс, с которого надо начинать поиск:
```js
const people = ["Tom", "Sam", "Bob", "Tom", "Alice", "Sam"];

console.log(people.includes("Bob", 2)); // true
console.log(people.includes("Bob", 4))  // false
```

В данном случае мы видим, что при поиске со 2-го индекса в массиве есть строка "Bob", тогда как начиная с 4-го индекса данная строка отсутствует.

Если если этот параметр не передается, то по умолчанию поиск идет с 0-го индекса.

При передаче отрицательного значения поиск идет с конца
```js
const people = ["Tom", "Sam", "Bob", "Tom", "Alice", "Sam"];

console.log(people.includes("Tom", -2)); // false - 2-й индекс с конца
console.log(people.includes("Tom", -3)) // true - 3-й индекс с конца
```

#### every()
Метод **`every()`** проверяет, все ли элементы соответствуют определенному условию:
```js
const numbers = [ 1, -12, 8, -4, 25, 42 ];
const passed = numbers.every(n => n > 0);
console.log(passed); // false
```

В метод `every()` в качестве параметра передается функция, которая представляет условие. Эта функция в качестве параметра принимает элемент и возвращает `true` (если элемент соответствует условию) или `false` (если не соответствует).

Если хотя бы один элемент не соответствует условию, то метод `every()` возвращает значение `false`.

В данном случае условие задается с помощью лямбда-выражения `n => n > 0`, которое проверяет, больше ли элемент нуля.

#### some()
Метод `some()` похож на метод `every()`, только он проверяет, соответствует ли хотя бы один элемент условию. И в этом случае метод `some()` возвращает `true`. Если элементов, соответствующих условию, в массиве нет, то возвращается значение `false`:
```js
const numbers = [ 1, -12, 8, -4, 25, 42 ];
const passed = numbers.some(n => n > 0);
console.log(passed); // true
```

#### filter()
Метод `filter()`, как `some()` и `every()`, принимает функцию условия:
```js
filter(callbackFn)
filter(callbackFn, thisArg)
```

В качестве параметра в `filter` передается функция-коллбек, которая будет вызываться для текущего перебираемого элемента массива. В эту функцию-коллбек можно перебрать до трех параметров:
```js
callback(element, index, array)
```

В функцию-коллбек последовательно передается текущий элемент (`element`), индекс элемента (`index`) и ссылка на сам перебираемый массив (`array`). Коллбек возвращает `true` (или значение, которое соответствует `true`), если элемент удовлетворяет условию. В ином случае возвращается `false`.

Опционально в качестве второго параметра в метод `filter()` можно передать объект, который внутри функции-коллбека можно получить через `this`.

В качестве результата метод `filter()` возвращает массив тех элементов, которые соответствуют этому условию:
```js
const numbers = [ 1, -12, 8, -4, 25, 42 ];
const filteredNumbers = numbers.filter(n => n > 0);
console.log(filteredNumbers); // [1, 8, 25, 42]
```

#### Перебор элементов с помощью forEach()
Метод **`forEach()`** осуществляют перебор элементов и применяют к каждому из них определенное действие.
```js
forEach(callbackFn)
forEach(callbackFn, thisArg)
```

В качестве параметра в `forEach` передается функция-коллбек, которая будет вызываться для текущего перебираемого элемента массива. В эту функцию-коллбек можно перебрать до трех параметров:
```js
callback(element, index, array)
```

В функцию-коллбек последовательно передается текущий элемент (`element`), индекс элемента (`index`) и ссылка на сам перебираемый массив (`array`).

Опционально в качестве второго параметра в метод `forEach()` можно передать объект, который внутри функции-коллбека можно получить через `this`.

Например, используем метод `forEach()` для вычисления квадратов чисел в массиве:
```js
const numbers = [ 1, 2, 3, 4, 5, 6];

numbers.forEach(n =>
    console.log("Квадрат числа", n, "равен", n * n )
);
```

Метод `forEach()` в качестве параметра принимает функцию, которая имеет один параметр — текущий перебираемый элемент массива. А в теле функции над этим элементом можно выполнить различные операции.

Консольный вывод программы:
```
Квадрат числа 1 равен 1
Квадрат числа 2 равен 4
Квадрат числа 3 равен 9
Квадрат числа 4 равен 16
Квадрат числа 5 равен 25
Квадрат числа 6 равен 36
```

#### Трансформация массива и map()
Метод `map()` похож на метод `forEach`, он принимает те же параметры:
```js
map(callbackFn)
map(callbackFn, thisArg)
```

Первый параметр — также функция-коллбек, в которую передаются текущий перебираемый элемент, его индекс и ссылка на массив. А второй параметр — значение для `this` внутри функции-коллбека. Но при этом метод `map()` возвращает новый массив с результатами операций над элементами массива.

Например, применим метод `map` к вычислению квадратов чисел массива:
```js
const numbers = [ 1, 2, 3, 4, 5, 6];

const squares = numbers.map(n => n * n);
console.log(squares);   //  [1, 4, 9, 16, 25, 36]
```

Функция, которая передается в метод `map()` получает текущий перебираемый элемент, выполняет над ним операции и возвращает некоторое значение. Это значение затем попадает в результирующий массив `squares`.

#### Поиск в массиве
Метод **`find()`** возвращает первый элемент массива, который соответствует некоторому условию. В качестве параметр метод `find` принимает функцию условия:
```js
const numbers = [1, 2, 3, 5, 8, 13, 21, 34];

// получаем первый элемент, который больше 10
let found = numbers.find(n => n > 10 );
console.log(found); // 13
```

В данном случае получаем первый элемент, который больше 10. Если элемент, соответствующий условию, не найден, то возвращается `undefined`.

Аналогично метод **`findLast()`** возвращает последний элемент, который соответствует условию:
```js
const numbers = [1, 2, 3, 5, 8, 13, 21, 34];

// получаем последний элемент, который меньше 10
let found = numbers.find(n => n < 10 );
console.log(found); // 8
```

Метод **`findIndex`** также принимает функцию условия, только возвращает индекс первого элемента массива, который соответствует этому условию:
```js
const numbers = [1, 2, 3, 5, 8, 13, 21, 34];

// получаем индекс первого элемента, который больше 10
let foundIndex = numbers.findIndex(n => n > 10 );
console.log(foundIndex);    // 5
```

Если элемент не найден, то возвращается число -1.

Аналогично метод **`findLastIndex()`** возвращает индекс последнего элемента, который соответствует условию:
```js
const numbers = [1, 2, 3, 5, 8, 13, 21, 34];

// получаем индекс последнего элемента,  который меньше 10
let foundIndex = numbers.findIndex(n => n < 10 );
console.log(foundIndex);    // 4
```

#### Метод flat и преобразование массива
Метод **`flat()`** упрощает массив с учетом указанной вложенности элементов:
```js
const people = ["Tom", "Bob", ["Alice", "Kate", ["Sam", "Ann"]]];
const flattenPeople = people.flat();
console.log(flattenPeople); // ["Tom", "Bob", "Alice", "Kate", ["Sam", "Ann"]]
```

То есть метод `flat()` фактически из вложенных массивов переводит элементы во внешний массив самого верхнего уровня. Однако мы видим, что элементы массива второго уровня вложенности перешли в массив первого уровня вложенности, но тем не менее по-прежнему находятся во вложенном массиве. Дело в том, что метод `flat()` по умолчанию применяется только к вложенным массивам первого уровня вложенности. Но мы можем передать в метод уровень вложености:
```js
const people = ["Tom", "Bob", ["Alice", "Kate", ["Sam", "Ann"]]];
const flattenPeople = people.flat(2);
console.log(flattenPeople); // ["Tom", "Bob", "Alice", "Kate", "Sam", "Ann"]
```

Если массив содержит вложенные массивы гораздо более глубоких уровней вложенности, или мы даже не знаем, какие уровни вложенности есть в массиве, но мы хотим, чтобы все элементы были преобразованы в один массив, то можно использовать значение `Infinity`:
```js
const people = ["Tom", "Bob", ["Alice", "Kate", ["Sam", "Ann"]]];
const flattenPeople = people.flat(Infinity);
console.log(flattenPeople); // ["Tom", "Bob", "Alice", "Kate", "Sam", "Ann"]
```

#### with
Иногда необходимо изменить элемент массива, но при этом также сохранить старое состояние массива. Метод **`with()`** автоматически создает копию старого массива, изменяет в ней элемент и возвращает новый массив с измененным элементом:
```js
const people = ["Tom", "Bob", "Sam"];
const modified = people.with(0, "Tomas");   // изменяем "Tom" на "Tomas"
console.log(people);    // ["Tom", "Bob", "Sam"] - начальный массив не изменился
console.log(modified);  // ["Tomas", "Bob", "Sam"] - изменилась копия
```

#### reduce
Метод **`reduce`** позволяет свести все значения массива в одно значение, которое возвращается из метода. В качестве параметра метод принимает функцию с 4 параметрами:
```js
function (prev,current, curIndex, array){ .... }
```

Параметры:

1. `prev`: предыдущий элемент (в начале — самый первый элемент)

2. `current`: текущий элемент (в начале — второй элемент)

3. `curIndex`: индекс текущего элемента

4. `array`: массив, для которого вызывается функция

Применим метод `reduce()` для нахождения суммы массива чисел:
```js
const numbers = [1, 2, 3, 4, 5];
const sum = numbers.reduce((prev,current) => prev +=current);
console.log(sum);   // 15
```

В данном случае в метод `reduce()` передается функция `(prev,current) => prev +=current`, которая складывает предыдущий элемент с текущим и возвращает их сумму.

Другая форма метода reduce принимает два параметра. Второй параметр — начальное значение, с которого начинается отсчет:
```js
const numbers = [1, 2, 3, 4, 5];
const sum = numbers.reduce((prev,current) => prev +current, 10);
console.log(sum);   // 25
```

В данном случае начальное значение prev будет равно 10.

Если метод `reduce` просматривает элементы массива с начала (слева направо), то метод `reduceRight()` делает это в обратном порядке — справо налево:
```js
const numbers = [1, 2, 3, 4, 5];
const reduced1 = numbers.reduce((prev,current) => prev +=current.toString());
console.log(reduced1);   // 12345
const reduced2 = numbers.reduceRight((prev,current) => prev +=current.toString());
console.log(reduced2);   // 54321
```

#### Комбинация методов
При необходимости мы можем объединить несколько операций в цепочку методов. Например, у нас есть массив пользователей:[^5.7]
```js
function Person(name, age){
        this.name = name;
        this.age = age;
}
const people = [
        new Person("Tom", 38), new Person("Kate", 31), 
        new Person("Bob", 42), new Person("Alice", 34), 
        new Person("Sam", 25)
    ];
```

Выведем из массива `people` имена всех пользователей, у которых возраст больше 33:
```js
const isAgeMoreThan33 = (p)=>p.age > 33;
const getPersonName = (p)=>p.name;
const printPersonName = (p)=>console.log(p);
 // получаем из Person строку с именем
const view = people
                .filter(isAgeMoreThan33)
                .map(getPersonName)
                .forEach(printPersonName);
```

### Наследование массивов
Массив представляет наиболее простой способ определения набора данных. Но иногда базовых возможностей массивов может быть недсотаточно. Например, определим массив, который представляет некоторую команду:
```js
const team = ["Tom", "Sam", "Bob"];
for(const person of team) {
    console.log(person);
}
```

Но что, если мы хотим добавить к команде какие-то дополнительные атрибуты — имя тренера, страну или город, где базируется команда, название, какие-то другие признаки? На первый взгляд, мы можем определить сложный объект:
```js
const team = {
    name: "Barcelona",              // название
    members: ["Tom", "Sam", "Bob"]  // игроки
};
for(const person of team.members) {
    console.log(person);
}
```

Но есть и другое решение, которое позволяет нам определить свой тип коллекции: создать свой класс, который будет унаследован от `Array`.

```js
class Team extends Array{

    constructor(name, ...members){
        super(...members);
        this.name = name;
    }
}
```

Здесь мы предполагаем, что в качестве первого параметра конструктора класса выступает имя команды, а в качестве второго — набор игроков команды, число которых не фиксировано.

Благодаря наследованию от `Array` мы можем рассматривать объекты класса `Team` как наборы данных и применять к ним все те операции, которые применяются к массивам:
```js
class Team extends Array{

    constructor(name, ...members){
        super(...members);
        this.name = name;
    }
}
// создаем объект команды
const barcelona = new Team("Barcelona", "Tom", "Sam", "Bob");
console.log(barcelona);     // Team(3) ["Tom", "Sam", "Bob"]

// перебор набора
for(const person of barcelona) {
    console.log(person);
}
barcelona.push("Tim");      // добавим один элемент
console.log(barcelona);     // Team(4) ["Tom", "Sam", "Bob", "Tim"]
barcelona.splice(1, 1);     // удалим второй элемент
console.log(barcelona);     // Team(3) ["Tom", "Bob", "Tim"]
```

#### Переопределение методов
Как и в общем при наследоваании м можем переопределять унаследованные методы. Например, переопределим поведение метода добавления **`push()`**, который отвечает за добавление в конец массива:
```js
class Team extends Array{

    constructor(name, ...members){
        super(...members);
        this.name = name;
    }
    push(person){
        if(person !== "admin") super.push(person);
    }
}

const snowbars = new Team("SnowBars", "Tom", "Sam", "Bob");

snowbars.push("admin");     // добавим один элемент - admin
console.log(snowbars);      // Team(3) ["Tom", "Sam", "Bob"]
snowbars.push("Tim");       // добавим один элемент - Tim
console.log(snowbars);      // Team(4) ["Tom", "Sam", "Bob", "Tim"]
```

В данном случае если в метод передано любое имя, кроме "admin", то оно добавляется в команду.[^5.8]

### Практическая работа. Работа с массивами

1. Запросить у пользователя три любых значения. Создать массив из этих элементов, удалить второй элемент и вывести оставшиеся значения по элементам в консоль.

2. Запросить у пользователя ряд значений любого типа. Ограничением последовательности является ввод пустого значения. Вывести все значения в консоль в порядке, обратном вводу.

3. Запросить у пользователя ряд значений любого типа. Ограничением последовательности является ввод пустого значения. Вывести в консоль два массива: исходный (значения в котором расположены в порядке введения пользователем) и с отсортированными по возрастанию значениями. Выводимые значения элементов массивов разделять точкой с запятой.

4. Сформировать двумерный массив чисел на основе данных, вводимых пользователем. Количество строк и столбцов должно определяться пользователем. Вывести итоговый массив в консоль.

6. Сформировать прямоугольную матрицу на основе данных, вводимых пользователем. Вывести транспонированную матрицу.

Каждую задачу оформить в виде отдельного файла-сценария с названием, соответствующим номеру задачи (*task_01.js*, *task_02.js*, *task_03.js*, *task_04.js*, *task_05.js*).

По завершении все задачи проверяются, проводится код-ревью и общий разбор ошибок.

#### Дополнительные задачи
1. Создать массив из трех элементов, значения которых вводятся пользователем. Удалить второй элемент и вывести массив по элементам с новой строки.

2. Дан массив чисел. Вывести его в обратном порядке с помощью метода `reverse()`.

3. Дан массив с элементами разного типа (например, `['c', 5, 2, 'b', 3, 1, 4, 'a']`). Отсортировать и вывести его по возрастанию.

4. Дан массив чисел. Соединить все элементы массива строкой с разделителем "+" с помощью метода `join()`.

5. Даны два массива чисел. Объединить их, отсортировать и найти медиану итогового массива.

6. Создать двумерный массив 3x3 и вывести элемент по центру.​

7. Переместить все нули из массива в его конец, сохраняя порядок остальных элементов.

8. Найти уникальный элемент в массиве и вернуть его.

9. Разделить массив на части заданного размера.

10. Объединить два массива, чередуя их элементы.

### Источники информации
[^2.5]: [Введение в массивы](https://metanit.com/web/javascript/2.5.php)
[^5.3]: [Создание массива и объект Array](https://metanit.com/web/javascript/5.3.php)
[^5.6]: [Массивы и spread-оператор](https://metanit.com/web/javascript/5.6.php)
[^5.7]: [Операции с массивами](https://metanit.com/web/javascript/5.7.php)
[^5.8]: [Наследование массивов](https://metanit.com/web/javascript/5.8.php)
