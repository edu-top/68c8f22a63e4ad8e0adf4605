## Функции

### Введение в функции
Функции представляют собой набор инструкций, которые можно повторно вызывать в различных частях программы по имени функции. В общем случае синтаксис определения функции выглядит следующим образом:
```js
function имя_функции(параметры){

    // Инструкции
}
```

Определение функции начинается с ключевого слова **`function`**, после которого следует имя функции. Наименование функции подчиняется тем же правилам, что и наименование переменной: оно может содержать только цифры, буквы, символы подчеркивания и доллара (`$`) и должно начинаться с буквы, символа подчеркивания или доллара.

После имени функции в скобках идет перечисление параметров. Даже если параметров у функции нет, то просто идут пустые скобки. Затем в фигурных скобках идет тело функции, содержащее набор инструкций.

Определим простейшую функцию:
```js
function hello(){

    console.log("Hello Metanit.com");
}
```

Данная функция называется `hello()`. Она не принимает никаких параметров и все, что она делает, это выводит на консоль браузера строку "Hello Metanit.com".

Чтобы функция выполнила свою работу, нам надо ее вызвать. Общий синтаксис вызова функции:
```js
имя_функции(параметры)
```

При вызове после имени вызываемой функции в скобках указывается список параметров. Если функция не имеет параметров, то указывются пустые скобки.

Например, определим и вызовем простейшую функцию:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>METANIT.COM</title>
</head>
<body>
<script>
// определение функции
function hello(){

    console.log("Hello Metanit.com");
}
// вызов функции
hello();
</script>
</body>
</html>
```

В данном случае функция `hello` не принимает параметров, поэтому при ее вызове указываются пустые скобки:
```js
hello();
```

![Функции в JavaScript](../img/3.2.png)

Отличительной чертой функций является то, что их можно многократно вызывать в различных местах программы:
```js
// определение функции
function hello(){
    console.log("Hello Metanit.com");
}
// вызов функции
hello();
hello();
hello();
```

#### Переменные и константы в качестве функций
Подобно тому, как константам и переменным присваиваются простейшие значения (числа, строки и т.д.), также им можно присваивать функции. Затем через такую переменную или константу можно вызвать присвоенную ей функцию:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>METANIT.COM</title>
</head>
<body>
<script>
// определение функции
function hello(){
    console.log("Hello from Metanit.com");
}
// передача константе message ссылки на функцию hello
const message = hello;
message();  // вызываем функцию, ссылка на которую хранится в константе message
</script>
</body>
</html>
```

Присвоив константе или переменной функцию:
```js
const message = hello;
```

затем мы можем по имени константы/переменной вызывать эту функцию:
```js
message();
```

Также мы можем динамически менять функции, которые хранятся в переменной:
```js
function goodMorning(){
    console.log("Доброе утро");
}
function goodEvening(){
    console.log("Добрый вечер");
}
let message = goodMorning;      // присваиваем переменной message функцию goodMorning
message();      // Доброе утро
message = goodEvening;          // меняем функцию в переменной message
message();      // Добрый вечер
```

#### Функции-выражения и анонимные функции
Необязательно давать функциям определенное имя. Можно использовать анонимные функции. Такие функции при определении присваиваются константе или переменной. Эти функции еще называют функции-выражения (function expression):
```js
const message = function(){

    console.log("Hello JavaScript");
}
message();
```

Используя имя константы или переменной, которой присвоена функция, можно вызывать эту функцию.

#### Локальные функции
JavaScript позволяет определять локальные функции — функции внутри других функций. Локальные функции видно только в рамках внешней функции, в которой они определены. Например:
```js
function print(){

    printHello();
    printHello();
    printHello();

    function printHello(){
        console.log("Hello");
    }
}
print();
printHello();   // Uncaught ReferenceError: printHello is not defined - локальную функцию можно вызвать только из ее окружающей функции
```

Здесь внутри функции `print` определена локальная функция `printHello`, которая просто выводит строку "Hello". И внутри функции `print` мы можем вызвать локальную функцию `printHello`, однако вне окружающей функции локальную функцию вызвать нельзя.

Данный пример довольно простой и не имеет большого смысла. Однако, как правило, локальные функции определяются для таких действий, которые применяются многократно только в рамках какой-то одной функции и больше нигде. К минусам локальных функции можно отнести то, что они создаются всякий раз, когда происходит вызов внешней функции.[^3.1]

### Параметры функции
Функция в JavaScript может принимать параметры. Параметры представляют способ передачи в функцию данных. Параметры указываются в скобках после названия функции.

Например, определим простейшую функцию, которая принимает один параметр:
```js
function print(message){
    console.log(message);
}

print("Hello JavaScript");
print("Hello METANIT.COM");
print("Function in JavaScript");
```

Функция `print()` принимает один параметр — `message`. Поэтому при вызове функции мы можем передать для него значение, например, некоторую строку:
```js
print("Hello JavaScript");
```

Передаваемые параметрам значения еще называют аргументами.

При этом в отличие от ряда других языков программирования мы в принципе можем не передавать значения параметрам. Например:
```js
function print(message){
    console.log(message);
}
print();
```

Если параметру не передается значение, тогда он будет иметь значение `undefined`.

Если функция принимает несколько параметров, то они перечисляются через запятую:
```js
function sum(a, b){
    const result = a + b;
    console.log(result);
}

sum(2, 6);          // 8
sum(4, 5);          // 9
sum(109, 11);       // 120
```

При вызове функции с несколькими параметрами значения передаются параметрам по позиции. То есть первое значение передается первому параметру, второе значение — второму и так далее. Например, в вызове:
```js
sum(2, 6);
```

#### Передача массива в качестве параметра и spread-оператор
Какие-то связанные данные удобно держать в виде массива. И, возможно, у нас возникнет необходимость передать весь этот набор данных в функцию. В общем случае мы можем передавать массив в качестве параметра и внутри функции обращаться к его отдельным элементам:
```js
function printPerson(person) {
    console.log("Name:", person[0]);
    console.log("Age:", person[1]);
    console.log("Email:", person[2]);
    console.log("=========================");
}
const tom = ["Tom", 39, "tom@example.com"];
const bob = ["Bob", 43, "bob@example.com"];

printPerson(tom);
printPerson(bob);
```

В данном случае функция `printPerson` принимает массив, который, как предполагается, имеет три элемента. И внутри функции происходит обращение к этим элементам.

Но рассмотрим другую ситуацию, когда функция принимает данные в виде отдельных параметров. И в этом случае удобнее использовать **spread-оператор**:
```js
function printPerson(username, age, email) {
    console.log("Name:", username);
    console.log("Age:", age);
    console.log("Email:", email);
    console.log("=========================");
}

const tom = ["Tom", 39, "tom@example.com"];
const bob = ["Bob", 43, "bob@example.com"];

printPerson(...tom);
printPerson(...bob);
```

Чтобы последовательно передать элементы массива параметрам функции перед именем массива указывается spread-оператор:
```js
printPerson(...tom);
```

Это все равно, что если бы мы написали
```js
printPerson(tom[0], tom[1], tom[2]);
```

только spread-оператор позволяет сделать передачу значений лаконичней.

#### Необязательные параметры и значения по умолчанию
Функция может принимать множество параметров, но при этом часть или все параметры могут быть необязательными. Если для параметров не передается значение, то по умолчанию они имеют значение "undefined". Однако иногда бывает необходимо, чтобы параметры обязательно имели какие-то значения, например, значения по умолчанию. До стандарта ES6 необходимо было проверять значения параметров на `undefined`:
```js
function sum(x, y){

    if(y === undefined) y = 5;
    if(x === undefined) x = 8;
    const z = x + y;
    console.log(z);
}
sum();          // 13
sum(6);         // 11
sum(6, 4)       // 10
```

Здесь функция `sum()` принимает два параметра. При вызове функции мы можем проверить их значения. При этом, вызывая функцию, необязательно передавать для этих параметров значения. Для проверки наличия значения параметров используется сравнение со значением `undefined`.

Также мы можем напрямую определять для параметров значения по умолчанию:
```js
function sum(x = 8, y = 5){

    const z = x + y;
    console.log(z);
}
sum();      // 13
sum(6);     // 11
sum(6, 4)   // 10
```

Если параметрам `x` и `y` не передаются значения, то они получаются в качестве значений числа 5 и 10 соответствено. Такой способ более лаконичен и интуитивен, чем сравнение с `undefined`.

При этом значение параметра по умолчанию может быть производным, представлять выражение:
```js
function sum(x = 8, y = 10 + x){

    const z = x + y;
    console.log(z);
}
sum();      // 26
sum(6);     // 22
sum(6, 4)   // 10
```

В данном случае значение параметра `y` зависит от значения `x`.

#### Функции с произвольным количеством параметров
JavaScript позволяет определять так называемые **variadic function** или функции с произвольным количеством параметров. Для этого можно использовать ряд инструментов.

##### Объект arguments
При необходимости мы можем получить все переданные параметры через доступный внутри функции объект **`arguments`**:
```js
function sum(){
    let result = 0;
    for(const n of arguments)
        result += n;
    console.log(result);
}
sum(6);             // 6
sum(6, 4)           // 10
sum(6, 4, 5)        // 15
```

При этом даже не важно, что при определении функции мы не указали никаких параметров, мы все равно можем их передать и получить их значения через **`arguments`**.

Причем мы можем даже определить параметры явным образом:
```js
function sum(a, b, c){
    console.log("a =", a);
    console.log("b =", b);
    console.log("c =", c);

    let result = 0;
    for(const n of arguments)
        result += n;
    console.log("result =", result);
}
sum(6, 4, 5, 8)     // 23
```

Несмотря на то, что функция формально принимает 3 параметра, мы можем передать ей большее количество аргументов и получить их через массив `arguments`. Консольный вывод программы:
```
a = 6
b = 4
c = 5
result = 23
```

Хотя мы можем перебрать объект **`arguments`** как массив, тем не менее это не массив. Хотя мы можем получить его длину с помощью свойства `length` и обращаться к переданным в функцию аргументам, используя индекс:
```js
function sum(nums){
    let result = 0;  // результат функции
    if(arguments.length >=1)     // если передан как минимум один параметр
    {
        result = result + arguments[0]; // обращаемся к первому параметру
    }
    if(arguments.length >=2) // если передано как минимум два параметра
    {
        result = result + arguments[1]; // обращаемся ко второму параметру
    }
    console.log("result =", result);
}

sum(6)          // result = 6
sum(6, 5)       // result = 11
sum(6, 5, 4)    // result = 11 - третий параметр не учитывается
```

##### rest-оператор
С помощью оператора **`...`** (rest-оператор) также можно передать переменное количество значений:
```js
function sum(...numbers){
    let result = 0;
    for(const n of numbers)
        result += n;
    console.log(result);
}
sum(6, 4, 5)     // 15
```

В данном случае параметр `...numbers` указывает, что вместо него можно передать разное количество значений. В самой функции `numbers` фактически представляет массив переданных значений, которые мы можем получить. При этом несмотря на это, при вызове функции в нее передается не массив, а именно отдельные значения.

Подобные rest-параметры можно комбинировать с обычными параметрами:
```js
function display(season, ...temps){
    console.log(season);
    for(index in temps){
        console.log(temps[index]);
    }
}
display("Весна", -2, -3, 4, 2, 5);
display("Лето", 20, 23, 31);
```

Здесь первое значение, передаваемое в функцию, будет интерпретироваться как значение для параметра `season`, все остальные значения перейдут параметру `temps`.

Консольный вывод:
```
Весна
-2
-3
4
2
5
Лето
20
23
31
```

##### Массив как параметр
Третий способ передачи неопределенного количества данных представляет передача их через параметр-массив. Хотя формально параметр у нас один (количество параметров определено), тем не менее количество конкретных данных в этом массиве неопределенно (как и в случае с массивом `arguments`):
```js
function sum(numbers){
    let result = 0;
    for(const n of numbers)
        result += n;
    console.log("result =", result);
}
const nums = [6, 4, 5, 8];
sum(nums)     // result = 23
```

#### Функции в качестве параметров
Функции могут выступать в качестве параметров других функций:
```js
function sum(x, y){
    return x + y;
}

function subtract(x, y){
    return x - y;
}

function operation(x, y, func){
  
    const result = func(x, y);
    console.log(result);
}

console.log("Sum");
operation(10, 6, sum);  // 16

console.log("Subtract");
operation(10, 6, subtract); // 4
```

Функция `operation` принимает три параметра: `x`, `y` и `func`. `func` — представляет функцию, причем на момент определения operation не важно, что это будет за функция. Единственное, что известно, что функция `func` может принимать два параметра и возвращать значение, которое затем отображается в консоли браузера. Поэтому мы можем определить различные функции (например, функции `sum` и `subtract` в данном случае) и передавать их в вызов функции `operation`.[^3.10]

### Результат функции
Функция может возвращать результат. Для этого используется оператор **`return`**, после которого указывается возвращаемое значение:
```js
function sum (a, b) {
    const result = a + b;
    return result;
}
```

В данном случае функция `sum()` принимает два параметра и возвращает их сумму. После оператора **`return`** идет возвращаемое значение. В данном случае это значение константы `result`, в реальности это может быть любое выражение, в том числе и результат другой функции.

После получения результата функции мы можем присвоить его какой-либо другой переменной или константе:
```js
function sum (a, b) {
  return a + b;
}
let num1 = sum(2, 4);
console.log(num1);  // 6

const num2 = sum(6, 34);
console.log(num2);  // 40
```

Функция может возвратить только одно значение. Если же нам надо возвратить несколько значений, то мы можем возвратить их в виде массива:
```js
function rectangle(width, height){

    const perimeter = width *2 + height * 2;
    const area = width * height;
    return [perimeter, area];
}

const rectangleData = rectangle(20, 30);
console.log(rectangleData[0]);  // 100 - периметр прямоугольника
console.log(rectangleData[1]);  // 600 - площадь прямоугольника
```

В данном случае в функцию `rectangle` передаются ширина и высота прямоугольника, а внутри функции по этим данным вычисяем периметр и площадь прямоугольника и в виде массива возвращаем из функции.

В качестве альтернативы можно поместить многочисленные возвращаемые данные в один объект:
```js
function rectangle(width, height){

    const rectPerimeter = width *2 + height * 2;
    const rectArea = width * height;
    return {perimeter: rectPerimeter, area: rectArea};
}

const rectangleData = rectangle(20, 30);
console.log("Perimeter:", rectangleData.perimeter);  // 100 - периметр прямоугольника
console.log("Area:", rectangleData.area);  // 600 - площадь прямоугольника
```

#### Возвращение функции из функции
Одна функция может возвращать другую функцию:
```js
function menu(n){

    if(n==1) return function(x, y){ return x + y;}
    else if(n==2) return function(x, y){ return x - y;}
    else if(n==3) return function(x, y){ return x * y;}
    return function(){ return 0;}
}

const action = menu(1);         // выбираем первый пункт - сложение
const result = action(2, 5);    // выполняем функцию и получаем результат в константу result
console.log(result);            // 7
```

В данном случае функция `menu()` в зависимости от переданного в нее значения возвращает одну из трех функций или пустую функцию, которая просто возвращает число 0.

Далее мы вызываем функцию `menu` и получаем результат этой функции — другую функцию в константу `action`.[^3.11]

```js
const action = menu(1);
```

То есть здесь `action` будет представлять функцию, которая принимает два параметра и возвращает число. Затем через имя константы мы можем вызвать эту функцию и получить ее результат в константу `result`:
```js
const result = action(2, 5);
```

Подобным образом мы можем получить и другую возвращаемые функции:
```js
function menu(n){

    if(n==1) return function(x, y){ return x + y;}
    else if(n==2) return function(x, y){ return x - y;}
    else if(n==3) return function(x, y){ return x * y;}
    return function(){ return 0;};
}

let action = menu(1);
console.log(action(2, 5));          // 7

action = menu(2);
console.log(action(2, 5));          // -3

action = menu(3);
console.log(action(2, 5));          // 10

action = menu(190);
console.log(action(2, 5));          // 0
```

Аналогичным образом можно возвращать функции по имени:
```js
function sum(x, y){ return x + y;}
function subtract(x, y){ return x - y;}
function multiply(x, y){ return x * y;}
function zero(){ return 0;}

function menu(n){

    switch(n){
        case 1: return sum;
        case 2: return subtract;
        case 3: return multiply;
        default: return zero;
    }

}

let action = menu(1);
console.log(action(5, 4));          // 9

action = menu(2);
console.log(action(5, 4));          // 1

action = menu(3);
console.log(action(5, 4));          // 20

action = menu(190);
console.log(action(5, 4));          // 0
```

### Стрелочные функции
Стрелочные функции (arrow functions) позоляют сократить определение обычных функций. Стрелочные функции определяются с помощью оператора `=>`, перед которым в скобках идут параметры функции, а после — собственно тело функции.

```js
(параметры) => действия_функции
```

Для примера возьмем сначала обычную примитивную функцию, которая выводит сообщение на консоль:
```js
function hello(){
    console.log("Hello");
}
hello();    // вызываем функцию
```

Теперь переделаем ее в стрелочную функцию:
```js
const hello = ()=> console.log("Hello");
hello();
```

В данном случае стрелочная функция присваивается константе `hello`, через которую затем можно вызвать данную функцию.

Здесь мы не используем параметры, поэтому указываются пустые скобки `()=> console.log("Hello");`

Далее через имя переменной мы можем вызвать данную функцию.

#### Передача параметров
Теперь определим стрелочную функцию, которая принимает один параметр:
```js
const print = (mes)=> console.log(mes);

print("Hello Metanit.com");
print("Welcome to JavaScript");
```

Здесь стрелочная функция принимает один параметр mes, значение которого выводится на консоль браузера.

Если стрелочная функция имеет только один параметр, то скобки вокруг списка параметров можно опустить:
```js
const print = mes=> console.log(mes);

print("Hello Metanit.com");
print("Welcome to JavaScript");
```

Другой пример — передадим два параметра:
```js
const sum = (x, y)=> console.log("Sum =", x + y);

sum(1, 2);      // Sum = 3
sum(4, 3);      // Sum = 7
sum(103, 2);    // Sum = 105
```

#### Возвращение результата
Чтобы возвратить значение из стрелочной функции, нам достаточно указать его после стрелки. Например, определим функцию, которая возвращает сумму двух чисел:
```js
const sum = (x, y)=> x + y;

console.log(sum(1, 2));     // 3
console.log(sum(4, 3));     // 7
console.log(sum(102, 5));   // 107
```

Другой пример — возвратим отформатированную строку:
```js
const hello = name => `Hello, ${name}`;

console.log(hello("Tom"));              // Hello, Tom
console.log(hello("Bob"));              // Hello, Bob
console.log(hello("Frodo Baggins"));    // Hello, Frodo Baggins
```

В данном случае функция `hello` принимает один параметр `name` — условное имя и создает на его основе сообщение с приветствием.

#### Возвращение объекта
Особо следует остановиться на случае, когда стрелочная функция возвращает объект:
```js
const user = (userName, userAge) => ({name: userName, age: userAge});

let tom = user("Tom", 34);
let bob = user("Bob", 25);

console.log(tom.name, tom.age);     // "Tom", 34
console.log(bob.name, bob.age);     // "Bob", 25
```

Объект также определяется с помощью фигурных скобок, но при этом он заключается в круглые скобки.

#### Функция из нескольких инструкций
Выше в примерах все стрелочные функции имели только одну инструкцию. Если же функция должна выполнять больше действий, то они, как и в обычной функции, заключаются в фигурные скобки:
```js
const square = n => {
    const result = n * n;
    console.log(result);
}

square(5);     // 25
square(6);     // 36
```

А если надо возвратить результат, применяется оператор `return`, как в обычной функции:[^3.8]
```js
const square = n => {
    const result = n * n;
    return result;
}

console.log(square(5));     // 25
```

### Область видимости переменных
Все переменные и константы в JavaScript имеют определенную область видимости, в пределах которой они могут действовать.

#### Глобальные переменные
Все переменные и константы, которые объявлены вне функций, являются глобальными:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>METANIT.COM</title>
</head>
<body>
<script>
var a = 5;
let b = 8;
const c = 9;
function displaySum(){

    var d = a + b + c;
    console.log(d);
}
displaySum(); // 22
</script>
</body>
</html>
```

Здесь переменные `a` и `b` и константа c являются глобальными. Они доступны из любого места программы.

А вот переменная `d` глобальной не является, так как она определена внутри функции и видна только в этой функции.

#### Определение локальной области видимости
Для определения локальной области видимости в JavaScript используются фигурные скобки `{ }`, которые создают блок кода. Этот блок кода может быть безымянным, может быть именнованным, например, функция, либо может представлять условную или циклическую конструкцию. Например, определение переменных в безымянном блоке кода:
```js
{
    var a = 5;
    let b = 8;
    const c = 9;
}
```

Однако в этом случае поведение переменной зависит от способа ее определения (через `var` или через `let`) и от типа блока. **`var`** определяет локальные переменные **уровня функции**, а **`let`** определяет локальные переменные **уровня блока кода** (подобным образом **`const`** определяет константы **уровня блока кода**). Рассмотрим, в чем состоит отличие.

#### Переменные и константы функции
Переменные и константы, определенные внутри функции, видны (то есть могут использоваться) только внутри этой функции:
```js
function print(){

    var a = 5;
    let b = 8;
    const c = 9;
    console.log("Function print: a =", a);
    console.log("Function print: b =", b);
    console.log("Function print: c =", c);
}
print();
console.log("Global: a =", a);  // Uncaught ReferenceError: a is not defined
```

Переменные `a` и `b` и константа c являются локальными, они существуют только в пределах функции. Вне функции их нельзя использовать, поэтому мы получим следующий консольный вывод:
```
Function print: a= 5
Function print: b= 8
Function print: c= 9
Uncaught ReferenceError: a is not defined
```

Здесь мы видим, что при попытке обратиться к переменной a вне функции `print()`, браузер выводит ошибку. При этом подобное поведение не зависит от того, что это за переменная — `var` или `let`, либо это константа. Подобное поведение для всех переменных и констант одинаково.

#### Локальные переменные в блоках кода, условиях и циклах
С переменными, которые определяются в безымянных блоках кода, а также в циклах и условных конструкциях ситуация чуть сложнее.

##### Переменная var
Переменная, объявленная с помощью **`var`**, может использоваться вне блока:
```js
// безымянный блок
{
    var a = 5;
}
console.log("a =", a);  // a = 5

// условная конструкция
if(true){
    var b = 6;
}
console.log("b =", b);  // b = 6

// цикл
for(let i = 0; i < 5; i++){
    var c = 7;
}
console.log("c =", c);  // c = 7
```

Единственное условие, что блок кода должен срабатывать, чтобы инициализировать переменную. Так, в примере выше условие в конструкции `if` и в цикле `for` установлено так, что блок этих конструкций будет выполняться. Однако, что если условие будет иным, и блок не будет выполняться?

```js
if(false){
    var b = 6;
}
console.log("b =", b);  // b = undefined

// цикл
for(let i = 1; i < 0; i++){
    var c = 7;
}
console.log("c =", c);  // c = undefined
```

В таком случае мы опять же сможем обращаться к переменным, только они будут иметь значение **`undefined`**.

##### Переменная let и константы
Теперь посмотрим, как будут вести себя в подобной ситуации переменные, определенные с помощью **`let`**:
```js
{
    let a = 5;
}
console.log("a =", a);  // Uncaught ReferenceError: a is not defined
```

В данном случае мы получим ошибку. Мы можем использовать переменные **`let`**, определенные внутри блока кода, только **внутри этого блока кода**.

Тоже самое относится и к константам:
```js
{
    const b = 5;
}
console.log("b =", b);  // Uncaught ReferenceError: b is not defined
```

#### Скрытие переменных
Что если у нас есть две переменных — одна глобальная, а другая локальная, которые имеют одинаковое имя:
```js
var z = 89;
function print(){

    var z = 10;
    console.log(z); // 10
}
print(); // 10
```

В этом случае в функции будет использоваться та переменная `z`, которая определена непосредственно в функции. То есть локальная переменная скроет глобальную. Однако конкретное поведение при скрытии зависит от того, как определяется переменная.

##### Скрытие переменной var
Выше было указано, что **`var`** определяет переменную **уровня функции**. Поэтому с помощью оператора `var` мы НЕ можем определить одновременно две переменных с одним и тем же именем и в функции, и в блоке кода в этой функции. Если мы это сделаем, то при объявлении переменной на уровне блока мы меняем значение переменной уровня функции:
```js
function displayZ(){

    var z = 20;

    {
        var z = 30; // Не определяет новую переменную, а изменяет значение переменной z уровня функции
        console.log("Block:", z);
    }
    console.log("Function:", z);
}
displayZ();
```

Здесь определение переменной `z` внутри блока фактически будет равноценно изменению значения переменной уровня функции и фактически это будет одна и та же переменная. Консольный вывод:
```
Block: 30
Function: 30
```

##### Скрытие переменной let
Как писалось выше, оператор **`let`** определяет переменную **уровня блока кода**. То есть каждый блок кода определяет новую область видимости, в которой существует переменная. Вне блока кода, где определена переменная, она не существует. Соответственно мы можем одновременно определить переменную на уровне блока и на уровне функции (в отличие от `var`):
```js
let z = 10;
function displayZ(){

    let z = 20;

    {
        let z = 30;
        console.log("Block:", z);
    }

    console.log("Function:", z);
}

displayZ();
console.log("Global:", z);
```

Здесь внутри функции `displayZ` определен блок кода, в котором определена переменная `z` (вместо безымянного блока это мог быть и блок условной конструкции или цикла). Она скрывает глобальную переменную и переменную `z`, определенную на уровне функции.

И в данном случае мы получим следующий консольный вывод:
```
Block: 30
Function: 20
Global: 10
```

##### Константы
Все, что относится к оператору `let`, относится и к оператору `const`, который определяет константы **уровня блока кода**. Блоки кода задают область видимости констант, а константы, определенные на вложенных блоках кода, скрывают внешние константы с тем же именем:
```js
const z = 10;
function displayZ(){

    const z = 20;

    {
        const z = 30;
        console.log("Block:", z);   // 30
    }
    console.log("Function:", z);    // 20
}

displayZ();
console.log("Global:", z);  // 10
```

#### Scope chain / Цепочка областей видимости
При выполнении кода, когда интерпретатор сталкивается с каким-то идентификатором (название переменной, константы, функции), то вначале он ищет опеределение этого идентификатора в текущей области видимости, благодаря чему собственно и работает скрытие переменных и констант. Например,
```js
const z = 10;
function displayZ(){

    const z = 20;
    console.log(z); // 20
}

displayZ();     // 20
```

Здесь интепретатор увидит, что в функции `displayZ` идет обращение к идентификатору `z`, и будет искать определение этого идентификатора внутри функции `displayZ`. И поскольку в этой функции есть определение константы `const z = 20`, то именно эта константа и будет использоваться.

Другой пример:
```js
const z = 10;
function displayZ(){

    console.log(z); // 10
}

displayZ();     // 10
```

Теперь внутри функции `displayZ` нет определения идентификатора `z`, поэтому для его поиска применяется `scope chain` — интерпретатор обращается к окружающей области видимости и выполняет поиск там. То есть смотри области видимости по цепочке от текущей — к внешним вплоть до глобальной области видимости.

#### Необъявленные переменные
При определении переменных в JavaScript мы можем не использовать ключевое слово **`let`** или **`var`**. Например:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>METANIT.COM</title>
</head>
<body>
    <script>
        {
            username = "Tom";
        }
        console.log(username);  // ошибки нет
        {
            console.log(username);  // ошибки нет, доступна внутри других блоков кода
        }
    </script>
</body>
</html>
```

Если мы не используем это ключевое слово **`let`**/**`var`** при определении переменной в функции, то такая переменная будет глобальной. Например:
```js
function setAge(){
    userage = 39;
}
setAge();
console.log(userage);   // 39
```

Несмотря на то, что вне функции `setAge` переменная `userage` нигде не определяется, тем не менее она доступна вне функции во внешнем контексте. Единственное условие — мы вызываем функцию, где определена такая переменная.

Однако если мы не вызовем функцию, переменная будет не определена:
```js
function setAge(){
    userage = 39;
}

// setAge();    Функция НЕ вызывается
console.log(userage);   // ошибка - Uncaught ReferenceError: userage is not defined
```

Ту же ошибку мы получили бы, если бы мы не только присваивали значение переменной, но и определяли бы ее как локальную по отношению к функции:
```js
function setAge(){
    var userage = 39;
}

setAge();
console.log(userage);   // ошибка - Uncaught ReferenceError: userage is not defined
```

#### strict mode
Определение глобальных переменных в функциях может вести к потенциальным ошибкам. Чтобы их избежать используется строгий режим или `strict mode`. Установить режим `strict mode` можно двумя способами:

- добавить выражение "use strict" в начало кода JavaScript, тогда strict mode будет применяться для всего кода

- добавить выражение "use strict" в начало тела функции, тогда strict mode будет применяться только для этой функции.[^3.2]

Глобальное применение `strict mode`:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>METANIT.COM</title>
</head>
<body>
    <script>
        "use strict";       // используем строгий режим

        username = "Tom";   // Uncaught ReferenceError: username is not defined
        console.log(username);
    </script>
</body>
</html>
```

В этом случае мы получим ошибку `SyntaxError: Unexpected identifier`, которая говорит о том, что переменная `username` не определена.

Аналогичную ошибку мы получим при определении глобальной переменной в функции:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>METANIT.COM</title>
</head>
<body>
    <script>
        "use strict";       // используем строгий режим
        function setAge(){
            userage = 39;       // Uncaught ReferenceError: userage is not defined
        }
        setAge();
        console.log(userage);
    </script>
</body>
</html>
```

Пример использования строгого режима на уровне функции:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>METANIT.COM</title>
</head>
<body>
    <script>
        username = "Tom";   // норм
        console.log(username);  // Tom

        function setAge(){
            "use strict";       // используем строгий режим на уровне функции
            userage = 39;       // Uncaught ReferenceError: userage is not defined
        }
        setAge();
        console.log(userage);
    </script>
</body>
</html>
```

### Практическая работа. Функциональное программирование
1. Создайте функцию, которая принимает имя пользователя и возвращает приветственное сообщение с этим именем (например, «Привет, Иван!»). В случае отсутствующего аргумента выводить «Привет, гость!»

2. Напишите функцию, которая принимает массив чисел и возвращает новый массив с только положительными или только отрицательными числами в зависимости от второго аргумента.

3. Создайте функцию, находяющую среднее значение по всем своим числовым аргументам. Число аргументов неограничено (может быть любым).

4. Напишите функцию, которая возвращает одну из функций, выполняющих математическое действие (сложение, вычитание, умножение, деление) над двумя аргументами. Результат возврата (одна из четырех возвращаемых функции) определяется значением аргумента.

5. Напишите функцию, принимающую числовые переменные и функцию обратного вызова для выполнения любой заданной пользователем математической операции над переданными числами.

#### Дополнительные задачи

1. Напишите функцию, которая принимает два числа и возвращает их сумму либо произведение в зависимости от значения третьего аргумента.

2. Напишите функцию, которая вычисляет факториал числа.

3. Создайте функцию, которая проверяет, является ли число четным.

4. Создайте функцию, которая принимает строку и возвращает ее в нижнем регистре.

5. Напишите функцию, которая принимает число и возвращает `true`, если оно простое, и `false` — иначе.

6. Создайте функцию, которая принимает два числа и возвращает большее из них.

7. Напишите функцию, которая принимает массив строк и возвращает строку, состоящую из первых символов всех строк.

8. Создайте функцию, которая принимает число и возвращает функцию, которая умножает переданный ей аргумент на это число.

9. Напишите функцию `mul(n,m)`, которая принимает два аргумента и возвращает произведение этих аргументов. Проверьте ее работу.

10. Создайте функцию `repeat(str, n)`, которая возвращает строку, состоящую и `n` повторений строки `str`. `n` — по умолчанию 2, `М` — пустая строка.

11. Создайте функцию `rgb()`, которая будет принимать три числовых аргумента и возвращать строку вида «rgb(23,100,134)». Если аргументы не заданы, считать их равными нулю.

12. Создайте функцию `avg()`, которая будет находить среднее значение по всем своим аргументам (аргументы величины числовые).

13. Напишите функцию `operation(m,n,o)`, в которой `m` и `n` — числовые переменные, а `o` — функциональный литерал, который берет два аргумента и выполняет математическую операцию над ними.

14. Напишите функцию `addN(n)`, которая вернёт другую функцию. Возвращенная функция должна складывать получаемый аргумент с аргументом `n` возвращающей функции.

### Источники информации
[^3.1]: [Функциональное программирование](https://metanit.com/web/javascript/3.1.php)
[^3.10]: [Параметры функции](https://metanit.com/web/javascript/3.10.php)
[^3.11]: [Результат функции](https://metanit.com/web/javascript/3.11.php)
[^3.8]: [Стрелочные функции](https://metanit.com/web/javascript/3.8.php)
[^3.2]: [Область видимости переменных](https://metanit.com/web/javascript/3.2.php)
