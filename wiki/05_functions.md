## Функции

### Введение в функции
Функции представляют собой набор инструкций, которые можно повторно вызывать в различных частях программы по имени функции. В общем случае синтаксис определения функции выглядит следующим образом:
```js
function имя_функции(параметры){

    // Инструкции
}
```

Определение функции начинается с ключевого слова **`function`**, после которого следует имя функции. Наименование функции подчиняется тем же правилам, что и наименование переменной: оно может содержать только цифры, буквы, символы подчеркивания и доллара (`$`) и должно начинаться с буквы, символа подчеркивания или доллара.

После имени функции в скобках идет перечисление параметров. Даже если параметров у функции нет, то просто идут пустые скобки. Затем в фигурных скобках идет тело функции, содержащее набор инструкций.

Определим простейшую функцию:
```js
function hello(){

    console.log("Hello Metanit.com");
}
```

Данная функция называется `hello()`. Она не принимает никаких параметров и все, что она делает, это выводит на консоль браузера строку "Hello Metanit.com".

Чтобы функция выполнила свою работу, нам надо ее вызвать. Общий синтаксис вызова функции:
```js
имя_функции(параметры)
```

При вызове после имени вызываемой функции в скобках указывается список параметров. Если функция не имеет параметров, то указывются пустые скобки.

Например, определим и вызовем простейшую функцию:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>METANIT.COM</title>
</head>
<body>
<script>
// определение функции
function hello(){

    console.log("Hello Metanit.com");
}
// вызов функции
hello();
</script>
</body>
</html>
```

В данном случае функция `hello` не принимает параметров, поэтому при ее вызове указываются пустые скобки:
```js
hello();
```

![Функции в JavaScript](../img/3.2.png)

Отличительной чертой функций является то, что их можно многократно вызывать в различных местах программы:
```js
// определение функции
function hello(){
    console.log("Hello Metanit.com");
}
// вызов функции
hello();
hello();
hello();
```

#### Переменные и константы в качестве функций
Подобно тому, как константам и переменным присваиваются простейшие значения (числа, строки и т.д.), также им можно присваивать функции. Затем через такую переменную или константу можно вызвать присвоенную ей функцию:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>METANIT.COM</title>
</head>
<body>
<script>
// определение функции
function hello(){
    console.log("Hello from Metanit.com");
}
// передача константе message ссылки на функцию hello
const message = hello;
message();  // вызываем функцию, ссылка на которую хранится в константе message
</script>
</body>
</html>
```

Присвоив константе или переменной функцию:
```js
const message = hello;
```

затем мы можем по имени константы/переменной вызывать эту функцию:
```js
message();
```

Также мы можем динамически менять функции, которые хранятся в переменной:
```js
function goodMorning(){
    console.log("Доброе утро");
}
function goodEvening(){
    console.log("Добрый вечер");
}
let message = goodMorning;      // присваиваем переменной message функцию goodMorning
message();      // Доброе утро
message = goodEvening;          // меняем функцию в переменной message
message();      // Добрый вечер
```

#### Функции-выражения и анонимные функции
Необязательно давать функциям определенное имя. Можно использовать анонимные функции. Такие функции при определении присваиваются константе или переменной. Эти функции еще называют функции-выражения (function expression):
```js
const message = function(){

    console.log("Hello JavaScript");
}
message();
```

Используя имя константы или переменной, которой присвоена функция, можно вызывать эту функцию.

#### Локальные функции
JavaScript позволяет определять локальные функции — функции внутри других функций. Локальные функции видно только в рамках внешней функции, в которой они определены. Например:
```js
function print(){

    printHello();
    printHello();
    printHello();

    function printHello(){
        console.log("Hello");
    }
}
print();
printHello();   // Uncaught ReferenceError: printHello is not defined - локальную функцию можно вызвать только из ее окружающей функции
```

Здесь внутри функции `print` определена локальная функция `printHello`, которая просто выводит строку "Hello". И внутри функции `print` мы можем вызвать локальную функцию `printHello`, однако вне окружающей функции локальную функцию вызвать нельзя.

Данный пример довольно простой и не имеет большого смысла. Однако, как правило, локальные функции определяются для таких действий, которые применяются многократно только в рамках какой-то одной функции и больше нигде. К минусам локальных функции можно отнести то, что они создаются всякий раз, когда происходит вызов внешней функции.[^3.1]

### Параметры функции
Функция в JavaScript может принимать параметры. Параметры представляют способ передачи в функцию данных. Параметры указываются в скобках после названия функции.

Например, определим простейшую функцию, которая принимает один параметр:
```js
function print(message){
    console.log(message);
}

print("Hello JavaScript");
print("Hello METANIT.COM");
print("Function in JavaScript");
```

Функция `print()` принимает один параметр — `message`. Поэтому при вызове функции мы можем передать для него значение, например, некоторую строку:
```js
print("Hello JavaScript");
```

Передаваемые параметрам значения еще называют аргументами.

При этом в отличие от ряда других языков программирования мы в принципе можем не передавать значения параметрам. Например:
```js
function print(message){
    console.log(message);
}
print();
```

Если параметру не передается значение, тогда он будет иметь значение `undefined`.

Если функция принимает несколько параметров, то они перечисляются через запятую:
```js
function sum(a, b){
    const result = a + b;
    console.log(result);
}

sum(2, 6);          // 8
sum(4, 5);          // 9
sum(109, 11);       // 120
```

При вызове функции с несколькими параметрами значения передаются параметрам по позиции. То есть первое значение передается первому параметру, второе значение — второму и так далее. Например, в вызове:
```js
sum(2, 6);
```

#### Передача массива в качестве параметра и spread-оператор
Какие-то связанные данные удобно держать в виде массива. И, возможно, у нас возникнет необходимость передать весь этот набор данных в функцию. В общем случае мы можем передавать массив в качестве параметра и внутри функции обращаться к его отдельным элементам:
```js
function printPerson(person) {
    console.log("Name:", person[0]);
    console.log("Age:", person[1]);
    console.log("Email:", person[2]);
    console.log("=========================");
}
const tom = ["Tom", 39, "tom@example.com"];
const bob = ["Bob", 43, "bob@example.com"];

printPerson(tom);
printPerson(bob);
```

В данном случае функция `printPerson` принимает массив, который, как предполагается, имеет три элемента. И внутри функции происходит обращение к этим элементам.

Но рассмотрим другую ситуацию, когда функция принимает данные в виде отдельных параметров. И в этом случае удобнее использовать **spread-оператор**:
```js
function printPerson(username, age, email) {
    console.log("Name:", username);
    console.log("Age:", age);
    console.log("Email:", email);
    console.log("=========================");
}

const tom = ["Tom", 39, "tom@example.com"];
const bob = ["Bob", 43, "bob@example.com"];

printPerson(...tom);
printPerson(...bob);
```

Чтобы последовательно передать элементы массива параметрам функции перед именем массива указывается spread-оператор:
```js
printPerson(...tom);
```

Это все равно, что если бы мы написали
```js
printPerson(tom[0], tom[1], tom[2]);
```

только spread-оператор позволяет сделать передачу значений лаконичней.

#### Необязательные параметры и значения по умолчанию
Функция может принимать множество параметров, но при этом часть или все параметры могут быть необязательными. Если для параметров не передается значение, то по умолчанию они имеют значение "undefined". Однако иногда бывает необходимо, чтобы параметры обязательно имели какие-то значения, например, значения по умолчанию. До стандарта ES6 необходимо было проверять значения параметров на `undefined`:
```js
function sum(x, y){

    if(y === undefined) y = 5;
    if(x === undefined) x = 8;
    const z = x + y;
    console.log(z);
}
sum();          // 13
sum(6);         // 11
sum(6, 4)       // 10
```

Здесь функция `sum()` принимает два параметра. При вызове функции мы можем проверить их значения. При этом, вызывая функцию, необязательно передавать для этих параметров значения. Для проверки наличия значения параметров используется сравнение со значением `undefined`.

Также мы можем напрямую определять для параметров значения по умолчанию:
```js
function sum(x = 8, y = 5){

    const z = x + y;
    console.log(z);
}
sum();      // 13
sum(6);     // 11
sum(6, 4)   // 10
```

Если параметрам `x` и `y` не передаются значения, то они получаются в качестве значений числа 5 и 10 соответствено. Такой способ более лаконичен и интуитивен, чем сравнение с `undefined`.

При этом значение параметра по умолчанию может быть производным, представлять выражение:
```js
function sum(x = 8, y = 10 + x){

    const z = x + y;
    console.log(z);
}
sum();      // 26
sum(6);     // 22
sum(6, 4)   // 10
```

В данном случае значение параметра `y` зависит от значения `x`.

#### Функции с произвольным количеством параметров
JavaScript позволяет определять так называемые **variadic function** или функции с произвольным количеством параметров. Для этого можно использовать ряд инструментов.

##### Объект arguments
При необходимости мы можем получить все переданные параметры через доступный внутри функции объект **`arguments`**:
```js
function sum(){
    let result = 0;
    for(const n of arguments)
        result += n;
    console.log(result);
}
sum(6);             // 6
sum(6, 4)           // 10
sum(6, 4, 5)        // 15
```

При этом даже не важно, что при определении функции мы не указали никаких параметров, мы все равно можем их передать и получить их значения через **`arguments`**.

Причем мы можем даже определить параметры явным образом:
```js
function sum(a, b, c){
    console.log("a =", a);
    console.log("b =", b);
    console.log("c =", c);

    let result = 0;
    for(const n of arguments)
        result += n;
    console.log("result =", result);
}
sum(6, 4, 5, 8)     // 23
```

Несмотря на то, что функция формально принимает 3 параметра, мы можем передать ей большее количество аргументов и получить их через массив `arguments`. Консольный вывод программы:
```
a = 6
b = 4
c = 5
result = 23
```

Хотя мы можем перебрать объект **`arguments`** как массив, тем не менее это не массив. Хотя мы можем получить его длину с помощью свойства `length` и обращаться к переданным в функцию аргументам, используя индекс:
```js
function sum(nums){
    let result = 0;  // результат функции
    if(arguments.length >=1)     // если передан как минимум один параметр
    {
        result = result + arguments[0]; // обращаемся к первому параметру
    }
    if(arguments.length >=2) // если передано как минимум два параметра
    {
        result = result + arguments[1]; // обращаемся ко второму параметру
    }
    console.log("result =", result);
}

sum(6)          // result = 6
sum(6, 5)       // result = 11
sum(6, 5, 4)    // result = 11 - третий параметр не учитывается
```

##### rest-оператор
С помощью оператора **`...`** (rest-оператор) также можно передать переменное количество значений:
```js
function sum(...numbers){
    let result = 0;
    for(const n of numbers)
        result += n;
    console.log(result);
}
sum(6, 4, 5)     // 15
```

В данном случае параметр `...numbers` указывает, что вместо него можно передать разное количество значений. В самой функции `numbers` фактически представляет массив переданных значений, которые мы можем получить. При этом несмотря на это, при вызове функции в нее передается не массив, а именно отдельные значения.

Подобные rest-параметры можно комбинировать с обычными параметрами:
```js
function display(season, ...temps){
    console.log(season);
    for(index in temps){
        console.log(temps[index]);
    }
}
display("Весна", -2, -3, 4, 2, 5);
display("Лето", 20, 23, 31);
```

Здесь первое значение, передаваемое в функцию, будет интерпретироваться как значение для параметра `season`, все остальные значения перейдут параметру `temps`.

Консольный вывод:
```
Весна
-2
-3
4
2
5
Лето
20
23
31
```

##### Массив как параметр
Третий способ передачи неопределенного количества данных представляет передача их через параметр-массив. Хотя формально параметр у нас один (количество параметров определено), тем не менее количество конкретных данных в этом массиве неопределенно (как и в случае с массивом `arguments`):
```js
function sum(numbers){
    let result = 0;
    for(const n of numbers)
        result += n;
    console.log("result =", result);
}
const nums = [6, 4, 5, 8];
sum(nums)     // result = 23
```

#### Функции в качестве параметров
Функции могут выступать в качестве параметров других функций:
```js
function sum(x, y){
    return x + y;
}

function subtract(x, y){
    return x - y;
}

function operation(x, y, func){
  
    const result = func(x, y);
    console.log(result);
}

console.log("Sum");
operation(10, 6, sum);  // 16

console.log("Subtract");
operation(10, 6, subtract); // 4
```

Функция `operation` принимает три параметра: `x`, `y` и `func`. `func` — представляет функцию, причем на момент определения operation не важно, что это будет за функция. Единственное, что известно, что функция `func` может принимать два параметра и возвращать значение, которое затем отображается в консоли браузера. Поэтому мы можем определить различные функции (например, функции `sum` и `subtract` в данном случае) и передавать их в вызов функции `operation`.[^3.10]

### Результат функции
Функция может возвращать результат. Для этого используется оператор **`return`**, после которого указывается возвращаемое значение:
```js
function sum (a, b) {
    const result = a + b;
    return result;
}
```

В данном случае функция `sum()` принимает два параметра и возвращает их сумму. После оператора **`return`** идет возвращаемое значение. В данном случае это значение константы `result`, в реальности это может быть любое выражение, в том числе и результат другой функции.

После получения результата функции мы можем присвоить его какой-либо другой переменной или константе:
```js
function sum (a, b) {
  return a + b;
}
let num1 = sum(2, 4);
console.log(num1);  // 6

const num2 = sum(6, 34);
console.log(num2);  // 40
```

Функция может возвратить только одно значение. Если же нам надо возвратить несколько значений, то мы можем возвратить их в виде массива:
```js
function rectangle(width, height){

    const perimeter = width *2 + height * 2;
    const area = width * height;
    return [perimeter, area];
}

const rectangleData = rectangle(20, 30);
console.log(rectangleData[0]);  // 100 - периметр прямоугольника
console.log(rectangleData[1]);  // 600 - площадь прямоугольника
```

В данном случае в функцию `rectangle` передаются ширина и высота прямоугольника, а внутри функции по этим данным вычисяем периметр и площадь прямоугольника и в виде массива возвращаем из функции.

В качестве альтернативы можно поместить многочисленные возвращаемые данные в один объект:
```js
function rectangle(width, height){

    const rectPerimeter = width *2 + height * 2;
    const rectArea = width * height;
    return {perimeter: rectPerimeter, area: rectArea};
}

const rectangleData = rectangle(20, 30);
console.log("Perimeter:", rectangleData.perimeter);  // 100 - периметр прямоугольника
console.log("Area:", rectangleData.area);  // 600 - площадь прямоугольника
```

#### Возвращение функции из функции
Одна функция может возвращать другую функцию:
```js
function menu(n){

    if(n==1) return function(x, y){ return x + y;}
    else if(n==2) return function(x, y){ return x - y;}
    else if(n==3) return function(x, y){ return x * y;}
    return function(){ return 0;}
}

const action = menu(1);         // выбираем первый пункт - сложение
const result = action(2, 5);    // выполняем функцию и получаем результат в константу result
console.log(result);            // 7
```

В данном случае функция `menu()` в зависимости от переданного в нее значения возвращает одну из трех функций или пустую функцию, которая просто возвращает число 0.

Далее мы вызываем функцию `menu` и получаем результат этой функции — другую функцию в константу `action`.[^3.11]

```js
const action = menu(1);
```

То есть здесь `action` будет представлять функцию, которая принимает два параметра и возвращает число. Затем через имя константы мы можем вызвать эту функцию и получить ее результат в константу `result`:
```js
const result = action(2, 5);
```

Подобным образом мы можем получить и другую возвращаемые функции:
```js
function menu(n){

    if(n==1) return function(x, y){ return x + y;}
    else if(n==2) return function(x, y){ return x - y;}
    else if(n==3) return function(x, y){ return x * y;}
    return function(){ return 0;};
}

let action = menu(1);
console.log(action(2, 5));          // 7

action = menu(2);
console.log(action(2, 5));          // -3

action = menu(3);
console.log(action(2, 5));          // 10

action = menu(190);
console.log(action(2, 5));          // 0
```

Аналогичным образом можно возвращать функции по имени:
```js
function sum(x, y){ return x + y;}
function subtract(x, y){ return x - y;}
function multiply(x, y){ return x * y;}
function zero(){ return 0;}

function menu(n){

    switch(n){
        case 1: return sum;
        case 2: return subtract;
        case 3: return multiply;
        default: return zero;
    }

}

let action = menu(1);
console.log(action(5, 4));          // 9

action = menu(2);
console.log(action(5, 4));          // 1

action = menu(3);
console.log(action(5, 4));          // 20

action = menu(190);
console.log(action(5, 4));          // 0
```

### Стрелочные функции
Стрелочные функции (arrow functions) позоляют сократить определение обычных функций. Стрелочные функции определяются с помощью оператора `=>`, перед которым в скобках идут параметры функции, а после — собственно тело функции.

```js
(параметры) => действия_функции
```

Для примера возьмем сначала обычную примитивную функцию, которая выводит сообщение на консоль:
```js
function hello(){
    console.log("Hello");
}
hello();    // вызываем функцию
```

Теперь переделаем ее в стрелочную функцию:
```js
const hello = ()=> console.log("Hello");
hello();
```

В данном случае стрелочная функция присваивается константе `hello`, через которую затем можно вызвать данную функцию.

Здесь мы не используем параметры, поэтому указываются пустые скобки `()=> console.log("Hello");`

Далее через имя переменной мы можем вызвать данную функцию.

#### Передача параметров
Теперь определим стрелочную функцию, которая принимает один параметр:
```js
const print = (mes)=> console.log(mes);

print("Hello Metanit.com");
print("Welcome to JavaScript");
```

Здесь стрелочная функция принимает один параметр mes, значение которого выводится на консоль браузера.

Если стрелочная функция имеет только один параметр, то скобки вокруг списка параметров можно опустить:
```js
const print = mes=> console.log(mes);

print("Hello Metanit.com");
print("Welcome to JavaScript");
```

Другой пример — передадим два параметра:
```js
const sum = (x, y)=> console.log("Sum =", x + y);

sum(1, 2);      // Sum = 3
sum(4, 3);      // Sum = 7
sum(103, 2);    // Sum = 105
```

#### Возвращение результата
Чтобы возвратить значение из стрелочной функции, нам достаточно указать его после стрелки. Например, определим функцию, которая возвращает сумму двух чисел:
```js
const sum = (x, y)=> x + y;

console.log(sum(1, 2));     // 3
console.log(sum(4, 3));     // 7
console.log(sum(102, 5));   // 107
```

Другой пример — возвратим отформатированную строку:
```js
const hello = name => `Hello, ${name}`;

console.log(hello("Tom"));              // Hello, Tom
console.log(hello("Bob"));              // Hello, Bob
console.log(hello("Frodo Baggins"));    // Hello, Frodo Baggins
```

В данном случае функция `hello` принимает один параметр `name` — условное имя и создает на его основе сообщение с приветствием.

#### Возвращение объекта
Особо следует остановиться на случае, когда стрелочная функция возвращает объект:
```js
const user = (userName, userAge) => ({name: userName, age: userAge});

let tom = user("Tom", 34);
let bob = user("Bob", 25);

console.log(tom.name, tom.age);     // "Tom", 34
console.log(bob.name, bob.age);     // "Bob", 25
```

Объект также определяется с помощью фигурных скобок, но при этом он заключается в круглые скобки.

#### Функция из нескольких инструкций
Выше в примерах все стрелочные функции имели только одну инструкцию. Если же функция должна выполнять больше действий, то они, как и в обычной функции, заключаются в фигурные скобки:
```js
const square = n => {
    const result = n * n;
    console.log(result);
}

square(5);     // 25
square(6);     // 36
```

А если надо возвратить результат, применяется оператор `return`, как в обычной функции:[^3.8]
```js
const square = n => {
    const result = n * n;
    return result;
}

console.log(square(5));     // 25
```

### Источники информации
[^3.1]: [Функциональное программирование](https://metanit.com/web/javascript/3.1.php)
[^3.10]: [Параметры функции](https://metanit.com/web/javascript/3.10.php)
[^3.11]: [Результат функции](https://metanit.com/web/javascript/3.11.php)
[^3.8]: [Стрелочные функции](https://metanit.com/web/javascript/3.8.php)
