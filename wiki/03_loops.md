## Циклические алгоритмы. Циклы

И, наконец, последняя алгоритмическая конструкция — **«повторение**».

Алгоритм реализован с использованием алгоритмической конструкции «повторение», если некая группа подряд идущих шагов алгоритма (она называется телом цикла) может выполняться многократно в зависимости от входных данных.

Алгоритм, содержащий конструкцию «повторение» называется **циклическим алгоритмом**.

Существует несколько разновидностей циклических алгоритмов.

Первый — **цикл с заданным условием продолжения работы** (цикл с предусловием или цикл-пока).

Второй — **цикл с заданным условием окончания работы** (цикл с постусловием или цикл-до).

И третий — **цикл с заданным числом повторений** (цикл с параметром).

![Виды циклов](../img/4e287700-accd-44ba-9988-6395cd366d8d.png)

Доказано, что при решении задач можно ограничиться только одним циклом — циклом с предусловием. Но в ряде случаев цикл с постусловием или цикл с параметром делают решение задачи легче.

Примером решения одной и той же задачи с помощью различных циклов может служить задача возведения некоторого числа $a$ в натуральную степень $n$.[^базовые-алгоритмические-структуры]

![Решение задачи разными циклами](../img/9e9d2b8d-8156-43b1-8828-f84a97fc6935.png)

Циклы позволяют в зависимости от определенных условий выполнять некоторое действие множество раз. В JavaScript имеются следующие виды циклов:[^2.7]

- `for`

- `for..in`

- `for..of`

- `while`

- `do..while`

### Цикл while
Цикл `while` выполняется до тех пор, пока некоторое условие истинно. Его формальное определение:
```js
while(условие){

    // действия
}
```

Цикл `while` здесь будет выполняться, пока значение `i` не станет равным 6.

Выведем с помощью **`while`** числа от 1 до 5:
```js
let i = 1;
while(i <=5){

    console.log(i);
    i++;
}
```

Например, цикл ниже выводит `i`, пока `i < 3`:
```js
let i = 0;
while (i < 3) { // выводит 0, затем 1, затем 2
  alert( i );
  i++;
}
```

Если бы строка `i++` отсутствовала в примере выше, то цикл бы повторялся (в теории) вечно. На практике, конечно, браузер не позволит такому случиться, он предоставит пользователю возможность остановить «подвисший» скрипт, а JavaScript на стороне сервера придётся «убить» процесс.[^while-for]

Любое выражение или переменная может быть условием цикла, а не только сравнение: условие `while` вычисляется и преобразуется в логическое значение.

Например, `while (i)` – более краткий вариант `while (i != 0)`:
```js
let i = 3;
while (i) { // когда i будет равно 0, условие станет ложным, и цикл остановится
  alert( i );
  i--;
}
```

!!! info Фигурные скобки не требуются для тела цикла из одной строки

    Если тело цикла состоит лишь из одной инструкции, мы можем опустить фигурные скобки `{…}`:

    ```js
    let i = 3;
    while (i) alert(i--);
    ```

### do..while
В цикле `do` сначала выполняется код цикла, а потом происходит проверка условия в инструкции `while`. И пока это условие истинно, цикл повторяется. Например:
```js
let i = 1;
do{
    console.log(i);
    i++;
}while(i <= 5)
```

Здесь код цикла сработает 5 раз, пока `i` не станет равным 5. При этом цикл **`do`** гарантирует хотя бы однократное выполнение действий, даже если условие в инструкции **`while`** не будет истинно.

Такая форма синтаксиса оправдана, если необходимо, чтобы тело цикла выполнилось хотя бы один раз, даже если условие окажется ложным. На практике чаще используется форма с предусловием: `while(…) {…}`.

### Цикл for
Цикл `for` имеет следующее формальное определение:
```js
for ([инициализация счетчика]; [условие]; [изменение счетчика]){

    // действия
}
```

Например, используем цикл **`for`** для перебора чисел от 0 до 4:
```js
for(let i = 0; i<5; i++){

    console.log(i);
}
console.log("Конец работы");
```

Первая часть объявления цикла — `let i = 0` — создает и инициализирует счетчик — переменную `i`. И перед выполнением цикла ее значение будет равно 0. По сути это то же самое, что и объявление переменной.

Вторая часть — условие, при котором будет выполняться цикл: `i<5`. В данном случае цикл будет выполняться, пока значение `i` не достигнет `5`.

Третья часть — `i++` — приращение счетчика на единицу.

То есть при запуске переменная `i` равна 0. Это значение отвечает условию `i<5`, поэтому будет выполняться блок цикла, а именно строка кода
```js
console.log(i);
```

После выполнения блока цикла выполняется треться часть объявления цикла — приращение счетчика. То есть переменная `i` сановится равной 1. Это значение также отвечает условию, поэтому блок цикла снова выполняется. Таким образом, блок цикла сработает 5 раз, пока значение `i` не станет равным 5. Это значение НЕ отвечает условию, поэтому произойдет выход из цикла. И управление программой перейдет к инструкциям, которые идут после блока цикла. Консольный вывод программы:
```
0
1
2
3
4
Конец работы
```

Каждое отдельное повторение цикла называется <dfn title="итерация">итерацией</dfn>. Таким образом, в данном случае сработают 5 итераций.

При этом необязательно увеличивать счетчик на единицу, можно производить с ним другие действия, например, уменьшать на единицу:
```js
for(let i = 10; i > 5; i--){

    console.log(i);
}
```

В данном случае на консоль выводится числа от 10 до 6.

Или увеличим счетчик на 2:
```js
for(let i = 0; i < 10; i+=2){

    console.log(i);
}
```

Здесь выводятся на консоль все четные числа от 0 до 8.

!!! info Встроенное объявление переменной

    В примере переменная счётчика `i` была объявлена прямо в цикле. Это так называемое «встроенное» объявление переменной. Такие переменные существуют только внутри цикла.

    ```js
    for (let i = 0; i < 3; i++) {
    alert(i); // 0, 1, 2
    }
    alert(i); // ошибка, нет такой переменной
    ```

    Вместо объявления новой переменной мы можем использовать уже существующую:
    ```js
    let i = 0;

    for (i = 0; i < 3; i++) { // используем существующую переменную
    alert(i); // 0, 1, 2
    }

    alert(i); // 3, переменная доступна, т.к. была объявлена снаружи цикла
    ```

Счетчик удобно использовать как индекс элементов массива и таким образом перебирать массив:
```js
const people = ["Tom", "Sam", "Bob"];
for(let i=0; i < 3; i++){

     console.log(people[i]);
}
```

Консольный вывод браузера:
```
Tom
Sam
Bob
```

#### Пропуск частей «for»
Любая часть `for` может быть пропущена. Таким образом можно опускать различные части объявления цикла:
```js
let i = 0;
for(; i < 60;){

    console.log(i);
    i = i + 10;
}
```

В данном случае переменная `i` определена вне цикла. В самом объявлении цикла есть только условие, остальные две части отсутствуют. Изменение переменной происходит в самом блоке цикла: оно увеличивается на 10. В итоге на консоль будут выведены числа 0, 10, 20, 30, 40, 50.

Для примера, мы можем пропустить начало если нам ничего не нужно делать перед стартом цикла.

Вот так:
```js
let i = 0; // мы уже имеем объявленную i с присвоенным значением

for (; i < 3; i++) { // нет необходимости в "начале"
  alert( i ); // 0, 1, 2
}
```

Можно убрать и шаг:
```js
let i = 0;

for (; i < 3;) {
  alert( i++ );
}
```

Это сделает цикл аналогичным `while (i < 3)`.

А можно и вообще убрать всё, получив бесконечный цикл:
```js
for (;;) {
  // будет выполняться вечно
}
```

При этом сами точки с запятой `;` обязательно должны присутствовать, иначе будет ошибка синтаксиса.

#### Применение нескольких счетчиков в цикле
При необходимости можно использовать несколько счетчиков:
```js
for(let i = 1, j=1; i < 5, j < 4; i++, j++){

    console.log(i + j);
}
// 1 итерация: i=1, j=1; i + j = 2
// 2 итерация: i=2, j=2; i + j = 4
// 3 итерация: i=3, j=3; i + j = 6
```

Здесь теперь используются два счетчика и два условия. Рассмотрим пошагово, что здесь происходит:

  1. Первая итерация. Начальные значения переменных `i` и `y`:

        ```js
        i=1, j=1;
        ```

        Для каждой переменной установлены свои условия. И вначале начальные значения переменных соответствуют этим условиям:

        ```js
        i < 5, j < 4;
        ```

        В блоке цикла выводится сумма этих переменных. И дальше значения обоих переменных увеличиваются на единицу. Они становятся равны
        ```js
        i=2, j=2;
        ```

        Эти значения также соответствуют условиям, поэтому выполняется вторая итерация.

2. Вторая итерация. Значения переменных `i` и `y`:

    ```js
    i=2, j=2;
    ```

    После выполнения блока цикла значения обоих переменных увеличиваются на единицу. Они становятся равны
    ```js
    i=3, j=3;
    ```

    Эти значения также соответствуют условиям, поэтому выполняется третья итерация.

3. Третья итерация. Значения переменных `i` и `y`:

    ```js
    i=3, j=3;
    ```

    После выполнения блока цикла значения обоих переменных увеличиваются на единицу. Они становятся равны
    ```js
    i=4, j=4;
    ```

    Значение переменной `i` соответствует условию `i < 5`, однако значение переменной `j` (4) НЕ соответствует условию `j < 4`. Поэтому происходит выход из цикла. Его работа завершена.

#### Выполнение действий в объявлении цикла
Стоит отметит, что третья часть цикла, где обычно происходит изменение счетчика в реальности представляет произвольное действие, которое выполняется после завершения цикла. Так, мы можем написать следующим образом:
```js
for(let i = 0; i < 5; console.log(i++));
console.log("Конец работы");
```

Здесь не определено блока цикла, а сами действия цикла определены в третьей части заголовка цикла — `console.log(i++)`.

Аналогично в первой части определения цикла — инициализации мы можем выполнять некоторые действия, а не обязательно только объявление счетчика:
```js
let i=0;
for(console.log("Init"); i < 5; i++){

    console.log(i);
}
```

Здесь определение счетчика вынесено вне цикла, а в инициализационной части цикла на консоль выводится строка. Вывод браузера:
```
Init
0
1
2
3
4
```

#### Вложенные циклы
Одни циклы могут внутри себя содержать другие:
```js
for(let i=1; i <= 5; i++){

     for(let j = 1; j <=5; j++){
        console.log(i * j);
     }
}
```

Здесь один цикл включается в себя другой. ВО внешнем цикле определяется переменная `i`. Вначале она равна 1 и это значение соответствует условию цикла (`i <=5`), поэтому будет выполняться блок цикла, который содержит внутренний цикл.

Во внутреннем цикле определяется переменная-счетчик `j`, которая изначально равна 1, и потом внутренний цикл выполняет 5 итераций, пока переменная `j` не станет равна 5.

После того, как блок внешнего цикла завершен, переменная `i` увеличивается на 1 и становится равной 2, что опять же соответствует условию. И снова выполняется блок внешнего цикла. В этом блоке снова выполняются пять итераций внутреннего цикла. И так далее. В итоге внутренний цикл будет выполняться 25 раз.

Используя вложенные циклы и несколько счетчиков можно перебирать многомерные массивы:
```js
const people = [["Tom", 39], ["Sam", 28],["Bob", 42]];
for(let i=0; i < 3; i++){   // перебираем двухмерный массив

    for(let j=0; j < 2; j++){ // перебираем вложенные массивы

        console.log(people[i][j]);
    }
    console.log("=================");   // для разделения элементов
}
```

Здесь массив people представляет двухмерный массив из 3-х элементов, где каждый элемент представляет, в свою очередь, подмассив из 2-х элементов — условно имени и возраста пользователя. Во внешнем цикле определяем счетчик `i` для прохода по всем подмассивам в двухмерном массиве `people`, а во внутреннем цикле определяем счетчик `j` для прохода по всем элементам каждого подмассива. Консольный вывод:
```
Tom
39
=================
Sam
28
=================
Bob
42
=================
```

### Операторы continue и break
Обычно цикл завершается при вычислении *условия* в `false`. Иногда бывает необходимо выйти из цикла до его завершения. В этом случае мы можем воспользоваться оператором `break`:
```js
for(let i=1; i <= 6; i++){

     if(i===4) break;
     console.log(i);
}
console.log("Конец работы");
```

Данный цикл увеличивает переменную `i` c 1 до 6 включая, то есть согласно условию цикла блок цикла должен выполняться 6 раз, то есть поизвести 6 итераций. Однако поскольку в блоке цикла происходит поверка `if(i===4) break;`, то, когда значение переменной `i` достигнет 4, то данное условие прервет выполнение цикла с помощью оператора `break`. И цикл завершит работу.
```
1
2
3
Конец работы
```

Если нам надо просто пропустить итерацию, но не выходить из цикла, мы можем применять оператор **`continue`**. Например, изменим предыдущий пример, только вместо `break` используем оператор **`continue`**:
```js
for(let i=1; i <= 6; i++){

    if(i===4) continue;
    console.log(i);
}
console.log("Конец работы");
```

В этом случае, когда значение переменная `i` станет равной 4 , то выражение `i===4` возвратит `true`, поэтому будет выполняться конструкция `if(i===4) continue;`. С помощью оператора **`continue`** она завершит текущую итерацию, далее идущие инструкции цикла не будут выполняться, а произойдет переход к следующей итерации:
```js
1
2
3
5
6
Конец работы
```

Например, следующий код подсчитывает сумму вводимых чисел до тех пор, пока посетитель их вводит, а затем – выдаёт:
```js
let sum = 0;

while (true) {

  let value = +prompt("Введите число", '');

  if (!value) break; // (*)

  sum += value;

}
alert( 'Сумма: ' + sum );
```

Директива `break` в строке `(*)` полностью прекращает выполнение цикла и передаёт управление на строку за его телом, то есть на `alert`.

Вообще, сочетание «бесконечный цикл + `break`» – отличная штука для тех ситуаций, когда условие, по которому нужно прерваться, находится не в начале или конце цикла, а посередине или даже в нескольких местах его тела.

Директива `continue` – «облегчённая версия» `break`. При её выполнении цикл не прерывается, а переходит к следующей итерации (если условие все ещё равно `true`).

Её используют, если понятно, что на текущем повторе цикла делать больше нечего.

Например, цикл ниже использует `continue`, чтобы выводить только нечётные значения:
```js
for (let i = 0; i < 10; i++) {

  // если true, пропустить оставшуюся часть тела цикла
  if (i % 2 == 0) continue;

  alert(i); // 1, затем 3, 5, 7, 9
}
```

Для чётных значений `i`, директива `continue` прекращает выполнение тела цикла и передаёт управление на следующую итерацию `for` (со следующим числом). Таким образом `alert` вызывается только для нечётных значений.

!!! info Директива `continue` позволяет избегать вложенности

    Цикл, который обрабатывает только нечётные значения, мог бы выглядеть так:
    ```js
    for (let i = 0; i < 10; i++) {

    if (i % 2) {
        alert( i );
    }

    }
    ```

    С технической точки зрения он полностью идентичен. Действительно, вместо `continue` можно просто завернуть действия в блок `if`.

    Однако мы получили дополнительный уровень вложенности фигурных скобок. Если код внутри `if` более длинный, то это ухудшает читаемость, в отличие от варианта с `continue`.

!!! warning Нельзя использовать `break`/`continue` справа от оператора „?“

    Обратите внимание, что эти синтаксические конструкции не являются выражениями и не могут быть использованы с тернарным оператором `?`. В частности, использование таких директив, как `break`/`continue`, вызовет ошибку.

    Например, если мы возьмём этот код:
    ```js
    if (i > 5) {
    alert(i);
    } else {
    continue;
    }
    ```

    …и перепишем его, используя вопросительный знак:
    ```js
    (i > 5) ? alert(i) : continue; // continue здесь приведёт к ошибке
    ```

    …то будет синтаксическая ошибка.

    Это ещё один повод не использовать оператор вопросительного знака `?` вместо `if`.

### Использование меток
Бывает, нужно выйти одновременно из нескольких уровней цикла сразу.

Например, в коде ниже мы проходимся циклами по `i` и `j`, запрашивая с помощью `prompt` координаты (i, j) с (0,0) до (2,2):
```js
for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`Значение на координатах (${i},${j})`, '');

    // Что если мы захотим перейти к Готово (ниже) прямо отсюда?
  }
}

alert('Готово!');
```

Нам нужен способ остановить выполнение, если пользователь отменит ввод.

Обычный `break` после `input` лишь прервёт внутренний цикл, но этого недостаточно. Достичь желаемого поведения можно с помощью меток.

Метка имеет вид идентификатора с двоеточием перед циклом:
```js
labelName: for (...) {
  ...
}
```

Вызов `break <labelName>` в цикле ниже ищет ближайший внешний цикл с такой меткой и переходит в его конец.
```js
outer: for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`Значение на координатах (${i},${j})`, '');

    // если пустая строка или Отмена, то выйти из обоих циклов
    if (!input) break outer; // (*)

    // сделать что-нибудь со значениями...
  }
}

alert('Готово!');

```

В примере выше это означает, что вызовом `break outer` будет разорван внешний цикл до метки с именем `outer`.

Таким образом управление перейдёт со строки, помеченной `(*)`, к `alert('Готово!')`.

Можно размещать метку на отдельной строке:
```js
outer:
for (let i = 0; i < 3; i++) { ... }
```

Директива `continue` также может быть использована с меткой. В этом случае управление перейдёт на следующую итерацию цикла с меткой.

!!! warning Метки не позволяют «прыгнуть» куда угодно

Метки не дают возможности передавать управление в произвольное место кода.

Например, нет возможности сделать следующее:
```js
break label; // не прыгает к метке ниже

label: for (...)
```

Директива `break` должна находиться внутри блока кода. Технически, подойдет любой маркированный блок кода, например:
```js
label: {
  // ...
  break label; // работает
  // ...
}
```

…Хотя в 99.9% случаев `break` используется внутри циклов, как мы видели в примерах выше.

К слову, `continue` возможно только внутри цикла.

### for..in
Цикл **`for..in`** предназначен главным образом для перебора объектов. Его формальное определение:
```js
for (свойство in объект) {
    // действия
}
```

Этот цикл перебирает все свойства объекта. Например:
```js
const person = {name: "Tom", age: 37};
for(prop in person){

    console.log(prop);
}
```

Здесь перебирается объект `person`, который имеет два свойства — `name` и `age`. Соответственно на консоли мы увидим:
```
name
age
```

Получив свойства и используя специальный синтаксис `объект[свойство]`, мы можем получить значение каждого свойства:
```js
const person = {name: "Tom", age: 37};
for(prop in person){

    console.log(prop, person[prop]);
}
```

Консольный вывод:
```
name Tom
age 37
```

### Цикл for...of
Цикл **`for...of`** предназначен для перебора наборов данных. Например, строка представляет фактически набор символов. И мы можем перебрать ее с помощью данного цикла:
```js
const text = "Hello";
for(char of text){

     console.log(char);
}
```

В итоге цикл перебирает все символы строки `text` и помещает каждый текущий символ в переменную `ch`, значение которой затем выводится на консоль.
```
H
e
l
l
o
```

Другим примером может быть перебор массива:
```js
const people = ["Tom", "Sam", "Bob"];
for(const person of people) {
    console.log(person);
}
```

В данном случае цикл перебирает элементы массива `people`. Каждый элемент последовательно помещается в константу `person`. И далее мы можем вывести ее значение на консоль:
```
Tom
Sam
Bob
```

### Итого
Мы рассмотрели 3 вида циклов:

- `while` – Проверяет условие перед каждой итерацией.
- `do..while` – Проверяет условие после каждой итерации.
- `for (;;) `– Проверяет условие перед каждой итерацией, есть возможность задать дополнительные настройки.

Чтобы организовать бесконечный цикл, используют конструкцию `while (true)`. При этом он, как и любой другой цикл, может быть прерван директивой `break`.

Если на данной итерации цикла делать больше ничего не надо, но полностью прекращать цикл не следует – используют директиву `continue`.

Обе этих директивы поддерживают метки, которые ставятся перед циклом. Метки – единственный способ для `break`/`continue` выйти за пределы текущего цикла, повлиять на выполнение внешнего.

Заметим, что метки не позволяют прыгнуть в произвольное место кода, в JavaScript нет такой возможности.

### Задачи

1. Вывести с помощью цикла с предусловием числа в определенном диапазоне. Границы интервала задаются пользователем. Вывод осуществлять в консоль.

2. Вывести с помощью цикла со счетчиком только четные или только нечетные числа в определенном диапазоне. Границы интервала задаются пользователем. Четность числа подтверждается пользователем, в противном случае выводятся только нечетные числа. Вывод осуществлять в консоль.

3. Возвести число в необходимую степень с помощью любого цикла. Основание и показатель степени вводятся пользователем. Вывод осуществлять с помощью модального окна.

4. Проверить, является ли введенное пользователем число простым. Вывод осуществлять с помощью модального окна.

5. Принимать пользовательский ввод последовательности целых чисел, при этом окончанием последовательности служит число 0. Определить наибольшее введенное значение и количество его повторений в последовательности. Вывод осуществлять с помощью модального окна.

Каждую задачу оформить в виде отдельного файла-сценария с названием, соответствующим номеру задачи. Подключить все сценарии на главную страницу (*index.html*).

Во всех задачах для ввода данных использовать модальные (диалоговые) окна, ввод данных обрабатывать на наличие ошибок, при этом вывод сообщений об ошибках осуществлять с помощью встроенных функций. В случае невалидного ввода перезапрашивать данные у пользователя.

По завершении все задачи проверяются, проводится код-ревью и общий разбор ошибок.

===

1. Вывести все целые числа из диапазона от А до В, кратные трем (А<=В).
2. Вывести все целые числа из диапазона от А до В ( А<=В ), оканчивающиеся на цифру Х.
3. Ввести целое число N > 0. Используя операции деления нацело и взятия остатка от деления, найти число, полученное при прочтении числа N справа налево.
4. Ввести действительное число х и натуральное число n. Вычислить x*(x - n)*(x - 2*n)(x - 3*n)…(x - n2).
5. Осуществить ввод последовательности целых чисел. Определить, сколько из них и какие принимают наибольшее значение. Последовательность потенциально не ограничена, окончанием последовательности служит число 0.

### Источники информации
[^базовые-алгоритмические-структуры]: [Урок 2: Базовые алгоримтические структуры](https://resh.edu.ru/subject/lesson/5457/conspect/166580/)
[^2.7]: [Циклы](https://metanit.com/web/javascript/2.7.php)
[^while-for]: [Циклы while и for](https://learn.javascript.ru/while-for)
