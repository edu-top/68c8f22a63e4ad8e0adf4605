## Объектная модель браузера

- [Объектная модель браузера](#объектная-модель-браузера)
  - [Browser Object Model и объект window](#browser-object-model-и-объект-window)
    - [Объект window](#объект-window)
    - [Свойства window](#свойства-window)
    - [Компоненты браузера](#компоненты-браузера)
    - [Свойство screen](#свойство-screen)
  - [Диалоговые окна и поиск на странице](#диалоговые-окна-и-поиск-на-странице)
    - [alert](#alert)
    - [confirm](#confirm)
    - [prompt](#prompt)
    - [find](#find)
    - [print](#print)
  - [Открытие, закрытие и позиционирование окон](#открытие-закрытие-и-позиционирование-окон)
    - [Закрытие окна](#закрытие-окна)
    - [Управление позицией и размером окна](#управление-позицией-и-размером-окна)
  - [История браузера. History API](#история-браузера-history-api)
    - [Событие popstate](#событие-popstate)
    - [Перемещение по одностраничному сайту](#перемещение-по-одностраничному-сайту)
  - [Объект location](#объект-location)
    - [Управление адресом](#управление-адресом)
  - [Источники информации](#источники-информации)

### Browser Object Model и объект window
*[BOM]: Browser Object Model

Большое значение в JavaScript имеет работа с веб-браузером и теми объектами, которые он предоставляет. Например, использование объектов браузера позволяет манипулировать элементами html, которые имеются на странице, или взаимодействовать с пользователем.

Все объекты, через которые JavaScript взаимодействует с браузером, описываются таким понятием как **Browser Object Model** (Объектная Модель Браузера).

Browser Object Model можно представить в виде следующей схемы:

![Browser Object Model in JavaScript](../img/bom.png)

В вершине находится главный объект — объект **`window`**, который представляет глобальный объект (фактически представляет собой браузер). Этот объект в свою очередь включает ряд других объектов, в частности, объект **`document`**, который представляет отдельную веб-страницу, отображаемую в браузере.[^7.1]

#### Объект window
Объект **`window`** представляет собой окно веб-браузера, в котором размещаются веб-страницы. **`window`** является глобальным объектом, поэтому при доступе к его свойствам и методам необязательно использовать его имя. Например, объект **`window`** имеет метод **`alert()`**, который отображает окно сообщения. Но нам необязательно писать:
```js
window.alert("Привет мир!");
```

`window` можно не использовать:
```js
alert("Привет мир!");
```

Но так как данный объект глобальный, то это накладывает некоторые ограничения. Например:
```js
var alert = function(message){

    console.log("Сообщение: ", message);
};
window.alert("Привет мир!");
```

С помощью `var` здесь определяется глобальная переменная `alert`. Все объявляемые в программе глобальные переменные или функции автоматически добавляются к объекту `window`. И поскольку название новой функции будет совпадать с названием метода `alert()`, то произойдет переопределение этого метода в объекте `window` новой функцией.

И если мы объявим в программе какую-нибудь глобальную переменную, то она нам доступна как свойство в объекте `window`:
```js
var message = "hello";
console.log(window.message);
```

#### Свойства window
С помощью свойств объекта `window` можно получить различную информацию об окне браузера. В частности, для определения положения окна применяются следующие свойства:

- **`innerHeight`**: содержит высоту окна, в том числе горизонтальные полосы прокрутки

- **`innerWidth`**: содержит ширину окна, в том числе вертикальные полосы прокрутки

- **`outerHeight`**: содержит высоту окна браузера, в том числе все полосы прокрутки браузера

- **`outerWidth`**: содержит ширину окна браузера, в том числе все полосы прокрутки браузера

- **`pageXOffset`**: псевдоним для `window.scrollX`

- **`pageYOffset`**: псевдоним для `window.scrollY`

- **`screenX`**: содержит позицию окна браузера по оси X, то есть расстояние от окна браузера до левого края экрана

- **`screenY`**: содержит позицию окна браузера по оси X, то есть расстояние от окна браузера до верхнего края экрана

- **`scrollX`**: содержит количество пикселей веб-страницы, прокрученных по горизонтали

- **`scrollY`**: содержит количество пикселей веб-страницы, прокрученных по вертикали

Например, получим положение окна:
```js
console.log(window.innerHeight);
console.log(window.innerWidth);
console.log(window.screenX);
console.log(window.screenY);
```

#### Компоненты браузера
Окно браузера обычно состоит из различных компонентов. В зависимости от конкретного браузера и персональных настроек набор конкретных компонентов может отличаться. Но в общем случае типовое окно браузера выглядит следующим образом:

![панели и компоненты веб-браузера в JavaScript](../img/browser3.png)

Помимо собственно области содержимого, в которой отображается веб-страница, веб-браузер имеет имеет еще ряд компонентов:

- адресная строка для ввода URL-адреса или поискового запроса (*Address Bar*)

- строка состояния (*Status Bar*), которая указывает, загружена ли веб-страница или находится в процессе загрузки

- строка меню (*Menu Bar*)

- панель инструментов (*ToolBar*)

- некоторая "личная" / "персональная" панель, которая, например, содержит закладк (*Personal Bar*)

- полосы прокрутки, которые отображают горизонтальное и вертикальное положение (*Horizontal/Vertical ScrollBar*)

Объект **`window`** имеет ограниченные возможности для взаимодействия с этими компонентами, в частности, для проверки наличия этих компонентов объект window имеет ряд свойств:

- **`locationbar`**: содержит объект, который указывает, отображается адресная строка или нет

- **`menubar`**: указывает, отображается ли панель меню или нет

- **`personalbar`**: указывает, отображается ли персональная панель (например, панель закладок) или нет

- **`scrollbars`**: указывает, отображаются ли полосы прокрутки или нет

- **`statusbar`**: указывает, отображается строка состояния или нет

- **`toolbar`**: указывает, отображается ли панель инструментов или нет

Например, узнаем отображается ли персональная панель:
```js
console.log(window.personalbar); // BarProp {visible: true} или BarProp {visible: false}
```

Свойство возвратит объект `BarProp`, в котором свойство `visible` собственно и указывает, отображается панель или нет.

#### Свойство screen
Для получения информации об экране также применяется свойство **`screen`** объекта `window`. Это свойство представляет объект типа **`Screen`**

- **`availTop`**: указывает на высоту фиксированных компонентов, которые примыкают к верхней стороне браузера, например, различных верхних панелей

- **`availLeft`**: указывает на ширину фиксированных компонентов, которые примыкают к левой стороне браузера,, например, различных левых панелей

- **`availHeight`**: содержит максимально доступную высоту в пикселях минус высоту верхних и нижних панелей

- **`availWidth`**: содержит максимально доступную ширину в пикселях минус ширину левых и правых панелей

- **`colorDepth`**: содержит глубину цвета экрана

- **`height`**: содержит высоту экрана в пикселях

- **`orientation`**: содержит объект типа `ScreenOrientation`, который предоставляет информацию об ориентации устройства

- **`pixelDepth`**: содержит глубину пикселя экрана

- **`width`**: содержит ширину экрана в пикселях

![свойство screen в window JavaScript](../img/screen.png)

Пример использования
```js
console.log(screen.availTop);       // 25
console.log(screen.availLeft);      // 0
console.log(screen.availHeight);    // 695
console.log(screen.availWidth);     // 1280
console.log(screen.width);          // 1280
console.log(screen.height);         // 800
console.log(screen.pixelDepth);     // 24
console.log(screen.colorDepth);     // 24
```

### Диалоговые окна и поиск на странице
Для взаимодействия с пользователем в объекте **`window`** определен ряд методов, которые позволяют создавать диалоговые окна или взаимодействуют с содержимым окна:

- **`alert()`**: выводит окно с сообщением

- **`confirm()`**: отображает окно с сообщением, в котором пользователь должен подтвердить действие двух кнопок OK и Отмена

- **`prompt()`**: позволяет с помощью диалогового окна запрашивать у пользователя какие-либо данные

- **`print()`**: отображает диалоговое окно для вывода страницы на печать

- **`find()`**: позволяет найти на странице определенный текст[^7.2]

#### alert
Например, с помощью метода **`alert()`** по нажатию на кнопку выведем окно с сообщением:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <button id="btn">Click</button>
    <script>
        const btn = document.getElementById("btn");
        btn.addEventListener("click", ()=>{
            alert("Hello METANIT.COM");   // отображаем всплывающее окно при нажати на кнопку
        });
    </script>
</body>
</html>
```

![функция alert в JavaScript](../img/browser4.png)

#### confirm
Метод **`confirm()`** отображает окно с сообщением, в котором пользователь должен подтвердить действие двух кнопок OK и Отмена. В зависимости от выбора пользователя метод возвращает `true` (если пользователь нажал OK) или `false` (если пользователь нажал кнопку Отмены):
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
<button id="btn">Click</button>
<script>
const btn = document.getElementById("btn");
btn.addEventListener("click", ()=>{
    const result = confirm("Завершить выполнение программы?");
    if(result===true)
        console.log("Работа программы завершена");
    else
        console.log("Программа продолжает работать");
});
</script>
</body>
</html>
```

![Функция confirm в JavaScript](../img/confirm.png)

#### prompt
Метод **`prompt()`** позволяет с помощью диалогового окна запрашивать у пользователя какие-либо данные. Данный метод возвращает введенное пользователем значение. Например, запросим на странице имя пользователя:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <button id="btn">Click</button>
    <script>
        const btn = document.getElementById("btn");
        btn.addEventListener("click", ()=>{
            const name = prompt("Введите свое имя:");
            console.log("Ваше имя: ", name)
        });
    </script>
</body>
</html>
```

Если пользователь откажется вводить значение и нажмет на кнопку отмены, то метод возвратит значение `null`.

![Функция prompt в JavaScript](../img/prompt.png)

#### find
Метод **`find()`** позволяет найти на странице текст, который передает в метод через параметр. Метод возвращает `true`, если текст найден, и `false`, если текст не найден. Например:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <input id="key" name="key" />
    <button id="btn">Find</button>
    <div>
    <p>— Ах, виноват-с, Петр Николаич! Я буду тихо, — сказал секретарь и продолжал полушёпотом: — Ну-с, а закусить, душа моя Григорий Саввич, тоже нужно умеючи. Надо знать, чем закусывать. Самая лучшая закуска, ежели желаете знать, селедка. Съели вы ее кусочек с лучком и с горчичным соусом, сейчас же, благодетель мой, пока еще чувствуете в животе искры, кушайте икру саму по себе или, ежели желаете, с лимончиком, потом простой редьки с солью, потом опять селедки, но всего лучше, благодетель, рыжики соленые, ежели их изрезать мелко, как икру, и, понимаете ли, с луком, с прованским маслом... объедение! Но налимья печенка — это трагедия!</p>
    <p>— М-да... — согласился почетный мировой, жмуря глаза. — Для закуски хороши также, того... душоные белые грибы...</p>
    </div>
    <script>
        const btn = document.getElementById("btn");
        const keyField = document.getElementById("key");
        btn.addEventListener("click", ()=>{
            const result = find(keyField.value);    // ищем введенное в поле слово
            console.log(result);
        });
    </script>
</body>
</html>
```

В данном случае по нажатию на кнопку ищем на странице введенный в текстовое поле текст. Если текст найден, то он выделяется.

![Функция find и поиск на странице в JavaScript](../img/find.png)

#### print
Метод **`print`** отображает диалоговое сообщение для вывода страницы на печать:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <button id="btn">Print</button>
    <p>Hello World</p>
    <script>
        const btn = document.getElementById("btn");
        const keyField = document.getElementById("key");
        btn.addEventListener("click", ()=>{
            print();    // выводим текущую страницу на печать
        });
    </script>
</body>
</html>
```

В зависимости от браузера окно печати может выглядеть различным образом. Например, вид в Google Chrome:

![Функция print и вывод страницы на печать в JavaScript](../img/print.png)

### Открытие, закрытие и позиционирование окон
Язык JavaScript позволят программно управлять окнами веб-браузера. Для этого объект **`window`** предоставляет ряд методов. Так, метод **`open()`** открывает определенный ресурс в новом окне или вкладке браузера. Стоит учитывать, что подобное действие лучше выполнять по действию пользователя, например, по нажатию на кнопку, потому что в ином случае браузеры могут заблокировать подобные окна. Например, определим следующую страницу:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <button onclick="openWindow()">Click</button>
    <script>
        function openWindow(){
            window.open("https://microsoft.com");
        }
    </script>
</body>
</html>
```

Здесь на веб-странице определена кнопка — элемент `button`. У кнопки установлен атрибут **`onclick`**, который указывает на функцию javascript, которая будет выполняться по нажатию этой кнопки.

В коде javascript определена функция `openWindow()`, которая выполняется по нажатию на кнопку. В этой функции выполняется функция **`window.open()`**, в которую в качестве первого параметра передается адрес — в данном случае "https://microsoft.com". И по нажатию на кнопку будет открываться в новой вкладке страницы "https://microsoft.com".

![window.open в javascript](../img/browser1.png)

Метод `open()` принимает ряд параметров:
```js
open();
open(url);
open(url, target);
open(url, target, windowFeatures);
```

В качестве первого параметра — **`url`** передается путь к ресурсу.

Второй параметр — **`target`** передается путь к ресурсу. Распространенные значения:

- **`_self`**: страница открывается в текущей вкладке

- **`_blank`**: страница открывается в новой вкладке или в отдельном окне

Например, открытие адреса в той же вкладке:
```js
window.open("https://example.com", "_self");
```

Третий параметр позволяет установить набор стилевых характеристик окна. Каждая стилевая характеристика определяется в виде наборов `name=value`, где `name` — название стилевой характеристики, а `value` — ее значение. Друг от друга стилевые характеристики отделены запятой.

В частности, можно использовать следующие характеристики:

- `popup`: указывает, будет ли открываться страница в отдельном всплывающем окне. Для этого может принимать такие значения, как `yes`, `1` или `true`. Например:

```js
window.open("https://example.com", "_blank", "popup=yes");
```

![всплывающие окна и window.open в javascript](../img/browser2.png)

- `width` / `innerWidth`: ширина окна в пикселях. Например, `width=640`

- `height` / `innerHeight`: высота окна в пикселях. Например, `height=480`

- `left` / `screenX`: координата X относительно начала экрана в пикселях. Например, `left=0`

- `top` / `screenY`: координата Y относительно начала экрана в пикселях. Например, `top=0`

- `location`: указывает, будет ли отображаться адресная строка. Например, `location=yes`

- `menubar`: указывает, будет ли отображаться панель меню. Например, `menubar=yes`

- `scrollbars`: указывает, будет ли окно иметь полосы прокрутки. Например, `scrollbars=yes`

- `status`: указывает, будет ли отображаться строка состояния. Например, `status=yes`

- `toolbar`: указывает, будет ли отображаться панель инструментов. Например, `toolbar=yes`

Последние пять параметров в качестве значений могут принимать `yes` и `no`, вместо которых также можно использовать `1` и `0` соответственно

Пример применения нескольких параметров:
```js
window.open("https://example.com", "_blank", "width=600,height=400,left=500,top=200");
```

Стоит отметить, что функция возвращает ссылку на окно, и с помощью этой ссылки мы можем управлять окном.

Также стоит отметить, что через свойство **`opener`** окна можно получить ссылку на главное окно, из которого было открыто текущее.

#### Закрытие окна
С помощью метода **`close()`** можно закрыть окно. Например:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
<button onclick="openWindow()">Open</button>
<button onclick="closeWindow()">Close</button>
<script>
let exampleWindow = null;

function openWindow(){
    if(!exampleWindow || exampleWindow.closed){  // если окно не открыто
        exampleWindow = window.open("https://example.com", "_blank", "width=600,height=400,left=500,top=200,popup=yes");
   }
}
function closeWindow(){
    exampleWindow?.close(); // если окно открыто, то закрываем его
    exampleWindow = null;
}
</script>
</body>
</html>
```

Здесь определены две кнопки для открытия и закрытия окна. Ссылка на само окно помещается в переменную `exampleWindow`, которая изначально равна `null`. По нажатию на первую кнопку вызывается функция `openWindow()`. В этой функции проверяем, что `exampleWindow` не равен null и что окно не закрыто (`exampleWindow.closed` не равно `false`). Вторая проверка необходима на случай, если окно будет закрыто нажатием на крестик в самом окне (в этом случае `closed=true`). И если окно не открыто, открываем его.

По нажатию на вторую кнопку у объекта `metanitWindow` вызываем метод `close` и устанавливаем переменную в `null`.

#### Управление позицией и размером окна
Для управления/изменения позиции и размера окна объект `window` предоставляет ряд методов:

- **`moveBy()`**: перемещает текущее окно браузера по горизонтали и вертикали на указанное количество пикселей. Первый параметр определяет перемещение по горизонтали, второй параметр - перемещение по вертикали в пикселях.

- **`moveTo()`**: перемещает текущее окно браузера по горизонтали и вертикали в указанное положение. Первый параметр определяет положение по горизонтали, второй параметр — положение по вертикали в пикселях.

- **`resizeBy()`**: масштабирует текущее окно браузера по горизонтали и вертикали на указанное количество пикселей. Первый параметр определяет значение масштабирования по горизонтали, второй параметр — значение масштабирования по вертикали.

- **`resizeTo()`**: масштабирует текущее окно браузера по горизонтали и вертикали до заданного размера. Первый параметр определяет ширину, второй параметр — высоту.

- **`scroll()`**: прокручивает содержимое окна до указанной позиции. Первый параметр указывает положение по горизонтали, второй параметр — положение по вертикали.

- **`scrollBy()`**: прокручивает содержимое окна на указанный коэффициент. Первый параметр определяет коэффициент прокрутки по горизонтали, второй параметр определяет коэффициент прокрутки по вертикали.

- **`scrollTo()`**: прокручивает содержимое окна до указанной позиции. Первый параметр указывает положение по горизонтали, второй параметр — положение по вертикали.

Примеры управления позицией и размерами окна:
```js
// сдвигаем окно браузера на 200 пикселей по горизонтали и на 100 пикселей по вертикали
window.moveBy(200, 100);
// Помещаем окно браузера на позицию с координатами (200, 150)
window.moveTo(200, 150);
// Увеличиваем окно браузера на 200 пиксей в ширину и 100 пикселей в высоту
window.resizeBy(200, 100);
// Сжимаем окно браузера на 200 пиксей в ширину и 100 пикселей в высоту
window.resizeBy(-200, -100);
// Прокручиваем контент окна на 100 пикселей по горизонтали и 200 пикселей по вертикали
window.scrollBy(100, 200);
// Прокручиваем содержимое браузера до позиции (100, 200)
window.scrollTo(100, 200);
```

Но стоит отметить, что на уровне браузера могут действовать ограничения на позиционирование и изменения размера окон, если окна загружают ресурсы с разных доменов.

Например, с помощью метода **`moveTo()`** переместитм окно на новую позицию:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
<button onclick="openWindow()">Open</button>
<button onclick="moveWindow()">Move</button>
<script>
let testWindow = null;

// открываем окно
function openWindow(){
    testWindow = window.open("test.html", "_blank", "width=600,height=400,left=200,top=200");
}
// сдвигаем окно
function moveWindow(){
    testWindow.moveTo(500,400);
}
</script>
</body>
</html>
```

В данном случае по нажатию на кнопку `Open` открываем окно, а по нажатию на кнопку `Move` перемещаем его на позицию с координатами `x=500, y=400` относительно левого верхнего угла экрана.[^7.7]

### История браузера. History API
При навигации между страницами браузер сохраняет всю историю о переходах в специальном стеке, который называется **history stack**. И каждый раз, когда браузер загружает новую веб-страницу или переходит по ссылке на веб-странице, браузер по умолчанию создает новую запись в истории просмотров. В коде JavaScript историю можно получить через свойство **`history`** объекта `window`. Данное свойство представляет тип **`History`**.[^7.3]

Объект **`History`** для взаимодействия с историей просмотров предоставляет ряд методов и свойств:

- Свойство **`length`** возвращает количество записей в истории просмотров

    ```js
    console.log("В истории ", history.length, " записей");
    ```

- Свойство **`state`** возвращает текущую запись из истории просмотров. По умолчанию при загрузке первой страницы в браузере это свойство равно `null`

    ```js
    console.log(history.state);
    ```

- Метод **`back()`** переходит к прошлой записи в истории просмотров, аналогично нажатию на кнопку Назад/Back в браузере

    ```js
    history.back(); // перемещение назад к прошлой странице
    ```

- Метод **`forward()`** переходит к следующей просмотренной странице, аналогично нажатию на кнопку Вперед/Next в браузере

    ```js
    history.forward(); // перемещение вперед к следующей странице
    ```

- Метод **`go()`** позволяет перемещаться вперед и назад по истории на определенное число страниц. Методу передается приращение, начиная с текущей веб-страницы. Например, значение -1 приводит к открытию предыдущей веб-страницы, а значение 1 вызывает открытие следующей веб-страницы. Если передается значение, для которого в истории нет соответствующей веб-страницы, этот метод ничего не делает. Если же метод вызывается без значения или со значением 0, текущая веб-страница перезагружается

    ```js
    history.go(-2);     // переход на 2 страницы назад
    history.go(2);      // переход на 2 страницы вперед
    history.go(0);      // перезагружаем текущую страницу
    ```

- Метод **`pushState()`** программно добавляет новую запись в историю просмотров. Он принимает три параметра:

    ```js
    history.pushState(state, title[, url])
    ```

  - Параметр `state` представляет добавляемый объект в историю просмотров. В качестве такого объекта состояния может быть чем угодно

  - Параметр `title` устанавливает заголовок. Стоит отметить, что браузеры могут игнорировать этот параметр

  - Параметр `url` представляет URL-адрес новой записи в истории. Является необязательным. Однако если используется, этот адрес url в этом параметре должен относиться к тому же домену, что и текущая страница. Браузер может устанавливать этот адрес в качестве текущего.

    Простейший пример
    ```js
    const state = { url: "/", title: "Home", decription: "Home Page" };
    // history.pushState(state, state.title);               // без url
    history.pushState(state, state.title, state.url);       // с url
    console.log(state);  // {url: "/", title: "Home", decription: "Home Page"}
    ```

- Метод **`replaceState()`** программно заменяет текущую запись в истории просмотров на новую. Он принимает те же три параметра:

    ```js
    history.replaceState(state, title, [url])
    ```

    Простейший пример
    ```js
    const state = { url: "home", title: "Home", decription: "Home Page" };
    history.replaceState(state, state.title, state.url);
    ```

#### Событие popstate
Каждый раз, когда текущая запись в истории посещений меняется (например, при нажатии на кнопку "Назад" в браузере), срабатывает событие **`popstate`**. Соответственно если мы хотим обрабатывать перемещение по истории просмотров с помощью кнопок браузера Назад/Вперед, то нам надо обрабатывать данное событие.

Для обработки события **`popstate`** в обработчик события передается объект события типа **`PopStateEvent`**. В этом объекте свойство `state` указывает на запись, удаленную из истории просмотров:
```js
window.addEventListener("popstate", (event) => {
    console.log(event.state);       // получаем старое состояние
});
```

#### Перемещение по одностраничному сайту
В качестве примера применения History API определим простейший одностраничный сайт в виде следующей веб-страницы ***index.html***:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
<nav><a href="#home">Home</a> | <a href="#about">About</a> | <a href="#contacts">Contacts</a></nav>
<h1 id="content"></h1>
<script>
// Контейнер, в который загружаем контент
const contentElement = document.getElementById("content");
// Объект, который содержит содержимое для различных страниц
const pages = {
    home: { content: "Home Page", url: "#home"},
    about: { content: "About Page", url: "#about"  },
    contacts: { content: "Contact Page", url: "#contacts"}
};
// Обработчик нажатия на ссылки
function handleClick(event){
    // получаем адрес перехода
    const url = event.target.getAttribute("href");
    // получаем имя страницы, которая совпадает с адресом перехода
    const pageName = url.split("#").pop();
    // получаем страницу из объекта pages
    const page = pages[pageName];
    // если текущий адрес совпадает с запрошенным, то игнорируем переход
    if(history.state.url != url) {
        contentElement.textContent = page.content;
        // добавляем в историю
        history.pushState(page,  // объект state
            event.target.textContent,   // Title
            event.target.href           // URL
        );
        document.title = event.target.textContent; // если браузер не устанавливает заголовок
    }
    return event.preventDefault();
}
// устанавливаем обработчик для извлечения состояния в History API
window.addEventListener("popstate", (event) => {
    if(event.state)       // если  есть состояние
        contentElement.textContent = event.state.content;   // получаем старое состояние
});
// устанавливаем обработчик нажатия для кнопок
const links = document.getElementsByTagName("a");
for (let i = 0; i < links.length; i++) {
    links[i].addEventListener("click", handleClick, true);
}
// по умолчанию загружаем Home Page
contentElement.textContent = pages.home.content;
history.pushState(pages.home, "Home", pages.home.url);
</script>
</body>
</html>
```

Итак, изначально на странице у нас три ссылки, нажимая на которые, мы будем переходить на условные страницы:
```html
<nav><a href="#home">Home</a> | <a href="#about">About</a> | <a href="#contacts">Contacts</a></nav>
```

Для простоты предположим, что контекст условных страниц будет состоять из одного заголовка и будет загружаться в соответствующий элемент на странице:
```html
<h1 id="content"></h1>
```

В коде JavaScript мы будем ссылаться на этот элемент через константу `contentElement`

В коде JavaScript определяем код условных страниц в виде объекта pages:
```js
const pages = {
    home: { content: "Home Page", url: "#home" },
    about: { content: "About Page", url: "#about" },
    contacts: { content: "Contact Page", url: "#contacts" }
};
```

Каждый объект однотипен: содержит свойство `content`, которое представляет содержимое условной страницы, и свойство `url` — адрес страницы. Собственно состояние `history.state` будет представлять один из этих объектов. Но тут важная условность — для простоты названия этих страниц — `home`/`about`/`contacts` совпадают с адресами ссылок. Можно было бы отвязать названия, но это привело бы к увеличению логики в сугубо демонстрационном примере.

Для обработки нажатия ссылок определяется функция `handleClick`, в которую передается объект события. И из этого объекта события через `event.target` мы можем получить нажатую ссылку и ее данные. Так, в начале получаем адрес ссылки и название страницы (которое равно адресу без начального слеша):
```js
// получаем адрес перехода
const url = event.target.getAttribute("href");
// получаем имя страницы, которая совпадает с адресом перехода
const pageName = url.split("#").pop();
// получаем страницу из объекта pages
const page = pages[pageName];
```

Получив нужную страницу, смотрим, какая ссылка нажата. Например, мы не хотим, чтобы находясь на определенной странице, пользователь заново загружал данные этой страницы, повторно нажимая на одну и ту же ссылку. И для этой цели берем в истории просмотров текущее состояние и проверяем его свойство `url`. Если текущее состояние (по сути текущая страница) имеет тот же адрес `url`, который запрошен, то нет смысла заново перезагружать содержимое страницы:
```js
if(history.state.url != url) {
```

Если запрошен адрес, отличный от текущего, то устанавливаем в качестве заголовка содержимое (свойство `content`) текущей страницы и добавляем запись в историю просмотров:
```js
contentElement.textContent = page.content;
// добавляем в историю
history.pushState(page,  // объект state
    event.target.textContent,   // Title
    event.target.href           // URL
);
document.title = event.target.textContent; // если браузер не устанавливает заголовок
```

Поскольку браузеры могут не устанавливать автоматически заголовок, то устанавливаем его вручную с помощью свойства `document.title`. Таким образом, в истории просмотров появится запись о переходе по ссылке.

Следует отметить, что в реальном приложении, как правило, подобные условные страницы определяются в отдельных файлах и подгружаются через AJAX.

Для обработки переходов с помощью кнопок браузера Назад/Вперед устанавливаем обработчик для события `popstate`:
```js
window.addEventListener("popstate", (event) => {
    if(event.state)       // если  есть состояние
        contentElement.textContent = event.state.content;   // получаем старое состояние
});
```

Здесь получаем извлеченное состояние из истории просмотров (`event.state`) и с помощью его свойства `content` устанавливаем содержимое заголовка.

В конце устанавливаем обработчик нажатия для кнопок:
```js
const links = document.getElementsByTagName("a");
for (let i = 0; i < links.length; i++) {
    links[i].addEventListener("click", handleClick, true);
}
```

И по умолчанию устанавливаем в качестве текущей условной страницы объект `home` из объекта `pages`, добавляя при этом соответствующую запись в историю просмотров:
```js
contentElement.textContent = pages.home.content;
history.pushState(pages.home, "Home", pages.home.url);
```

Кинем веб-страницу в браузер и мы сможем переходить по ссылкам как по отдельным страницам:

![Хранение состояния страниц в History API в JavaScript](../img/history1.png)

Также вместо символов хеша `#` для опредения ссылки (то есть индентификаторов фрагмента) также можно использовать слеши `/`, что, к примеру, будет лучше для индексации страницы поисковиками. Так, пример выше мы можем переписать следующим образом:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <nav><a href="/home">Home</a> | <a href="/about">About</a> | <a href="/contacts">Contacts</a></nav>
    <h1 id="content"></h1>
    <script>
        // Контейнер, в который загружаем контент
        const contentElement = document.getElementById("content");
        // Объект, который содержит содержимое для различных страниц
        const pages = {
            home: { content: "Home Page", url: "/home" },
            about: { content: "About Page", url: "/about" },
            contacts: { content: "Contact Page", url: "/contacts" }
        };
        // Обработчик нажатия на ссылки
        function handleClick(event){
            // получаем адрес перехода
            const url = event.target.getAttribute("href");
            // получаем имя страницы, которая совпадает с адресом перехода
            const pageName = url.split("/").pop();
            // получаем страницу из объекта pages
            const page = pages[pageName];
            // если текущий адрес совпадает с запрошенным, то игнорируем переход
            if(history.state.url != url) {
                contentElement.textContent = page.content;
                // добавляем в историю
                history.pushState(page,  // объект state
                    event.target.textContent,   // Title
                    event.target.href           // URL
                );
                document.title = event.target.textContent; // если браузер не устанавливает заголовок
            }
            return event.preventDefault();
        }
        // устанавливаем обработчик для извлечения состояния в History API
        window.addEventListener("popstate", (event) => {
            if(event.state)       // если  есть состояние
                contentElement.textContent = event.state.content;   // получаем старое состояние
        });
        // устанавливаем обработчик нажатия для кнопок
        const links = document.getElementsByTagName("a");
        for (let i = 0; i < links.length; i++) {
            links[i].addEventListener("click", handleClick, true);
        }
        // по умолчанию загружаем Home Page
        contentElement.textContent = pages.home.content;
        history.pushState(pages.home, "Home", pages.home.url);
    </script>
</body>
</html>
```

Но в этом случае страница должна располагаться на веб-сервере:

![History API в JavaScript](../img/history2.png)

### Объект location
Объект **`location`** содержит информацию о расположении текущей веб-страницы: URL, информацию о сервере, номер порта, протокол. С помощью свойств объекта мы можем получить эту информацию:[^7.4]

- **`href`**: полный адрес URL веб-страницы

- **`origin`**: общая схема запроса

- **`protocol`**: протокол (включая двоеточие), например, `http:` или `https:`

- **`host`**: хост, например, `localhost.com`. Если адрес URL содержит номер порта, то порт также входит в хост, например, `localhost.com:8080`

- **`hostname`**: домен, аналогичен хосту, только не включает порт, например, `localhost.com`

- **`port`**: порт, используемый ресурсом

- **`pathname`**: путь к ресурсу — та часть адреса, которая идет после хоста после слеша /

- **`hash`**: идентификатор фрагмента — та часть адреса, которая идет после символа решетки `#` (при его наличии)

- **`search`**: строка запроса — та часть адреса, которая идет после знака вопроса `?` (при его налии)

- **`username`**: имя пользователя, которое указано в адресе. Например, в адресе https://tom:qwerty5@localhost.com это подстрока "tom"

- **`password`**: пароль, который указан в адресе. Например, в адресе «https://tom:qwerty5@localhost.com это подстрока "qwerty5"

В общем случае формат адреса URL выглядит следующим образом:
```js
protocol//username:password@hostname:port/path?search#hash
```

Например, пусть есть следующая веб-страница *index.html*:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
  <title>DevPM</title>
</head>
<body>
<script>
    console.log("href:", location.href);
    console.log("path:", location.pathname);
    console.log("origin:", location.origin);
    console.log("protocol:", location.protocol);
    console.log("port:", location.port);
    console.log("host:", location.host);
    console.log("hostname", location.hostname);
    console.log("hash:", location.hash);
    console.log("search:", location.search);
</script>
</body>
</html>
```

Пусть она лежит на локальном веб-сервере, и к ней мы обращаемся с помощью адреса http://localhost:8080/index.html?name=tom&age=39#userinfo:

![Объект location в JavaScript](../img/location.png)

#### Управление адресом
Также объект `location` предоставляет ряд методов, которые можно использовать для управления адресом веб-страницы:

- **`assign(url)`**: загружает ресурс, который находится по пути `url`

- **`reload(forcedReload)`**: перезагружает текущую веб-страницу. Параметр `forcedReload` указывает, надо ли использовать кэш браузера. Если параметр равен `true`, то кэш не используется

- **`replace(url)`**: заменяет текущую веб-станицу другим ресурсом, который находится по пути `url`. В отличие от метода `assign`, который также загружает веб-станицу с другого ресурса, метод `replace` не сохраняет предыдущую веб-страницу в стеке истории переходов `history`, поэтому мы не сможем вызвать метод `history.back()` для перехода к ней.

Для перенаправления на другой ресурс мы можем использовать как свойства, так и методы `location`:
```js
location = "http://google.com";
// аналогично
// location.href = "http://google.com";
// location.assign("http://google.com");
```

Переход на другой локальный ресурс:
```js
location.replace("index.html");
```

Например, выполним переход на странице по нажатию на кнопку:
```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>DevPM</title>
</head>
<body>
    <input type="url" id="url" />
    <button id="btn">Click</button>
    <script>
        const btn = document.getElementById("btn");
        btn.addEventListener("click", () => {
            const url = document.getElementById("url").value;
            location.assign(url);
        });
    </script>
</body>
</html>
```

Здесь по нажатию на кнопку выполняется переход по адресу, который введен в текстовое поле `url`.

Переход с помощью метода **`replace()`** производится аналогично:
```js
const btn = document.getElementById("btn");
btn.addEventListener("click", () => {
    const url = document.getElementById("url").value;
    location.replace(url);
});
```

Перезагрузка страницы:

Переход с помощью метода **`replace()`** производится аналогично:
```js
const btn = document.getElementById("btn");
btn.addEventListener("click", () => {
    const url = document.getElementById("url").value;
    location.reload(true);
});
```

### Источники информации
[^7.1]: [Browser Object Model и объект window](https://metanit.com/web/javascript/7.1.php)
[^7.2]: [Диалоговые окна и поиск на странице](https://metanit.com/web/javascript/7.2.php)
[^7.7]: [Открытие, закрытие и позиционирование окон](https://metanit.com/web/javascript/7.7.php)
[^7.3]: [История браузера. History API](https://metanit.com/web/javascript/7.3.php)
[^7.4]: [Объект location](https://metanit.com/web/javascript/7.4.php)
