## Веб-компоненты

- [Веб-компоненты](#веб-компоненты)
  - [Компонентная архитектура](#компонентная-архитектура)
  - [Пользовательские элементы (Custom Elements)](#пользовательские-элементы-custom-elements)
      - [Добавление методов](#добавление-методов)
      - [События жизненного цикла](#события-жизненного-цикла)
      - [Добавление атрибутов](#добавление-атрибутов)
      - [Стилизация CSS](#стилизация-css)
      - [Пример: «time-formatted»](#пример-time-formatted)
      - [Наблюдение за атрибутами](#наблюдение-за-атрибутами)
      - [Порядок рендеринга](#порядок-рендеринга)
      - [Модифицированные встроенные элементы](#модифицированные-встроенные-элементы)
      - [Итого](#итого)
  - [Shadow DOM](#shadow-dom)
    - [Встроенный теневой DOM](#встроенный-теневой-dom)
    - [Теневое дерево](#теневое-дерево)
    - [Инкапсуляция](#инкапсуляция)
    - [Итого](#итого-1)
  - [Элемент "template"](#элемент-template)
    - [Использование template](#использование-template)
    - [Итого](#итого-2)
  - [Слоты теневого DOM, композиция](#слоты-теневого-dom-композиция)
    - [Именованные слоты](#именованные-слоты)
    - [Содержимое слота «по умолчанию»](#содержимое-слота-по-умолчанию)
    - [Слот по умолчанию (первый без имени)](#слот-по-умолчанию-первый-без-имени)
    - [Пример меню](#пример-меню)
    - [Обновление слотов](#обновление-слотов)
    - [API слотов](#api-слотов)
    - [Итого](#итого-3)
  - [Настройка стилей теневого DOM](#настройка-стилей-теневого-dom)
    - [:host](#host)
    - [Каскадирование](#каскадирование)
    - [:host(selector)](#hostselector)
    - [Применение стилей к содержимому слотов](#применение-стилей-к-содержимому-слотов)
    - [CSS-хуки с пользовательскими свойствами](#css-хуки-с-пользовательскими-свойствами)
    - [Итого](#итого-4)
  - [Теневой DOM и события](#теневой-dom-и-события)
    - [Всплытие и метод event.composedPath()](#всплытие-и-метод-eventcomposedpath)
    - [Свойство: event.composed](#свойство-eventcomposed)
    - [Генерация событий](#генерация-событий)
    - [Итого](#итого-5)
  - [Практическая работа](#практическая-работа)
    - [Элемент "живой таймер"](#элемент-живой-таймер)
  - [Дополнительные источники](#дополнительные-источники)
  - [Источники информации](#источники-информации)

<dfn title="веб-компоненты">Веб-компоненты</dfn> — совокупность стандартов, которая позволяет создавать новые, пользовательские HTML-элементы со своими свойствами, методами, инкапсулированными DOM и стилями.[^web-components]

### Компонентная архитектура
В идее самостоятельного компонента нет ничего нового. Такой подход используется во многих фреймворках.

Хорошо известное правило разработки сложного программного обеспечения гласит: не создавай сложное программное обеспечение.[^webcomponents-intro]

Если что-то становится сложным – раздели это на более простые части и соедини наиболее очевидным способом.

**Хороший архитектор – это тот, кто может сделать сложное простым.**

Мы можем разделить пользовательский интерфейс на визуальные компоненты: каждый из них занимает своё место на странице, выполняет определённую задачу, и отделен от остальных.

Рассмотрим какой-нибудь сайт, например Twitter.

![Twitter components](../img/twitter-components.png)

Он естественным образом разделён на компоненты:

![Twitter components](../img/twitter-comp.png)

1. Верхняя навигация.
2. Данные пользователя.
3. Предложения подписаться.
4. Форма отправки сообщения.
5. (а так же 6 и 7) – сообщения.

Компоненты могут содержать подкомпоненты, например сообщения могут быть частями родительского компонента «список сообщений». Кликабельное фото пользователя может быть самостоятельным компонентом и т.д.

Как мы определяем, что является компонентом? Это приходит из соображений здравого смысла, а также с интуицией и опытом. Обычно это объект, отделимый визуально, который мы можем описать с точки зрения того, что он делает и как он взаимодействует со страницей. В примере выше, страница содержит блоки, каждый из которых играет свою роль, и логично выделить их в компоненты.

Компонент имеет:

- свой собственный JavaScript-класс.
- DOM-структура управляется исключительно своим классом, и внешний код не имеет к ней доступа (принцип «инкапсуляции»).
- CSS-стили, применённые к компоненту.
- API: события, методы класса и т.п., для взаимодействия с другими компонентами.

Ещё раз заметим, в компонентном подходе как таковом нет ничего особенного.

Существует множество фреймворков и методов разработки для их создания, каждый из которых со своими плюсами и минусами. Обычно особые CSS классы и соглашения используются для эмуляции компонентов – области видимости CSS и инкапсуляция DOM.

«Веб-компоненты» предоставляют встроенные возможности браузера для этого, поэтому нам больше не нужно эмулировать их.

- [Пользовательские элементы](https://html.spec.whatwg.org/multipage/custom-elements.html#custom-elements) – для определения пользовательских HTML-элементов.
- [Теневой DOM](https://dom.spec.whatwg.org/#shadow-trees) – для создания внутреннего DOM компонента, скрытого от остальных.
- [Области видимости CSS](https://drafts.csswg.org/css-scoping/) – для определения стилей, которые применяются только внутри теневого DOM компонента.
- [Перенаправление событий](https://dom.spec.whatwg.org/#retarget) и другие мелочи для создания более удобных в разработке пользовательских компонентов.

### Пользовательские элементы (Custom Elements)
По умолчанию HTML предоставляет ряд встроенных элементов, из которых мы можем составить структуру веб-страницы. Однако мы не ограничены встроенными html-элементами и можем сами создать и использовать свои элементы html.[^8.8]

Мы можем создавать пользовательские HTML-элементы, описываемые нашим классом, со своими методами и свойствами, событиями и так далее.

Как только пользовательский элемент определён, мы можем использовать его наравне со встроенными HTML-элементами.

Это замечательно, ведь словарь HTML-тегов богат, но не бесконечен. Не существует `<easy-tabs>`, `<sliding-carousel>`, `<beautiful-upload>`… Просто подумайте о любом другом теге, который мог бы нам понадобиться.

Мы можем определить их с помощью специального класса, а затем использовать, как если бы они всегда были частью HTML.

Существует два вида пользовательских элементов:

1. **Автономные пользовательские элементы** – «полностью новые» элементы, расширяющие абстрактный класс `HTMLElement`.
2. **Пользовательские встроенные элементы** – элементы, расширяющие встроенные, например кнопку `HTMLButtonElement` и т.п.

Сначала мы разберёмся с автономными элементами, а затем перейдём к пользовательским встроенным.

В JavaScript HTML-элемент представлен интерфейсом **`HTMLElement`**. Соответственно, реализуя данный интерфейс в JavaScript, мы можем создать свои классы, которые будут представлять элементы html, и потом их использовать. Что-то наподобие следующего:
```html
<!DOCTYPE html>
<html>
<head>
  <title>DevPM</title>
  <meta charset="utf-8">
</head>
<body>
  <hello-world></hello-world>
</body>
</html>
```

В данном случае в коде странице определен элемент `<hello-world>`, и в реальности такого элемента конечно же не существует. Но сейчас мы его создадим.

Чтобы создать пользовательский элемент, нам нужно сообщить браузеру ряд деталей о нём: как его показать, что делать, когда элемент добавляется или удаляется со страницы и т.д.

Это делается путём создания класса со специальными методами. Это просто, так как существует всего несколько методов, и все они являются необязательными.

Вот набросок с полным списком:
```js
class MyElement extends HTMLElement {
  constructor() {
    super();
    // элемент создан
  }

  connectedCallback() {
    // браузер вызывает этот метод при добавлении элемента в документ
    // (может вызываться много раз, если элемент многократно добавляется/удаляется)
  }

  disconnectedCallback() {
    // браузер вызывает этот метод при удалении элемента из документа
    // (может вызываться много раз, если элемент многократно добавляется/удаляется)
  }

  static get observedAttributes() {
    return [/* массив имён атрибутов для отслеживания их изменений */];
  }

  attributeChangedCallback(name, oldValue, newValue) {
    // вызывается при изменении одного из перечисленных выше атрибутов
  }

  adoptedCallback() {
    // вызывается, когда элемент перемещается в новый документ
    // (происходит в document.adoptNode, используется очень редко)
  }

  // у элемента могут быть ещё другие методы и свойства
}
```

Итак, чтобы определить класс, который будет представлять html-элемент, нам достаточно создать класс, который реализует интерфейс **`HTMLElement`**:
```js
class HelloWorld extends HTMLElement {

}
```

Второй важный момент — нам надо зарегистрировать наш кастомный html-элемент, чтобы браузер знал, что есть такой элемент. Для этого применяется встроенная функция:
```js
customElements.define(name, constructor, options);
```

Она принимает три параметра:

- `name`: имя кастомного элемента html, который будет представлять класс JavaScript. Важно: имя должно содержать дефис.

- `constructor`: конструктор (по сути класс JavaScript), который представляет кастомный элемент html.

- `options`: необязательный параметр — объект, который настраивает кастомный html-элемент. В настоящий момент он поддерживает один параметр — `extends`. Он определяет название встроенного html-элемента, который применяется для создания кастомного элемента html.

Например, в нашем случае мы могли бы вызвать эту функцию так:
```js
customElements.define("hello-world", HelloWorld);
```

Итак, нам нужно зарегистрировать элемент:
```js
// сообщим браузеру, что <my-element> обслуживается нашим новым классом
customElements.define("my-element", MyElement);
```

Теперь для любых HTML-элементов с тегом `<my-element>` создаётся экземпляр `MyElement` и вызываются вышеупомянутые методы. Также мы можем использовать `document.createElement('my-element')` в JavaScript.[^custom-elements]

!!! info Имя пользовательского элемента должно содержать дефис `-`

    Имя пользовательского элемента должно содержать дефис `-`, например, `my-element` и `super-button` – валидные имена, а `myelement` – нет.

    Это необходимо, чтобы гарантировать отсутствие конфликтов имён между встроенными и пользовательскими элементами HTML.

То есть в общем это будет выглядеть следующим образом:
```js
<!DOCTYPE html>
<html>
<head>
<title>DevPM</title>
<meta charset="utf-8">
</head>
<body>

<hello-world></hello-world>

<script>
class HelloWorld extends HTMLElement {

}
customElements.define("hello-world", HelloWorld);
</script>
</body>
</html>
```

Но пока кастомный элемент "hello-world" ничего не делает. Добавим ему какую-нибудь примитивную задачу. Пусть он выводит некоторое приветствие.

Как правило, классы кастомных элементов применяют конструктор. Причем в самом начале конструктора должен идти вызов функции **`super()`**, который гарантирует, что наш класс унаследовал все методы, атрибуты и свойства интерфейса `HTMlElement`.

```js
class HelloWorld extends HTMLElement {
    constructor() {
        super();
    }
}
```

Но кроме того, в конструкторе мы можем определить некоторую базовую логику нашего элемента. Например:
```html
<!DOCTYPE html>
<html>
<head>
<title>DevPM</title>
<meta charset="utf-8">
</head>
<body>

<hello-world></hello-world>

<script>
class HelloWorld extends HTMLElement {
    constructor() {
        super();

        let welcome = "Доброе утро";
        const hour = new Date().getHours();
        if (hour > 17) {
            welcome = "Добрый вечер";
        } else if (hour > 12) {
            welcome = "Добрый день";
        }

        this.innerText= welcome;
        // либо так
        // this.textContent = welcome;
    }
}

customElements.define("hello-world", HelloMetanit);
</script>
</body>
</html>
```

В конструкторе мы получаем текущее время и в зависимости от текущего часа определяем текст приветствия. Поскольку наш класс применяет интерфейс `HTMLElement`, то соответственно мы можем в нем использовать стандартные для html-элементов свойства. В частности, в данном случае для установки текста элемента применяется свойство `innerText` (также можно было бы использовать свойство `textContent`).

![Создание html-элемента и HTMLElement](../img/5.1.png)

##### Добавление методов
Как и в обычных классах, мы можем определять в классах элементов методы и затем вызывать их. Например, определим простейший метод, который возвращает текущее время:
```html
<!DOCTYPE html>
<html>
<head>
<title>DevPM</title>
<meta charset="utf-8">
</head>
<body>

<hello-world id="hello"></hello-world>
<script>
class HelloWorld extends HTMLElement {

    constructor() {
        super();

        let welcome = "Доброе утро";
        const hour = new Date().getHours();
        if (hour > 17) {
            welcome = "Добрый вечер";
        } else if (hour > 12) {
            welcome = "Добрый день";
        }
        this.style="cursor:pointer;"
        this.innerText= welcome;
    }

    showTime(){
        console.log(new Date().toTimeString());
    }
}

customElements.define("hello-world", HelloWorld);

// получаем элемент
const hello = document.getElementById("hello");
// по нажатию вызываем его метод showTime
hello.addEventListener("click", ()=> hello.showTime());
</script>
</body>
</html>
```

Для примера в классе элемента определен метод `showTime`, который просто выводит на консоль текущее время. В коде javascript мы получаем по `id` данный элемент, прикрепляем к нему обработчик нажатия, в котором вызываем вышеопределенный метод `showTime()`. В итоге по нажатию в консоли мы увидим текущее время:

![Создание html-элемента и HTMLElement и customElements.define](../img/5.2.png)

##### События жизненного цикла
Кастомный элемент html имеет свой жизненный цикл, который описывается следующими методами:

- **`connectedCallback`**: вызывается каждый раз, когда кастомный элемент html добавляется в DOM.

- **`disconnectedCallback`**: вызывается каждый раз, когда кастомный элемент html удаляется из DOM.

- **`adoptedCallback`**: вызывается каждый раз, когда кастомный элемент html перемещается в новый элемент.

- **`attributeChangedCallback`**: вызывается при каждом изменении (добавлении, изменении значения или удаления) атрибута кастомного элемента html.

Например, применим метод `connectedCallback()`:
```html
<!DOCTYPE html>
<html>
<head>
<title>DevPM</title>
<meta charset="utf-8">
</head>
<body>

<hello-world id="hello"></hello-world>
<script>
class HelloWorld extends HTMLElement {

    constructor() {
        super();

        let welcome = "Доброе утро";
        const hour = new Date().getHours();
        if (hour > 17) {
            welcome = "Добрый вечер";
        } else if (hour > 12) {
            welcome = "Добрый день";
        }
        this.style.cursor="pointer"
        this.innerText= welcome;
    }
    connectedCallback() {
      this.style.color = "red";
    }
    showTime(){
        console.log(new Date().toTimeString());
    }
}

customElements.define("hello-world", HelloWorld);
</script>
</body>
</html>
```

В данном случае в методе `connectedCallback()` просто устанавливаем цвет шрифта — в данном случае красный цвет:
```js
this.style.color = "red";
```

##### Добавление атрибутов
Также мы можем определить у элемента свои атрибуты и затем использовать их. Например, выше при добавлении элемента на страницу у него устанавливается красный цвет текста. Зададим установку цвета с помощью атрибута:
```html
<!DOCTYPE html>
<html>
<head>
<title>DevPM</title>
<meta charset="utf-8">
</head>
<body>

<hello-world hellocolor="#2980b9"></hello-world>
<br/>
<hello-world></hello-world>
<script>
class HelloWorld extends HTMLElement {

    constructor() {
        super();

        let welcome = "Доброе утро";
        const hour = new Date().getHours();
        if (hour > 17) {
            welcome = "Добрый вечер";
        } else if (hour > 12) {
            welcome = "Добрый день";
        }
        this.style.cursor="pointer"
        this.innerText= welcome;
    }
    connectedCallback() {
        this.style.color = "red";
        if (this.hasAttribute("hellocolor")) {
            this.style.color = this.getAttribute("hellocolor");
        }
    }
    showTime(){
        console.log(new Date().toTimeString());
    }
}

customElements.define("hello-world", HelloWorld);
</script>
</body>
</html>
```

В данном случае элемент принимает атрибут `hellocolor`, который задает цвет текста элемента. Если этот атрибут определен, то по нему устанавливаем цвет текста. Если не определен, то применяется цвет по умолчанию — красный:
```js
this.style.color = "red";
if (this.hasAttribute("hellocolor")) {
    this.style.color = this.getAttribute("hellocolor");
}
```

![атрибуты html-элемента и HTMLElement и customElements.define и connectedCallback](../img/5.3.png)

##### Стилизация CSS
Стилизация элемента через CSS производится также, как и стилизация любого другого элемента:
```html
<!DOCTYPE html>
<html>
<head>
<title>DevPM Vault</title>
<meta charset="utf-8">
<style>
hello-world{
    font-family: Verdana;
    font-size:22px;
}
</style>
</head>
<body>
<hello-world hellocolor="#2980b9"></hello-world>
<script>
class HelloWorld extends HTMLElement {

    constructor() {
        super();

        let welcome = "Доброе утро";
        const hour = new Date().getHours();
        if (hour > 17) {
            welcome = "Добрый вечер";
        } else if (hour > 12) {
            welcome = "Добрый день";
        }
        this.style.cursor="pointer"
        this.innerText= welcome;
    }
    connectedCallback() {
        this.style.color = "red";
        if (this.hasAttribute("hellocolor")) {
            this.style.color = this.getAttribute("hellocolor");
        }
    }
    showTime(){
        console.log(new Date().toTimeString());
    }
}

customElements.define("hello-world", HelloWorld);
</script>
</body>
</html>
```

![Стилизация CSS для html-элемента и HTMLElement и customElements.define и connectedCallback](../img/5.4.png)

##### Пример: «time-formatted»
Например, элемент `<time>` уже существует в HTML для даты/времени. Но сам по себе он не выполняет никакого форматирования. Давайте создадим элемент `<time-formatted>`, который отображает время в удобном формате с учётом языка:
```html
<script>
class TimeFormatted extends HTMLElement { // (1)

  connectedCallback() {
    let date = new Date(this.getAttribute('datetime') || Date.now());

    this.innerHTML = new Intl.DateTimeFormat("default", {
      year: this.getAttribute('year') || undefined,
      month: this.getAttribute('month') || undefined,
      day: this.getAttribute('day') || undefined,
      hour: this.getAttribute('hour') || undefined,
      minute: this.getAttribute('minute') || undefined,
      second: this.getAttribute('second') || undefined,
      timeZoneName: this.getAttribute('time-zone-name') || undefined,
    }).format(date);
  }

}

customElements.define("time-formatted", TimeFormatted); // (2)
</script>

<!-- (3) -->
<time-formatted datetime="2019-12-01"
  year="numeric" month="long" day="numeric"
  hour="numeric" minute="numeric" second="numeric"
  time-zone-name="short"
></time-formatted>
```

![Custom elements](../img/custom-elements_01.png)

1. Класс имеет только один метод `connectedCallback()` – браузер вызывает его, когда элемент `<time-formatted>` добавляется на страницу (или когда HTML-парсер обнаруживает его), и он использует встроенный форматировщик данных `Intl.DateTimeFormat`, хорошо поддерживаемый в браузерах, чтобы показать красиво отформатированное время.
2. Нам нужно зарегистрировать наш новый элемент, используя `customElements.define(tag, class`).
3. И тогда мы сможем использовать его везде.

!!! info Обновление пользовательских элементов

    Если браузер сталкивается с элементами `<time-formatted>` до `customElements.define`, то это не ошибка. Но элемент пока неизвестен, как и любой нестандартный тег.

    Такие «неопределённые» элементы могут быть стилизованы с помощью CSS селектора `:not(:defined)`.

    Когда вызывается `customElements.define`, они «обновляются»: для каждого создаётся новый экземпляр `TimeFormatted` и вызывается `connectedCallback`. Они становятся `:defined`.

    Чтобы получить информацию о пользовательских элементах, есть следующие методы:

    - `customElements.get(name)` – возвращает класс пользовательского элемента с указанным именем `name`,
    - `customElements.whenDefined(name)` – возвращает промис, который переходит в состояние «успешно выполнен» со значением конструктора пользовательского элемента, когда определён пользовательский элемент с указанным именем `name`.

!!! info Рендеринг происходит в `connectedCallback`, не в `constructor`

    В приведённом выше примере содержимое элемента рендерится (создаётся) в `connectedCallback`.

    Почему не в `constructor`?

    Причина проста: когда вызывается `constructor`, делать это слишком рано. Экземпляр элемента создан, но на этом этапе браузер ещё не обработал/назначил атрибуты: вызовы `getAttribute` вернули бы `null`. Так что мы не можем рендерить здесь.

    Кроме того, если подумать, это лучше с точки зрения производительности – отложить работу до тех пор, пока она действительно не понадобится.

    `connectedCallback` срабатывает, когда элемент добавляется в документ. Не просто добавляется к другому элементу как дочерний, но фактически становится частью страницы. Таким образом, мы можем построить отдельный DOM, создать элементы и подготовить их для последующего использования. Они будут рендериться только тогда, когда попадут на страницу.

##### Наблюдение за атрибутами
В текущей реализации `<time-formatted>` после того, как элемент отрендерился, дальнейшие изменения атрибутов не дают никакого эффекта. Это странно для HTML-элемента. Обычно, когда мы изменяем атрибут, например `a.href`, мы ожидаем, что изменение будет видно сразу. Так что давайте исправим это.

Мы можем наблюдать за атрибутами, поместив их список в статический геттер `observedAttributes()`. При изменении таких атрибутов вызывается `attributeChangedCallback`. Он срабатывает не для любого атрибута по соображениям производительности.

Вот новый `<time-formatted>`, который автоматически обновляется при изменении атрибутов:
```html
<script>
class TimeFormatted extends HTMLElement {

  render() { // (1)
    let date = new Date(this.getAttribute('datetime') || Date.now());

    this.innerHTML = new Intl.DateTimeFormat("default", {
      year: this.getAttribute('year') || undefined,
      month: this.getAttribute('month') || undefined,
      day: this.getAttribute('day') || undefined,
      hour: this.getAttribute('hour') || undefined,
      minute: this.getAttribute('minute') || undefined,
      second: this.getAttribute('second') || undefined,
      timeZoneName: this.getAttribute('time-zone-name') || undefined,
    }).format(date);
  }

  connectedCallback() { // (2)
    if (!this.rendered) {
      this.render();
      this.rendered = true;
    }
  }

  static get observedAttributes() { // (3)
    return ['datetime', 'year', 'month', 'day', 'hour', 'minute', 'second', 'time-zone-name'];
  }

  attributeChangedCallback(name, oldValue, newValue) { // (4)
    this.render();
  }

}

customElements.define("time-formatted", TimeFormatted);
</script>

<time-formatted id="elem" hour="numeric" minute="numeric" second="numeric"></time-formatted>

<script>
setInterval(() => elem.setAttribute('datetime', new Date()), 1000); // (5)
</script>
```

![Custom elements](../img/custom-elements_02.png)

1. Логика рендеринга перенесена во вспомогательный метод `render()`.
2. Мы вызываем его один раз, когда элемент вставляется на страницу.
3. При изменении атрибута, указанного в `observedAttributes()`, вызывается `attributeChangedCallback`.
4. …и происходит ререндеринг элемента.
5. В конце мы легко создаём живой таймер.

##### Порядок рендеринга
Когда HTML-парсер строит DOM, элементы обрабатываются друг за другом, родители до детей. Например, если у нас есть `<outer><inner></inner></outer>`, то элемент `<outer>` создаётся и включается в DOM первым, а затем `<inner>`.

Это приводит к важным последствиям для пользовательских элементов.

Например, если пользовательский элемент пытается получить доступ к `innerHTML` в `connectedCallback`, он ничего не получает:
```html
<script>
customElements.define('user-info', class extends HTMLElement {

  connectedCallback() {
    alert(this.innerHTML); // пусто (*)
  }

});
</script>

<user-info>Джон</user-info>
```

Если вы запустите это, `alert` будет пуст.

Это происходит именно потому, что на этой стадии ещё не существуют дочерние элементы, DOM не завершён. HTML-парсер подключил пользовательский элемент `<user-info>` и теперь собирается перейти к его дочерним элементам, но пока не сделал этого.

Если мы хотим передать информацию в пользовательский элемент, мы можем использовать атрибуты. Они доступны сразу.

Или, если нам действительно нужны дочерние элементы, мы можем отложить доступ к ним, используя `setTimeout` с нулевой задержкой.

Это работает:
```html
<script>
customElements.define('user-info', class extends HTMLElement {

  connectedCallback() {
    setTimeout(() => alert(this.innerHTML)); // Джон (*)
  }

});
</script>

<user-info>Джон</user-info>
```

Теперь `alert` в строке `(*)` показывает «Джон», поскольку мы запускаем его асинхронно, после завершения парсинга HTML. Мы можем обработать дочерние элементы при необходимости и завершить инициализацию.

С другой стороны, это решение также не идеально. Если вложенные пользовательские элементы тоже используют `setTimeout` для инициализации, то они встают в очередь: первым запускается внешний `setTimeout`, а затем внутренний.

Так что внешний элемент завершает инициализацию раньше внутреннего.

Продемонстрируем это на примере:
```html
<script>
customElements.define('user-info', class extends HTMLElement {
  connectedCallback() {
    alert(`${this.id} connected.`);
    setTimeout(() => alert(`${this.id} initialized.`));
  }
});
</script>

<user-info id="outer">
  <user-info id="inner"></user-info>
</user-info>
```

Порядок вывода:

1. outer connected.
2. inner connected.
3. outer initialized.
4. inner initialized.

Мы ясно видим, что внешний элемент `outer` завершает инициализацию `(3)` до внутреннего `inner (4)`.

Нет встроенного колбэка, который срабатывает после того, как вложенные элементы готовы. Если нужно, мы можем реализовать подобное самостоятельно. Например, внутренние элементы могут отправлять события наподобие `initialized`, а внешние могут слушать и реагировать на них.

##### Модифицированные встроенные элементы
Новые элементы, которые мы создаём, такие как `<time-formatted>`, не имеют связанной с ними семантики. Они не известны поисковым системам, а устройства для людей с ограниченными возможностями не могут справиться с ними.

Но такие вещи могут быть важны. Например, поисковой системе было бы интересно узнать, что мы показываем именно время. А если мы делаем специальный вид кнопки, почему не использовать существующую функциональность `<button>`?

Мы можем расширять и модифицировать встроенные HTML-элементы, наследуя их классы.

Например, кнопки `<button>` являются экземплярами класса `HTMLButtonElement`, давайте построим элемент на его основе.

1. Унаследуем `HTMLButtonElement` нашим классом:

    ```js
    class HelloButton extends HTMLButtonElement { /* методы пользовательского элемента */ }
    ```

2. Предоставим третий аргумент в `customElements.define`, указывающий тег:

    ```js
    customElements.define('hello-button', HelloButton, {extends: 'button'});
    ```

    Бывает, что разные теги имеют одинаковый DOM-класс, поэтому указание тега необходимо.

3. В конце, чтобы использовать наш пользовательский элемент, вставим обычный тег `<button>`, но добавим к нему `is="hello-button":`

    ```html
    <button is="hello-button">...</button>
    ```

Вот полный пример:
```html
<script>
// Кнопка, говорящая "привет" по клику
class HelloButton extends HTMLButtonElement {
  constructor() {
    super();
    this.addEventListener('click', () => alert("Привет!"));
  }
}

customElements.define('hello-button', HelloButton, {extends: 'button'});
</script>

<button is="hello-button">Нажми на меня</button>

<button is="hello-button" disabled>Отключена</button>
```

![Custom elements](../img/custom-elements_03.png)

Наша новая кнопка расширяет встроенную. Так что она сохраняет те же стили и стандартные возможности, наподобие атрибута `disabled`.

##### Итого
Есть два типа пользовательских элементов:

1. «Автономные» – новые теги, расширяющие `HTMLElement`.

    Схема определения:
    ```js
    class MyElement extends HTMLElement {
    constructor() { super(); /* ... */ }
    connectedCallback() { /* ... */ }
    disconnectedCallback() { /* ... */  }
    static get observedAttributes() { return [/* ... */]; }
    attributeChangedCallback(name, oldValue, newValue) { /* ... */ }
    adoptedCallback() { /* ... */ }
    }
    customElements.define('my-element', MyElement);
    /* <my-element> */
    ```

2. «Модифицированные встроенные элементы» – расширения существующих элементов.

    Требуют ещё один аргумент в `.define` и атрибут `is="..."` в HTML:
    ```js
    class MyButton extends HTMLButtonElement { /*...*/ }
    customElements.define('my-button', MyElement, {extends: 'button'});
    /* <button is="my-button"> */
    ```

Пользовательские элементы широко поддерживаются среди браузеров. Существует полифил: https://github.com/webcomponents/polyfills/tree/master/packages/webcomponentsjs.

### Shadow DOM
Теневой DOM («Shadow DOM») используется для инкапсуляции. Благодаря ему в компоненте есть собственное «теневое» DOM-дерево, к которому нельзя просто так обратиться из главного документа, у него могут быть изолированные CSS-правила и т.д.[^shadow-dom]

#### Встроенный теневой DOM
Задумывались ли вы о том, как устроены и стилизованы сложные браузерные элементы управления?

Например, `<input type="range">`:

<input type="range">

Браузер рисует их своими силами и по своему усмотрению. Их DOM-структура обычно нам не видна, но в инструментах разработчика можно её посмотреть. К примеру, в Chrome для этого нужно активировать пункт «Show user agent shadow DOM».

После этого `<input type="range">` выглядит так:

![Shadow DOM range](../img/shadow-dom-range.png)

То, что находится под `#shadow-root` – и называется «shadow DOM» (теневой DOM).

Мы не можем получить доступ к теневому DOM встроенных элементов с помощью обычных JavaScript-вызовов или с помощью селекторов. Это не просто обычные потомки, это мощное средство инкапсуляции.

В примере выше можно увидеть полезный атрибут `pseudo`. Он нестандартный и существует по историческим причинам. С его помощью можно стилизовать подэлементы через CSS, например, так:
```html
<style>
/* делаем цвет шкалы ползунка красным */
input::-webkit-slider-runnable-track {
  background: red;
}
</style>

<input type="range">
```

![Shadow DOM](../img/shadow-dom_01.png)

Ещё раз заметим, что `pseudo` – нестандартный атрибут. Если говорить хронологически, то сначала браузеры начали экспериментировать с инкапсуляцией внутренних DOM-структур для элементов, а уже потом, через некоторое время, появился стандарт Shadow DOM, который позволяет делать то же самое нам, разработчикам.

Далее мы воспользуемся современным стандартом Shadow DOM, описанным в спецификации [DOM spec](https://dom.spec.whatwg.org/#shadow-trees) и других спецификациях.

#### Теневое дерево
Каждый DOM-элемент может иметь 2 типа поддеревьев DOM:

1. Light tree – обычное, «светлое», DOM-поддерево, состоящее из HTML-потомков. Все поддеревья, о которых мы говорили в предыдущих главах, были «light».
2. Shadow tree – скрытое, «теневое», DOM-поддерево, не отражённое в HTML, скрытое от посторонних глаз.

Если у элемента имеются оба поддерева, браузер отрисовывает только теневое дерево. Также мы всё же можем задать «композицию» теневого и обычного деревьев. Позже в главе [Слоты теневого DOM, композиция](https://learn.javascript.ru/slots-composition) мы рассмотрим детали.

Теневое дерево можно использовать в пользовательских элементах (Custom Elements), чтобы спрятать внутренности компонента и применить к ним локальные стили.

Например, этот `<show-hello>` элемент прячет свой внутренний DOM в теневом дереве:
```html
<script>
customElements.define('show-hello', class extends HTMLElement {
  connectedCallback() {
    const shadow = this.attachShadow({mode: 'open'});
    shadow.innerHTML = `<p>
      Hello, ${this.getAttribute('name')}
    </p>`;
  }
});
</script>

<show-hello name="John"></show-hello>
```

![Shadow DOM](../img/shadow-dom_02.png)

А вот как получившийся DOM выглядит в инструментах разработчика в Chrome, весь контент внутри «#shadow-root»:

![Shadow DOM say hello](../img/shadow-dom-say-hello.png)

Итак, вызов `elem.attachShadow({mode: …})` создаёт теневое дерево.

Есть два ограничения:

1. Для каждого элемента мы можем создать только один shadow root.
2. В качестве `elem` может быть использован пользовательский элемент (Custom Element), либо один из следующих элементов: «article», «aside», «blockquote», «body», «div», «footer», «h1…h6», «header», «main», «nav», «p», «section» или «span». Остальные, например, `<img>`, не могут содержать теневое дерево.

Свойство `mode` задаёт уровень инкапсуляции. У него может быть только два значения:

- `"open"` – корень теневого дерева («shadow root») доступен как `elem.shadowRoot`.

  Любой код может получить теневое дерево `elem`.

- `"closed"` – `elem.shadowRoot` всегда возвращает `null`.

  До теневого DOM в таком случае мы сможем добраться только по ссылке, которую возвращает `attachShadow` (и, скорее всего, она будет спрятана внутри класса). Встроенные браузерные теневые деревья, такие как у `<input type="range">`, закрыты. До них не добраться.

С возвращаемым методом `attachShadow` объектом [корнем теневого дерева](https://dom.spec.whatwg.org/#shadowroot), можно работать как с обычным DOM-элементом: менять его `innerHTML` или использовать методы DOM, такие как `append`, чтобы заполнить его.

Элемент с корнем теневого дерева называется – «хозяин» (host) теневого дерева, и он доступен в качестве свойства `host` у shadow root:
```js
// при условии, что {mode: "open"}, иначе elem.shadowRoot равен null
alert(elem.shadowRoot.host === elem); // true
```

<dfn title="хост теневого дерева">Хост теневого дерева</dfn> — это DOM-элемент, который выступает в качестве "хозяина" для теневого DOM (shadow DOM), то есть корневого узла теневого поддерева. Именно к этому элементу привязывается теневое дерево, и через него осуществляется доступ к его содержимому и настройкам.​

**Основные свойства хоста**:
- хост — это обычный HTML-элемент, который становится контейнером для теневого DOM;

- у хоста появляется свойство `shadowRoot`, которое указывает на корень теневого дерева (если оно создано в режиме "open");

- теневое дерево изолировано от основного DOM, что позволяет скрыть внутреннюю структуру компонента и защитить его от внешних стилей и скриптов.

Хост теневого дерева — ключевая концепция в современной веб-разработке, особенно при создании кастомных элементов и компонентов с изолированной структурой и стилями.

#### Инкапсуляция
Теневой DOM отделён от главного документа:

1. Элементы теневого DOM не видны из обычного DOM через `querySelector`. В частности, элементы теневого DOM могут иметь такие же идентификаторы, как у элементов в обычном DOM (light DOM). Они должны быть уникальными только внутри теневого дерева.
2. У теневого DOM свои стили. Стили из внешнего DOM не применятся.

Например:
```html
<style>
  /* стили документа не применятся в теневом дереве внутри #elem (1) */
  p { color: red; }
</style>

<div id="elem"></div>

<script>
  elem.attachShadow({mode: 'open'});
    // у теневого дерева свои стили (2)
  elem.shadowRoot.innerHTML = `
    <style> p { font-weight: bold; } </style>
    <p>Hello, John!</p>
  `;

  // <p> виден только запросам внутри теневого дерева (3)
  alert(document.querySelectorAll('p').length); // 0
  alert(elem.shadowRoot.querySelectorAll('p').length); // 1
</script>
```

1. Стили главного документа не влияют на теневое дерево.
2. …Но свои внутренние стили работают.
3. Чтобы добраться до элементов в теневом дереве, нам нужно искать их изнутри самого дерева.

#### Итого
Теневой DOM – это способ создать свой, изолированный, DOM для компонента.

1. `shadowRoot = elem.attachShadow({mode: open|closed})` – создаёт теневой DOM для `elem`. Если `mode="open"`, он доступен через свойство `elem.shadowRoot`.
2. Мы можем создать подэлементы внутри `shadowRoot` с помощью `innerHTML` или других методов DOM.

Элементы теневого DOM:

- Обладают собственной областью видимости идентификаторов
- Невидимы JavaScript селекторам из главного документа, таким как `querySelector`,
- Стилизуются своими стилями из теневого дерева, не из главного документа.

Теневой DOM, если имеется, отрисовывается браузером вместо обычных потомков (light DOM). В главе [Слоты теневого DOM, композиция](https://learn.javascript.ru/slots-composition) мы разберём, как делать их композицию.

### Элемент "template"
Встроенный элемент `<template>` предназначен для хранения шаблона HTML. Браузер полностью игнорирует его содержимое, проверяя лишь синтаксис, но мы можем использовать этот элемент в JavaScript, чтобы создать другие элементы.[^template-element]

В теории, для хранения разметки мы могли бы создать невидимый элемент в любом месте HTML. Что такого особенного в `<template>`?

Во-первых, его содержимым может быть любой корректный HTML-код, даже такой, который обычно нуждается в специальном родителе.

К примеру, мы можем поместить сюда строку таблицы `<tr>`:
```html
<template>
  <tr>
    <td>Содержимое</td>
  </tr>
</template>
```

Обычно, если элемент `<tr>` мы поместим, скажем, в `<div>`, браузер обнаружит неправильную структуру DOM и «исправит» её, добавив снаружи `<table>`. Это может оказаться не тем, что мы хотели. `<template>` же оставит разметку ровно такой, какой мы её туда поместили.

Также внутри `<template>` можно поместить стили и скрипты:
```html
<template>
  <style>
    p { font-weight: bold; }
  </style>
  <script>
    alert("Привет");
  </script>
</template>
```

Браузер рассматривает содержимое `<template>` как находящееся «вне документа»: стили, определённые в нём, не применяются, скрипты не выполнятся, `<video autoplay>` не запустится и т.д.

Содержимое оживёт (скрипт выполнится), когда мы поместим его в нужное нам место.

#### Использование template
Содержимое шаблона доступно по его свойству `content` в качестве [`DocumentFragment`](https://learn.javascript.ru/modifying-document#document-fragment) – особый тип DOM-узла.

Можно обращаться с ним так же, как и с любыми другими DOM-узлами, за исключением одной особенности: когда мы его куда-то вставляем, то в это место вставляется не он сам, а его дети.

Пример:
```html
<template id="tmpl">
  <script>
    alert("Привет");
  </script>
  <div class="message">Привет, Мир!</div>
</template>

<script>
  let elem = document.createElement('div');

  // Клонируем содержимое шаблона для того, чтобы переиспользовать его несколько раз
  elem.append(tmpl.content.cloneNode(true));

  document.body.append(elem);
  // Сейчас скрипт из <template> выполнится
</script>
```

Давайте перепишем пример Shadow DOM из прошлой главы учебника с помощью `<template>`:
```html
<template id="tmpl">
  <style> p { font-weight: bold; } </style>
  <p id="message"></p>
</template>

<div id="elem">Нажми на меня</div>

<script>
  elem.onclick = function() {
    elem.attachShadow({mode: 'open'});

    elem.shadowRoot.append(tmpl.content.cloneNode(true)); // (*)

    elem.shadowRoot.getElementById('message').innerHTML = "Привет из теней!";
  };
</script>
```

![Template](../img/template_01.png)

Когда мы клонируем и вставляем `tmpl.content` в строке `(*)`, то, так как это `DocumentFragment`, вместо него вставляются его потомки (`<style>`, `<p>`).

Именно они и формируют теневой DOM:
```html
<div id="elem">
  #shadow-root
    <style> p { font-weight: bold; } </style>
    <p id="message"></p>
</div>
```

#### Итого
Подводим итоги:

- Содержимым `<template>` может быть любой синтаксически корректный HTML.
- Содержимое `<template>` считается находящимся «вне документа», поэтому оно ни на что не влияет.
- Мы можем получить доступ к `template.content` из JavaScript, клонировать его и переиспользовать в новом компоненте.

Элемент `<template>` уникальный по следующим причинам:

- Браузер проверяет правильность HTML-синтаксиса в нём (в отличие от строк в скриптах).
- …При этом позволяет использовать любые HTML-теги, даже те, которые без соответствующей обёртки не используются (например `<tr>`).
- Его содержимое оживает (скрипты выполняются, `<video autoplay>` проигрывается и т. д.), когда помещается в документ.

Элемент `<template>` не поддерживает итерацию, связывания данных или подстановки переменных. Однако эти возможности можно реализовать поверх него.

### Слоты теневого DOM, композиция
Многим типам компонентов, таким как вкладки, меню, галереи изображений и другие, нужно какое-то содержимое для отображения.

Так же, как встроенный в браузер `<select>` ожидает получить контент пунктов `<option>`, компонент `<custom-tabs>` может ожидать, что будет передано фактическое содержимое вкладок, а `<custom-menu>` – пунктов меню.[^slots-composition]

Код, использующий меню `<custom-menu>`, может выглядеть так:
```html
<custom-menu>
  <title>Сладости</title>
  <item>Леденцы</item>
  <item>Фруктовые тосты</item>
  <item>Кексы</item>
</custom-menu>
```

…Затем компонент должен правильно его отобразить – как обычное меню с заданным названием и пунктами, обрабатывать события меню и т.д.

Как это реализовать?

Можно попробовать проанализировать содержимое элемента и динамически скопировать и переставить DOM-узлы. Это возможно, но если мы будем перемещать элементы в теневой DOM, CSS-стили документа не будут применяться, и мы потеряем визуальное оформление. Кроме того, нужно будет писать дополнительный код.

К счастью, нам этого делать не нужно. Теневой DOM поддерживает элементы `<slot>`, которые автоматически наполняются контентом из обычного, «светлого» DOM-дерева.

#### Именованные слоты
Давайте рассмотрим работу слотов на простом примере.

Теневой DOM `<user-card>` имеет два слота, заполняемых из обычного DOM:
```html
<script>
customElements.define('user-card', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'});
    this.shadowRoot.innerHTML = `
      <div>Имя:
        <slot name="username"></slot>
      </div>
      <div>Дата рождения:
        <slot name="birthday"></slot>
      </div>
    `;
  }
});
</script>

<user-card>
  <span slot="username">Иван Иванов</span>
  <span slot="birthday">01.01.2001</span>
</user-card>
```

![Slots](../img/slots_01.png)

В теневом DOM `<slot name="X">` определяет «точку вставки» – место, где отображаются элементы с `slot="X"`.

Затем браузер выполняет «композицию»: берёт элементы из обычного DOM-дерева и отображает их в соответствующих слотах теневого DOM-дерева. В результате мы получаем именно то, что хотели – компонент, который можно наполнить данными.

После выполнения скрипта структура DOM выглядит следующим образом (без учёта композиции):
```html
<user-card>
  #shadow-root
    <div>Имя:
      <slot name="username"></slot>
    </div>
    <div>Дата рождения:
      <slot name="birthday"></slot>
    </div>
  <span slot="username">Иван Иванов</span>
  <span slot="birthday">01.01.2001</span>
</user-card>
```

Мы создали теневой DOM, он изображён под `#shadow-root`. Теперь у элемента есть два DOM-дерева: обычное («светлое») и теневое.

Чтобы отобразить содержимое, для каждого `<slot name="...">` в теневом DOM браузер ищет `slot="..."` с таким же именем в обычном DOM. Эти элементы отображаются внутри слотов:

<figure style="background: white">

![Shadow DOM user card](../img/shadow-dom-user-card.svg)

</figure>

В результате выстраивается так называемое «развёрнутое» (*flattened*) DOM-дерево:
```html
<user-card>
  #shadow-root
    <div>Имя:
      <slot name="username">
        <!-- элемент слота вставляется в слот -->
        <span slot="username">Иван Иванов</span>
      </slot>
    </div>
    <div>Дата рождения:
      <slot name="birthday">
        <span slot="birthday">01.01.2001</span>
      </slot>
    </div>
</user-card>
```

…Но развёрнутое DOM-дерево существует только для целей отображения и обработки событий. Это то, что мы видим на экране. Оно, в некотором плане, «виртуальное». Фактически в документе расположение узлов не меняется.

Это можно легко проверить, запустив `querySelectorAll`: все узлы находятся на своих местах.
```js
// узлы светлого DOM находятся в том же месте, в `<user-card>`
alert( document.querySelectorAll('user-card span').length ); // 2
```

Так что развёрнутый DOM составляется из теневого вставкой в слоты. Браузер использует его для рендеринга и при всплытии событий (об этом позже). Но JavaScript видит документ «как есть» – до построения развёрнутого DOM-дерева.

!!! warning Атрибут slot=«…» могут иметь только дети первого уровня

    Атрибут `slot="..."` работает только на непосредственных детях элемента-хозяина теневого дерева (в нашем примере это элемент `<user-card>`). Для вложенных элементов он игнорируется.

    Например, здесь второй `<span>` игнорируется (так как он не является потомком верхнего уровня элемента `<user-card>`):

    ```html
    <user-card>
      <span slot="username">Иван Иванов</span>
      <div>
        <!-- некорректный слот, должен быть на верхнем уровне user-card: -->
        <span slot="birthday">01.01.2001</span>
      </div>
    </user-card>
    ```

Если в светлом DOM есть несколько элементов с одинаковым именем слота, они добавляются в слот один за другим.

Например, этот код:
```html
<user-card>
  <span slot="username">Иван</span>
  <span slot="username">Иванов</span>
</user-card>
```

Даст такой развёрнутый DOM с двумя элементами в `<slot name="username">`:
```html
<user-card>
  #shadow-root
    <div>Имя:
      <slot name="username">
        <span slot="username">Иван</span>
        <span slot="username">Иванов</span>
      </slot>
    </div>
    <div>Дата рождения:
      <slot name="birthday"></slot>
    </div>
</user-card>
```

#### Содержимое слота «по умолчанию»
Если мы добавляем данные в `<slot>`, это становится содержимым «по умолчанию». Браузер отображает его, если в светлом DOM-дереве отсутствуют данные для заполнения слота.

Например, в этой части теневого дерева текст `Аноним` отображается, если в светлом дереве нет значения `slot="username"`.

```html
<div>Имя:
  <slot name="username">Аноним</slot>
</div>
```

#### Слот по умолчанию (первый без имени)
Первый `<slot>` в теневом дереве без атрибута name является слотом по умолчанию. Он будет отображать данные со всех узлов светлого дерева, не добавленные в другие слоты

Например, давайте добавим слот по умолчанию в наш элемент `<user-card>`; он будет собирать всю информацию о пользователе, не занесённую в другие слоты:
```html
<script>
customElements.define('user-card', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'});
    this.shadowRoot.innerHTML = `
    <div>Имя:
      <slot name="username"></slot>
    </div>
    <div>Дата рождения:
      <slot name="birthday"></slot>
    </div>
    <fieldset>
      <legend>Другая информация</legend>
      <slot></slot>
    </fieldset>
    `;
  }
});
</script>

<user-card>
  <div>Я люблю плавать.</div>
  <span slot="username">Иван Иванов</span>
  <span slot="birthday">01.01.2001</span>
  <div>...И играть в волейбол!</div>
</user-card>
```

![Slots](../img/slots_02.png)

Всё содержимое обычного дерева, не добавленное в слоты, попало в `<fieldset>` «Другая информация».

Элементы добавляются в слот по очереди, один за другим, поэтому оба элемента данных, которые не были добавлены в слоты, попадают в слот по умолчанию.

Развёрнутое DOM-дерево выглядит так:
```html
<user-card>
  #shadow-root
    <div>Имя:
      <slot name="username">
        <span slot="username">Иван Иванов</span>
      </slot>
    </div>
    <div>Дата рождения:
      <slot name="birthday">
        <span slot="birthday">01.01.2001</span>
      </slot>
    </div>
    <fieldset>
      <legend>Другая информация</legend>
      <slot>
        <div>Я люблю плавать.</div>
        <div>...И играть в волейбол!</div>
      </slot>
    </fieldset>
</user-card>
```

#### Пример меню
Давайте вернёмся к меню `<custom-menu>`, упомянутому в начале главы.

Мы можем использовать слоты для распределения элементов.

Вот разметка для меню `<custom-menu>`:
```html
<custom-menu>
  <span slot="title">Сладости</span>
  <li slot="item">Леденцы</li>
  <li slot="item">Фруктовые тосты</li>
  <li slot="item">Кексы</li>
</custom-menu>
```

Шаблон теневого DOM-дерева с правильными слотами:
```html
<template id="tmpl">
  <style> /* стили меню */ </style>
  <div class="menu">
    <slot name="title"></slot>
    <ul><slot name="item"></slot></ul>
  </div>
</template>
```

1. `<span slot="title">` попадает в `<slot name="title">`.
2. В шаблоне много элементов `<li slot="item">`, но только один слот `<slot name="item">`. Поэтому все такие `<li slot="item">` добавляются в `<slot name="item">` один за другим, формируя список.

Развёрнутое DOM-дерево становится таким:
```html
<custom-menu>
  #shadow-root
    <style> /* стили меню */ </style>
    <div class="menu">
      <slot name="title">
        <span slot="title">Сладости</span>
      </slot>
      <ul>
        <slot name="item">
          <li slot="item">Леденцы</li>
          <li slot="item">Фруктовые тосты</li>
          <li slot="item">Кексы</li>
        </slot>
      </ul>
    </div>
</custom-menu>
```

Можно заметить, что в валидном DOM-дереве тег `<li>` должен быть прямым потомком тега `<ul>`. Но это развёрнутый DOM, который описывает то, как компонент отображается, в нём такая ситуация нормальна.

Осталось только добавить обработчик `click` для открытия и закрытия списка, и меню `<custom-menu>` готово:
```js
customElements.define('custom-menu', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'});

    // tmpl -- шаблон для теневого DOM-дерева (выше)
    this.shadowRoot.append( tmpl.content.cloneNode(true) );

    // мы не можем выбирать узлы светлого DOM, поэтому обработаем клики на слоте
    this.shadowRoot.querySelector('slot[name="title"]').onclick = () => {
      // открыть/закрыть меню
      this.shadowRoot.querySelector('.menu').classList.toggle('closed');
    };
  }
});
```

Вот полное демо:

![Slots](../img/slots_03.png)

Конечно, мы можем расширить функциональность меню, добавив события, методы и т.д.

#### Обновление слотов
Что если внешний код хочет динамически добавить или удалить пункты меню?

**Браузер наблюдает за слотами и обновляет отображение при добавлении и удалении элементов в слотах.**

Также, поскольку узлы светлого DOM-дерева не копируются, а только отображаются в слотах, изменения внутри них сразу же становятся видны.

Таким образом, нам ничего не нужно делать для обновления отображения. Но если код компонента хочет узнать об изменениях в слотах, можно использовать событие `slotchange`.

Например, здесь пункт меню вставляется динамически через 1 секунду, и заголовок меняется через 2 секунды:
```html
<custom-menu id="menu">
  <span slot="title">Сладости</span>
</custom-menu>

<script>
customElements.define('custom-menu', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'});
    this.shadowRoot.innerHTML = `<div class="menu">
      <slot name="title"></slot>
      <ul><slot name="item"></slot></ul>
    </div>`;

    // shadowRoot не может иметь обработчиков событий, поэтому используется первый потомок
    this.shadowRoot.firstElementChild.addEventListener('slotchange',
      e => alert("slotchange: " + e.target.name)
    );
  }
});

setTimeout(() => {
  menu.insertAdjacentHTML('beforeEnd', '<li slot="item">Леденцы</li>')
}, 1000);

setTimeout(() => {
  menu.querySelector('[slot="title"]').innerHTML = "Новое меню";
}, 2000);
</script>
```

Отображение меню обновляется каждый раз без нашего вмешательства.

Здесь есть два события `slotchange`:

1. При инициализации:

    `slotchange: title` запускается сразу же, как только `slot="title"` из обычного дерева попадает в соответствующий слот.

2. Через 1 секунду:

    `slotchange: item` запускается, когда добавляется новый элемент `<li slot="item">`.

Обратите внимание, что событие `slotchange` не запускается через 2 секунды, когда меняется контент `slot="title"`. Это происходит потому, что сам слот не меняется. Мы изменяем содержимое элемента, который находится в слоте, а это совсем другое.

Если мы хотим отслеживать внутренние изменения обычного DOM-дерева из JavaScript, можно также использовать более обобщённый механизм: [`MutationObserver`](https://learn.javascript.ru/mutation-observer).

#### API слотов
И, наконец, давайте поговорим о методах JavaScript, связанных со слотами.

Как мы видели раньше, JavaScript смотрит на «реальный», а не на развёрнутый DOM. Но если у теневого дерева стоит `{mode: 'open'}`, то мы можем выяснить, какие элементы находятся в слоте, и, наоборот, определить слот по элементу, который в нём находится:

- `node.assignedSlot` – возвращает элемент `<slot>`, в котором находится `node`.
- `slot.assignedNodes({flatten: true/false})` – DOM-узлы, которые находятся в слоте. Опция `flatten` имеет значение по умолчанию `false`. Если явно изменить значение на `true`, она просматривает развёрнутый DOM глубже и возвращает вложенные слоты, если есть вложенные компоненты, и резервный контент, если в слоте нет узлов.
- `slot.assignedElements({flatten: true/false})` – DOM-элементы, которые находятся в слоте (то же самое, что выше, но только узлы-элементы).

Эти методы можно использовать не только для отображения содержимого, которое находится в слотах, но и для его отслеживания в JavaScript.

Например, если компонент `<custom-menu>` хочет знать, что он показывает, он может отследить событие `slotchange` и получить пункты меню из `slot.assignedElements`:
```html
<custom-menu id="menu">
  <span slot="title">Сладости</span>
  <li slot="item">Леденцы</li>
  <li slot="item">Фруктовые тосты</li>
</custom-menu>

<script>
customElements.define('custom-menu', class extends HTMLElement {
  items = []

  connectedCallback() {
    this.attachShadow({mode: 'open'});
    this.shadowRoot.innerHTML = `<div class="menu">
      <slot name="title"></slot>
      <ul><slot name="item"></slot></ul>
    </div>`;

    // слотовый элемент добавляется/удаляется/заменяется
    this.shadowRoot.firstElementChild.addEventListener('slotchange', e => {
      let slot = e.target;
      if (slot.name == 'item') {
        this.items = slot.assignedElements().map(elem => elem.textContent);
        alert("Items: " + this.items);
      }
    });
  }
});

// пункты меню обновятся через 1 секунду
setTimeout(() => {
  menu.insertAdjacentHTML('beforeEnd', '<li slot="item">Кексы</li>')
}, 1000);
</script>
```

#### Итого
Обычно, если у элемента есть теневое дерево, то содержимое обычного, светлого DOM не показывается. Слоты позволяют показать элементы светлого DOM на заданных местах в теневом DOM.

Существует два вида слотов:

- Именованные слоты: `<slot name="X">...</slot>` – получают элементы светлого DOM с slot="X".
- Слот по умолчанию: первый `<slot>` без имени (последующие неименованные слоты игнорируются) – показывает элементы элементов светлого дерева, которые не находятся в других слотах.
- Если одному слоту назначено несколько элементов, они добавляются один за другим.
- Содержимое элемента `<slot>` используется как резервное. Оно отображается, если в слоте нет элементов из светлого дерева.

Процесс отображения элементов внутри слота называется «композицией». В результате композиции строится «развёрнутый DOM».

При композиции не происходит перемещения узлов – с точки зрения JavaScript, DOM остаётся прежним.

JavaScript может получить доступ к слотам с помощью следующих методов:

- `slot.assignedNodes/Elements()` – возвращает узлы/элементы, которые находятся внутри `slot`.
- `node.assignedSlot` – обратный метод, возвращает слот по узлу.

Если мы хотим знать, что показываем, мы можем отследить контент слота следующими способами:

- событие `slotchange` – запускается, когда слот наполняется контентом в первый раз, и при каждой операции добавления/удаления/замещения элемента в слоте, за исключением его потомков. Сам слот будет `event.target`.
- [`MutationObserver`](https://learn.javascript.ru/mutation-observer) для более глубокого просмотра содержимого элемента в слоте и отслеживания изменений в нём.

**Таким образом**:
- **Теневой DOM** (*Shadow DOM*) — это технология инкапсуляции, позволяющая создавать изолированные DOM-деревья для веб-компонентов, которые не влияют на основной документ и не подвержены внешнему воздействию.
- **Шаблоны** (*template*) используются для описания структуры компонента, которую можно повторно использовать без негативного влияния на стили и логику страницы.
- **Слоты** (*slots*) позволяют передавать контент внутрь теневого дерева, обеспечивая гибкость и переиспользование компонентов.​

В совокупности эти технологии обеспечивают чистую инкапсуляцию, переиспользование и независимость компонентов в современной веб-разработке.

Теперь, когда мы научились показывать элементы светлого DOM в теневом DOM, давайте посмотрим, как их правильно стилизовать. Основное правило звучит так: теневые элементы стилизуются внутри, а обычные элементы – снаружи; однако есть заметные исключения.

Мы рассмотрим их подробно в следующей главе.

### Настройка стилей теневого DOM
Теневой DOM может содержать теги `<style>` и `<link rel="stylesheet" href="…">`. В последнем случае таблицы стилей кешируются по протоколу HTTP, так что они не будут загружаться повторно при использовании одного шаблона для многих компонентов.

Как правило, локальные стили работают только внутри теневого DOM, а стили документа – вне его. Но есть несколько исключений.[^shadow-dom-style]

#### :host
Селектор `:host` позволяет выбрать элемент-хозяин (элемент, содержащий теневое дерево).

Например, мы создаём элемент `<custom-dialog>` который нужно расположить по-центру. Для этого нам необходимо стилизовать сам элемент `<custom-dialog>`.

Это именно то, что делает `:host`:
```html
<template id="tmpl">
  <style>
    /* стиль будет применён изнутри к элементу <custom-dialog> */
    :host {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      display: inline-block;
      border: 1px solid red;
      padding: 10px;
    }
  </style>
  <slot></slot>
</template>

<script>
customElements.define('custom-dialog', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'}).append(tmpl.content.cloneNode(true));
  }
});
</script>

<custom-dialog>
  Hello!
</custom-dialog>
```

![Shadow DOM styles](../img/shadow-dom-styles_01.png)

#### Каскадирование
Элемент-хозяин (элемент `<custom-dialog>`) находится в светлом DOM, поэтому к нему применяются CSS-стили документа.

Если есть некоторое свойство, стилизованное как в `:host` локально, так и в документе, то стиль документа будет приоритетным.

Например, если в документе из примера поставить:
```html
<style>
custom-dialog {
  padding: 0;
}
</style>
```

…то `<custom-dialog>` будет без `padding`.

Это очень удобно, поскольку мы можем задать стили «по умолчанию» в компоненте в его правиле `:host`, а затем, при желании, легко переопределить их в документе.

Исключение составляет тот случай, когда локальное свойство помечено как `!important`, для таких свойств приоритет имеют локальные стили.

#### :host(selector)
То же, что и `:host`, но применяется только в случае, если элемент-хозяин подходит под селектор `selector`.

Например, мы бы хотели выровнять по центру `<custom-dialog>`, только если он содержит атрибут `centered`:
```html
<template id="tmpl">
  <style>
    :host([centered]) {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      border-color: blue;
    }

    :host {
      display: inline-block;
      border: 1px solid red;
      padding: 10px;
    }
  </style>
  <slot></slot>
</template>

<script>
customElements.define('custom-dialog', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'}).append(tmpl.content.cloneNode(true));
  }
});
</script>


<custom-dialog centered>
  Centered!
</custom-dialog>

<custom-dialog>
  Not centered.
</custom-dialog>
```

![Shadow DOM styles](../img/shadow-dom-styles_02.png)

Теперь дополнительные стили для выравнивания по центру применяются только к первому элементу: `<custom-dialog centered>`.

Подводя итог, мы можем использовать семейство селекторов `:host` для стилизации основного элемента компонента. Эти стили (если только не стоит `!important`) могут быть переопределены документом.

#### Применение стилей к содержимому слотов
Теперь давайте рассмотрим ситуацию со слотами.

Элементы слотов происходят из светлого DOM, поэтому они используют стили документа. Локальные стили не влияют на содержимое слотов.

В примере ниже текст в `<span>` жирный в соответствии со стилями документа, но не берёт `background` из локальных стилей:
```html
<style>
  span { font-weight: bold }
</style>

<user-card>
  <div slot="username"><span>John Smith</span></div>
</user-card>

<script>
customElements.define('user-card', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'});
    this.shadowRoot.innerHTML = `
      <style>
      span { background: red; }
      </style>
      Имя: <slot name="username"></slot>
    `;
  }
});
</script>
```

![Shadow DOM styles](../img/shadow-dom-styles_03.png)

В результате текст жирный, но не красный.

Если мы хотим стилизовать слотовые элементы в нашем компоненте, то есть два варианта.

Первое – можно стилизовать сам `<slot>` и полагаться на наследование CSS:
```html
<user-card>
  <div slot="username"><span>John Smith</span></div>
</user-card>

<script>
customElements.define('user-card', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'});
    this.shadowRoot.innerHTML = `
      <style>
      slot[name="username"] { font-weight: bold; }
      </style>
      Имя: <slot name="username"></slot>
    `;
  }
});
</script>
```

![Shadow DOM styles](../img/shadow-dom-styles_04.png)

Здесь `<span>John Smith</span>` выделяется жирным шрифтом, потому что наследование CSS действует между `<slot>` и его содержимым. Но в CSS как таковом не все свойства наследуются.

Другой вариант – использовать псевдокласс `::slotted(селектор)`. Соответствует элементам, если выполняются два условия:

1. Это слотовый элемент, пришедший из светлого DOM. Имя слота не имеет значения. Просто любой элемент, вставленный в `<slot>`, но только сам элемент, а не его потомки.
2. Элемент соответствует селектору.

В нашем примере `::slotted(div)` выбирает в точности `<div slot="username">`, но не его дочерние элементы:
```html
<user-card>
  <div slot="username">
    <div>John Smith</div>
  </div>
</user-card>

<script>
customElements.define('user-card', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'});
    this.shadowRoot.innerHTML = `
      <style>
      ::slotted(div) { border: 1px solid red; }
      </style>
      Name: <slot name="username"></slot>
    `;
  }
});
</script>
```

![Shadow DOM styles](../img/shadow-dom-styles_05.png)

Обратите внимание, что селектор `::slotted` не может спускаться дальше в слот. Эти селекторы недействительны:
```css
::slotted(div span) {
  /* наш слот <div> не соответствует этому */
}

::slotted(div) p {
  /* не может войти в светлый DOM */
}
```

Кроме того, `::slotted` можно использовать только в CSS. Мы не можем использовать его в `querySelector`.

#### CSS-хуки с пользовательскими свойствами
Как можно стилизовать внутренние элементы компонента из основного документа?

Селекторы типа `:host` применяют правила к элементу `<custom-dialog>` или `<user-card>`, но как стилизовать элементы теневого DOM внутри них? Например, в `<user-card>` мы хотели бы разрешить внешнему документу изменять внешний вид пользовательских полей.

Аналогично тому, как мы предусматриваем у компонента методы, чтобы взаимодействовать с ним, мы можем использовать переменные CSS (пользовательские свойства CSS) для его стилизации.

**Пользовательские свойства CSS существуют одновременно на всех уровнях, как светлом, так и в тёмном DOM.**

Например, в теневом DOM мы можем использовать CSS-переменную `--user-card-field-color` для стилизации полей, а документ будет её устанавливать:
```html
<style>
  .field {
    color: var(--user-card-field-color, black);
    /* если переменная --user-card-field-color не определена, будет использован цвет black */
  }
</style>
<div class="field">Имя: <slot name="username"></slot></div>
<div class="field">Дата рождения: <slot name="birthday"></slot></div>
```

Затем мы можем объявить это свойство во внешнем документе для `<user-card>`:
```css
user-card {
  --user-card-field-color: green;
}
```

Пользовательские CSS свойства проникают через теневой DOM, они видны повсюду, поэтому внутреннее правило `.field` будет использовать его.

Вот полный пример:
```html
<style>
  user-card {
    --user-card-field-color: green;
  }
</style>

<template id="tmpl">
  <style>
    .field {
      color: var(--user-card-field-color, black);
    }
  </style>
  <div class="field">Имя: <slot name="username"></slot></div>
  <div class="field">Дата рождения: <slot name="birthday"></slot></div>
</template>

<script>
customElements.define('user-card', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'});
    this.shadowRoot.append(document.getElementById('tmpl').content.cloneNode(true));
  }
});
</script>

<user-card>
  <span slot="username">John Smith</span>
  <span slot="birthday">01.01.2001</span>
</user-card>
```

![Shadow DOM styles](../img/shadow-dom-styles_06.png)

#### Итого
Теневой DOM может включать в себя стили, такие как `<style>` или `<link rel="stylesheet">`.

Локальные стили могут влиять на:

- теневое дерево,
- элемент-хозяин, при помощи псевдоклассов `:host` и `:host()`,
- слотовые элементы (из светлого DOM), `::slotted(селектор)` позволяет стилизовать сами слотовые элементы, но не их дочерние элементы.

Стили документов могут влиять на:

- элемент-хозяин (так как он находится во внешнем документе)
- слотовые элементы и их содержимое (так как они также физически присутствуют во внешнем документе)

Когда свойства CSS конфликтуют, обычно стили документа имеют приоритет, если только свойство не помечено как `!important`. Тогда предпочтение отдаётся локальным стилям.

Пользовательские свойства CSS проникают через теневой DOM. Они используются как «хуки» для придания элементам стиля:

1. Компонент использует пользовательское CSS-свойство для стилизации ключевых элементов, например `var(--component-name-title, <значение по умолчанию>)`.
2. Автор компонента публикует эти свойства для разработчиков, они так же важны, как и другие общедоступные методы компонента.
3. Когда разработчик хочет стилизовать заголовок, он назначает CSS-свойство `--component-name-title` для элемента-хозяина или выше.

### Теневой DOM и события
Смысл создания теневого DOM-дерева – это инкапсуляция внутренних деталей компонента.

Допустим, клик произошёл внутри теневого DOM на компоненте `<user-card>`. Но скрипты основного документа ничего не знают о внутреннем устройстве теневой DOM-структуры, в особенности, если компонент создан сторонней библиотекой.

Поэтому, чтобы не нарушать инкапсуляцию, *браузер меняет у этого события целевой элемент*.

**События, которые произошли в теневом DOM, но пойманы снаружи этого DOM, имеют элемент-хозяин в качестве целевого элемента `event.target`.**[^shadow-dom-events]

Рассмотрим простой пример:
```html
<user-card></user-card>

<script>
customElements.define('user-card', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'});
    this.shadowRoot.innerHTML = `<p>
      <button>Нажми меня</button>
    </p>`;
    this.shadowRoot.firstElementChild.onclick =
      e => alert("Внутренний целевой элемент: " + e.target.tagName);
  }
});

document.onclick =
  e => alert("Внешний целевой элемент: " + e.target.tagName);
</script>
```

![Shadow DOM events](../img/shadow-dom-events_01.png)

Если нажать на кнопку, то выведется следующее:

1. Внутренний целевой элемент: `BUTTON` – внутренний обработчик событий получает правильный целевой элемент – элемент, находящийся внутри теневого DOM.
2. Внешний целевой элемент: `USER-CARD` – обработчик событий на уровне документа получает элемент-хозяин в качестве целевого.

Хорошо, что браузер подменяет целевые элементы событий. Потому что внешний документ ничего не знает о внутреннем устройстве компонента. С его (внешнего документа) точки зрения, событие происходит на `<user-card>`.

**Подмена целевого элемента не происходит, если событие берёт начало на элементе из слота, который фактически находится в обычном, светлом DOM.**

Например, если пользователь кликнет на `<span slot="username">` в примере ниже – целевой элемент события будет именно этот `span` для обоих обработчиков – теневого и обычного (светлого):
```html
<user-card id="userCard">
  <span slot="username">John Smith</span>
</user-card>

<script>
customElements.define('user-card', class extends HTMLElement {
  connectedCallback() {
    this.attachShadow({mode: 'open'});
    this.shadowRoot.innerHTML = `<div>
      <b>Имя:</b> <slot name="username"></slot>
    </div>`;

    this.shadowRoot.firstElementChild.onclick =
      e => alert("Внутренний целевой элемент: " + e.target.tagName);
  }
});

userCard.onclick = e => alert(`Внешний целевой элемент: ${e.target.tagName}`);
</script>
```

![Shadow DOM events](../img/shadow-dom-events_02.png)

Если клик произойдёт на `"John Smith"`, то для обоих обработчиков – внутреннего и внешнего – целевым элементом будет `<span slot="username">`. Это элемент обычного (светлого) DOM, так что подмены не происходит.

С другой стороны, если клик произойдёт на элементе, который находится в теневом DOM, например, на `<b>Имя</b>`, то как только всплытие выйдет за пределы теневой DOM-структуры, его `event.target станет <user-card>`.

#### Всплытие и метод event.composedPath()
Для обеспечения всплытия событий используется развёрнутый DOM.

Таким образом, если у нас есть элемент в слоте, и событие происходит где-то внутри него, то оно всплывает до `<slot>` и выше.

Полный путь к изначальному целевому элементу, со всеми теневыми элементами, можно получить, воспользовавшись методом `event.composedPath()`. Как видно из названия, этот метод возвращает путь после композиции.

В примере выше развёрнутое DOM-дерево будет таким:
```html
<user-card id="userCard">
  #shadow-root
    <div>
      <b>Имя:</b>
      <slot name="username">
        <span slot="username">John Smith</span>
      </slot>
    </div>
</user-card>
```

Так что, при клике по `<span slot="username">` вызов метода `event.composedPath()` вернёт массив: [`span`, `slot`, `div`, `shadow-root`, `user-card`, `body`, `html`, `document`, `window`]. Что в точности отражает цепочку родителей от целевого элемента в развёрнутой DOM-структуре после композиции.

!!! warning Детали теневого DOM-дерева доступны только для деревьев с `{mode:'open'}`

    Если теневое DOM-дерево было создано с `{mode: 'closed'}`, то после композиции путь будет начинаться с элемента-хозяина: `user-card` и дальше вверх по дереву.

    Этот метод следует тем же принципам, что и остальные. Внутреннее устройство закрытых DOM-деревьев совершенно скрыто.

#### Свойство: event.composed
Большинство событий успешно всплывают сквозь границу теневого DOM. Но не все.

Это поведение регулируется с помощью свойства `composed` объекта события. Если оно `true`, то событие пересекает границу. Иначе, оно может быть поймано лишь внутри теневого DOM.

Если посмотреть в [спецификацию UI Events](https://www.w3.org/TR/uievents), то большинство событий имеют `composed: true`:

- `blur`, `focus`, `focusin`, `focusout`,
- `click`, `dblclick`,
- `mousedown`, `mouseup`, `mousemove`, `mouseout`, `mouseover`,
- `wheel`,
- `beforeinput`, `input`, `keydown`, `keyup`.

Все события курсора и сенсорные события также имеют `composed: true`.

Хотя есть и события, имеющие `composed: false`:

- `mouseenter`, `mouseleave` (они вообще не всплывают),
- `load`, `unload`, `abort`, `error`,
- `select`,
- `slotchange`.

Эти события могут быть пойманы только на элементах того же DOM, в котором находится целевой элемент события.

#### Генерация событий
Когда мы генерируем своё событие, то, чтобы оно всплывало за пределы компонента, нужно установить оба свойства: `bubbles` и `composed` – в значение `true`.

Например, здесь мы создаём элемент `div#inner` в теневом DOM-дереве элемента `div#outer` и генерируем на нём два события. Только одно с флагом `composed: true` выйдет наружу, в документ:
```html
<div id="outer"></div>

<script>
outer.attachShadow({mode: 'open'});

let inner = document.createElement('div');
outer.shadowRoot.append(inner);

/*
div(id=outer)
  #shadow-dom
    div(id=inner)
*/

document.addEventListener('test', event => alert(event.detail));

inner.dispatchEvent(new CustomEvent('test', {
  bubbles: true,
  composed: true,
  detail: "composed"
}));

inner.dispatchEvent(new CustomEvent('test', {
  bubbles: true,
  composed: false,
  detail: "not composed"
}));
</script>
```

#### Итого
Только те события пересекают границы теневого DOM, у которых флаг `composed` установлен в значение `true`.

У большинства встроенных событий стоит `composed: true`, это описано в соответствующих спецификациях:

- UI Events https://www.w3.org/TR/uievents.
- Touch Events https://w3c.github.io/touch-events.
- Pointer Events https://www.w3.org/TR/pointerevents.
- …И так далее.

У некоторых встроенных событий всё же стоит `composed: false`:

- `mouseenter`, `mouseleave` (вообще не всплывают),
- `load`, `unload`, `abort`, `error`,
- `select`,
- `slotchange`.

Эти события могут быть пойманы только на элементах, принадлежащих тому же DOM-дереву.

Если мы генерируем своё событие `CustomEvent`, то должны явно поставить флаг `composed: true`.

Обратите внимание, что в случае вложенных компонентов теневые DOM могут быть вложены друг в друга. События с флагом `composed` всплывают через границы всех теневых DOM. Поэтому, если событие предназначено только для ближайшего внешнего компонента-родителя, мы можем инициировать его на элементе-хозяине и установить флаг `composed: false`. Тогда оно будет уже вне теневого DOM компонента, но не выплывает наружу в «ещё более внешний» DOM.

### Практическая работа

#### Элемент "живой таймер"

У нас уже есть элемент `<time-formatted>`, показывающий красиво отформатированное время.

Создайте элемент `<live-timer>`, показывающий текущее время:

1. Внутри он должен использовать `<time-formatted>`, не дублировать его функциональность.
2. Должен тикать (обновляться) каждую секунду.
3. На каждом тике должно генерироваться пользовательское событие с именем `tick`, содержащее текущую дату в `event.detail` (смотрите главу [Генерация пользовательских событий](https://learn.javascript.ru/dispatch-events)).

Использование:
```html
<live-timer id="elem"></live-timer>

<script>
  elem.addEventListener('tick', event => console.log(event.detail));
</script>
```
Демо:
![Custom elements](../img/custom-elements_04.png)

Пожалуйста, обратите внимание:

1. Мы останавливаем таймер `setInterval`, когда элемент удаляется из документа. Это важно, иначе он продолжит тикать, даже если больше не нужен. И браузер не сможет очистить память от этого элемента.
2. Мы можем получить доступ к текущей дате через свойство `elem.date`. Все методы и свойства класса, естественно, являются методами и свойствами элемента.
Открыть решение в песочнице.

### Дополнительные источники
- HTML Living Standard: https://html.spec.whatwg.org/#custom-elements.
- Совместимость: https://caniuse.com/#feat=custom-elementsv1.
- DOM: https://dom.spec.whatwg.org/#shadow-trees
- Совместимость: https://caniuse.com/#feat=shadowdomv1
- Теневой DOM упоминается во многих других спецификациях, например [DOM Parsing](https://w3c.github.io/DOM-Parsing/#the-innerhtml-mixin) указывает, что у shadow root есть `innerHTML`.

### Источники информации
[^web-components]: [Веб-компоненты](https://learn.javascript.ru/web-components)
[^webcomponents-intro]: [С орбитальной высоты](https://learn.javascript.ru/webcomponents-intro)
[^custom-elements]: [Пользовательские элементы (Custom Elements)](https://learn.javascript.ru/custom-elements)
[^8.8]: [Создание своего элемента HTML](https://metanit.com/web/javascript/8.8.php)
[^shadow-dom]: [Shadow DOM](https://learn.javascript.ru/shadow-dom)
[^template-element]: [Элемент "template"](https://learn.javascript.ru/template-element)
[^slots-composition]: [Слоты теневого DOM, композиция](https://learn.javascript.ru/slots-composition)
[^shadow-dom-style]: [Настройка стилей теневого DOM](https://learn.javascript.ru/shadow-dom-style)
[^shadow-dom-events]: [Теневой DOM и события](https://learn.javascript.ru/shadow-dom-events)
